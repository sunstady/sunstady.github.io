<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sanstyle</title>
  <subtitle>功有所不全 才有所不任 力有所不足</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sanstylemc.cn/"/>
  <updated>2018-04-05T09:19:11.737Z</updated>
  <id>http://www.sanstylemc.cn/</id>
  
  <author>
    <name>MC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux查看内存</title>
    <link href="http://www.sanstylemc.cn/2018/04/05/Linux%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98/"/>
    <id>http://www.sanstylemc.cn/2018/04/05/Linux查看内存/</id>
    <published>2018-04-05T09:18:39.000Z</published>
    <updated>2018-04-05T09:19:11.737Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/sunstady/hexo/blob/master/Linux%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98/1.png?raw=true" alt="1"><br><a id="more"></a><br>方法一: <code>free</code><br>直观的展示Linux系统内存使用及交换区的容量大小<br><img src="https://github.com/sunstady/hexo/blob/master/Linux%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98/2.png?raw=true" alt="2"><br>方法二: <code>top</code><br>动态实时查看系统中每一个进程的资源使用情况<br><img src="https://github.com/sunstady/hexo/blob/master/Linux%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98/3.png?raw=true" alt="3"><br>方法三: <code>cat /proc/meminfo</code><br><img src="https://github.com/sunstady/hexo/blob/master/Linux%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98/4.png?raw=true" alt="4"><br>方法四: <code>gnome-system-monitor</code>一个显示最近一段时间内的CPU、内存、交换区及网络使用情况的识图工具。<br><img src="https://github.com/sunstady/hexo/blob/master/Linux%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98/5.png?raw=true" alt="5"><br>方法五: <code>ps aux –sort -rss</code>各个线程的资源使用情况。<br><img src="https://github.com/sunstady/hexo/blob/master/Linux%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98/6.png?raw=true" alt="6"><br>方法六: <code>vmstat -s</code> vmstat命令显示实时的和平均的统计，覆盖CPU、内存、I/O等内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/sunstady/hexo/blob/master/Linux%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98/1.png?raw=true&quot; alt=&quot;1&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.sanstylemc.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git命令</title>
    <link href="http://www.sanstylemc.cn/2018/04/05/Git%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.sanstylemc.cn/2018/04/05/Git命令/</id>
    <published>2018-04-05T08:35:43.000Z</published>
    <updated>2018-04-05T08:36:24.676Z</updated>
    
    <content type="html"><![CDATA[<p>需要学习的东西太多了，很多命令用到时却忘了，分享一个经典的Git 常用命清单，建议收藏，或者收进你的云笔记中，方便用到时查阅。<br><a id="more"></a><br>|名词|翻译|<br>|-|:-:|<br>|workspace|工作区|<br>|Index/Stage|暂存区|<br>|Repository|仓库区(本地仓库)|<br>|Remote|远程仓库|</p>
<h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><p>在当前目录新建一个Git代码库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git init</span></div></pre></td></tr></table></figure></p>
<p>新建一个目录，将其初始化为Git代码库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></div></pre></td></tr></table></figure></p>
<p>下载一个项目和它的整个代码历史<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">clone</span> <span class="title">[url</span>]</div></pre></td></tr></table></figure></p>
<h2 id="添加或删除文件"><a href="#添加或删除文件" class="headerlink" title="添加或删除文件"></a>添加或删除文件</h2><p>添加指定文件到暂存区<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="builtin-name">add</span> [file1] [file2]<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></div></pre></td></tr></table></figure></p>
<p>添加指定目录到暂存区，包括子目录<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">add</span><span class="bash"> [dir]</span></div></pre></td></tr></table></figure></p>
<p>添加当前目录的所有文件到暂存区<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">add</span><span class="bash"> .</span></div></pre></td></tr></table></figure></p>
<p>添加每个变化前，都会要求确认。对于同一个文件的多处变化，可以实现分次提交<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">add</span><span class="bash"> -p</span></div></pre></td></tr></table></figure></p>
<p>删除工作区文件，并且将这次删除放入暂存区<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm [file1] [file2]......</div></pre></td></tr></table></figure></p>
<p>停止追踪指定文件，但该文件会保留在工作区<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git rm --cached [<span class="keyword">file</span>]</div></pre></td></tr></table></figure></p>
<p>改名文件，并且将这个改名放入暂存区<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git mv [<span class="keyword">file</span>-original] [<span class="keyword">file</span>-original]</div></pre></td></tr></table></figure></p>
<h2 id="代码提交到仓库"><a href="#代码提交到仓库" class="headerlink" title="代码提交到仓库"></a>代码提交到仓库</h2><p>提交暂存区到仓库区<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></div></pre></td></tr></table></figure></p>
<p>提交暂存区的指定文件到仓库区<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit <span class="string">[file1]</span> <span class="string">[file2]</span>... -m <span class="string">[message]</span></div></pre></td></tr></table></figure></p>
<p>提交工作区自上次commit之后的变化，直接到仓库区<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></div></pre></td></tr></table></figure></p>
<p>提交时显示所有diff信息<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git commit -v</span></div></pre></td></tr></table></figure></p>
<p>使用一次新的commit，替代上一次提交。如果代码没有任何变化，则用来改写上一次commit的提交信息。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></div></pre></td></tr></table></figure></p>
<p>重做上一次commit，并包括指定文件的新变化<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit --amend [file1] [file2]...</div></pre></td></tr></table></figure></p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>列出所有本地分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git branch</span></div></pre></td></tr></table></figure></p>
<p>列出所有远程分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></div></pre></td></tr></table></figure></p>
<p>列出所有本地分支和远程分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></div></pre></td></tr></table></figure></p>
<p>新建一个分支，但依然停留在当前分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></div></pre></td></tr></table></figure></p>
<p>新建一个分支，并切换到该分支<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">branch </span>-<span class="keyword">b </span>[<span class="keyword">branch]</span></div></pre></td></tr></table></figure></p>
<p>新建一个分支，指向指定commit<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch <span class="string">[branch]</span> <span class="string">[commit]</span></div></pre></td></tr></table></figure></p>
<p>新建一个分支，与指定的远程分支建立追踪关系<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch --track <span class="string">[branch]</span> <span class="string">[remote-branch]</span></div></pre></td></tr></table></figure></p>
<p>切换到指定分支，并更新工作区<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></div></pre></td></tr></table></figure></p>
<p>切换到上一个分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></div></pre></td></tr></table></figure></p>
<p>建立追踪关系，在现有分支与指定的远程分支之间<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git branch --<span class="keyword">set</span>-upstream <span class="comment">[branch] [remote-branch]</span></div></pre></td></tr></table></figure></p>
<p>合并指定分支到当前分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></div></pre></td></tr></table></figure></p>
<p>选择一个commit，合并进当前分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></div></pre></td></tr></table></figure></p>
<p>删除分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></div></pre></td></tr></table></figure></p>
<p>删除远程分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></div><div class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></div></pre></td></tr></table></figure></p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>列出所有tag<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git tag</span></div></pre></td></tr></table></figure></p>
<p>新建一个tag在当前commit<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>]</div></pre></td></tr></table></figure></p>
<p>新建一个tag在指定commit<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>] [commit]</div></pre></td></tr></table></figure></p>
<p>删除本地tag<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> [<span class="keyword">tag</span>]</div></pre></td></tr></table></figure></p>
<p>删除远程tag<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>git push origin <span class="symbol">:refs/tags/</span>[tagname]</div></pre></td></tr></table></figure></p>
<p>查看tag信息<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></div></pre></td></tr></table></figure></p>
<p>提交指定tag<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push <span class="string">[remote]</span> <span class="string">[tag]</span></div></pre></td></tr></table></figure></p>
<p>提交所有tag<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></div></pre></td></tr></table></figure></p>
<p>新建一个分支，指向某个tag<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b <span class="string">[branch]</span> <span class="string">[tag]</span></div></pre></td></tr></table></figure></p>
<h2 id="查看历史或统计信息"><a href="#查看历史或统计信息" class="headerlink" title="查看历史或统计信息"></a>查看历史或统计信息</h2><p>显示有变更的文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git status</span></div></pre></td></tr></table></figure></p>
<p>显示当前分支的版本历史<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></div></pre></td></tr></table></figure></p>
<p>显示commit历史，以及每次commit发生变更的文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></div></pre></td></tr></table></figure></p>
<p>搜索提交历史，根据关键词<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></div></pre></td></tr></table></figure></p>
<p>显示某个commit之后的所有变动，每个commit占据一行<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> [tag] HEAD <span class="comment">--pretty=format:%s</span></div></pre></td></tr></table></figure></p>
<p>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></div></pre></td></tr></table></figure></p>
<p>显示某个文件的版本历史，包括文件改名<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --follow [<span class="keyword">file</span>]</div><div class="line"><span class="symbol">$</span> git whatchanged [<span class="keyword">file</span>]</div></pre></td></tr></table></figure></p>
<p>显示指定文件相关的每一次diff<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git <span class="built-in">log</span> -p [<span class="keyword">file</span>]</div></pre></td></tr></table></figure></p>
<p>显示过去5次提交<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> <span class="number">-5</span> <span class="comment">--pretty --oneline</span></div></pre></td></tr></table></figure></p>
<p>显示所有提交过的用户，按提交次数排序<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></div></pre></td></tr></table></figure></p>
<p>显示指定文件式什么人在什么时间修改过<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git blame [<span class="keyword">file</span>]</div></pre></td></tr></table></figure></p>
<p>显示暂存区和工作区的差异<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git diff</span></div></pre></td></tr></table></figure></p>
<p>显示暂存区和上一个commit的差异<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git diff --cached [<span class="keyword">file</span>]</div></pre></td></tr></table></figure></p>
<p>显示工作区与当前分支最新commit之间的差异<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></div></pre></td></tr></table></figure></p>
<p>显示两次提交之间的差异<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">diff</span> [<span class="built_in">first</span>-branch]...[<span class="built_in">second</span>-branch]</div></pre></td></tr></table></figure></p>
<p>显示今天你写了多少行代码<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">dirr </span>--<span class="keyword">shortstat </span><span class="string">"@&#123;0 day ago&#125;"</span></div></pre></td></tr></table></figure></p>
<p>显示某次提交的元数据和内容变化<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></div></pre></td></tr></table></figure></p>
<p>显示某次提交发生变化的文件<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show --<span class="keyword">name</span>-<span class="keyword">only</span> [commit]</div></pre></td></tr></table></figure></p>
<p>显示某次提交时，某个文件的内容<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git show <span class="string">[commit]</span>:<span class="string">[filename]</span></div></pre></td></tr></table></figure></p>
<h2 id="代码远程同步"><a href="#代码远程同步" class="headerlink" title="代码远程同步"></a>代码远程同步</h2><p>下载远程仓库的所有变动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></div></pre></td></tr></table></figure></p>
<p>显示所有远程仓库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></div></pre></td></tr></table></figure></p>
<p>显示某个远程仓库的信息<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></div></pre></td></tr></table></figure></p>
<p>增加一个新的远程仓库，并命名<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add <span class="string">[shortname]</span> <span class="string">[url]</span></div></pre></td></tr></table></figure></p>
<p>取回远程仓库的变化，并与本地分支合并<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull <span class="string">[remote]</span> <span class="string">[branch]</span></div></pre></td></tr></table></figure></p>
<p>上传本地指定分支到远程仓库<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push <span class="string">[remote]</span> <span class="string">[branch]</span></div></pre></td></tr></table></figure></p>
<p>强行推送当前分支到远程仓库，即使有冲突<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></div></pre></td></tr></table></figure></p>
<p>推送所有分支到远程仓库<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git push [remote] --<span class="keyword">all</span></div></pre></td></tr></table></figure></p>
<h2 id="撤销恢复"><a href="#撤销恢复" class="headerlink" title="撤销恢复"></a>撤销恢复</h2><p>恢复暂存区的指定文件到工作区<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git checkout [<span class="keyword">file</span>]</div></pre></td></tr></table></figure></p>
<p>恢复某个commit的指定文件到暂存区和工作区<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout <span class="string">[commit]</span> <span class="string">[file]</span></div></pre></td></tr></table></figure></p>
<p>恢复暂存区的所有文件到工作区<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></div></pre></td></tr></table></figure></p>
<p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git reset [<span class="keyword">file</span>]</div></pre></td></tr></table></figure></p>
<p>重置暂存区与工作区，与上一次commit保持一致<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></div></pre></td></tr></table></figure></p>
<p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></div></pre></td></tr></table></figure></p>
<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></div></pre></td></tr></table></figure></p>
<p>重置当前HEAD为指定commit，但保持暂存区和工作区不变<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></div></pre></td></tr></table></figure></p>
<p>新建一个commit，用来撤销指定commit。后者的所有变化都将被前者抵消，并且应用到当前分支<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></div></pre></td></tr></table></figure></p>
<p>暂时将未提交的变化移除，稍后再植入<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git stash</span></div><div class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要学习的东西太多了，很多命令用到时却忘了，分享一个经典的Git 常用命清单，建议收藏，或者收进你的云笔记中，方便用到时查阅。&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.sanstylemc.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://www.sanstylemc.cn/2018/04/05/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://www.sanstylemc.cn/2018/04/05/Java注解/</id>
    <published>2018-04-05T06:46:04.000Z</published>
    <updated>2018-04-05T06:46:52.751Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我们将看到五个Java编译器支持的注解，并了解其期望用途。顺便，我们将探索其创建背后的基本原理，围绕其用途的一些特质，以及正确应用的一些例子。<br><a id="more"></a></p>
<h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p>覆盖方法的实现或为抽象方法提供实现的能力是任何面向对象(OO)语言的核心。由于Java是OO语言，具有许多常见的面向对象的抽象机制，所以在非终极超类定义的非最终方法或接口中地任何方法(接口方法不能是最终的)都可以被子类覆盖。虽然开始时覆盖方法看起来很简单，但是如果执行不正确，则可能会引入许多微小的bug。例如，用覆盖类类型的单个参数覆盖Object#equals方法就是一种常见的错误:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Foo foo)</span> </span>&#123;</div><div class="line">    <span class="comment">// Check if the supplied object is equal to this object</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于所有类都隐式地从Object类继承，Foo类的目的是覆盖Object#equals方法， 因此Foo可被测试是否与Java中的任何其他对象相等。虽然我们的意图是正确的，但我们的实现则并非如此。实际上，我们的实现根本不覆盖Object#equals方法。相反，我们提供了方法的重载: 我们不是替换Object类提供的equals方法的实现，而是提供第二个方法来专门接受Foo对象，而不是Object对象。我们的错误可以简单实现来举例说明，该实现对所有的相等检查都返回true，但当提供的对象被视为Object(Java将执行的操作，例如在Java Collections Framework即JCF中)时，就永远不会调用它:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">equals</span>(<span class="params">Foo foo</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Object foo = <span class="keyword">new</span> Foo();</div><div class="line">Object identicalFoo = <span class="keyword">new</span> Foo();</div><div class="line">System.<span class="keyword">out</span>.println(foo.<span class="keyword">equals</span>(identicalFoo)); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>这是一个非常微妙但常见的错误，可以被编译器捕获。我们的意图是覆盖Object#equals方法，但因为我们指定了一个类型为Foo而不是Object类型的参数，所以我们实际上提供了重载的Object#equals方法，而不是覆盖它。为了捕获这种错误，我们引入@Override注解，它指示编译器检查覆盖实际有没有执行。如果没有执行有效的覆盖，则会抛出错误。因此，我们可以更新Foo类，如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Foo foo)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们尝试编译这个类，我们现在收到以下错误:<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ javac Foo.java</div><div class="line">Foo.java:<span class="number">3</span>: error: <span class="function"><span class="keyword">method</span> <span class="title">does</span> <span class="title">not</span> <span class="title">override</span> <span class="title">or</span> <span class="title">implement</span> <span class="title">a</span> <span class="title">method</span> <span class="title">from</span> <span class="title">a</span> <span class="title">supertype</span></span></div><div class="line"><span class="function">@<span class="title">Override</span></span></div><div class="line"><span class="function">^</span></div><div class="line"><span class="function">1 <span class="title">error</span></span></div></pre></td></tr></table></figure></p>
<p>实质上，我们已经将我们已经覆盖方法的这一隐含的假设转变为由编译器进行的显性验证。如果我们的意图被错误地实现，那么Java编译器会发出一个错误–不允许我们不正确实现的代码被成功编译。通常，如果以下任一条件不满足，则Java编译器将针对使用@Override注解地方法发出错误(引用自Override注解文档): </p>
<ul>
<li>该方法确实会覆盖或实现在超类中声明地方法。</li>
<li>该方法的签名与在Object中声明的任何公共方法（即equals或hashCode方法）的签名覆盖等价（override-equivalent）。<br>因此，我们也可以使用此注解来确保子类方法实际上也覆盖超类中地非最终具体方法或抽象方法: <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doSomethingElse</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomethingElse</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">20</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Foo bar = <span class="keyword">new</span> Bar();</div><div class="line">System.out.println(bar.doSomething()); <span class="comment">// 10</span></div><div class="line">System.out.println(bar.doSomethingElse()); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>@Override注解不仅不限于超类中的具体或抽象方法，而且还可用于确保接口的方法也被覆盖（从JDK 6开始）:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">implements</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Foo bar = <span class="keyword">new</span> Bar();</div><div class="line">System.out.println(bar.doSomething()); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>通常，覆盖非final类方法、抽象超类方法或接口方法的任何方法都可以使用@Override进行注解。</p>
<h2 id="Functionallnterface"><a href="#Functionallnterface" class="headerlink" title="@Functionallnterface"></a>@Functionallnterface</h2><p>随着JDK 8中lambda表达式的引入，函数式接口在Java中变得越来越流行。这些特殊类型的接口可以用lambda表达式、方法引用或构造函数引用代替。根据@Functionallnterface文档，函数式接口的定义如下: </p>
<blockquote>
<p>一个函数式接口只有一个抽象方法。由于默认方法有一个实现，所以它们不是抽象的。</p>
</blockquote>
<p>例如，以下接口被视为函数式接口:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>Foo &#123;</div><div class="line">    public int doSomething();</div><div class="line">&#125;</div><div class="line">public<span class="built_in"> interface </span>Bar &#123;</div><div class="line">    public int doSomething();</div><div class="line">    public<span class="built_in"> default </span>int doSomethingElse() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此，下面的每一个都可以用lambda表达式代替，如下所示:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FunctionalConsumer</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeFoo</span>(<span class="params">Foo foo</span>) </span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(foo.doSomething());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeBar</span>(<span class="params">Bar bar</span>) </span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(bar.doSomething());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">FunctionalConsumer consumer = <span class="keyword">new</span> FunctionalConsumer();</div><div class="line">consumer.consumeFoo(() -&gt; <span class="number">10</span>); <span class="comment">// 10</span></div><div class="line">consumer.consumeBar(() -&gt; <span class="number">20</span>); <span class="comment">// 20</span></div></pre></td></tr></table></figure></p>
<p>重点要注意的是，抽象类，即使它们只包含一个抽象方法，也不是函数式接口。与@Override注解类似，Java编译器提供了@Functionallnterface注解以确保接口确实是函数式接口。例如，我们可以将此注解添加到上面创建的接口中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bar</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">int</span> <span class="title">doSomethingElse</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们错误地将接口定义为非函数接口并用@Functionallnterface注解了错误地接口，则Java编译器会发出错误。例如，我们可以定义以下带注解地非函数式接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomethingElse</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们试图编译这个接口，则会收到以下错误:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ javac Foo.java</div><div class="line">Foo.java:<span class="number">1</span>: error: Unexpected <span class="meta">@FunctionalInterface</span> <span class="keyword">annotation</span></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line">^</div><div class="line">Foo <span class="keyword">is</span> not a functional <span class="class"><span class="keyword">interface</span></span></div><div class="line">multiple non-overriding <span class="keyword">abstract</span> methods found <span class="keyword">in</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span></span></div><div class="line"><span class="number">1</span> error</div></pre></td></tr></table></figure></p>
<p>使用这个注解，我们可以确保我们不会错误地创建原本打算用作函数式接口地非函数式接口。需要注意地是，即使在@Functionallnterface注解不存在地情况下，接口也可以用作函数式接口(可以替代为lambdas，方法引用和构造函数引用)，正如我们前面地示例中所见地那样。这类似于@Override注解，即一个方法是可以被覆盖地，即使它不包含@Override注解。在这两种情况下，注解都是允许编译器执行期望意图的可选技术。</p>
<h2 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h2><p>警告是所有编译器的重要组成部分，为开发人员提供的反馈–可能危险的行为或在未来的编译器版本中可能会出现的错误。例如，在Java中使用泛型类型而没有其关联的正式型参数(称为原始类型)会导致警告，就像使用不推荐使用的代码一样(请参阅下面的@Deprecated部分)。虽然这些警告很重要，但它们可能并不总是适用甚至并不总是正确的。例如，可能会有对不安全的类型转换发生警告的情况，但是基于使用它的上下文，我们可以保证它是安全的。<br>为了忽略某些上下文中的特定警告，JDK 5中引入了@SuppressWarnings注解。此注解接受一个或多个字符串参数–描述要忽略的警告名称。虽然这些警告的名称通常在编译器实现之间有所不同，但又3种警告在Java语言中是标准化的(因此在所有Java编译器实现中都很常见): </p>
<ul>
<li>unchecked: 表示类型转换未经检查的警告(编译器无法保证类型转换是安全的)，导致发生的可能原因有访问原始类型的成员(参见《JLS》4.8章节)、窄参考转换或不安全的向下转换(参见《JLS》5.1.6章节)、未经检查的类型转换(参见《JLS》5.1.9章节)、使用带有可变参数的泛型参数(参见《JLS》8.4.1章节和下面的@SafeVarargs部分)、使用无效的协变返回类型(参见《JLS》8.4.8.3章节)、不确定的参数评估(参见《JLS》15.12.4.2章节)、未经检查的方法引用类型的转换(参见《JLS》15.13.2章节)、或未经检查到的lambda类型的对话(参见《JLS》15.27.3章节)。</li>
<li>deprecation: 表示使用了已弃用的方法、类、类型等的警告(参见《JLS》9.6.4.6章节和下面的@Deprecated部分)。</li>
<li>removal: 表示使用了最终废弃的方法、类、类型等的警告(参见《JLS》9.6.4.6章节和下面的@Deprecated部分)。</li>
</ul>
<p>为了忽略特定的警告，可以将@SuppressedWarning注解与抑制警告(以字符串数组的形式提供)的一个或多个名字添加到发生警告的上下文中:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">Foo</span> &#123;</div><div class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">doSomething</span>(<span class="variable">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>) List myList) &#123;</div><div class="line">    <span class="comment">// Do something with myList</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@SuppressWarnings注解可用于以下任何一种情况: </p>
<ul>
<li>类型</li>
<li>域</li>
<li>方法</li>
<li>参数</li>
<li>构造函数</li>
<li>局部变量</li>
<li>模块<br>一般来说，@SuppressWarnings注解应该应用于最直接的警告范围。例如，如果方法中的局部变量应忽略警告，则应将@SuppressWarnings注解应用于局部变量，而不是包含局部变量的方法或类: <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line">        List myList = <span class="keyword">new</span> ArrayList();</div><div class="line">        <span class="comment">// Do something with myList</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h2><p>可变参数在Java中是一种很有用的技术手段，但在与泛型参数一起使用时，它们也可能会导致一些严重的问题。由于泛型在Java中式非特定的，所以具有泛型类型的变量的实际(实现)类型不能在运行时被断定。由于无法做出此判断，因此变量可能会存储非其实际类型的引用到类型，如以下代码片段所示:<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">List</span> ln = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</div><div class="line">ln.add(<span class="number">1</span>);</div><div class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; ls = ln; <span class="comment">// unchecked warning</span></div><div class="line"><span class="built_in">String</span> s = ls.<span class="keyword">get</span>(<span class="number">0</span>); <span class="comment">// ClassCastException</span></div></pre></td></tr></table></figure></p>
<p>在将ln分配给ls后，堆中存在变量ls，该变量具有List<string>的类型，但存储引用到实际为List<number>类型的值。这个无效的引用被称为堆污染。由于直到运行时才确定此错误，因此它会在编译时显示为警告，并在运行时出现ClassCastException。当泛型参数与可变参数组合时，可能会加剧此问题:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T... args)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></number></string></p>
<p>在这种情况下，Java编译器会在调用站点内部创建一个数组来存储可变数量的参数，但是T的类型并未实现，因此在运行时会丢失。实质上，到doSomething的参数实际上式Object[]类型。如果依赖T的运行时类型，那么这会导致严重的问题，如下面的代码片段所示:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Foo &#123;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="built_in">void</span> doSomething(T... args) &#123;</div><div class="line">        <span class="built_in">Object</span>[] objects = args;</div><div class="line">        <span class="built_in">String</span> <span class="built_in">string</span> = (<span class="built_in">String</span>) objects[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Foo foo = <span class="keyword">new</span> Foo();</div><div class="line">foo.&lt;<span class="built_in">Number</span>&gt;doSomething(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>如果执行此代码片段，那么将导致ClassCastException，因为在调用站点传递的第一个Number参数不能转换为String（类似于独立堆污染示例中抛出的ClassCastException）。通常，可能会出现以下情况：编译器没有足够的信息来正确确定通用可变参数的确切类型，这会导致堆污染，这种污染可以通过允许内部可变参数数组从方法中转义来传播，如下面摘自《Effective Java》第3版 pp.147的例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T[] <span class="title">toArray</span>(<span class="params">T... args</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> args;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在某些情况下，我们知道方法实际上是类型安全的，不会造成堆污染。如果可以在保证的情况下做出这个决定，那么我们可以使用@SafeVarargs注解来注解该方法，从而抑制与可能的堆污染相关的警告。但是，这引出了一个问题：什么时候通用可变参数方法会被认为是类型安全的？Josh Bloch在《Effective Java》第3版第147页的基础上提供了一个完善的解决方案——基于方法与内部创建的用于存储其可变参数的数组的交互：</p>
<blockquote>
<p>如果方法没有存储任何东西到数组（这会覆盖参数）且不允许对数组的引用进行转义（这会使得不受信任的代码可以访问数组），那么它是安全的。换句话说，如果可变参数数组仅用于从调用者向方法传递可变数量的参数——毕竟，这是可变参数的目的——那么该方法是安全的。</p>
</blockquote>
<p>因此，如果我们创建了以下方法（来自pp.149同上），那么我们可以用@SafeVarags注解来合理地注解我们的方法：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@SafeVarargs</div><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; flatten(<span class="keyword">List</span><span class="meta">&lt;?</span> extends T&gt;... lists) &#123;</div><div class="line"><span class="keyword">List</span>&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">List</span><span class="meta">&lt;?</span> extends T&gt; <span class="keyword">list</span> : lists) &#123;</div><div class="line">result.addAll(<span class="keyword">list</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h2><p>在开发代码时，有时候代码会变得过时和不应该再被使用。在这些情况下，通常会有个替补的更适合手头的任务，且虽然现存的对过时代码的调用可能会保留，但是所有新的调用都应该使用替换方法。这个过时的代码被称为不推荐使用的代码。在某些紧急情况下，不建议使用的代码可能会被删除，应该在未来的框架或库版本从其代码库中删除弃用的代码之前立即转换为替换代码。<br>了支持不推荐使用的代码的文档，Java包含@Deprecated注解，它会将一些构造函数、域、局部变量、方法、软件包、模块、参数或类型标记为已弃用。如果弃用的元素（构造函数，域，局部变量等）被使用了，则编译器发出警告。例如，我们可以创建一个弃用的类并按如下所示使用它：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span>&#125;</div><div class="line">Foo foo = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure></p>
<p>如果我们编译此代码（在命名为Main.java的文件中），我们会收到以下警告：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ javac Main.java</div><div class="line">Note: Main<span class="selector-class">.java</span> uses or overrides <span class="selector-tag">a</span> deprecated API.</div><div class="line">Note: Recompile with -Xlint:deprecation <span class="keyword">for</span> <span class="selector-tag">details</span>.</div></pre></td></tr></table></figure></p>
<p>通常，每当使用@Deprecated注解的元素时，都会引发警告，除了用于以下五种情况：</p>
<ul>
<li>声明本身就被声明为是弃用的（即递归调用）。</li>
<li>声明被注解禁止弃用警告（即@SuppressWarnings(“deprecation”）注解，如上所述，应用于使用弃用元素的上下文。</li>
<li>使用和声明都在同一个最外面的类中（即，如果类调用其本身的弃用方法）。</li>
<li>用在import声明中，该声明导入通常不赞成使用的类型或构件（即，在将已弃用的类导入另一个类时）。</li>
<li>exports或opens指令内。</li>
</ul>
<p>正如前面所说的，在某些情况下，当不推荐使用的元素将被删除，则调用代码应立即删除不推荐使用的元素（称为terminally deprecated code）。在这种情况下，可以使用forRemoval参数提供的@Deprecated注解，如下所示：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Deprecated</span>(forRemoval = <span class="literal">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span>&#125;</div></pre></td></tr></table></figure></p>
<p>使用此最终弃用代码会导致一系列更严格的警告：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ javac Main.java</div><div class="line">Main.java:<span class="number">7</span>: warning: [removal] Foo <span class="keyword">in</span> com.foo <span class="keyword">has</span> been <span class="keyword">deprecated</span> <span class="keyword">and</span> marked <span class="keyword">for</span> removal</div><div class="line">Foo foo = <span class="keyword">new</span> Foo();</div><div class="line">^</div><div class="line">Main.java:<span class="number">7</span>: warning: [removal] Foo <span class="keyword">in</span> com.foo <span class="keyword">has</span> been <span class="keyword">deprecated</span> <span class="keyword">and</span> marked <span class="keyword">for</span> removal</div><div class="line">Foo foo = <span class="keyword">new</span> Foo();</div><div class="line">^</div><div class="line"><span class="number">2</span> warnings</div></pre></td></tr></table></figure></p>
<p>除了标准@Deprcated注解所描述的相同异常之外，总是会发出最终弃用的警告。我们还可以通过为注解提供since变量来添加文档到@Deprecated注解中：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Deprecated</span>(since = <span class="string">"1.0.5"</span>, forRemoval = <span class="literal">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span>&#125;</div></pre></td></tr></table></figure></p>
<p>可以使用@deprecated JavaDoc元素（注意小写字母d）进一步文档化已弃用的元素，如以下代码片段所示：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"><span class="markdown">/**</span></span></div><div class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Some test class.</span></span></div><div class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@deprecated Replaced by &#123;@link com.foo.NewerFoo&#125;.</span></span></div><div class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>@author Justin Albano</span></span></div><div class="line"><span class="comment"><span class="markdown">*/</span></span></div><div class="line"><span class="meta">@Deprecated</span>(since = <span class="string">"1.0.5"</span>, forRemoval = <span class="keyword">true</span>)</div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本文中，我们将看到五个Java编译器支持的注解，并了解其期望用途。顺便，我们将探索其创建背后的基本原理，围绕其用途的一些特质，以及正确应用的一些例子。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CSS技巧</title>
    <link href="http://www.sanstylemc.cn/2018/04/05/CSS%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.sanstylemc.cn/2018/04/05/CSS技巧/</id>
    <published>2018-04-05T02:54:57.000Z</published>
    <updated>2018-04-05T02:55:40.175Z</updated>
    
    <content type="html"><![CDATA[<p>这几个CSS技巧，可以用在项目上，帮助自己很好地整理自己的元素并让他们看起来挺不错的。<br><a id="more"></a></p>
<h2 id="黑白图像"><a href="#黑白图像" class="headerlink" title="黑白图像"></a>黑白图像</h2><p>这段代码会让你的彩色照片显示为黑白照片。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span><span class="selector-class">.desaturate</span> &#123; <span class="attribute">filter</span>: <span class="built_in">grayscale</span>(100%); <span class="attribute">-webkit-filter</span>: <span class="built_in">grayscale</span>(100%); <span class="attribute">-moz-filter</span>: <span class="built_in">grayscale</span>(100%); <span class="attribute">-ms-filter</span>: <span class="built_in">grayscale</span>(100%); <span class="attribute">-o-filter</span>: <span class="built_in">grayscale</span>(100%);&#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用-not-在菜单上应用-取消应用边框"><a href="#使用-not-在菜单上应用-取消应用边框" class="headerlink" title="使用:not()在菜单上应用/取消应用边框"></a>使用:not()在菜单上应用/取消应用边框</h2><p>先给每一个菜单项添加边框<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* add border*/</span><span class="selector-class">.nav</span> <span class="selector-tag">li</span> &#123;<span class="attribute">border</span>=right: <span class="number">1px</span> solid <span class="number">#666</span>;&#125;</div></pre></td></tr></table></figure></p>
<p>然后再出去最后一个元素<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//<span class="built_in">remove</span> <span class="built_in">border</span> /.nav <span class="built_in">li</span>: <span class="built_in">last</span>-child &#123;<span class="built_in">border</span>-right: none;&#125;</div></pre></td></tr></table></figure></p>
<p>可以直接使用:not()伪类来应用元素:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.nav</span> <span class="selector-tag">li</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-child)</span> &#123;<span class="attribute">border-right</span>: <span class="number">1px</span> solid <span class="number">#666</span>;&#125;</div></pre></td></tr></table></figure></p>
<p>这样代码就干净，易读，易于理解了。<br>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符(~)：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.<span class="selector-class">.nav</span> <span class="selector-tag">li</span>: first-child ~ <span class="selector-tag">li</span> &#123;<span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#666</span>;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="页面顶部阴影"><a href="#页面顶部阴影" class="headerlink" title="页面顶部阴影"></a>页面顶部阴影</h2><p>下面这个简单的CSS3代码片段可以给网页加上漂亮的顶部阴影效果:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:before</span> &#123; <span class="attribute">content</span>: <span class="string">""</span>; <span class="attribute">position</span>: fixed; <span class="attribute">top</span>: -<span class="number">10px</span>; <span class="attribute">left</span>: <span class="number">0</span>; <span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">10px</span>; <span class="attribute">-webkit-box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">10px</span> <span class="built_in">rgba</span>(0,0,0,.8); <span class="attribute">-moz-box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">10px</span> <span class="built_in">rgba</span>(0,0,0,.8); <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">10px</span> <span class="built_in">rgba</span>(0,0,0,.8); <span class="attribute">z-index</span>: <span class="number">100</span>;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="给body添加行高"><a href="#给body添加行高" class="headerlink" title="给body添加行高"></a>给body添加行高</h2><p>你不需要分别添加line-height到每个p, h标记等，只要添加到body即可:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>&#123; <span class="attribute">line-height</span>: <span class="number">1</span>;&#125;</div></pre></td></tr></table></figure></p>
<p>这样文本元素就可以很容易地从body继承。</p>
<p>##所有一切都垂直居中<br>要将所有元素垂直居中，太简单了:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123; <span class="attribute">height</span>: <span class="number">100%</span>; <span class="attribute">margin</span>: <span class="number">0</span>;&#125;<span class="selector-tag">body</span> &#123; <span class="attribute">-webkit-align-items</span>: center; <span class="attribute">-ms-flex-align</span>: center; <span class="attribute">align-items</span>: center; <span class="attribute">display</span>: -webkit-flex; <span class="attribute">display</span>: flex;&#125;</div></pre></td></tr></table></figure></p>
<p>注意: 在IE11中要小心flexbox。</p>
<h2 id="逗号分隔地列表"><a href="#逗号分隔地列表" class="headerlink" title="逗号分隔地列表"></a>逗号分隔地列表</h2><p>让HTML列表项看上去像一个真正地，用逗号分隔地列表:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-child)</span><span class="selector-pseudo">::after</span> &#123; <span class="attribute">content</span>: <span class="string">","</span>;&#125;</div></pre></td></tr></table></figure></p>
<p>堆最后一个列表项使用:not()伪类。</p>
<h2 id="使用负地nth-child选择项目"><a href="#使用负地nth-child选择项目" class="headerlink" title="使用负地nth-child选择项目"></a>使用负地nth-child选择项目</h2><p>在CSS中使用负地nth-child选择项目1到项目n。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">li</span> &#123; <span class="attribute">display</span>: none;&#125;<span class="comment">/* select items 1 through 3 and display them */</span><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(-n+3)</span> &#123; <span class="attribute">display</span>: block;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="对图标使用SVG"><a href="#对图标使用SVG" class="headerlink" title="对图标使用SVG"></a>对图标使用SVG</h2><p>我们没有理由不对图标使用SVG:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.logo</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"logo.svg"</span>);&#125;</div></pre></td></tr></table></figure></p>
<p>SVG对所有地分辨率类型都具有良好地扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p>
<h2 id="优化显示文本"><a href="#优化显示文本" class="headerlink" title="优化显示文本"></a>优化显示文本</h2><p>有时，字体并不能在所有设备上都达到最佳地显示，所以可以让设备浏览器来帮助你:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123; <span class="attribute">-moz-osx-font-smoothing</span>: grayscale; <span class="attribute">-webkit-font-smoothing</span>: antialiased; <span class="attribute">text-rendering</span>: optimizeLegibility;&#125;</div></pre></td></tr></table></figure></p>
<p>注: 请负责人地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。</p>
<h2 id="对纯CSS滑块使用max-height"><a href="#对纯CSS滑块使用max-height" class="headerlink" title="对纯CSS滑块使用max-height"></a>对纯CSS滑块使用max-height</h2><p>使用max-height和溢出隐藏来实现只有CSS地滑块:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.slider</span> <span class="selector-tag">ul</span> &#123; <span class="attribute">max-height</span>: <span class="number">0</span>; <span class="attribute">overlow</span>: hidden;&#125;<span class="selector-class">.slider</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">ul</span> &#123; <span class="attribute">max-height</span>: <span class="number">1000px</span>; <span class="attribute">transition</span>: .<span class="number">3s</span> ease;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="继承box-sizing"><a href="#继承box-sizing" class="headerlink" title="继承box-sizing"></a>继承box-sizing</h2><p>让box-sizing继承html:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123; <span class="attribute">box-sizing</span>: border-box;&#125;*, *<span class="selector-pseudo">:before</span>, *<span class="selector-pseudo">:after</span> &#123; <span class="attribute">box-sizing</span>: inherit;&#125;</div></pre></td></tr></table></figure></p>
<p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。</p>
<h2 id="表格单元格等宽"><a href="#表格单元格等宽" class="headerlink" title="表格单元格等宽"></a>表格单元格等宽</h2><p>表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.calendar</span> &#123; <span class="attribute">table-layout</span>: fixed;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用Flexbox摆脱外边距地各种hack"><a href="#使用Flexbox摆脱外边距地各种hack" class="headerlink" title="使用Flexbox摆脱外边距地各种hack"></a>使用Flexbox摆脱外边距地各种hack</h2><p>当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.list</span> &#123; <span class="attribute">display</span>: flex; <span class="attribute">justify-content</span>: space-between;&#125;<span class="selector-class">.list</span> <span class="selector-class">.person</span> &#123; <span class="attribute">flex-basis</span>: <span class="number">23%</span>;&#125;</div></pre></td></tr></table></figure></p>
<p>现在，列表分隔符就会在均匀间隔地位置出现。</p>
<h2 id="使用属性选择器用于空链接"><a href="#使用属性选择器用于空链接" class="headerlink" title="使用属性选择器用于空链接"></a>使用属性选择器用于空链接</h2><p>当a元素没有文本值，但 href 属性有链接的时候显示链接:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="http"]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">::before</span> &#123; <span class="attribute">content</span>: <span class="built_in">attr</span>(href);</div></pre></td></tr></table></figure></p>
<h2 id="检测鼠标双击"><a href="#检测鼠标双击" class="headerlink" title="检测鼠标双击"></a>检测鼠标双击</h2><p>HTML<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"test3"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">" "</span> <span class="attr">readonly</span>=<span class="string">"true"</span> /&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://renpingjun.com"</span>&gt;</span>Double click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>CSS<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.test3</span> <span class="selector-tag">span</span> &#123; <span class="attribute">position</span>: relative;&#125;<span class="selector-class">.test3</span> <span class="selector-tag">span</span> <span class="selector-tag">a</span> &#123; <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">2</span>;&#125;<span class="selector-class">.test3</span> <span class="selector-tag">span</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-class">.test3</span> <span class="selector-tag">span</span> <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">z-index</span>: <span class="number">4</span>;&#125;<span class="selector-class">.test3</span> <span class="selector-tag">span</span> <span class="selector-tag">input</span> &#123; <span class="attribute">background</span>: transparent; <span class="attribute">border</span>: <span class="number">0</span>; <span class="attribute">cursor</span>: pointer; <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: -<span class="number">1px</span>; <span class="attribute">left</span>: <span class="number">0</span>; <span class="attribute">width</span>: <span class="number">101%</span>; <span class="comment">/* Hacky */</span> <span class="attribute">height</span>: <span class="number">301%</span>; <span class="comment">/* Hacky */</span> <span class="attribute">z-index</span>: <span class="number">3</span>;&#125;<span class="selector-class">.test3</span> <span class="selector-tag">span</span> <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123; <span class="attribute">background</span>: transparent; <span class="attribute">border</span>: <span class="number">0</span>; <span class="attribute">z-index</span>: <span class="number">1</span>;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CSS写出三角形"><a href="#CSS写出三角形" class="headerlink" title="CSS写出三角形"></a>CSS写出三角形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* create an arrow that points up */</span><span class="selector-tag">div</span><span class="selector-class">.arrow-up</span> &#123; <span class="attribute">width</span>:<span class="number">0px</span>; <span class="attribute">height</span>:<span class="number">0px</span>; <span class="attribute">border-left</span>:<span class="number">5px</span> solid transparent; <span class="comment">/* left arrow slant */</span> <span class="attribute">border-right</span>:<span class="number">5px</span> solid transparent; <span class="comment">/* right arrow slant */</span> <span class="attribute">border-bottom</span>:<span class="number">5px</span> solid <span class="number">#2f2f2f</span>; <span class="comment">/* bottom, add background color here */</span> <span class="attribute">font-size</span>:<span class="number">0px</span>; <span class="attribute">line-height</span>:<span class="number">0px</span>;&#125;<span class="comment">/* create an arrow that points down */</span><span class="selector-tag">div</span><span class="selector-class">.arrow-down</span> &#123; <span class="attribute">width</span>:<span class="number">0px</span>; <span class="attribute">height</span>:<span class="number">0px</span>; <span class="attribute">border-left</span>:<span class="number">5px</span> solid transparent; <span class="attribute">border-right</span>:<span class="number">5px</span> solid transparent; <span class="attribute">border-top</span>:<span class="number">5px</span> solid <span class="number">#2f2f2f</span>; <span class="attribute">font-size</span>:<span class="number">0px</span>; <span class="attribute">line-height</span>:<span class="number">0px</span>;&#125;<span class="comment">/* create an arrow that points left */</span><span class="selector-tag">div</span><span class="selector-class">.arrow-left</span> &#123; <span class="attribute">width</span>:<span class="number">0px</span>; <span class="attribute">height</span>:<span class="number">0px</span>; <span class="attribute">border-bottom</span>:<span class="number">5px</span> solid transparent; <span class="comment">/* left arrow slant */</span> <span class="attribute">border-top</span>:<span class="number">5px</span> solid transparent; <span class="comment">/* right arrow slant */</span> <span class="attribute">border-right</span>:<span class="number">5px</span> solid <span class="number">#2f2f2f</span>; <span class="comment">/* bottom, add background color here */</span> <span class="attribute">font-size</span>:<span class="number">0px</span>; <span class="attribute">line-height</span>:<span class="number">0px</span>;&#125;<span class="comment">/* create an arrow that points right */</span><span class="selector-tag">div</span><span class="selector-class">.arrow-right</span> &#123; <span class="attribute">width</span>:<span class="number">0px</span>; <span class="attribute">height</span>:<span class="number">0px</span>; <span class="attribute">border-bottom</span>:<span class="number">5px</span> solid transparent; <span class="comment">/* left arrow slant */</span> <span class="attribute">border-top</span>:<span class="number">5px</span> solid transparent; <span class="comment">/* right arrow slant */</span> <span class="attribute">border-left</span>:<span class="number">5px</span> solid <span class="number">#2f2f2f</span>; <span class="comment">/* bottom, add background color here */</span> <span class="attribute">font-size</span>:<span class="number">0px</span>; <span class="attribute">line-height</span>:<span class="number">0px</span>;&#125;</div></pre></td></tr></table></figure>
<h2 id="CSS3-calc-的使用"><a href="#CSS3-calc-的使用" class="headerlink" title="CSS3 calc()的使用"></a>CSS3 calc()的使用</h2><p>calc() 用法类似于函数，能够给元素设置动态的值:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* basic calc */</span><span class="selector-class">.simpleBlock</span> &#123; <span class="attribute">width</span>: <span class="built_in">calc</span>(100% - 100px);&#125;<span class="comment">/* calc in calc */</span><span class="selector-class">.complexBlock</span> &#123; <span class="attribute">width</span>: <span class="built_in">calc</span>(100% - 50% / 3); <span class="attribute">padding</span>: <span class="number">5px</span> <span class="built_in">calc</span>(3% - 2px); <span class="attribute">margin-left</span>: <span class="built_in">calc</span>(10% + 10px);&#125;</div></pre></td></tr></table></figure></p>
<h2 id="文本渐变"><a href="#文本渐变" class="headerlink" title="文本渐变"></a>文本渐变</h2><p>文本渐变效果很流行，使用 CSS3 能够很简单就实现:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h2</span><span class="selector-attr">[data-text]</span> &#123; <span class="attribute">position</span>: relative;&#125;<span class="selector-tag">h2</span><span class="selector-attr">[data-text]</span><span class="selector-pseudo">::after</span> &#123; <span class="attribute">content</span>: <span class="built_in">attr</span>(data-text); <span class="attribute">z-index</span>: <span class="number">10</span>; <span class="attribute">color</span>: <span class="number">#e3e3e3</span>; <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>; <span class="attribute">-webkit-mask-image</span>: <span class="built_in">-webkit-gradient</span>(linear, left top, left bottom, from(rgba(0,0,0,0)), <span class="built_in">color-stop</span>(50%, rgba(0,0,0,1)), <span class="built_in">to</span>(rgba(0,0,0,0)));&#125;</div></pre></td></tr></table></figure></p>
<h2 id="禁用鼠标事件"><a href="#禁用鼠标事件" class="headerlink" title="禁用鼠标事件"></a>禁用鼠标事件</h2><p>CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.disabled</span> &#123; <span class="attribute">pointer-events</span>: none; &#125;</div></pre></td></tr></table></figure></p>
<h2 id="模糊文本"><a href="#模糊文本" class="headerlink" title="模糊文本"></a>模糊文本</h2><p>简单但很漂亮的文本模糊效果，简单又好看！<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.blur</span> &#123; <span class="attribute">color</span>: transparent; <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(0,0,0,0.5);&#125;</div></pre></td></tr></table></figure></p>
<h2 id="简单的方法调整图片大小"><a href="#简单的方法调整图片大小" class="headerlink" title="简单的方法调整图片大小"></a>简单的方法调整图片大小</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.content</span> <span class="selector-tag">img</span> &#123;</div><div class="line"><span class="attribute">height</span>:auto;</div><div class="line"><span class="attribute">width</span>:<span class="number">500px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="IE-HTML-Hack"><a href="#IE-HTML-Hack" class="headerlink" title="IE HTML Hack"></a>IE HTML Hack</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-id">#content</span> &#123;<span class="attribute">width</span>: <span class="number">580px</span>&#125;</div><div class="line">* <span class="selector-tag">html</span> <span class="selector-tag">body</span> <span class="selector-tag">div</span><span class="selector-id">#content</span> &#123;<span class="attribute">width</span>: <span class="number">600px</span>&#125;</div></pre></td></tr></table></figure>
<h2 id="CSS-阴影"><a href="#CSS-阴影" class="headerlink" title="CSS 阴影"></a>CSS 阴影</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.shadow</span> &#123;</div><div class="line"><span class="attribute">-moz-box-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">5px</span> <span class="number">6px</span> <span class="number">#ccc</span>;</div><div class="line"><span class="attribute">-webkit-box-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">5px</span> <span class="number">6px</span> <span class="number">#ccc</span>;</div><div class="line"><span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">5px</span> <span class="number">6px</span> <span class="number">#ccc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CSS首字放大"><a href="#CSS首字放大" class="headerlink" title="CSS首字放大"></a>CSS首字放大</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-letter</span> &#123;</div><div class="line"><span class="attribute">display</span>: block;</div><div class="line"><span class="attribute">float</span>: left;</div><div class="line"><span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">0</span> <span class="number">0</span>;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line"><span class="attribute">font-size</span>: <span class="number">1.4em</span>;</div><div class="line"><span class="attribute">background</span>: <span class="number">#ddd</span>;</div><div class="line"><span class="attribute">font-family</span>: Helvetica;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="用CSS反转图像"><a href="#用CSS反转图像" class="headerlink" title="用CSS反转图像"></a>用CSS反转图像</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#content</span> <span class="selector-tag">img</span> &#123;</div><div class="line"><span class="attribute">-moz-transform</span>: <span class="built_in">scaleX</span>(-1);</div><div class="line"><span class="attribute">-o-transform</span>: <span class="built_in">scaleX</span>(-1);</div><div class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">scaleX</span>(-1);</div><div class="line"><span class="attribute">transform</span>: <span class="built_in">scaleX</span>(-1);</div><div class="line"><span class="attribute">filter</span>: FlipH;</div><div class="line"><span class="attribute">-ms-filter</span>: <span class="string">"FlipH"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="移除被点链接的点框"><a href="#移除被点链接的点框" class="headerlink" title="移除被点链接的点框"></a>移除被点链接的点框</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">outline</span>: none&#125;</div><div class="line">或者</div><div class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">outline</span>: <span class="number">0</span>&#125;</div></pre></td></tr></table></figure>
<h2 id="在CSS中使用特殊字体"><a href="#在CSS中使用特殊字体" class="headerlink" title="在CSS中使用特殊字体"></a>在CSS中使用特殊字体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">你可以使用CSS来加载特殊字体，你要做的就是把这个TTF格式的字体上传到服务器上，然后使用字体规则在CSS上导入它。</div></pre></td></tr></table></figure>
<h2 id="元素透明"><a href="#元素透明" class="headerlink" title="元素透明"></a>元素透明</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line"><span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=50);</div><div class="line"><span class="attribute">-moz-opacity</span>:<span class="number">0.5</span>;</div><div class="line"><span class="attribute">-khtml-opacity</span>: <span class="number">0.5</span>;</div><div class="line"><span class="attribute">opacity</span>: <span class="number">0.5</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用CSS显示链接之后的URL"><a href="#使用CSS显示链接之后的URL" class="headerlink" title="使用CSS显示链接之后的URL"></a>使用CSS显示链接之后的URL</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">content</span>:<span class="string">" ("</span> <span class="built_in">attr</span>(href) <span class="string">") "</span>;&#125;</div><div class="line">这会在链接锚点后显示<span class="selector-tag">URL</span>。你也可以用字体或其他样式定义它。</div></pre></td></tr></table></figure>
<h2 id="为手持设备定制特殊样式"><a href="#为手持设备定制特殊样式" class="headerlink" title="为手持设备定制特殊样式"></a>为手持设备定制特殊样式</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link <span class="attribute">type</span>=<span class="string">"text/css"</span> <span class="attribute">rel</span>=<span class="string">"stylesheet"</span> <span class="attribute">href</span>=<span class="string">"handheldstyle.css"</span> <span class="attribute">media</span>=<span class="string">"handheld"</span>&gt;</div></pre></td></tr></table></figure>
<h2 id="文字的水平居中"><a href="#文字的水平居中" class="headerlink" title="文字的水平居中"></a>文字的水平居中</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">text</span>-<span class="keyword">align</span>:center;</div></pre></td></tr></table></figure>
<h2 id="link状态的设置顺序"><a href="#link状态的设置顺序" class="headerlink" title="link状态的设置顺序"></a>link状态的设置顺序</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span>:link</div><div class="line"><span class="selector-tag">a</span>:visited</div><div class="line"><span class="selector-tag">a</span>:hover</div><div class="line"><span class="selector-tag">a</span>:active</div></pre></td></tr></table></figure>
<h2 id="用图片充当列表标志"><a href="#用图片充当列表标志" class="headerlink" title="用图片充当列表标志"></a>用图片充当列表标志</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> &#123;<span class="attribute">list-style</span>: none&#125;</div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</div><div class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"path-to-your-image"</span>);</div><div class="line"><span class="attribute">background-repeat</span>: none;</div><div class="line"><span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0.5em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="禁止自动换行"><a href="#禁止自动换行" class="headerlink" title="禁止自动换行"></a>禁止自动换行</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">white-space</span>:nowrap; &#125;</div></pre></td></tr></table></figure>
<h2 id="获得焦点的表单元素"><a href="#获得焦点的表单元素" class="headerlink" title="获得焦点的表单元素"></a>获得焦点的表单元素</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid green; &#125;</div></pre></td></tr></table></figure>
<h2 id="user-select-禁止用户选中文本"><a href="#user-select-禁止用户选中文本" class="headerlink" title="user-select 禁止用户选中文本"></a>user-select 禁止用户选中文本</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line"><span class="attribute">user-select</span>: none; <span class="comment">/* Standard syntax */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="清除手机tap事件后element-时候出现的一个高亮"><a href="#清除手机tap事件后element-时候出现的一个高亮" class="headerlink" title="清除手机tap事件后element 时候出现的一个高亮"></a>清除手机tap事件后element 时候出现的一个高亮</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line"><span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(0,0,0,0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="增强用户体验，使用伪元素实现增大点击热区"><a href="#增强用户体验，使用伪元素实现增大点击热区" class="headerlink" title="增强用户体验，使用伪元素实现增大点击热区"></a>增强用户体验，使用伪元素实现增大点击热区</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">::befoer</span>&#123;</div><div class="line"><span class="attribute">content</span>:<span class="string">""</span>;</div><div class="line"><span class="attribute">position</span>:absolute;</div><div class="line"><span class="attribute">top</span>:-<span class="number">10px</span>;</div><div class="line"><span class="attribute">right</span>:-<span class="number">10px</span>;</div><div class="line"><span class="attribute">bottom</span>:-<span class="number">10px</span>;</div><div class="line"><span class="attribute">left</span>:-<span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="伪元素实现换行，替代换行标签"><a href="#伪元素实现换行，替代换行标签" class="headerlink" title="伪元素实现换行，替代换行标签"></a>伪元素实现换行，替代换行标签</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">inline-element</span> <span class="selector-pseudo">::after</span>&#123;</div><div class="line"><span class="attribute">content</span>:<span class="string">"A"</span>;</div><div class="line"><span class="attribute">white-space</span>: pre;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="will-change提高页面滚动、动画等渲染性能"><a href="#will-change提高页面滚动、动画等渲染性能" class="headerlink" title="will-change提高页面滚动、动画等渲染性能"></a>will-change提高页面滚动、动画等渲染性能</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 关键字值 */</span></div><div class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">auto</span>;</div><div class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">scroll-position</span>;</div><div class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">contents</span>;</div><div class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">transform</span>; <span class="comment">/* &lt;custom-ident&gt;示例 */</span></div><div class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">opacity</span>; <span class="comment">/* &lt;custom-ident&gt;示例 */</span></div><div class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">left</span>, <span class="selector-tag">top</span>; <span class="comment">/* 两个&lt;animateable-feature&gt;示例 */</span></div><div class="line"><span class="selector-tag">will-change</span>的使用也要谨慎，遵循最小化影响原则，不要这样直接写在默认状态中，因为<span class="selector-tag">will-change</span>会一直挂着：</div><div class="line"><span class="selector-class">.will-change</span> &#123;</div><div class="line"><span class="attribute">will-change</span>: transform;</div><div class="line"><span class="attribute">transition</span>: transform <span class="number">0.3s</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.will-change</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(1.5);</div><div class="line">&#125;</div><div class="line">可以让父元素<span class="selector-tag">hover</span>的时候，声明<span class="selector-tag">will-change</span>，这样，移出的时候就会自动<span class="selector-tag">remove</span>，触发的范围基本上是有效元素范围。</div><div class="line"><span class="selector-class">.will-change-parent</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.will-change</span> &#123;</div><div class="line"><span class="attribute">will-change</span>: transform;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.will-change</span> &#123;</div><div class="line"><span class="attribute">transition</span>: transform <span class="number">0.3s</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.will-change</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(1.5);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="box-sizing-让元素的宽度、高度包含border和padding"><a href="#box-sizing-让元素的宽度、高度包含border和padding" class="headerlink" title="box-sizing 让元素的宽度、高度包含border和padding"></a>box-sizing 让元素的宽度、高度包含border和padding</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="attribute">box-sizing</span>: border-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="calc-function-计算属性值"><a href="#calc-function-计算属性值" class="headerlink" title="calc() function, 计算属性值"></a>calc() function, 计算属性值</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line"><span class="attribute">width</span>: <span class="built_in">calc</span>(100% - 100px);</div><div class="line">&#125;</div><div class="line">例子就是让宽度为100%减去100<span class="selector-tag">px</span>的值</div></pre></td></tr></table></figure>
<h2 id="css实现不换行、自动换行、强制换行"><a href="#css实现不换行、自动换行、强制换行" class="headerlink" title="css实现不换行、自动换行、强制换行"></a>css实现不换行、自动换行、强制换行</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不换行</span></div><div class="line">white-space:nowrap;</div><div class="line"><span class="comment">//自动换行</span></div><div class="line"><span class="keyword">word</span>-wrap: <span class="built_in">break</span>-<span class="keyword">word</span>;</div><div class="line"><span class="keyword">word</span>-<span class="built_in">break</span>: normal;</div><div class="line"><span class="comment">//强制换行</span></div><div class="line"><span class="keyword">word</span>-<span class="built_in">break</span>:<span class="built_in">break</span>-all;</div></pre></td></tr></table></figure>
<h2 id="perspective-透视"><a href="#perspective-透视" class="headerlink" title="perspective 透视"></a>perspective 透视</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这个属性的存在决定你看到的元素是2<span class="selector-tag">d</span>还是3<span class="selector-tag">d</span>。一般设置在包裹元素的父类上。</div><div class="line"><span class="selector-class">.div-box</span> &#123;</div><div class="line"><span class="attribute">perspective</span>: <span class="number">400px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="设置图像透明度的两种方式"><a href="#设置图像透明度的两种方式" class="headerlink" title="设置图像透明度的两种方式"></a>设置图像透明度的两种方式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">opcity</span><span class="selector-pseudo">:0.6</span>；</div><div class="line"><span class="selector-tag">background</span><span class="selector-pseudo">:rgba(0</span>,0,0,<span class="selector-class">.6</span>)；</div></pre></td></tr></table></figure>
<h2 id="position定位属性"><a href="#position定位属性" class="headerlink" title="position定位属性"></a>position定位属性</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">position</span>属性指定一个元素(静态的、相对的、绝对或固定)的定位方法的类型。</div><div class="line"><span class="attribute">position</span>的属性值：</div><div class="line">absolute：生成绝对定位的元素；</div><div class="line">fixed：生成绝对定位的元素，相对于浏览器窗口进行定位；</div><div class="line">relative：生成相对定位的元素，相对于其正常位置经行定位。</div><div class="line"><span class="attribute">z-index</span>：指定一个元素的堆叠顺序。</div></pre></td></tr></table></figure>
<h2 id="cursor属性"><a href="#cursor属性" class="headerlink" title="cursor属性"></a>cursor属性</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cursor属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状。</div><div class="line">CSS提供的cursor值：</div><div class="line">pointer ：小手指；</div><div class="line"><span class="keyword">help</span>：箭头加问号；</div><div class="line"><span class="keyword">wait</span>：转圈圈；</div><div class="line"><span class="keyword">move</span>：移动光标；</div><div class="line">crosshair：十字光标。</div><div class="line">通过pointer属性我们可以伪造超链接：</div><div class="line">&lt;span <span class="keyword">style</span>=<span class="string">"cursor:pointer;color:blue;"</span>&gt;pointer&lt;/span&gt;</div></pre></td></tr></table></figure>
<h2 id="隐藏没有静音、自动播放的影片"><a href="#隐藏没有静音、自动播放的影片" class="headerlink" title="隐藏没有静音、自动播放的影片"></a>隐藏没有静音、自动播放的影片</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">video</span><span class="selector-attr">[autoplay]</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[muted]</span>) &#123;</div><div class="line"><span class="attribute">display</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Font-Size-基准"><a href="#Font-Size-基准" class="headerlink" title="Font-Size 基准"></a>Font-Size 基准</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 假设浏览器的默认的大小是 16px ， 首先将其设置为10px (font-size:10/16) */</span></div><div class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>:<span class="number">10</span>/<span class="number">16</span>;&#125;</div><div class="line"><span class="comment">/* 然后就可以用em做统一字体单位了 2.4em = 24px */</span></div><div class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2.4</span> em&#125;</div></pre></td></tr></table></figure>
<h2 id="透明容器"><a href="#透明容器" class="headerlink" title="透明容器"></a>透明容器</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line"><span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=50); <span class="comment">/* for ie */</span></div><div class="line"><span class="attribute">-moz-opacity</span>:<span class="number">0.5</span>; <span class="comment">/* for ff */</span></div><div class="line"><span class="attribute">-khtml-opacity</span>: <span class="number">0.5</span>; <span class="comment">/* for webkit as chrome */</span></div><div class="line"><span class="attribute">opacity</span>: <span class="number">0.5</span>; <span class="comment">/* for opera */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几个CSS技巧，可以用在项目上，帮助自己很好地整理自己的元素并让他们看起来挺不错的。&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://www.sanstylemc.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Java多态的实现原理</title>
    <link href="http://www.sanstylemc.cn/2018/04/03/Java%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://www.sanstylemc.cn/2018/04/03/Java多态的实现原理/</id>
    <published>2018-04-03T07:36:59.000Z</published>
    <updated>2018-04-03T11:45:07.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java多态概述"><a href="#Java多态概述" class="headerlink" title="Java多态概述"></a>Java多态概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;多态是面向对象编程语言的重要特性，它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。Java对于方法调用动态绑定的实现主要依赖于方法表，但通过类引用调用(invokevitual)和接口引用调用(invokeinterface)的实现则有所不同。<br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>类引用调用的大致过程为:</code>Java编译器将Java源代码编译成class文件，在编译过程中，会根据静态类型将调用的符号引用写到class文件中。在执行时，JVM根据class文件找到调用方法的符号引用，然后在静态类型的方法表中找到偏移量，然后根据this指针确定对象的实际类型，使用实际类型的方法表，偏移量跟静态类型中方法表的偏移量一样，如果在实际类型的方法表中找到该方法，则直接调用，否则，认为没有重写父类该方法。按照继承关系从下往上搜索。<br><img src="https://github.com/sunstady/hexo/blob/master/Java%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/3.png?raw=true" alt="1"><br>&nbsp;&nbsp;&nbsp;&nbsp;从上图可以看出，当程序运行时，需要某个类时，类载入子系统会将相应的class文件载入到JVM中，并在内部建立该类的类型信息（这个类型信息其实就是class文件在JVM中存储的一种数据结构），包含java类定义的所有信息，包括方法代码，类变量、成员变量、以及本博文要重点讨论的方法表。这个类型信息就存储在方法区。<br>&nbsp;&nbsp;&nbsp;&nbsp;注意，这个方法区中的类型信息跟在堆中存放的class对象是不同的。在方法区中，这个class的类型信息只有唯一的实例（所以是各个线程共享的内存区域），而在堆中可以有多个该class对象。可以通过堆中的class对象访问到方法区中类型信息。就像在java反射机制那样，通过class对象可以访问到该类的所有信息一样。<br><code>方法表是实现动态调用的核心。上面讲过方法表存放在方法区中的类型信息中。为了优化对象
调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，
方法表中的每一个项都是对应方法的指针。</code><br>这些方法中包括从父类继承的所有方法以及自身重写（override）的方法。<br><code>方法区:</code>方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br><code>运行时常量池:</code>它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。方法区的内存回收目标是针对常量池的回收及对类型的卸载。</p>
<h2 id="Java的方法调用方式"><a href="#Java的方法调用方式" class="headerlink" title="Java的方法调用方式"></a>Java的方法调用方式</h2><blockquote>
<p>1、Java 的方法调用有两类，动态方法调用与静态方法调用。<br>2、静态方法调用是指对于类的静态方法的调用方式，是静态绑定的；而动态方法调用需要有方法调用所作用的对象，是动态绑定的。<br>3、类调用 (invokestatic) 是在编译时就已经确定好具体调用方法的情况。<br>4、实例调用 (invokevirtual)则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。<br>5、JVM 的方法调用指令有四个，分别是 invokestatic，invokespecial，invokesvirtual 和 invokeinterface。前两个是静态绑定，后两个是动态绑定的。本文也可以说是对于JVM后两种调用实现的考察。</p>
</blockquote>
<h2 id="方法表与方法调用"><a href="#方法表与方法调用" class="headerlink" title="方法表与方法调用"></a>方法表与方法调用</h2><p>如有类定义Persion、Girl、Boy<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;     </div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;     </div><div class="line">    <span class="keyword">return</span> <span class="string">"I'm a person."</span>;     </div><div class="line">     &#125;     </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;     </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;&#125;     </div><div class="line">        </div><div class="line"> &#125;     </div><div class="line">    </div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;     </div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;     </div><div class="line">    <span class="keyword">return</span> <span class="string">"I'm a boy"</span>;     </div><div class="line">     &#125;     </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;&#125;     </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;&#125;     </div><div class="line"> &#125;     </div><div class="line">    </div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;     </div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;     </div><div class="line">    <span class="keyword">return</span> <span class="string">"I'm a girl"</span>;     </div><div class="line">     &#125;     </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;&#125;     </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>&#123;&#125;     </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当这三个类被载入到Java虚拟机之后，方法区中就包含了各自的类的信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;Girl 和 Boy 的方法表包含继承自 Object 的方法，继承自直接父类Person的方法及各自新定义的方法。注意方法表条目指向的具体的方法地址，如 Girl 继承自Object的方法中，只有 toString()指向自己的实现（Girl 的方法代码），其余皆指向 Object 的方法代码；其继承自于 Person 的方法 eat() 和 speak() 分别指向 Person 的方法实现和本身的实现。<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。</code><br>&nbsp;&nbsp;&nbsp;&nbsp;因此，方法表的偏移量总是固定的。所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。<br>&nbsp;&nbsp;&nbsp;&nbsp;Person或Object中的任意一个方法，在它们的方法表和其子类 Girl和Boy的方法表中的位置(index)是一样的。这样 JVM在调用实例方法其实只需要指定调用方法表中的第几个方法即可。</p>
<h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;因为 Java 类是可以同时实现多个接口的，而当用接口引用调用某个方法的时候，情况就有所不同了。<br>&nbsp;&nbsp;&nbsp;&nbsp;Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同样的方法在基类和派生类的方法表的位置就可能不一样了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IDance</span></span>&#123;     </div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span></span>;     </div><div class="line"> &#125;     </div><div class="line">    </div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;     </div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;     </div><div class="line">   <span class="keyword">return</span> <span class="string">"I'm a person."</span>;     </div><div class="line">     &#125;     </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;     </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;&#125;     </div><div class="line">        </div><div class="line"> &#125;     </div><div class="line">    </div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Dancer</span> <span class="keyword">extends</span> <span class="title">Person</span>     </span></div><div class="line"><span class="class"> <span class="keyword">implements</span> <span class="title">IDance</span> </span>&#123;     </div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;     </div><div class="line">   <span class="keyword">return</span> <span class="string">"I'm a dancer."</span>;     </div><div class="line">     &#125;     </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span></span>&#123;&#125;     </div><div class="line"> &#125;     </div><div class="line">    </div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">implements</span> <span class="title">IDance</span></span>&#123;     </div><div class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;     </div><div class="line">   <span class="keyword">return</span> <span class="string">"A snake."</span>;     </div><div class="line">     &#125;     </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span></span>&#123;     </div><div class="line"> <span class="comment">//snake dance     </span></div><div class="line">     &#125;     </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可以看到，由于接口的介入，继承自于接口 IDance 的方法 dance()在类Dancer和Snake的方法表中的位置已经不一样了，显然我们无法仅根据偏移量来进行方法的调用。<br>&nbsp;&nbsp;&nbsp;&nbsp;Java对于接口方法的调用是采用搜索方法表的方式，如，要在Dancer的方法表中找到dance()方法，必须搜索Dancer的整个方法表。<br>&nbsp;&nbsp;&nbsp;&nbsp;因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是慢于类方法的调用的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java多态概述&quot;&gt;&lt;a href=&quot;#Java多态概述&quot; class=&quot;headerlink&quot; title=&quot;Java多态概述&quot;&gt;&lt;/a&gt;Java多态概述&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;多态是面向对象编程语言的重要特性，它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。Java对于方法调用动态绑定的实现主要依赖于方法表，但通过类引用调用(invokevitual)和接口引用调用(invokeinterface)的实现则有所不同。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>悲观锁与乐观锁</title>
    <link href="http://www.sanstylemc.cn/2018/04/02/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <id>http://www.sanstylemc.cn/2018/04/02/悲观锁与乐观锁/</id>
    <published>2018-04-02T01:45:43.000Z</published>
    <updated>2018-04-02T01:46:14.074Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在<a href="https://sanstylemc.cn/2018/04/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">数据库的锁机制</a>中介绍过，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;乐观并发控制(乐观锁)和悲观并发控制(悲观锁)是并发控制主要采用的技术手段。<br>&nbsp;&nbsp;&nbsp;&nbsp;无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。<br>&nbsp;&nbsp;&nbsp;&nbsp;针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）<br><code>在数据库中，悲观锁的流程如下:</code></p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。<br>&nbsp;&nbsp;&nbsp;&nbsp;其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</p>
</blockquote>
<p><code>MySQL InnoDB中使用悲观锁</code></p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//0.开始事务</div><div class="line"><span class="keyword">begin</span>;/<span class="keyword">begin</span> <span class="keyword">work</span>;/<span class="keyword">start</span> <span class="keyword">transaction</span>; (三者选一就可以)</div><div class="line">//1.查询出商品信息</div><div class="line"><span class="keyword">select</span> <span class="keyword">status</span> <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</div><div class="line">//2.根据商品信息生成订单</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (<span class="keyword">id</span>,goods_id) <span class="keyword">values</span> (<span class="literal">null</span>,<span class="number">1</span>);</div><div class="line">//3.修改商品status为2</div><div class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>;</div><div class="line">//4.提交事务</div><div class="line"><span class="keyword">commit</span>;/<span class="keyword">commit</span> <span class="keyword">work</span>;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p>
</blockquote>
<p><code>优点与不足</code><br>&nbsp;&nbsp;&nbsp;&nbsp;悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。<br>&nbsp;&nbsp;&nbsp;&nbsp;相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。<br>&nbsp;&nbsp;&nbsp;&nbsp;实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</p>
</blockquote>
<p><code>使用版本号实现乐观锁</code><br>&nbsp;&nbsp;&nbsp;&nbsp;使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.查询出商品信息</div><div class="line"><span class="keyword">select</span> (<span class="keyword">status</span>,<span class="keyword">status</span>,<span class="keyword">version</span>) <span class="keyword">from</span> t_goods <span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125;</div><div class="line"><span class="number">2.</span>根据商品信息生成订单</div><div class="line"><span class="number">3.</span>修改商品<span class="keyword">status</span>为<span class="number">2</span></div><div class="line"><span class="keyword">update</span> t_goods </div><div class="line"><span class="keyword">set</span> <span class="keyword">status</span>=<span class="number">2</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></div><div class="line"><span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125; <span class="keyword">and</span> <span class="keyword">version</span>=#&#123;<span class="keyword">version</span>&#125;;</div></pre></td></tr></table></figure></p>
<p><code>优点与不足</code><br>&nbsp;&nbsp;&nbsp;&nbsp;乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在&lt;a href=&quot;https://sanstylemc.cn/2018/04/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;数据库的锁机制&lt;/a&gt;中介绍过，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。&lt;br&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.sanstylemc.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库的锁机制</title>
    <link href="http://www.sanstylemc.cn/2018/04/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.sanstylemc.cn/2018/04/02/数据库的锁机制/</id>
    <published>2018-04-02T01:26:04.000Z</published>
    <updated>2018-04-02T01:26:33.903Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在并发访问情况下，可能会出现脏读、不可重复读和幻读等读现象，为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念。<br><a id="more"></a></p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><blockquote>
<p>在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制是确保及时纠正由并发操作导致的错误的一种机制。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;数据库管理系统(DBMS)中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不被破坏事务的隔离性和统一性以及数据库的统一性。下面举例说明并发操作 带来的数据不一致性问题:<br>&nbsp;&nbsp;&nbsp;&nbsp;现有两处火车票售票点，同时读取某一趟列车车票数据库中车票余额为 X。两处售票点同时卖出一张车票，同时修改余额为 X -1写回数据库，这样就造成了实际卖出两张火车票而数据库中的记录却只少了一张。 产生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制(悲观锁)是并发控制主要采用的技术手段。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。<br>&nbsp;&nbsp;&nbsp;&nbsp;在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。<br><code>锁的分类</code><br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">按操作划分，可分为DML锁、DDL锁</div><div class="line">按锁的粒度划分，可分为表级锁、行级锁、页级锁<span class="comment">(mysql)</span></div><div class="line">按锁级别划分，可分为共享锁、排他锁</div><div class="line">按加锁方式划分，可分为自动锁、显示锁</div><div class="line">按使用方式划分，可分为乐观锁、悲观锁</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁))。 DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义。其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在并发访问情况下，可能会出现脏读、不可重复读和幻读等读现象，为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.sanstylemc.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程通信</title>
    <link href="http://www.sanstylemc.cn/2018/04/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.sanstylemc.cn/2018/04/01/Java多线程通信/</id>
    <published>2018-04-01T11:22:36.000Z</published>
    <updated>2018-04-01T11:23:24.983Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。<br><a id="more"></a></p>
<h2 id="如何让两个线程依次执行"><a href="#如何让两个线程依次执行" class="headerlink" title="如何让两个线程依次执行"></a>如何让两个线程依次执行</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;假设有两个线程，一个是线程A，另一个是线程B，两个线程分别依次打印1-3三个数字即可。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">long1_1</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</div><div class="line">	    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	        <span class="meta">@Override</span></div><div class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	            printNumber(<span class="string">"A"</span>);</div><div class="line">	        &#125;</div><div class="line">	    &#125;);</div><div class="line">	    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	        <span class="meta">@Override</span></div><div class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	            printNumber(<span class="string">"B"</span>);</div><div class="line">	        &#125;</div><div class="line">	    &#125;);</div><div class="line">	    A.start();</div><div class="line">	    B.start();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(String threadName)</span> </span>&#123;</div><div class="line">	    <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">	    <span class="keyword">while</span> (i++ &lt; <span class="number">3</span>) &#123;</div><div class="line">	        <span class="keyword">try</span> &#123;</div><div class="line">	            Thread.sleep(<span class="number">100</span>);</div><div class="line">	        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">	            e.printStackTrace();</div><div class="line">	        &#125;</div><div class="line">	        System.out.println(threadName + <span class="string">"print:"</span> + i);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		demo1();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/0805b944cfc94d6cd42364e671cc3ac1925856aa/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/1.png" alt="1"><br>&nbsp;&nbsp;&nbsp;&nbsp;可以看到A和B是同时打印的。<br>&nbsp;&nbsp;&nbsp;&nbsp;那么，如果我们希望B在A全部打印完后再开始打印呢？可以利用thread.join()方法，代码如下:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">long1_1</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	        @Override</div><div class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	            printNumber(<span class="string">"A"</span>);</div><div class="line">	        &#125;</div><div class="line">	    &#125;);</div><div class="line">	    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	        @Override</div><div class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	            System.<span class="keyword">out</span>.println(<span class="string">"B 开始等待 A"</span>);</div><div class="line">	            <span class="keyword">try</span> &#123;</div><div class="line">	                A.<span class="keyword">join</span>();</div><div class="line">	            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">	                e.printStackTrace();</div><div class="line">	            &#125;</div><div class="line">	            printNumber(<span class="string">"B"</span>);</div><div class="line">	        &#125;</div><div class="line">	    &#125;);</div><div class="line">	    B.start();</div><div class="line">	    A.start();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumber</span>(<span class="params">String threadName</span>) </span>&#123;</div><div class="line">	    <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">	    <span class="keyword">while</span> (i++ &lt; <span class="number">3</span>) &#123;</div><div class="line">	        <span class="keyword">try</span> &#123;</div><div class="line">	            Thread.sleep(<span class="number">100</span>);</div><div class="line">	        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">	            e.printStackTrace();</div><div class="line">	        &#125;</div><div class="line">	        System.<span class="keyword">out</span>.println(threadName + <span class="string">"print:"</span> + i);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		demo1();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/0805b944cfc94d6cd42364e671cc3ac1925856aa/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/2.png" alt="2"></p>
<h2 id="如何让两个线程按照指定方式有序交叉运行？"><a href="#如何让两个线程按照指定方式有序交叉运行？" class="headerlink" title="如何让两个线程按照指定方式有序交叉运行？"></a>如何让两个线程按照指定方式有序交叉运行？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;A在打印完1后，再让B打印1，2，3，最后再回到A继续打印2，3。这种需求下，显然Thread.join()已经不能满足了。我们需要更细粒度的锁来控制执行顺序。这里可以用object.wait()和object.notify()两个方法来实现。代码如下:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">long1_1</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	    Object <span class="keyword">lock</span> = <span class="keyword">new</span> Object();</div><div class="line">	    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	        @Override</div><div class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	            System.<span class="keyword">out</span>.println(<span class="string">"INFO: A 等待锁"</span>);</div><div class="line">	            synchronized (<span class="keyword">lock</span>) &#123;</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"INFO: A 得到了锁 lock"</span>);</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"A 1"</span>);</div><div class="line">	                <span class="keyword">try</span> &#123;</div><div class="line">	                    System.<span class="keyword">out</span>.println(<span class="string">"INFO: A 准备进入等待状态，放弃锁 lock 的控制权"</span>);</div><div class="line">	                    <span class="keyword">lock</span>.wait();</div><div class="line">	                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">	                    e.printStackTrace();</div><div class="line">	                &#125;</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"INFO: 有人唤醒了 A, A 重新获得锁 lock"</span>);</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"A 2"</span>);</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"A 3"</span>);</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">	    &#125;);</div><div class="line">	    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	        @Override</div><div class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	            System.<span class="keyword">out</span>.println(<span class="string">"INFO: B 等待锁"</span>);</div><div class="line">	            synchronized (<span class="keyword">lock</span>) &#123;</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"INFO: B 得到了锁 lock"</span>);</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"B 1"</span>);</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"B 2"</span>);</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"B 3"</span>);</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"INFO: B 打印完毕，调用 notify 方法"</span>);</div><div class="line">	                <span class="keyword">lock</span>.notify();</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">	    &#125;);</div><div class="line">	    A.start();</div><div class="line">	    B.start();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumber</span>(<span class="params">String threadName</span>) </span>&#123;</div><div class="line">	    <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">	    <span class="keyword">while</span> (i++ &lt; <span class="number">3</span>) &#123;</div><div class="line">	        <span class="keyword">try</span> &#123;</div><div class="line">	            Thread.sleep(<span class="number">100</span>);</div><div class="line">	        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">	            e.printStackTrace();</div><div class="line">	        &#125;</div><div class="line">	        System.<span class="keyword">out</span>.println(threadName + <span class="string">"print:"</span> + i);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		demo1();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/0805b944cfc94d6cd42364e671cc3ac1925856aa/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/3.png" alt="3"><br>&nbsp;&nbsp;&nbsp;&nbsp;那么，这个过程发生了什么呢？</p>
<blockquote>
<p>1、首先创建一个A和B共享的对象锁lock = new Object();<br>2、当A得到锁后，先打印1，然后调用lock.wait()方法，交出锁的控制权，进入wait状态；<br>3、对B而言，由于A最开始得到了锁，导致B无法执行；直到A调用lock.wait()释放控制权后，B才得到了锁；<br>4、B在得到锁后打印1，2，3；然后调用lock.notify()方法，唤醒正在 wait的A;<br>5、A被唤醒后，继续打印剩下的2，3。</p>
</blockquote>
<h2 id="四个线程ABCD，其中D要等到ABC全执行完毕后才执行，而且ABC是同步运行的"><a href="#四个线程ABCD，其中D要等到ABC全执行完毕后才执行，而且ABC是同步运行的" class="headerlink" title="四个线程ABCD，其中D要等到ABC全执行完毕后才执行，而且ABC是同步运行的"></a>四个线程ABCD，其中D要等到ABC全执行完毕后才执行，而且ABC是同步运行的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;A，B，C三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要A，B，C都运行完了，D再开始运行。针对这种情况，我们可以利用CountdownLatch来实现这类通信方式。它的基本用法是：</p>
<blockquote>
<p>1、创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);<br>2、在等待线程里调用countDownLatch.await()方法，进入等待状态，直到计数值变成0；<br>3、在其他线程里，调用countDownLatch.countDown()方法，该方法会将计数值减小1；<br>4、当其他线程的countDown()方法把计数值变成0时，等待线程里的countDownLatch.await()立即退出，继续执行下面的代码。代码如下:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">long1_1</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	    <span class="keyword">int</span> worker = <span class="number">3</span>;</div><div class="line">	    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(worker);</div><div class="line">	    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	        @Override</div><div class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	            System.<span class="keyword">out</span>.println(<span class="string">"D is waiting for other three threads"</span>);</div><div class="line">	            <span class="keyword">try</span> &#123;</div><div class="line">	                countDownLatch.<span class="keyword">await</span>();</div><div class="line">	                System.<span class="keyword">out</span>.println(<span class="string">"All done, D starts working"</span>);</div><div class="line">	            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">	                e.printStackTrace();</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">	    &#125;).start();</div><div class="line">	    <span class="keyword">for</span> (<span class="keyword">char</span> threadName=<span class="string">'A'</span>; threadName &lt;= <span class="string">'C'</span>; threadName++) &#123;</div><div class="line">	        final String tN = String.valueOf(threadName);</div><div class="line">	        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	            @Override</div><div class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	                System.<span class="keyword">out</span>.println(tN + <span class="string">"is working"</span>);</div><div class="line">	                <span class="keyword">try</span> &#123;</div><div class="line">	                    Thread.sleep(<span class="number">100</span>);</div><div class="line">	                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">	                    e.printStackTrace();</div><div class="line">	                &#125;</div><div class="line">	                System.<span class="keyword">out</span>.println(tN + <span class="string">"finished"</span>);</div><div class="line">	                countDownLatch.countDown();</div><div class="line">	            &#125;</div><div class="line">	        &#125;).start();</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		demo1();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/0805b944cfc94d6cd42364e671cc3ac1925856aa/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/4.png" alt="4"><br>&nbsp;&nbsp;&nbsp;&nbsp;其实简单点来说，CountDownLatch就是一个倒计数器，我们把初始计数值设置为3，当D运行时，先调用countDownLatch.await()检查计数器值是否为0，若不为0则保持等待状态；当ABC各自运行完后都会利用countDownLatch.countDown()，将倒计数器减1，当三个都运行完后，计数器被减至0；此时立即触发D的await()运行结束，继续向下执行。因此，CountDownLatch适用于一个线程去等待多个线程的情况。</p>
<h2 id="线程-A-B-C-各自开始准备，直到三者都准备完毕，然后再同时运行。"><a href="#线程-A-B-C-各自开始准备，直到三者都准备完毕，然后再同时运行。" class="headerlink" title="线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行。"></a>线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行。</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;为了实现线程间互相等待这种需求，我们可以利用 CyclicBarrier 数据结构，它的基本用法是：</p>
<blockquote>
<p>1、先创建一个公共CyclicBarrier对象，设置同时等待的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);<br>2、这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用cyclicBarrier.await(); 即可开始等待别人；<br>3、当指定的 同时等待的线程数都调用了。cyclicBarrier.await();时，意味着这些线程都准备完毕好，然后这些线程才 同时继续执行。代码如下:<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</div><div class="line"></div><div class="line"><span class="keyword">public</span> class long1_1&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> demo1() &#123;</div><div class="line">	    <span class="built_in">int</span> runner = <span class="number">3</span>;</div><div class="line">	    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(runner);</div><div class="line">	    <span class="keyword">final</span> Random <span class="built_in">random</span> = <span class="keyword">new</span> Random();</div><div class="line">	    <span class="keyword">for</span> (<span class="built_in">char</span> runnerName=<span class="string">'A'</span>; runnerName &lt;= <span class="string">'C'</span>; runnerName++) &#123;</div><div class="line">	        <span class="keyword">final</span> <span class="keyword">String</span> rN = <span class="keyword">String</span>.valueOf(runnerName);</div><div class="line">	        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	            @Override</div><div class="line">	            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</div><div class="line">	                <span class="keyword">long</span> prepareTime = <span class="built_in">random</span>.nextInt(<span class="number">10000</span>) + <span class="number">100</span>;</div><div class="line">	                System.out.<span class="built_in">println</span>(rN + <span class="string">"is preparing for time:"</span> + prepareTime);</div><div class="line">	                <span class="keyword">try</span> &#123;</div><div class="line">	                    Thread.sleep(prepareTime);</div><div class="line">	                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">	                    e.printStackTrace();</div><div class="line">	                &#125;</div><div class="line">	                <span class="keyword">try</span> &#123;</div><div class="line">	                    System.out.<span class="built_in">println</span>(rN + <span class="string">"is prepared, waiting for others"</span>);</div><div class="line">	                    cyclicBarrier.await(); <span class="comment">// 当前运动员准备完毕，等待别人准备好</span></div><div class="line">	                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">	                    e.printStackTrace();</div><div class="line">	                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</div><div class="line">	                    e.printStackTrace();</div><div class="line">	                &#125;</div><div class="line">	                System.out.<span class="built_in">println</span>(rN + <span class="string">"starts running"</span>); <span class="comment">// 所有运动员都准备好了，一起开始跑</span></div><div class="line">	            &#125;</div><div class="line">	        &#125;).start();</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		demo1();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/0805b944cfc94d6cd42364e671cc3ac1925856aa/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/5.png" alt="5"></p>
<h2 id="子线程完成某件任务后，把得到的结果回传给主线程"><a href="#子线程完成某件任务后，把得到的结果回传给主线程" class="headerlink" title="子线程完成某件任务后，把得到的结果回传给主线程"></a>子线程完成某件任务后，把得到的结果回传给主线程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;回顾线程的创建，我们一般会把 Runnable 对象传给 Thread 去执行。Runnable定义如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>Runnable&#123;</div><div class="line">	public abstract void <span class="builtin-name">run</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可以看到 run() 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 Callable：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可以看出 Callable 最大区别就是返回范型 V 结果。<br>&nbsp;&nbsp;&nbsp;&nbsp;那么下一个问题就是，如何把子线程的结果回传回来呢？在Java里，有一个类是配合Callable使用的：FutureTask，不过注意，它获取结果的 get 方法会阻塞主线程。<br>&nbsp;&nbsp;&nbsp;&nbsp;举例，我们想让子线程去计算从 1 加到 100，并把算出的结果返回到主线程。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.Callable;</div><div class="line">import java.util.concurrent.ExecutionException;</div><div class="line">import java.util.concurrent.FutureTask;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">long1_1</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	    Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">	        @Override</div><div class="line">	        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span>(<span class="params"></span>) throws Exception </span>&#123;</div><div class="line">	            System.<span class="keyword">out</span>.println(<span class="string">"Task starts"</span>);</div><div class="line">	            Thread.sleep(<span class="number">1000</span>);</div><div class="line">	            <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">	            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i++) &#123;</div><div class="line">	                result += i;</div><div class="line">	            &#125;</div><div class="line">	            System.<span class="keyword">out</span>.println(<span class="string">"Task finished and return result"</span>);</div><div class="line">	            <span class="keyword">return</span> result;</div><div class="line">	        &#125;</div><div class="line">	    &#125;;</div><div class="line">	    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</div><div class="line">	    <span class="keyword">new</span> Thread(futureTask).start();</div><div class="line">	    <span class="keyword">try</span> &#123;</div><div class="line">	        System.<span class="keyword">out</span>.println(<span class="string">"Before futureTask.get()"</span>);</div><div class="line">	        System.<span class="keyword">out</span>.println(<span class="string">"Result:"</span> + futureTask.<span class="keyword">get</span>());</div><div class="line">	        System.<span class="keyword">out</span>.println(<span class="string">"After futureTask.get()"</span>);</div><div class="line">	    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">	        e.printStackTrace();</div><div class="line">	    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">	        e.printStackTrace();</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		demo1();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/0805b944cfc94d6cd42364e671cc3ac1925856aa/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/6.png" alt="6"><br>&nbsp;&nbsp;&nbsp;&nbsp;可以看到，主线程调用 futureTask.get() 方法时阻塞主线程；然后 Callable 内部开始执行，并返回运算结果；此时 futureTask.get() 得到结果，主线程恢复运行。<br>&nbsp;&nbsp;&nbsp;&nbsp;通过 FutureTask 和Callable可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 ExecutorService，把 FutureTask 放到线程池去管理执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>equal()和hashCode()比较</title>
    <link href="http://www.sanstylemc.cn/2018/04/01/equal-%E5%92%8ChashCode-%E6%AF%94%E8%BE%83/"/>
    <id>http://www.sanstylemc.cn/2018/04/01/equal-和hashCode-比较/</id>
    <published>2018-04-01T07:40:37.000Z</published>
    <updated>2018-04-01T07:41:41.520Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;equal()反映的是对象或变量具体的值，即两个对象里面包含的值–可能是对象的引用，也可能是值类型的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;而hashCode()是对象或变量通过哈希算法计算出的哈希值。<br>&nbsp;&nbsp;&nbsp;&nbsp;之所以有hashCode()方法，是因为在批量的对象比较中，hashCode要比equals来的快，很多集合都用到了hashCode，比如HashTable。<br><a id="more"></a></p>
<blockquote>
<p>两个obj，如果equals()相等，hashCode()一定相等。<br>两个obj，如果hashCode()相等，equals()不一定相等(Hash散列值由冲突的情况，虽然概率很低)。<br>所以: 可以考虑在集合中，判断两个对象是否相等的规则是:<br>第一步: 如果hashCode()相等，则查看第二步，否则不相等。<br>第二步: 查看equals()是否相等，如果相等，则两obj相等，否则还是不相等。</p>
</blockquote>
<p>1、<code>equals()和hashCode()这两个方法都是从Object类中继承过来的</code></p>
<blockquote>
<p>equals()是对两个对象的地址值进行的比较(即比较引用是否相同)。<br>hashCode()是一个本地方法。它的实现是根据本地机器相关的。</p>
</blockquote>
<p>2、<code>Java语言对equals()的要求如下，这些要求是必须遵循的:</code></p>
<blockquote>
<p>A) 对称性: 如果x.equals(y)返回是”true”，那么y.equals(x)也应该返回是”true”。<br>B) 反射性: x.equals(x)必须返回是”true”。<br>C) 类推性: 如果x.equals(y)返回是”true”，而且y.equals(z)返回是”true”，那么z.equals(x)也应该返回是”true”。<br>D) 一致性: 如果x.equals(y)返回是”true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是”true”。<br>任何情况下，x.euqals(null)，永远返回是”false”；x.equals(和x不同类型的对象)永远返回是”false”。</p>
</blockquote>
<p>3、<code>equals()和hashCode()</code></p>
<blockquote>
<p>equals()相等的两个对象，hashCode()一定相等；反过来: hashCode()不等，一定能推出equals()也不等；hashCode()相等，equals()可能相等，也可能不等。</p>
</blockquote>
<p>1、为什么要重载equal方法？</p>
<blockquote>
<p>因为Object的equal方法默认是两个对象的引用的比较，意思就是指向同一内存，地址则相等；如果你现在需要利用对象里面的值来判断是否相等，则重载equal方法。</p>
</blockquote>
<p>2、为什么重置hashCode方法？</p>
<blockquote>
<p>一般的地方不需要重置hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode，那么为什么要重载hashCode呢？就HashMap来说，好比HashMap就是一个大内存块，里面有很多小内存块，小内存块里面是一系列的对象，可以利用hashCode来查找小内存块hashCode%size(小内存块数量)，所以当equal相等时，hashCode必须相等，而且如果是Object对象，必须重载hashCode和equal方法。</p>
</blockquote>
<p>3、为什么equal()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等?</p>
<blockquote>
<p>1、因为是按照hashCode来访问小内存块，所以hashCode必须相等。<br>2、HashMap获取一个对象是比较key的hashCode相等和equal为true。之所以hashCode相等，却可以equal不等，就比如ObjectA和ObjectB他们都有属性name，那么hashCode都以name计算，所以hashCode一样，但是两个对象属于不同类型，所以equal为false。</p>
</blockquote>
<p>4、为什么需要HashCode？</p>
<blockquote>
<p>1、 通过hashCode可以很快的查到小内存块。<br>2、通过hashCode比较比equal方法快，当get时先比较hashCode，如果hashCode不同，直接返回false。</p>
</blockquote>
<p>5、hashCode()作用</p>
<blockquote>
<p>hashCode()方法使用来提高Map里面的搜索效率的,Map会根据不同的hashCode()来放在不同的桶里面,Map在搜索一个对象的时候先通过hashCode()找到相应的桶,然后再根据equals()方法找到相应的对象。</p>
</blockquote>
<p>6、Java中的集合（Collection）有两类，一类是List，再有一类是Set。你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。<br>&nbsp;&nbsp;&nbsp;&nbsp;那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是Object.equals方法了。<br>&nbsp;&nbsp;&nbsp;&nbsp;但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。<br>&nbsp;&nbsp;&nbsp;&nbsp;也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。<br>&nbsp;&nbsp;&nbsp;&nbsp;哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。我们可以认为hashCode方法返回的就是对象存储的物理地址（实际可能并不是,例如:通过获取对象的物理地址然后除以8再求余,余数几是计算得到的散列值,我们就认为返回一个不是物理地址的数值,而是一个可以映射到物理地址的值）。<br>&nbsp;&nbsp;&nbsp;&nbsp;这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;equal()反映的是对象或变量具体的值，即两个对象里面包含的值–可能是对象的引用，也可能是值类型的值。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;而hashCode()是对象或变量通过哈希算法计算出的哈希值。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之所以有hashCode()方法，是因为在批量的对象比较中，hashCode要比equals来的快，很多集合都用到了hashCode，比如HashTable。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Object类及其常用方法</title>
    <link href="http://www.sanstylemc.cn/2018/04/01/Object%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://www.sanstylemc.cn/2018/04/01/Object类及其常用方法/</id>
    <published>2018-04-01T07:06:28.000Z</published>
    <updated>2018-04-01T07:42:00.352Z</updated>
    
    <content type="html"><![CDATA[<p>Object类是一个特殊的类，是所有类的父类，如果一个类没有用extends明确指出继承于某个类，那么它默认继承Object类。Object类中三个常用的方法: <code>toString()</code>、<code>equals()</code>、<code>hashCode()</code>。<br><a id="more"></a></p>
<h2 id="取得对象信息的方法-toString"><a href="#取得对象信息的方法-toString" class="headerlink" title="取得对象信息的方法: toString()"></a>取得对象信息的方法: toString()</h2><p>该方法在打印对象时候被调用，将对象信息变为字符串返回，默认输出对象地址。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Students</span>&#123;</div><div class="line">	String name= <span class="string">"zhangsan"</span>;</div><div class="line">	<span class="keyword">int</span> age= <span class="number">21</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">long1_1</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		Students students= <span class="keyword">new</span> Students();</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"姓名: "</span>+ students.name+ <span class="string">", 年龄: "</span>+ students.age);<span class="comment">//输出对象属性</span></div><div class="line">		System.<span class="keyword">out</span>.println(students);<span class="comment">//直接输出对象信息</span></div><div class="line">		System.<span class="keyword">out</span>.println(students.toString());<span class="comment">//调用父类方法输出对象信息</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/d3635a3a49e2fbc2e16ce57088772c6285dc67c1/Object%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/1.png" alt="1"><br>上述结果可看出编译器默认调用<code>toString()</code>方法输出对象，但输出的是对象的地址，我们并不能看懂它的意思。就要通过重写Object类的toString()方法来输出对象属性信息。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Students</span>&#123;</div><div class="line">	String name= <span class="string">"zhangsan"</span>;</div><div class="line">	<span class="keyword">int</span> age= <span class="number">21</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"姓名: "</span>+ name+ <span class="string">", 年龄: "</span>+ age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">long1_1</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		Students students= <span class="keyword">new</span> Students();</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"姓名: "</span>+ students.name+ <span class="string">", 年龄: "</span>+ students.age);<span class="comment">//输出对象属性</span></div><div class="line">		System.<span class="keyword">out</span>.println(students);<span class="comment">//直接输出对象信息</span></div><div class="line">		System.<span class="keyword">out</span>.println(students.toString());<span class="comment">//调用父类方法输出对象信息</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/d3635a3a49e2fbc2e16ce57088772c6285dc67c1/Object%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/2.png" alt="2"></p>
<h2 id="对象相等判断方法-equals"><a href="#对象相等判断方法-equals" class="headerlink" title="对象相等判断方法: equals()"></a>对象相等判断方法: equals()</h2><p>该方法用于比较帝乡是否相等，而且此方法必须被重写。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Students</span>&#123;</div><div class="line">	String name;</div><div class="line">	<span class="keyword">int</span> age;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Students</span>(<span class="params">String name, <span class="keyword">int</span> age</span>) </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name= name;</div><div class="line">		<span class="keyword">this</span>.age= age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">long1_1</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		Students s1= <span class="keyword">new</span> Students(<span class="string">"zhangsang"</span>, <span class="number">21</span>);</div><div class="line">		Students s2= <span class="keyword">new</span> Students(<span class="string">"lisi"</span>, <span class="number">21</span>);</div><div class="line">		System.<span class="keyword">out</span>.println(s1.<span class="keyword">equals</span>(s2));</div><div class="line">		System.<span class="keyword">out</span>.println(s1.<span class="keyword">equals</span>(s2)?<span class="string">"s1和s2是同一个人"</span>: <span class="string">"s1和s2不是同一个人"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/d3635a3a49e2fbc2e16ce57088772c6285dc67c1/Object%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/3.png" alt="3"><br>很明显输出的结果是错误的，因为equals()方法比较的是两个对象的地址 ，所以必须重写方法才能到达目的。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Student</span>&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">    <span class="comment">//重写父类（Object类）中的equals方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">equals</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        boolean temp;</div><div class="line">        Student s1 = <span class="keyword">new</span> Student();</div><div class="line">        s1.name=<span class="string">"张三"</span>;s1.age=<span class="number">12</span>;</div><div class="line">        Student s2 = <span class="keyword">new</span> Student();</div><div class="line">        s2.name=<span class="string">"张三"</span>;s2.age=<span class="number">12</span>;</div><div class="line">        <span class="keyword">if</span>((s1.name.<span class="keyword">equals</span>(s2.name))&amp;&amp;(s1.age==s2.age))&#123;</div><div class="line">            temp = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            temp = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">long1_1</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</div><div class="line">        Student s3 = <span class="keyword">new</span> Student();</div><div class="line">        System.<span class="keyword">out</span>.println(s3.<span class="keyword">equals</span>()?<span class="string">"是同一人"</span>:<span class="string">"不是同一人"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="对象签名-hashCode"><a href="#对象签名-hashCode" class="headerlink" title="对象签名: hashCode()"></a>对象签名: hashCode()</h2><p>该方法用来返回其所在对象的物理地址(哈希码值)，常会和equals方法同时重写，确保相等的两个对象拥有相等的hashCode。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Student</span></div><div class="line">&#123;</div><div class="line">    String name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">    <span class="comment">//重写父类（Object类）中的equals方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">equals</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        boolean temp;</div><div class="line">        Student s1 = <span class="keyword">new</span> Student();</div><div class="line">        s1.name=<span class="string">"张三"</span>;s1.age=<span class="number">12</span>;</div><div class="line">        Student s2 = <span class="keyword">new</span> Student();</div><div class="line">        s2.name=<span class="string">"张三"</span>;s2.age=<span class="number">12</span>;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"s1的哈希码："</span>+s1.hashCode());</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"s2的哈希码："</span>+s2.hashCode());</div><div class="line">        <span class="keyword">if</span>((s1.name.<span class="keyword">equals</span>(s2.name))&amp;&amp;(s1.age==s2.age))&#123;</div><div class="line">            temp = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            temp = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> temp;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写hashCode()方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> age*(name.hashCode());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">long1_1</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</div><div class="line">        Student s3 = <span class="keyword">new</span> Student();</div><div class="line">        System.<span class="keyword">out</span>.println(s3.<span class="keyword">equals</span>()?<span class="string">"s1和s2是同一人"</span>:<span class="string">"s1和s2不是同一人"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/d3635a3a49e2fbc2e16ce57088772c6285dc67c1/Object%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/4.png" alt="4"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Object类是一个特殊的类，是所有类的父类，如果一个类没有用extends明确指出继承于某个类，那么它默认继承Object类。Object类中三个常用的方法: &lt;code&gt;toString()&lt;/code&gt;、&lt;code&gt;equals()&lt;/code&gt;、&lt;code&gt;hashCode()&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务及其四个特性</title>
    <link href="http://www.sanstylemc.cn/2018/04/01/MySQL%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%85%B6%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7/"/>
    <id>http://www.sanstylemc.cn/2018/04/01/MySQL事务及其四个特性/</id>
    <published>2018-04-01T01:32:55.000Z</published>
    <updated>2018-04-01T01:33:29.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务概念引入"><a href="#事务概念引入" class="headerlink" title="事务概念引入"></a>事务概念引入</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;现实生活中，我们往往经常会进行转账操作，转账操作可以分为两部分来完成，转入和转出。只有这两部分都完成了才可以认为是转账成功。在数据库中，这个过程是使用两条语句来完成的，如果其中任意一条语句出现了异常没有执行，则会导致两个账号的金额不同步，造成错误。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了防止上面可能出现的情况，MySQL引入了事务，所谓事务就是针对数据库的一组操作，它可以由一条或多条SQL语句组成，同一个事务的操作具备同步的特点，如果其中有一条语句不能执行的话，那么所有的语句都不会执行，也就是说，事务中的语句要么都执行，要么都不执行。<br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;在使用数据库时候需要使用事务，必须先开启事务，开启事务的语句具体如下:<br><code>start transaction;</code><br>即:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/0541984ef0c403e9971cf5b1e11fe393d0c788f4/MySQL%E4%BA%8B%E5%8A%A1/1.png" alt="1"><br>上面语句是用来开启事务，事务开启之后就可以执行SQL语句，SQL语句执行成功之后，需要使用相应语句提交事务，提交事务的语句如下:<br><code>commit;</code><br>需要注意的是，在MySQL中直接书写SQL语句都是自动提交的，而事务中的操作语句需要使用<code>commit</code>语句手动提交，只有事务提交后其中的操作才会生效。<br>如果不想提交事务，我们还可以使用相关语句取消事务(也称回滚)，具体语句如下:<br><code>rollback;</code><br>注: <code>rollback</code>语句只能针对未提交的事务执行的回滚操作，已经提交的事务是不能回滚的。</p>
<h2 id="事务的四个基本要素-ACID"><a href="#事务的四个基本要素-ACID" class="headerlink" title="事务的四个基本要素(ACID)"></a>事务的四个基本要素(ACID)</h2><p>ACID，指数据库事务正确执行的四个基本要素的缩写。包含: <code>原子性</code>、<code>一致性</code>、<code>隔离性</code>、<code>持久性</code>。<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">原子性: 原子性意味着事务的整体性和不可分割性，这就类似化学中的原子，是一个不可分割的单元。一个事务可以是一个（任务）操作，也可以是多个（任务）操作，假设一个事务由多个操作（任务）组成，那么这些操作必须都执行成功这个事务才被认为执行成功，只要其中有一个任务执行失败那么整个事务都会被认为执行失败，导致自动回滚到初始状态，通俗来讲就是“同进退”，这保证了事务的整体性。这就是事物的原子性。 专业来讲，原子的执行是一个全部发生或全部失败的整体过程。在一个原子操作中，如果事务中的任何一个语句失败，前面执行的语句都将被返回，以保证数据的整体性不被破坏。这在常用的系统应用中，为保证数据的安全性起到一定作用。 </span></div><div class="line"><span class="section">一致性: 在MySql事务处理过程中，无论事务是完全成功或是在中途因某些环节失败而导致失败，但事务使系统处于一致的状态时，必须保持一致性，用户A向用户B的账户中转入5000元，但用户B在查询转账信息的时候，发现自己的账户只增加了3000元，这样不能使整个事务达到一致性。 在MySql中，一致性主要由MySql的日志机制处理，它记录数据库的所有变化，为事务回复提供跟踪记录。如果系统在事务处理中间发生错误，MySql恢复过程将使用这些日志发现事务是否已经完全成功执行或需要返回。一致性属性保证数据库从不返回一个未处理的事务。</span></div><div class="line"><span class="section">隔离性: 它是指每个事务在自己的空间发生，和其他发生在系统中的事务隔离，而且事务的结果只在它完全被执行的时候才能看到，如果该事务未提交，则其他会话看不到执行的结果。这样的话即使一个系统中同时发生多个事务，孤立性也可以保证特定的事务在完成之前，其结果是不被公布的。当系统支持多个同时存在的用户和连接时，系统必须遵守孤立性原则，否则在执行过程中可能导致大量数据被破坏，孤立性保证每个事务完整地在其各自的空间内被顺序的执行，保证事务之间不会相互冲突。</span></div><div class="line"><span class="section">持久性: 在MySql中，即使是数据库系统崩溃，一个提交的事务仍然在坚持。当一个事务完成，数据库的日志已经被更新时，持久性即可发挥其特有功效。在MySql中，如果系统崩溃或者数据存储介质被破坏，通过使用日志，系统能够恢复在重启前进行的最后一次成功更新，可以反应系统崩溃时处于执行过程的事务的变化。 MySql的持久性是通过一条记录事务过程中系统变化的二进制事务日志文件来实现的。如果遇到硬件损坏或者系统的异常关机，系统在下一次启动时，通过使用最后的备份和日志就可以恢复丢失数据。</span></div></pre></td></tr></table></figure></p>
<p>如何使用事务？<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">databases</span> <span class="keyword">test</span>;</div><div class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> accounts(</div><div class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</div><div class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">40</span>),</div><div class="line">money <span class="built_in">float</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> accounts(<span class="keyword">name</span>, money) <span class="keyword">values</span>(<span class="string">'a'</span>, <span class="number">1000</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> accounts(<span class="keyword">name</span>, money) <span class="keyword">values</span>(<span class="string">'b'</span>, <span class="number">1000</span>);</div></pre></td></tr></table></figure></p>
<p>执行效果如下:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/0541984ef0c403e9971cf5b1e11fe393d0c788f4/MySQL%E4%BA%8B%E5%8A%A1/2.png" alt="2"><br>演示使用事务来实现转账功能:<br>首先开启一个事务，然后通过update语句将a账户的100元转给b账户，然后提交事务，具体语句如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</div><div class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money= money- <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>= <span class="string">'a'</span>;</div><div class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money= money+ <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>= <span class="string">'b'</span>;</div><div class="line"><span class="keyword">commit</span>;</div></pre></td></tr></table></figure></p>
<p>执行效果如下:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/0541984ef0c403e9971cf5b1e11fe393d0c788f4/MySQL%E4%BA%8B%E5%8A%A1/3.png" alt="3"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事务概念引入&quot;&gt;&lt;a href=&quot;#事务概念引入&quot; class=&quot;headerlink&quot; title=&quot;事务概念引入&quot;&gt;&lt;/a&gt;事务概念引入&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现实生活中，我们往往经常会进行转账操作，转账操作可以分为两部分来完成，转入和转出。只有这两部分都完成了才可以认为是转账成功。在数据库中，这个过程是使用两条语句来完成的，如果其中任意一条语句出现了异常没有执行，则会导致两个账号的金额不同步，造成错误。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为了防止上面可能出现的情况，MySQL引入了事务，所谓事务就是针对数据库的一组操作，它可以由一条或多条SQL语句组成，同一个事务的操作具备同步的特点，如果其中有一条语句不能执行的话，那么所有的语句都不会执行，也就是说，事务中的语句要么都执行，要么都不执行。&lt;br&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.sanstylemc.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://www.sanstylemc.cn/2018/03/31/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.sanstylemc.cn/2018/03/31/Java多线程/</id>
    <published>2018-03-31T08:25:33.000Z</published>
    <updated>2018-03-31T08:26:53.895Z</updated>
    
    <content type="html"><![CDATA[<p>Java多线程实现方式主要有四种:<br>&nbsp;&nbsp;&nbsp;&nbsp;继承Thread类，重写run方法、实现Runnable接口，重写run方法，实现Run nable接口的实现类的实例对象作为Thread构造函数的target、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程(线程池)。<br>&nbsp;&nbsp;&nbsp;&nbsp;其中前两种方式线程执行完后都没有返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果。后两种是带返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中。<br><a id="more"></a></p>
<h2 id="继承Thread类的线程"><a href="#继承Thread类的线程" class="headerlink" title="继承Thread类的线程"></a>继承Thread类的线程</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">long1_1</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">long1_1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">//编写子类的构造方法，可缺省</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">//编写自己的线程代码</span></div><div class="line">        System.<span class="keyword">out</span>.println(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123; </div><div class="line">    	long1_1 threadDemo01 = <span class="keyword">new</span> long1_1(); </div><div class="line">        threadDemo01.setName(<span class="string">"我是自定义的线程1"</span>);</div><div class="line">        threadDemo01.start();       </div><div class="line">        System.<span class="keyword">out</span>.println(Thread.currentThread().toString()); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/cab9515de1920426c5f254aa8af76a5663c0105d/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.png" alt="1"></p>
<h2 id="通过实现Runnable接口、实现run方法，接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，通过调用start-方法启动线程。"><a href="#通过实现Runnable接口、实现run方法，接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，通过调用start-方法启动线程。" class="headerlink" title="通过实现Runnable接口、实现run方法，接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，通过调用start()方法启动线程。"></a>通过实现Runnable接口、实现run方法，接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，通过调用start()方法启动线程。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">long1_1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line">        System.out.println(Thread.currentThread().getName());</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</div><div class="line">        t1.start(); </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;我是通过实现接口的线程实现方式！"</span>);</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/cab9515de1920426c5f254aa8af76a5663c0105d/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.png" alt="2"></p>
<h2 id="通过Callable和FutureTask创建线程"><a href="#通过Callable和FutureTask创建线程" class="headerlink" title="通过Callable和FutureTask创建线程"></a>通过Callable和FutureTask创建线程</h2><p>a: 创建Callable接口的实现类，并实现Call方法<br>b: 创建Callable实现类的实现，使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的Call方法的返回值<br>c: 使用FutureTask对象作为Thread对象的target创建并启动线程<br>d: 调用FutureTaske对象的get()来获取子线程执行结束的返回值<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> long1_1 &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * @param args</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args) &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        Callable&lt;<span class="built_in">Object</span>&gt; oneCallable = <span class="keyword">new</span> Tickets&lt;<span class="built_in">Object</span>&gt;();</div><div class="line">        FutureTask&lt;<span class="built_in">Object</span>&gt; oneTask = <span class="keyword">new</span> FutureTask&lt;<span class="built_in">Object</span>&gt;(oneCallable);</div><div class="line">        Thread t = <span class="keyword">new</span> Thread(oneTask);</div><div class="line">        System.out.println(Thread.currentThread().getName());</div><div class="line">        t.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Tickets&lt;<span class="built_in">Object</span>&gt; <span class="keyword">implements</span> Callable&lt;<span class="built_in">Object</span>&gt;&#123;</div><div class="line">    <span class="comment">//重写call方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="built_in">Object</span> call() throws Exception &#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;我是通过实现Callable接口通过FutureTask包装器来实现的线程"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/cab9515de1920426c5f254aa8af76a5663c0105d/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/3.png" alt="3"></p>
<h2 id="通过线程池创建线程"><a href="#通过线程池创建线程" class="headerlink" title="通过线程池创建线程"></a>通过线程池创建线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">long1_1</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> POOL_NUM = <span class="number">10</span>;     <span class="comment">//线程池数量</span></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException </span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;POOL_NUM; i++)  </div><div class="line">        &#123;  </div><div class="line">            RunnableThread thread = <span class="keyword">new</span> RunnableThread();</div><div class="line">            <span class="comment">//Thread.sleep(1000);</span></div><div class="line">            executorService.execute(thread);  </div><div class="line">        &#125;</div><div class="line">        <span class="comment">//关闭线程池</span></div><div class="line">        executorService.shutdown(); </div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span>  </span></div><div class="line"><span class="class"></span>&#123;    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"通过线程池方式创建的线程："</span> + Thread.currentThread().getName() + <span class="string">" "</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/cab9515de1920426c5f254aa8af76a5663c0105d/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.png" alt="4"><br>ExecutorService、Callable都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，还有Future接口也是属于这个框架。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java多线程实现方式主要有四种:&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;继承Thread类，重写run方法、实现Runnable接口，重写run方法，实现Run nable接口的实现类的实例对象作为Thread构造函数的target、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程(线程池)。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;其中前两种方式线程执行完后都没有返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果。后两种是带返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList和LinkedList的区别</title>
    <link href="http://www.sanstylemc.cn/2018/03/31/ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.sanstylemc.cn/2018/03/31/ArrayList和LinkedList的区别/</id>
    <published>2018-03-31T07:24:19.000Z</published>
    <updated>2018-03-31T07:27:50.591Z</updated>
    
    <content type="html"><![CDATA[<p><code>ArrayList</code>和<code>LinkedList</code>是常用的两种存储结构。<br><a id="more"></a><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表的数据结构。这俩都是对List接口的实现。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列。</div><div class="line">对于随机访问<span class="keyword">get</span>和<span class="keyword">set</span>，ArrayList觉得优于LinkedList，因为LinkedList是线性的数据存储方式，需要移动指针从前往后依次查找。</div><div class="line">对于新增和删除操作<span class="keyword">add</span>和<span class="keyword">remove</span>，LinkedList比较占优势，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要移动数据。</div><div class="line">从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。</div><div class="line">ArrayList主要控件开销在于需要在List列表预留一定空间；而LinkedList主要控件开销在于需要存储结点信息以及结点指针信息。</div><div class="line">LinkedList需要更多的内存空间，因为它除了要存储数据之外，还需要存储该结点的前后结点信息，而ArrayList索引处就是存的数据。</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">long1_1</span> &#123;</span></div><div class="line">	<span class="keyword">static</span> final <span class="keyword">int</span> N=<span class="number">50000</span>;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">timeList</span><span class="params">(List <span class="built_in">list</span>)</span></span>&#123;</div><div class="line">        <span class="keyword">long</span> start=System.currentTimeMillis();</div><div class="line">        Object o = <span class="keyword">new</span> Object();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</div><div class="line">            <span class="built_in">list</span>.add(<span class="number">0</span>, o);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> System.currentTimeMillis()-start;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">readList</span><span class="params">(List <span class="built_in">list</span>)</span></span>&#123;</div><div class="line">        <span class="keyword">long</span> start=System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="built_in">list</span>.size();i&lt;j;i++)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> System.currentTimeMillis()-start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> List <span class="title">addList</span><span class="params">(List <span class="built_in">list</span>)</span></span>&#123;</div><div class="line">        Object o = <span class="keyword">new</span> Object();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</div><div class="line">            <span class="built_in">list</span>.add(<span class="number">0</span>, o);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"ArrayList添加"</span>+N+<span class="string">"条耗时："</span>+timeList(<span class="keyword">new</span> ArrayList()));</div><div class="line">        System.out.println(<span class="string">"LinkedList添加"</span>+N+<span class="string">"条耗时："</span>+timeList(<span class="keyword">new</span> LinkedList()));</div><div class="line"></div><div class="line">        List list1=addList(<span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">        List list2=addList(<span class="keyword">new</span> LinkedList&lt;&gt;());</div><div class="line">        System.out.println(<span class="string">"ArrayList查找"</span>+N+<span class="string">"条耗时："</span>+readList(list1));</div><div class="line">        System.out.println(<span class="string">"LinkedList查找"</span>+N+<span class="string">"条耗时："</span>+timeList(list2));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们在集合中装5万条数据，测试运行结果如下:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/5fa64a9a35fb77be9a695ca8c4772512d1ebf57f/ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" alt="2"><br>可以看到ArrayList更适合读取数据，LinkedList更多的时候添加或删除数据。</p>
<blockquote>
<p>当插入的数据量很小时，两者区别不太大，当插入的数据量大时，大约在容量的1/10之前，LinkedList会优于ArrayList，在其后就劣于ArrayList，且越靠近后面越差。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt;和&lt;code&gt;LinkedList&lt;/code&gt;是常用的两种存储结构。&lt;br&gt;
    
    </summary>
    
    
      <category term="框架" scheme="http://www.sanstylemc.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机的架构</title>
    <link href="http://www.sanstylemc.cn/2018/03/30/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.sanstylemc.cn/2018/03/30/Java虚拟机的架构/</id>
    <published>2018-03-30T14:26:29.000Z</published>
    <updated>2018-03-30T14:27:00.460Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/sunstady/hexo/4fc2d1028c844a7fb3bef9dd217d045e6e158327/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9E%B6%E6%9E%84/1.png" alt="1"><br><a id="more"></a><br><code>类加载子系统</code>: 负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。除了类信息外，方法区中可能还会存放运行时常量池信息，包括字符串字面量和数字量(这部分常量信息是Class文件中常量池部分的内存映射)。当JVM使用类加载器装载某个类时，它首先要定位对应的Class文件，然后读入这个Class文件，最后，JVM提取该文件的内容信息，并将这些信息存储到方法区，最后返回一个Class实例。<br><code>方法区</code>： 方法区主要存储的是方法，静态成员，常量。方法区中给每个类都规定了空间并且持有this和super的引用。当运行到哪个对象的时候，通过this动态指向该对象，引用该对象的成员变量，然后和方法以及局部变量一起在栈中进行运算。方法区的大小不必是固定的，默认最小值为16MB，最大为64MB，JVM可根据应用需要动态调整。同时，方法区也不一定是连续的，方法区可以在一个堆(甚至是JVM自己的堆)中自由分配。<br><code>Java堆</code>: Java堆是在JVM启动的时候就建立的，是java程序最主要的内存工作区域。堆空间是所有线程共享的。这块内存区域存放了对象实例及数组(所有new的对象)也就是<code>Object object= new Object();</code>这里object只是一个引用是放在栈里面的，new Object()被放在了堆内存里面。由于现在收集器都是采用分代收集算法，堆被划为新生代和老年代。新生代主要存储所创建的对象和尚未进入老年代的对象，老年代存储经过多次新生代GC(Minor GC)仍然存活的对象。<br><code>直接内存</code>: Java的NIO库允许Java程序使用直接内存。直接内存是在Java堆外的、直接向系统申请的内存空间。通常，访问直接内存的速度会优于Java堆。因此出于性能考虑，读写频繁的场合应考虑使用直接内存。因为直接内存不在java堆内，因此直接内存的大小不会直接受限于jvm参数-Xmx，而它和java堆的总和，受制于操作系统的内存大小。<br><code>垃圾回收系统</code>: 这是JVM的重要组成部分，垃圾回收器可以直接对方法区、Java堆和直接内存进行回收。在其中Java堆则是垃圾回收器的重点工作区域，对于不在使用的垃圾对象，垃圾回收系统会在后台查找标识，并且释放这些不用的垃圾对象。<br><code>Java栈</code>: 每一个线程中都有私有的Java栈，一个线程的Java栈在线程被创建的时候就会被创建。Java栈由许多栈帧组成，一个栈帧包含一个Java方法调用的状态。当线程调用要给Java方法时，虚拟机压入一个新的栈帧到该线程的Java栈中，当该方法返回时，这个栈帧就从Java栈中弹出。Java栈中存储线程中Java方法调用的状态包括：局部变量、方法参数、返回值以及运算的中间结果等，并且对象的引用也存在栈中。Java虚拟机没有寄存器，其指令集使用Java栈来存储中间数据。这样设计的原因是为了保持Java虚拟机的指令集尽量紧凑，同时也便于Java虚拟机在只有很少通用寄存器的平台上实现。另外，基于栈的体系结构，也有助于运行时某些虚拟机实现的动态编译器和即时编译器的代码优化。<br><code>本地方法栈</code>: 任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的栈，虚拟机只是简单地动态连接并直接调用指定的本地方法。其中方法区和堆由该虚拟机实例中所有线程共享。当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息放到方法区。当程序运行时，虚拟机会把所有该程序在运行时创建的对象放到堆中。像其它运行时内存区一样，本地方法栈占用的内存区可以根据需要动态扩展或收缩。<br><code>PC寄存器</code>: PC寄存器也是每个线程私有的空间，Java虚拟机会为每个Java线程创建PC寄存器。在任意时刻，一个Java线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向当前正在被执行的指令，若是本地方法，则PC的值就是undefined。<br><code>执行引擎</code>: 最核心的组件之一，负责执行虚拟机的字节码。现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后再执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/sunstady/hexo/4fc2d1028c844a7fb3bef9dd217d045e6e158327/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9E%B6%E6%9E%84/1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="框架" scheme="http://www.sanstylemc.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>重置MySQL密码</title>
    <link href="http://www.sanstylemc.cn/2018/03/29/%E9%87%8D%E7%BD%AEMySQL%E5%AF%86%E7%A0%81/"/>
    <id>http://www.sanstylemc.cn/2018/03/29/重置MySQL密码/</id>
    <published>2018-03-29T06:10:53.000Z</published>
    <updated>2018-03-29T06:11:23.662Z</updated>
    
    <content type="html"><![CDATA[<p><code>ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)</code><br>一般这个错误是由密码错误引起的，解决的方法自然是重置密码。<br><a id="more"></a><br>假设我们使用的是root账户。<br>1、重置密码的第一步是跳过MySql的密码认证过程。</p>
<blockquote>
<p>vim /etc/my.cnf(注: windows下修改的是my.ini)</p>
</blockquote>
<p>在文档内搜索<code>mysqld</code>定位到<code>[mysqld]</code>字段:<br><code>/mysqld</code>(在vim编辑状态下直接输入该命令可搜索文本内容)<br>在<code>[mysqld]</code>后面任意一行添加<code>skip-grant-tables</code>用来跳过密码验证的过程。<br>保存文档并退出。<br>2、接下来重启MySql:<br><code>/etc/init.d/mysql restart</code>(有些用户可能需要使用/etc/init.d/mysqld restart)<br>3、重启之后输入<code>mysql</code>就可进入mysql。<br>4、接下来就是用sql来修改root的密码。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">use mysql;</div><div class="line">update<span class="built_in"> user </span><span class="builtin-name">set</span> <span class="attribute">password</span>=password("你的新密码") where <span class="attribute">user</span>=<span class="string">"root"</span>;</div><div class="line">flush privileges;</div><div class="line">quit</div></pre></td></tr></table></figure></p>
<p>到这里root账户就已经重置成新的密码了。<br>5、便器my.cnf去掉刚才添加的内容，然后重启MySql。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ERROR 1045 (28000): Access denied for user &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; (using password: YES)&lt;/code&gt;&lt;br&gt;一般这个错误是由密码错误引起的，解决的方法自然是重置密码。&lt;br&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.sanstylemc.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>cookie和session的区别</title>
    <link href="http://www.sanstylemc.cn/2018/03/28/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.sanstylemc.cn/2018/03/28/cookie和session的区别/</id>
    <published>2018-03-28T09:45:41.000Z</published>
    <updated>2018-03-29T06:38:46.791Z</updated>
    
    <content type="html"><![CDATA[<p>对于许多人来说，都知道的是，cookie是存储在客户端的，可以用来放需要长期使用的内容，例如用户密码、用户账户等等，服务器是可以获取到cookie的内容的；而session则是存储在服务器端，通过唯一的session_id来区别用户，用于保存用户的登录状态和请求等，客户是不能获取到其内容的。这对于许多人来说都是比较基础的内容，也是表现形式上的区别，在这里我们深入的了解一下两者。<br><a id="more"></a></p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><figure class="highlight ldif"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">cookie是存在于客户端的由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</span></div><div class="line"><span class="attribute">cookie的内容主要包括</span>: 名字、值、过期时间、路径和域。其中路径与域一起构成cookie的作用范围，若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。</div><div class="line"><span class="attribute">cookie是服务器端给客户端分发的一种凭证，客户端要请求服务，就需要在发送数据的同时发送cookie，服务器端通过识别cookie的内容，得知用户身份。</span></div></pre></td></tr></table></figure>
<p>要查看cookie可以在控制台输入<code>javascript: alert(document.cookie);</code>就可以看到网站分发的cookie了。</p>
<blockquote>
<p>实际上的cookie有两种，分别是停留在浏览器所占内容的<br>临时性的cookie，在页面窗口关闭之后就被删除，被称为session cookie；而另外一种是通过存放在硬盘空间中长期 存在的cookie，这种cookie被称为persistent cookie，也就是我们通常意义上所讲的cookie。</p>
</blockquote>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">session的出现</span>: 对于cookie是存储在客户端的，这种存储在客户端的信息往往是不安全的，所以后来又有了session，客户端浏览器向服务器发送请求的时候，服务器将客户端的信息以某种形式存储在服务器上，这种存储在服务器端的信息在客户端第二次访问服务器的时候被使用，用来确定用户的状态等信息。</div><div class="line"><span class="attribute">session的使用</span>: 服务器会在客户端第一次请求服务的时候创建session对象，与cookie类似，session对象也是以键值对的形式存储的。每个session 对象都有独立的session_id，对于特定的客户，就赋予特定的session，可以区分不同的用户。需要注意的是，通常是在用户请求具体服务的时候才会创建session，单纯的访问静态的内容（如HTML）并不会创建session。而在创建之后的每一次客户访问服务器都会更新session的内容，比如session的最后访问时间等等。还有一点是session的内容应该尽量的精简，因为session是存储在服务器端的，需要占用到宝贵的服务器资源（一般放在服务器内存里），所以这里在有大量客户访问的时候，会导致服务器的资源不够用。此外还会给session设置有效期，对于长时间没有活跃的session会从内存中删除，这也是我们用一些Web应用时会有说“登录超时”的情况出现。</div><div class="line"><span class="attribute">session的依赖实现</span>: 对于上面所说的session，它对于用户来说是透明的，在客户请求服务的时候，客户端需要有一个标示自己身份的凭证，但是仅仅是标示自己的身份，所以这个标示会比较小。通过这个身份，服务器才能从内存中的多个session中知道用户是对应于哪一个session。一般来说session是要依赖于cookie来实现，这一点在上面讲到cookie的分类时说到，这时候生成的cookie就是上文提到的session cookie，而cookie的内容就是session的特定的id，这个cookie在浏览器关闭的时候就会失效。因此同一个机器上的两个浏览器窗口访问服务器的时候会生成两个不同的session。但是如果两个窗口是由同一个父窗口打开的话，子窗口会共享父窗口的cookie，所以这时候是共享一个session。</div></pre></td></tr></table></figure>
<p><code>如果禁用了cookie，那要怎么实现session</code></p>
<blockquote>
<p>在浏览器禁用cookie或者不支持cookie的时候，通常会采取一种叫做”URL重写”的方式来实现session，也就是以类似于GET方式，将session_id写在URL的后面，这样服务器也能获取到客户的session_id，通过这个独立的id就能识别特定的用户了。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于许多人来说，都知道的是，cookie是存储在客户端的，可以用来放需要长期使用的内容，例如用户密码、用户账户等等，服务器是可以获取到cookie的内容的；而session则是存储在服务器端，通过唯一的session_id来区别用户，用于保存用户的登录状态和请求等，客户是不能获取到其内容的。这对于许多人来说都是比较基础的内容，也是表现形式上的区别，在这里我们深入的了解一下两者。&lt;br&gt;
    
    </summary>
    
    
      <category term="Skill" scheme="http://www.sanstylemc.cn/tags/Skill/"/>
    
  </entry>
  
  <entry>
    <title>Spring解析</title>
    <link href="http://www.sanstylemc.cn/2018/03/28/Spring%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.sanstylemc.cn/2018/03/28/Spring解析/</id>
    <published>2018-03-28T05:01:31.000Z</published>
    <updated>2018-03-28T05:27:40.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><p>1、Spring是一个开源框架，Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。Spring是一个IOC和AOP容器框架。<br>在Java开发领域，SPring相对于EJB来说是一种 轻量级的、非侵入性的Java开发框架。<br><a id="more"></a><br>Spring主要核心是:<br>1) 控制反转(IOC):</p>
<blockquote>
<p>概念: 控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系<br>核心: bean工厂；在Spring中，bean工厂创建的各个实例称作bean  </p>
</blockquote>
<p>以前传统的Java开发模式中，当需要一个对象时，我们会自己使用new或getInstance等直接或间接调用构造方法创造一个对象，而在Spring开发模式中，Spring容器使用了工厂模式为我们创建了所需要的对象，我们使用时不需要自己去创建，直接调用Spring为我们提供的对象即可，这就是控制反转思想。实例化一个Java对象由三种方式: 使用类构造器，使用静态工厂方法，使用实例工厂方法。当使用Spring时我们就不需要关心通过何种方式实例化一个对象，Spring通过控制反转机制自动为我们实例化一个对象。<br>2) 依赖注入(DI): Spring使用JavaBean对象的Set方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程就是依赖注入的基本思想。<br>3) 面向切面编程(AOP): 在面向对象编程 (OOP)思想中，我们将事物纵向抽象成一个个的对象。而在面向切面编程中，我们将一个个对象某些类似的方面横向抽象成一个切面，对这个切面进行一些如权限验证，事物管理，记录日志等公用操作初级的过程就是面向切面编程的思想。<br>2、在Spring中，所有管理的对象都是JavaBean对象，而BeanFactory和ApplicationContext就是Spring框架的两个IOC容器，现在一般使用ApplicationContext，其不但包含了BeanFactory的作用，同时还进行更多的扩展。</p>
<h2 id="Spring原理"><a href="#Spring原理" class="headerlink" title="Spring原理"></a>Spring原理</h2><p>1) 内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 。<br>2) Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过  配置类达到的。<br>3) Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象）  要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。</p>
<h2 id="代理的两种方式"><a href="#代理的两种方式" class="headerlink" title="代理的两种方式"></a>代理的两种方式</h2><p><code>静态代理</code></p>
<ul>
<li>针对每个具体类分别编写代理类</li>
<li>针对一个接口编写一个代理类</li>
</ul>
<p><code>动态代理</code></p>
<ul>
<li>针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类。<br>不用写代理类，虚拟机根据真实对象实现的接口产生一个类，通过类实例化一个动态代理，在实例化动态代理时将真实对象及装备注入到动态代理中，向客户端公开的是动态代理，当客户端调用动态代理方法时，动态代理根据类的反射得到真实对象的Method,调用装备的invoke方法，将动态代理、 Method、方法参数传与装备的invoke方法，invoke方法在唤起method方法前或后做一些处理。     <blockquote>
<p>产生动态代理的类: java.lang.refect.Proxy<br>装备必须实现InvocationHandler接口实现invoke方法。</p>
</blockquote>
</li>
</ul>
<h2 id="Spring的三种注入方式是什么"><a href="#Spring的三种注入方式是什么" class="headerlink" title="Spring的三种注入方式是什么"></a>Spring的三种注入方式是什么</h2><blockquote>
<p>setter<br>interface<br>constructor</p>
</blockquote>
<h2 id="Spring的核心接口及核类配置文件是什么"><a href="#Spring的核心接口及核类配置文件是什么" class="headerlink" title="Spring的核心接口及核类配置文件是什么"></a>Spring的核心接口及核类配置文件是什么</h2><blockquote>
<p>FactoryBean: 工厂 Bean主要实现ioc/di<br>ApplicationContext ac= new FileXmlApplicationContext(“applicationContext.xml”);<br>Object obj= ac.getBean(“id值”);</p>
</blockquote>
<h2 id="Spring框架的7个模块"><a href="#Spring框架的7个模块" class="headerlink" title="Spring框架的7个模块"></a>Spring框架的7个模块</h2><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p>
<blockquote>
<p><code>核心容器</code>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。<br><code>Spring 上下文</code>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。<br><code>Spring AOP</code>：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。<br><code>Spring DAO</code>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。<br><code>Spring ORM</code>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。<br><code>Spring Web 模块</code>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。<br><code>Spring MVC 框架</code>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。<br>Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Spring&quot;&gt;&lt;a href=&quot;#什么是Spring&quot; class=&quot;headerlink&quot; title=&quot;什么是Spring&quot;&gt;&lt;/a&gt;什么是Spring&lt;/h2&gt;&lt;p&gt;1、Spring是一个开源框架，Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。Spring是一个IOC和AOP容器框架。&lt;br&gt;在Java开发领域，SPring相对于EJB来说是一种 轻量级的、非侵入性的Java开发框架。&lt;br&gt;
    
    </summary>
    
    
      <category term="框架" scheme="http://www.sanstylemc.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>String中加号和字符串拼接</title>
    <link href="http://www.sanstylemc.cn/2018/03/28/String%E4%B8%AD%E5%8A%A0%E5%8F%B7%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/"/>
    <id>http://www.sanstylemc.cn/2018/03/28/String中加号和字符串拼接/</id>
    <published>2018-03-28T03:51:08.000Z</published>
    <updated>2018-03-28T03:51:53.798Z</updated>
    
    <content type="html"><![CDATA[<p>字符串常量是编译时确定的，编译完成，生成class文件，那就不会再变了。在编译的时候，编译器会将字符串常量直接放在一起，然后查找常量池里面，有没有对应的字符串。<br><a id="more"></a><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">String </span><span class="keyword">str1= </span>new <span class="keyword">String("abc");</span></div><div class="line"><span class="keyword">String </span><span class="keyword">str2= </span><span class="string">"abc"</span><span class="comment">;</span></div><div class="line"><span class="keyword">String </span><span class="keyword">str3= </span><span class="string">"a"</span>+ <span class="string">"b"</span>+ <span class="string">"c"</span><span class="comment">;</span></div><div class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str1== </span><span class="keyword">str2); </span>  //输出false</div><div class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str1.intern()== </span><span class="keyword">str2); </span> //输出true</div><div class="line">//intern()方法返回字符串对象的规范化表示形式。</div><div class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str2== </span><span class="keyword">str3); </span>  //输出true</div><div class="line"><span class="keyword">String </span><span class="keyword">str4= </span><span class="string">"ab"</span><span class="comment">;</span></div><div class="line"><span class="keyword">String </span><span class="keyword">str5= </span><span class="keyword">str4+ </span><span class="string">"c"</span><span class="comment">;</span></div><div class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str2== </span><span class="keyword">str5); </span>  //输出false</div></pre></td></tr></table></figure></p>
<ul>
<li>第一个<code>str1== str2</code>对比的是引用的地址是否相同，由于str1采用的是<code>new String</code>方式定义的，所以地址引用一定不相等。</li>
<li>第二个<code>str1.intern()== str2</code>，当str1调用intern的时候，会检查字符串池中是否含有 该字符串。由于定义的str2已经进入字符串池中，所以会得到相同的引用。</li>
<li>定义str3，在编译的时候，编译器会将字符串常量直接放在一起，然后查找常量池里面，有没有对应的字符串，所以str2和str3是相等的，也就是指向相同的内存区域。</li>
<li>看一下下面的代码<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">String</span> a = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"ab"</span>);</div><div class="line"><span class="keyword">String</span> b = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"ab"</span>);</div><div class="line"><span class="keyword">String</span> c = <span class="string">"ab"</span>;</div><div class="line"><span class="keyword">String</span> d = <span class="string">"a"</span> + <span class="string">"b"</span>;</div><div class="line"><span class="keyword">String</span> e = <span class="string">"b"</span>;</div><div class="line"><span class="keyword">String</span> f = <span class="string">"a"</span> + e;</div><div class="line"></div><div class="line">System.out.<span class="built_in">println</span>(b.intern() == a);   <span class="comment">//输出false</span></div><div class="line">System.out.<span class="built_in">println</span>(b.intern() == c);   <span class="comment">//输出true</span></div><div class="line">System.out.<span class="built_in">println</span>(b.intern() == d);   <span class="comment">//输出true</span></div><div class="line">System.out.<span class="built_in">println</span>(b.intern() == f);   <span class="comment">//输出false</span></div><div class="line">System.out.<span class="built_in">println</span>(b.intern() == a.intern());   <span class="comment">//输出true</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>由运行结果可以看出来，b.intern() == a和b.intern() == c可知，采用new 创建的字符串对象不进入字符串池，并且通过b.intern() == d和b.intern() == f可知，字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如f中的e）则不会进入字符串池中。但是字符串一旦进入字符串池中，就会先查找池中有无此对象。如果有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串常量是编译时确定的，编译完成，生成class文件，那就不会再变了。在编译的时候，编译器会将字符串常量直接放在一起，然后查找常量池里面，有没有对应的字符串。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>py常识</title>
    <link href="http://www.sanstylemc.cn/2018/03/28/py%E5%B8%B8%E8%AF%86/"/>
    <id>http://www.sanstylemc.cn/2018/03/28/py常识/</id>
    <published>2018-03-28T02:22:05.000Z</published>
    <updated>2018-03-28T02:47:08.066Z</updated>
    
    <content type="html"><![CDATA[<p>一些基础的python知识。<br><a id="more"></a></p>
<h2 id="python特性"><a href="#python特性" class="headerlink" title="python特性"></a>python特性</h2><blockquote>
<p>1) python是一种解释型语言，这意味着，与C、C++不同，python不需要在运行之前进行编译，它是边运行边解释。<br>2) python是动态类型化的，这意味着当你声明它们或类似的东西时，你不需要声明变量的类型。你可以x= 1，然后x= “abc”没有错误。<br>3) python非常适合面向对象编程，因为它允许定义类以及组合和继承。python没有访问修饰符(例C++大的public，private)。<br>4) 在python中函数是一等对象，这意味着它们可以在运行时动态创建，能赋值给变量或者作为参数传给函数，还能作为函数的返回值。<br>5) python代码容易上手，开发速度很快，但运行速度通常比编译语言慢。幸运的是，python允许包含基于C的扩展，所以瓶颈可以被优化掉。比如，numpy包就是一个很好的例子，它非常快，因为它所做的很多运算在底部都是用C编写的。</p>
</blockquote>
<h2 id="python中的赋值、浅拷贝和深拷贝的区别"><a href="#python中的赋值、浅拷贝和深拷贝的区别" class="headerlink" title="python中的赋值、浅拷贝和深拷贝的区别"></a>python中的赋值、浅拷贝和深拷贝的区别</h2><blockquote>
<p>1) <code>对象的赋值</code><br>python中对象的赋值实际上是简单的对象引用，也就是说，当你创建一个对象，然后把它复制给另一个变量的时候，python并没有拷贝这个对象，而是拷贝了这个对象的引用。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/1754108a3c1c7b65cc088a2fe1317e53c0a5cf2d/py%E5%B8%B8%E8%AF%86/1.png" alt="1"></p>
</blockquote>
<p>2) <code>浅拷贝</code></p>
<blockquote>
<p><code>对于可变对象深浅拷贝</code> </p>
</blockquote>
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:center">值</th>
<th style="text-align:right">地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>=浅拷贝</td>
<td style="text-align:center">值相等</td>
<td style="text-align:right">地址相等</td>
</tr>
<tr>
<td>copy浅拷贝</td>
<td style="text-align:center">值相等</td>
<td style="text-align:right">地址不相等</td>
</tr>
<tr>
<td>deepcopy深拷贝</td>
<td style="text-align:center">值相等</td>
<td style="text-align:right">地址不相等</td>
</tr>
</tbody>
</table>
<blockquote>
<p>一般引用copy.copy()，可以进行对象的浅拷贝。它复制了对象但对于对象中的元素，依然使用原始的引用。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/9582c97b0cc4db60b3b844bdab6a26185f4683f0/py%E5%B8%B8%E8%AF%86/2.png" alt="2"><br>使用copy对a进行浅拷贝，b复制了a的对象，但是b里面的[2, 3, 4]和a里面的[2, 3, 4]其实都是指向同一块内存地址，所以改变了a[1]之后，b里面的b[1]也发生了改变。</p>
<p><code>对于不可变对象的深浅拷贝</code><br>不可变对象类型，没有被拷贝的说法，即便是用深拷贝，查看id的话也是一样的，如果对其重新赋值，也只是新创建一个对象，替换掉旧的而已。一句话就是，不可变类型，不管是深拷贝还是浅拷贝，地址值和拷贝后的值都是一样的。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/a99c74107615d9f8b75c552b526d81e9867f3cff/py%E5%B8%B8%E8%AF%86/2_1.png" alt="2.1"><br>3) <code>深拷贝</code><br>深拷贝需要用copy.deepcopy()进行拷贝。它是复制一个容器对象，以及它里面的所有元素(包含元素的子元素)<br><img src="https://raw.githubusercontent.com/sunstady/hexo/1754108a3c1c7b65cc088a2fe1317e53c0a5cf2d/py%E5%B8%B8%E8%AF%86/3.png" alt="3"><br>当对a列表进行深度拷贝之后，b复制了a的对象，但是b里面的[2, 3, 4]和a里面的[2, 3, 4]其实都是指向不同的内存地址。</p>
</blockquote>
<h2 id="python中的-和is的区别"><a href="#python中的-和is的区别" class="headerlink" title="python中的==和is的区别"></a>python中的<code>==</code>和<code>is</code>的区别</h2><blockquote>
<p><code>is</code>也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是id是否相同。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/1754108a3c1c7b65cc088a2fe1317e53c0a5cf2d/py%E5%B8%B8%E8%AF%86/4.png" alt="4"><br>而<code>==</code>是python标准操作符中的比较操作符，用来比较判断两个对象的value(值)是否相等。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/1754108a3c1c7b65cc088a2fe1317e53c0a5cf2d/py%E5%B8%B8%E8%AF%86/5.png" alt="5"></p>
</blockquote>
<h2 id="线程如何在python中实现"><a href="#线程如何在python中实现" class="headerlink" title="线程如何在python中实现"></a>线程如何在python中实现</h2><blockquote>
<p>python有一个多线程包threading，可以使用多线程来加快你的代码。但是python有一个叫做Global Interpreter Lock(GIL)的构造。GIL确保只有一个”线程”可以在任何时候执行。<br>线程获取GIL，做一些工作，然后将GIL传递到下一个线程。这种情况发生得非常快，所以对于人眼而言，它可能看起来像你的线程并行执行，但它们实际上只是轮流使用相同的CPU内核。因此GIL的存在是得python中的多线程无法真正的利用多核的优势来提高性能。<br>对于IO密集型操作，在等待操作系统返回的时候会释放GIL；再比如爬虫因为有等待的服务器的响应时间，可以利用多线程来加速。但是对于CPU密集型操作，只能通过多进程Multiprocess来加速。</p>
</blockquote>
<h2 id="python中的猴子补丁式是什么"><a href="#python中的猴子补丁式是什么" class="headerlink" title="python中的猴子补丁式是什么"></a>python中的猴子补丁式是什么</h2><blockquote>
<p>考虑下面的例子:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/1754108a3c1c7b65cc088a2fe1317e53c0a5cf2d/py%E5%B8%B8%E8%AF%86/6.png" alt="6"><br>猴子补丁:<br>是一种非常pythonic的用法，即函数再python中可以像使用变量一样对它进行赋值等操作，我们可以再运行时动态替换模块，俗称手法，称为猴子补丁。我们通过对MyClass.f重新赋值，动态的改变了输出的结果。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/1754108a3c1c7b65cc088a2fe1317e53c0a5cf2d/py%E5%B8%B8%E8%AF%86/7.png" alt="7"></p>
</blockquote>
<h2 id="python中的负数index"><a href="#python中的负数index" class="headerlink" title="python中的负数index"></a>python中的负数index</h2><blockquote>
<p>python中的负数index是用来做什么的？<br>python中的序列是索引的，它由正数和负数组成。正的数字使用’0’作为第一个索引，’1’作为第二个索引。<br>负数的索引从’-1’开始，表示序列中的最后一个索引，’-2’作为倒数第二个索引，序列像整数一样向前。<br>负数索引也可以用来非常方便的切片，比如:<br><img src="https://raw.githubusercontent.com/sunstady/hexo/1754108a3c1c7b65cc088a2fe1317e53c0a5cf2d/py%E5%B8%B8%E8%AF%86/8.png" alt="8"></p>
</blockquote>
<h2 id="类里面的new和init的区别"><a href="#类里面的new和init的区别" class="headerlink" title="类里面的new和init的区别"></a>类里面的new和init的区别</h2><blockquote>
<p>1) <code>__init__</code>为初始化方法，而<code>__new__</code>方法才是真正的构造函数。只有继承了object的新式类才有<code>__new__</code>。<br>2) <code>——new__</code>至少要有一个参数cls，代表要实例化的类，此参数在实例化时由python解释器自动提供，<code>__new__</code>必须要有返回值，返回实例化出来的实例。<br>3) <code>__init__</code>有一个参数self，就是这个<code>__new__</code>返回的实例，先运行<code>__new__</code>然后才运行<code>__init__</code>。<br>4) <code>__init__</code>在<code>__new__</code>的基础上可以完成一些其它初始的动作，<code>__init__</code>不需要返回值。</p>
</blockquote>
<h2 id="python中的参数-args和-kwargs"><a href="#python中的参数-args和-kwargs" class="headerlink" title="python中的参数*args和**kwargs"></a>python中的参数<code>*args</code>和<code>**kwargs</code></h2><blockquote>
<p><code>*args</code>是可变参数，一般用来表示我们不能确定多少参数将被传递给函数，或者如果我们想用列表或元组的方式传递给函数。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/1754108a3c1c7b65cc088a2fe1317e53c0a5cf2d/py%E5%B8%B8%E8%AF%86/9.png" alt="9"><br><code>**kwargs</code>是可变关键字参数，当我们不知道有多少关键字参数会传递给一个函数时，或者想把一个字典作为关键字参数时使用。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/1754108a3c1c7b65cc088a2fe1317e53c0a5cf2d/py%E5%B8%B8%E8%AF%86/10.png" alt="10"><br>注: <code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中，但是<code>*args</code>必须在<code>**kwargs</code>前面。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些基础的python知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://www.sanstylemc.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>禁止U盘拷贝</title>
    <link href="http://www.sanstylemc.cn/2018/03/27/%E7%A6%81%E6%AD%A2U%E7%9B%98%E6%8B%B7%E8%B4%9D/"/>
    <id>http://www.sanstylemc.cn/2018/03/27/禁止U盘拷贝/</id>
    <published>2018-03-27T06:52:12.000Z</published>
    <updated>2018-03-27T06:52:40.341Z</updated>
    
    <content type="html"><![CDATA[<p>经常会有人在我们电脑上拷贝一些东西，那我们不想让别人拷贝怎么办呢？<br><a id="more"></a><br>1、键入<code>win + r</code>键，打开运行，输入<code>gpedit.msc</code>，打开本地组策略编辑器。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/7677a713dc129c7bdfbd31a9cc145c61cd4f165b/%E7%A6%81%E6%AD%A2U%E7%9B%98%E6%8B%B7%E8%B4%9D/1.png" alt="1"><br>2、点击<code>计算机配置</code>–&gt;<code>管理模板</code>–&gt;<code>系统</code>，找到右侧<code>可移动存储访问</code>。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/7677a713dc129c7bdfbd31a9cc145c61cd4f165b/%E7%A6%81%E6%AD%A2U%E7%9B%98%E6%8B%B7%E8%B4%9D/2.png" alt="2"><br>3、双击后可看到右侧有五个可移动磁盘项目，我们不想让别人从我们电脑拷贝的话，双击<code>拒绝写入权限</code>。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/7677a713dc129c7bdfbd31a9cc145c61cd4f165b/%E7%A6%81%E6%AD%A2U%E7%9B%98%E6%8B%B7%E8%B4%9D/3.png" alt="3"><br>4、选中<code>已启用</code>，点击<code>确定</code>。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/7677a713dc129c7bdfbd31a9cc145c61cd4f165b/%E7%A6%81%E6%AD%A2U%E7%9B%98%E6%8B%B7%E8%B4%9D/4.png" alt="4"><br>5、打开U盘，将文件放入U盘，可以看到提示需要管理员权限。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/7677a713dc129c7bdfbd31a9cc145c61cd4f165b/%E7%A6%81%E6%AD%A2U%E7%9B%98%E6%8B%B7%E8%B4%9D/5.png" alt="5"><br>6、我们点击继续，发现没有办法将文件放入U盘。<br><img src="https://raw.githubusercontent.com/sunstady/hexo/7677a713dc129c7bdfbd31a9cc145c61cd4f165b/%E7%A6%81%E6%AD%A2U%E7%9B%98%E6%8B%B7%E8%B4%9D/6.png" alt="6"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常会有人在我们电脑上拷贝一些东西，那我们不想让别人拷贝怎么办呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="http://www.sanstylemc.cn/tags/CTF/"/>
    
  </entry>
  
</feed>
