<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sanstyle</title>
  <subtitle>功有所不全 才有所不任 力有所不足</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sanstylemc.cn/"/>
  <updated>2018-10-15T03:14:52.743Z</updated>
  <id>http://www.sanstylemc.cn/</id>
  
  <author>
    <name>MC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程安全的使用HashMap</title>
    <link href="http://www.sanstylemc.cn/2018/10/15/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8HashMap/"/>
    <id>http://www.sanstylemc.cn/2018/10/15/线程安全的使用HashMap/</id>
    <published>2018-10-15T03:14:00.000Z</published>
    <updated>2018-10-15T03:14:52.743Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;HashMap是线程不安全的，HashMap是一个接口，是Map的一个子接口，是将键映射到值的对象，不允许键重复，允许空键和空值。由于非线程安全，HashMap的效率要较HashTable的效率高一些。<br><a id="more"></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在Java8之前，HashMap和其他基于map的类都是通过链地址法解决冲突，它们使用单向链表来存储相同索引值的元素。在最坏的情况下，这种方式会将HashMap的get方法的性能从O(1)降低到O(n)。为了解决在频繁冲突时hashmap性能降低的问题，Java8中使用平衡术来替代链表存储冲突的元素。这意味着我们可以将最坏情况下的性能从O(n)提高到O(logn)。<br>&nbsp;&nbsp;&nbsp;&nbsp;在Java8中使用常量TREEIFY_THRESHOLD来控制是否切换到平衡树来存储。目前，这个常量值是8，这意味着当有超过8个元素的索引一样时，HashMap会使用树来存储它们。<br>&nbsp;&nbsp;&nbsp;&nbsp;这一改变是为了继续优化常用类。在Java7中为了优化常用类对ArrayList和HashMap采用了延迟加载的机制，在有元素加入之前不会分配内存，这会减少空的链表和HashMap占用的内存。<br>&nbsp;&nbsp;&nbsp;&nbsp;这一动态的特性使得HashMap一开始使用链表，并在冲突的元素数量超过制定值时用平衡二叉树替换链表。不过这一特性在所有基于hashtable的类中并没有，例如Hashtable和WeakHashMap。<br>&nbsp;&nbsp;&nbsp;&nbsp;目前，只有ConcurrentHashMap，LinkedHashMap和HashMap会在频繁冲突的情况下使用平衡树。</p>
<h2 id="什么时候会产生冲突"><a href="#什么时候会产生冲突" class="headerlink" title="什么时候会产生冲突"></a>什么时候会产生冲突</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;HashMap中调用hashcode()方法来计算hashcode。<br>&nbsp;&nbsp;&nbsp;&nbsp;由于在Java中两个不同的对象可能有一样的hashcode，也就是说不同的键可能有一样的hashcode，此时会产生冲突。</p>
<ul>
<li>相同对象的hashCode一定是相同的，但相同的hashCode不一定是相同的对象。</li>
<li>在HashTable和HashMap中，冲突的产生是由于不同对象的hashCode()方法返回了一样的值。</li>
<li>从Java1中就存在的hashtable类为了保证迭代顺序不变，即便在频繁冲突的情况下也不会使用平衡树。这一决定是为了不破坏某些较老的需要依赖于Hashtable迭代顺序的Java应用。</li>
</ul>
<h2 id="为什么HashMap是线程不安全的"><a href="#为什么HashMap是线程不安全的" class="headerlink" title="为什么HashMap是线程不安全的"></a>为什么HashMap是线程不安全的</h2><p>HashMap的内部存储结构为：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">transient <span class="keyword">Node</span><span class="title">&lt;K</span>, V&gt;[] table;</div><div class="line"></div><div class="line">static class <span class="keyword">Node</span><span class="title">&lt;K</span>, V&gt; implements Map.Entry<span class="tag">&lt;K, V&gt;</span> &#123;</div><div class="line">    final int hash;</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    <span class="keyword">Node</span><span class="title">&lt;K</span>, V&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可以看到HashMap内部存储使用了一个Node数组(默认大小是16)，而Node类包含一个类型为Node的next的变量，也就是相当于一个链表，所有hash值相同(即产生了冲突)的key会存储到同一个链表里。<br>&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，在Java8中如果hash值相同的key数量大于指定值(默认是8)时使用平衡树来代替链表，这会将get()方法的性能从O(n)提高到O(logn)。</p>
<h2 id="HashMap的自动扩容机制"><a href="#HashMap的自动扩容机制" class="headerlink" title="HashMap的自动扩容机制"></a>HashMap的自动扩容机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;HashMap内部的Node数组默认的大小是16，假设有100万个元素，那么最好的情况下每个hash桶里都有62500个元素，这时get(), put(), remove()等方法效率都会降低。为了解决这个问题，HashMap提供了自动扩容机制，当元素个数达到数组大小loadFactor后会扩大数组的大小，在默认情况下，数组大小为16，loadFactor为0.75，也就是说当HashMap中的元素超过16/ 0.75= 12时，会把数组大小扩展为2* 16= 32，并且重新计算每个元素在新数组中的位置。</p>
<h2 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来存储Entry对象。</p>
<h2 id="两个对象的hashcode相同会发生什么"><a href="#两个对象的hashcode相同会发生什么" class="headerlink" title="两个对象的hashcode相同会发生什么"></a>两个对象的hashcode相同会发生什么</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;因为hashcode相同，所以它们的bucket位置相同，”碰撞”会发生。因为HashMap使用LinkedList存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在LinkedList中。<br>&nbsp;&nbsp;&nbsp;&nbsp;既然两个键的hashcode相同，如何获取值对象呢？当我们调用get()方法时，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。如果两个值对象存储在同一个bucket，会调用keys.equals()方法去找到LinkedList中正确的节点，最终找到要找的值对象。</p>
<h2 id="为什么线程不安全"><a href="#为什么线程不安全" class="headerlink" title="为什么线程不安全"></a>为什么线程不安全</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;个人觉得HashMap在并发时可能出现的问题主要是两方面，首先如果多个线程同时使用put方法添加元素，而且假设正好存在两个put的key发生了碰撞(hash值一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put数据被覆盖。第二就是如果多个线程同时检测到元素个数超过数组大小*loadFactor，这样就会发生多个线程同时对Node数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。</p>
<blockquote>
<p>HashMap在并发执行put操作时会引起死循环，导致CPU利用率接近100%。因为多线程会导致HashMap的Node链表形成环形数据结构，一旦形成环形数据结构，Node的next节点永远不为空，就会在获取Node时产生死循环。</p>
</blockquote>
<h2 id="如何线程安全的使用HashMap"><a href="#如何线程安全的使用HashMap" class="headerlink" title="如何线程安全的使用HashMap"></a>如何线程安全的使用HashMap</h2><ul>
<li>Hashtable</li>
<li>ConcurrentHashMap</li>
<li>Synchronized Map</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;主要说一下ConcurrentHashMap。</p>
<h3 id="锁分段技术"><a href="#锁分段技术" class="headerlink" title="锁分段技术"></a>锁分段技术</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里”按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的。但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。<br>&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，首先获得它对应的Segment锁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HashMap是线程不安全的，HashMap是一个接口，是Map的一个子接口，是将键映射到值的对象，不允许键重复，允许空键和空值。由于非线程安全，HashMap的效率要较HashTable的效率高一些。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库引擎</title>
    <link href="http://www.sanstylemc.cn/2018/10/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/"/>
    <id>http://www.sanstylemc.cn/2018/10/12/数据库引擎/</id>
    <published>2018-10-12T05:01:07.000Z</published>
    <updated>2018-10-12T06:57:47.305Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;MySQL中主要有两个引擎MyISAM呵InnoDB，每个引擎有利有弊。<br><a id="more"></a></p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;MyISAM适用于一些大量查询的应用，但对于有大量写功能的应用不是很好。甚至你只需要update一个字段整个表都会被锁起来。而别的进程就算是读操作也不行要等到当前update操作完成之后才能继续进行。另外，MyISAM对于select count(*)这类操作是超级快的。<br>PS: 为什么呢？</p>
<ul>
<li>MyISAM保存表的总行数，因此count(*)并且无where子句。很快会返回表的总行数。</li>
<li>……, 利用count(column)并且无where子句，并且此column不为null，很快会返回表的总行数。</li>
<li>……, ……, ……, MySQL会对表进行全表或全索引扫描来确定行数。</li>
<li>InnoDB查询count(*), count(column(not null)), count(cloumn(may be null))并且无where子句，MySQL会对表进行全表或全索引扫描来确定行数。</li>
<li>MyISAM和InnoDB查询count(*), count(cloumn(not null)), count(column(may be null))并且存在where子句，MySQL会对表进行索引扫描(如果列上有索引)，速度也比较快。</li>
</ul>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;InnoDB的趋势会是一个非常复杂的存储引擎，对于一些小的应用会比MyISAM还慢，但是支持”行锁”，所以在写操作比较多的时候会比较优秀。并且，它支持很多的高级应用，例如：事务。<br>PS: 行锁？<br><code>防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决。</code></p>
<h3 id="数据库是acid属性"><a href="#数据库是acid属性" class="headerlink" title="数据库是acid属性"></a>数据库是acid属性</h3><ul>
<li>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li>
<li>一致性：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。</li>
<li>隔离性：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的”独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li>持久性：事务完成后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>
<h3 id="事务并发调度的问题"><a href="#事务并发调度的问题" class="headerlink" title="事务并发调度的问题"></a>事务并发调度的问题</h3><ul>
<li>脏读：A事务读取B事务尚未提交的更改数据，并在这个数据基础上操作。如果B事务回滚，那么A事务读到的数据根本不是合法的，称为脏读。在Oracle中，由于有version控制，不会出现脏读。</li>
<li>不可重复读：A事务读取了B事务已经提交的更改(或删除)数据。比如A事务第一次读取数据，然后B事务更改该数据并提交，A事务再次读取数据，两次读取的数据不一样。</li>
<li>幻读：A事务读取了B事务已经提交的新增数据。注意和不可重复读的区别，这里是新增，不可重复读是更改(或删除)。这两种情况对策是不一样的，对于不可重复读，只需要采取行级锁防止该记录数据被更改或删除，然而对于幻读必须加表级锁，防止在这个表中新增一条数据。</li>
<li>第一类丢失更新：A事务撤销时，把已提交的B事务的数据覆盖掉。</li>
<li>第二类丢失更新：A事务提交时，把已提交的B事务的数据覆盖掉。</li>
</ul>
<h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><ul>
<li>一级封锁协议：事务T中如果对数据R有写操作，必须在这个事务中对R的第一次读操作前对它加X锁，直到事务结束才释放。事务结束包括正常结束和非正常结束。</li>
<li>二级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。</li>
<li>三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可见，三级锁操作一个比一个厉害(满足高级锁一定满足低级锁)。但有个非常致命的地方，一级锁协议就要在第一次读加X锁，直到事务结束。几乎就要在整个事务加写锁了，效率非常低。<code>三级封锁协议只是一个理论上的东西，实际数据库常用另一套方法来解决事务并发问题</code>。</p>
<h3 id="隔离性级别"><a href="#隔离性级别" class="headerlink" title="隔离性级别"></a>隔离性级别</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;MySQL用意向锁(另一种机制)来解决事务并发问题，为了区别封锁协议，弄了一个新概念隔离性级别，MySQL一般默认<code>可重复读</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别/读数据一致性及允许的并发副作用</th>
<th style="text-align:center">读数据一致性</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未提交读</td>
<td style="text-align:center">最低级别，只能保证不读取物理上损坏的数据</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">已提交读</td>
<td style="text-align:center">语句级</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">可重复读</td>
<td style="text-align:center">事务级</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">可序列化</td>
<td style="text-align:center">最高级别，事务级</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p><code>可重复读能解决脏读和不可重复读，但不能解决丢失修改</code>。</p>
<h2 id="MySQL的行锁和表锁"><a href="#MySQL的行锁和表锁" class="headerlink" title="MySQL的行锁和表锁"></a>MySQL的行锁和表锁</h2><ul>
<li>表级锁：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<h3 id="MyISAM的锁"><a href="#MyISAM的锁" class="headerlink" title="MyISAM的锁"></a>MyISAM的锁</h3><ul>
<li>只有表锁，锁又分为读锁和写锁。</li>
<li>没有事务，不用考虑并发问题。</li>
<li>由于锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了。</li>
</ul>
<h3 id="InnoDB的行锁和表锁"><a href="#InnoDB的行锁和表锁" class="headerlink" title="InnoDB的行锁和表锁"></a>InnoDB的行锁和表锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;没有特定的语法。MySQL的行锁是通过索引体现的。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果where条件中只用到索引项，则加的是行锁；否则加的是表锁。比如是主键索引，唯一索引和聚簇索引等。如果sql的where是全表扫描的，想加行锁也爱莫能助。<br>&nbsp;&nbsp;&nbsp;&nbsp;行锁和表锁对我们编程有什么影响，要在where中尽量只用索引项，否则就会触发表锁。</p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><a href="http://sanstylemc.cn/2018/04/02/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/" target="_blank" rel="external">乐观锁和悲观锁</a></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><a href="http://sanstylemc.cn/2018/04/01/MySQL%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%85%B6%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7/" target="_blank" rel="external">事务</a></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><a href="http://sanstylemc.cn/2018/07/24/%E7%B4%A2%E5%BC%95/" target="_blank" rel="external">索引</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MySQL中主要有两个引擎MyISAM呵InnoDB，每个引擎有利有弊。&lt;br&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.sanstylemc.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis性能调优</title>
    <link href="http://www.sanstylemc.cn/2018/10/07/Redis%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://www.sanstylemc.cn/2018/10/07/Redis性能调优/</id>
    <published>2018-10-07T01:33:28.000Z</published>
    <updated>2018-10-07T01:34:14.346Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。<br><a id="more"></a></p>
<h2 id="Redis性能调优"><a href="#Redis性能调优" class="headerlink" title="Redis性能调优"></a>Redis性能调优</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;针对Redis的性能优化，主要从下面几个层面入手：</p>
<ul>
<li>最初的也是最重要的，确保没有让Redis执行耗时长的命令。</li>
<li>使用pipelining将连续执行的命令组合执行。</li>
<li>操作系统的Transparent huge pages功能必须关闭：<code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code></li>
<li>如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。可以通过./redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。</li>
<li>检查数据持久化策略。</li>
<li>考虑引入读写分离机制。</li>
</ul>
<h2 id="长耗时命令"><a href="#长耗时命令" class="headerlink" title="长耗时命令"></a>长耗时命令</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis绝大多数写命令的时间复杂度都在O(1)到O(N)之间，在文本和官方文档中均对每个命令的时间复杂度有说明。<br>&nbsp;&nbsp;&nbsp;&nbsp;通常来说，O(1)的命令是安全的，O(N)命令在使用时需要注意，如果N的数量级不可预知，则应避免使用。例如对一个field数未知的Hash数据执行HGETALL/HKEYS/HVALS命令，通常来说这些命令执行的很快，但如果这个Hash中的field数量极多，耗时就会成倍增长。<br>&nbsp;&nbsp;&nbsp;&nbsp;又如使用SUNION对两个Set执行Union操作，或使用SORT对List/Set执行排序操作等时，都应该严加注意。<br>&nbsp;&nbsp;&nbsp;&nbsp;避免在使用这些O(N)命令时发生问题主要有几个方法：</p>
<ul>
<li>不要把List当作列表使用，仅当作队列使用。</li>
<li>通过机制严格控制Hash、Set、Sorted Set的大小。</li>
<li>可能的话，将排序、并集、交集等操作放在客户端执行。</li>
<li>绝对禁止使用KEYS命令。</li>
<li>避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis提供了SCAN命令，可以对Redis中存储的所有key进行游标式的遍历，避免使用KEYS命令带来的性能问题。同时还有SSCAN/HSCAN/ZSCAN等命令，分别用于对Set/Hash/Sorted Set中的元素进行游标式遍历。SCAN类命令的使用请参考<a href="https://redis.io/commands/scan" target="_blank" rel="external">官方文档</a> 。<br>&nbsp;&nbsp;&nbsp;&nbsp;Redis提供了Slow Log功能，可以自动记录耗时较长的命令。相关的配置参数有两个：</p>
<ul>
<li>slowlog-log-slower-than xxxms #执行时间慢于xxx毫秒的命令计入Slow Log</li>
<li>slowlog-max-len xxx #Slow Log的长度，即最大记录多少条Slow Log</li>
</ul>
<p>使用SLOWLOG GET [number]命令，可以输出最近进入Slow Log的number条命令。<br>使用SLOWLOG RESET命令，可以重置Slow Log。</p>
<h2 id="网络引发的延迟"><a href="#网络引发的延迟" class="headerlink" title="网络引发的延迟"></a>网络引发的延迟</h2><ul>
<li>尽可能使用长连接或连接池，避免频繁创建销毁连接。</li>
<li>客户端进行的批量数据操作，应使用Pipeline特性在一次交互中完成。</li>
</ul>
<h2 id="数据持久化引发的延迟"><a href="#数据持久化引发的延迟" class="headerlink" title="数据持久化引发的延迟"></a>数据持久化引发的延迟</h2><p>Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p>
<ul>
<li>AOF+ fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响。</li>
<li>AOF+ fsync every second是比较好的折中方案，每秒fsync一次。</li>
<li>AOF+ fsync never会提供AOF持久化方案下的最优性能</li>
<li>使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置。</li>
<li>每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了24GB内存的Redis实例为例，共需要拷贝24GB/4KB* 8= 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。<br>&nbsp;&nbsp;&nbsp;&nbsp;可以通过INFO命令返回的latest_usec字段查看上一次fork操作的耗时(微秒)。</p>
<h2 id="Swap引发的延迟"><a href="#Swap引发的延迟" class="headerlink" title="Swap引发的延迟"></a>Swap引发的延迟</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;当Linux将Redis所用的内存分页移至swap空间时，将会阻塞Redis进程，导致Redis出现不正常的延迟。Swap通常在物理内存不足或一些进程在进行大量I/O操作时发生，应尽可能避免上述两种情况的出现。<br>&nbsp;&nbsp;&nbsp;&nbsp;/proc/&lt; pid &gt;/smaps文件中会保存进行的swap记录，通过查看这个文件，能够判断Redis的延迟是否由Swap产生。如果这个文件中记录了较大的Swap size，则说明延迟很有可能是Swap造成的。</p>
<h2 id="数据淘汰引发的延迟"><a href="#数据淘汰引发的延迟" class="headerlink" title="数据淘汰引发的延迟"></a>数据淘汰引发的延迟</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。<br><code>引入读写分离机制</code><br>&nbsp;&nbsp;&nbsp;&nbsp;Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。<br>&nbsp;&nbsp;&nbsp;&nbsp;在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减少主节点的压力。<br>&nbsp;&nbsp;&nbsp;&nbsp;尤其是针对一些使用了长耗时命令的统计类任务，完全可以执行在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Redis采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。&lt;br&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.sanstylemc.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>spring笔记一</title>
    <link href="http://www.sanstylemc.cn/2018/09/21/spring%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://www.sanstylemc.cn/2018/09/21/spring笔记一/</id>
    <published>2018-09-21T01:36:18.000Z</published>
    <updated>2018-09-21T01:37:19.729Z</updated>
    
    <content type="html"><![CDATA[<p>以前的笔记，推上来记录下。<br><a id="more"></a></p>
<p><code>IOC和DI的区别？</code><br>IOC和DI是同一件事情，都是将对象控制权交给第三方(Spring)管理，只是站在不同角度。</p>
<p><code>IOC钟哪些方面的控制被反转了？</code><br>获得依赖对象的过程被反转了。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<p><code>BeanFactory和FactoryBean的区别？</code><br>BeanFactory：是一个工厂(其实是构建了一个spring上下文的环境，容器)，用来管理和获取很多Bean对象。<br>FactoryBean：是一个Bean生成工具，是用来获取一种类型对象的Bean，它是构造Bean实例的一种方式。</p>
<p><code>spEL表达式</code><br>spEL(Spring Expression Language)是一种表达式语言，它是spring3.x版本的新特性。<br>它的作用是：支持在运行时操作和查询对象，其语法类似统一的EL语言，但是spEL提供了额外的功能，功能更强大。</p>
<p><code>什么是EL、OGNL、spEL</code><br>EL：操作servlet相关的一些对象和相关的值<br>OGNL：主要操作struts值栈<br>spEL：操作bean相关的</p>
<p><code>直接new ClassPathXmlApplicationContext()有什么缺点</code><br>缺点：在创建Spring容器同时，需要对容器种对象初始化。而每次初始化容器的时候，都创建了新的容器对象，消耗了资源，降低了性能。<br>解决思路：保证容器对象只有一个。<br>解决方案：将Spring容器绑定到Web Servlet容器上，让Web容器来管理Spring容器的创建和销毁。<br>分析：ServletContext在Web服务运行过程中是唯一的，其初始化的时候，会自动执行ServletContextListener监听器(用来监听上下文的创建和销毁)。<br>具体步骤为：编写一个ServletContestListener监听器，在监听到ServletContext创建的时候，创建Spring容器，并将其放到ServletContext的属性中保存。<br>我们无需手动创建该监听器，因为Spring提供了一个叫ContextLoaderListener的监听器，它位于spring-web-4.2.5.REKEASE.jar中。<br>开发步骤：<br>第一步：导入spring web的jar<br>第二步：在web.xml配置Spring的核心监听器<br>第三步：启动tomcat服务器，结果发现异常，因为默认会加载。<br>根据异常提示：发现spring的BeanFactory没有初始化，说明没有找到spring容器，即applicationContext.xml文件。<br>第四步：在web容器中配置spring文件路径<br>为什么没有找到applicationContext.xml文件呢？因为此时加载的是WEB-INF/applicationContext.xml，而不是src下的applicationContext.xml文件。<br>原因：找到ContextLoaderListener.class，再找到ContextLoader.class，发现默认加载的WEB-INF/applicationContext.xml。<br>解决方案：需要在web.xml中配置，加载spring容器applicationContext.xml文件的路径。<br>重新启动tomcat服务器，没有异常，问题解决。<br>第五步：修改Servlet代码。在Servlet中通过ServletContext获取Spring容器对象。<br>第一种方式：使用getAttribute。<br>第二种方式：使用WebApplicationContextUtils(推荐)。</p>
<p><code>servletContext</code><br>1、servletContext就是代表web应用的一个servlet类。也就是说一个web应用只有一个servletContext对象。<br>2、servletContext是用来管理web应用下的资源的。<br>3、servletContext是可以被所有访问其代表web应用的用户共享的。<br>4、servletContext是在服务器端被创建和销毁的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前的笔记，推上来记录下。&lt;br&gt;
    
    </summary>
    
    
      <category term="ssm" scheme="http://www.sanstylemc.cn/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>内部匿名类</title>
    <link href="http://www.sanstylemc.cn/2018/09/17/%E5%86%85%E9%83%A8%E5%8C%BF%E5%90%8D%E7%B1%BB/"/>
    <id>http://www.sanstylemc.cn/2018/09/17/内部匿名类/</id>
    <published>2018-09-17T00:36:10.000Z</published>
    <updated>2018-09-17T00:40:37.212Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;什么是内部匿名类，为什么它引用外部变量得加final？并且不能重新赋值？<br><a id="more"></a></p>
<h2 id="什么是内部匿名类"><a href="#什么是内部匿名类" class="headerlink" title="什么是内部匿名类"></a>什么是内部匿名类</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NiMing</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</div><div class="line">        <span class="keyword">final</span> String name = <span class="string">"Haha"</span>;</div><div class="line">        new FunLisenter() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> void <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</div><div class="line">                System.<span class="keyword">out</span>.println(name);</div><div class="line">            &#125;</div><div class="line">        &#125;.<span class="keyword">fun</span>();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 外部接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunLisenter</span> </span>&#123;</div><div class="line">    void <span class="function"><span class="title">fun</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;什么是内部匿名类呢？上述demo中的:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">new FunLisenter() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> void <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</div><div class="line">        System.<span class="keyword">out</span>.println(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这就是内部匿名类。<br>&nbsp;&nbsp;&nbsp;&nbsp;接口不能new，为什么这里被new出来了？因为它是匿名内部类，它是特殊的存在。<br>&nbsp;&nbsp;&nbsp;&nbsp;看它的编译后的<code>.class</code>文件。<br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E5%86%85%E9%83%A8%E5%8C%BF%E5%90%8D%E7%B1%BB/1.png?raw=true" alt="1"><br>&nbsp;&nbsp;&nbsp;&nbsp;发现两个Java文件编译后出来了3个class文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;这就是特殊的存在，我们反编译这个特别的NiMing$1.class文件：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NiMing</span>$1 <span class="title">implements</span> <span class="title">FunLisenter</span> </span>&#123;</div><div class="line">    Main$<span class="number">1</span>() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> void <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Haha"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;发现一个奇怪的类实现了我们的FunLisenter接口，难道new的FunLisenter就是new的这个奇怪的NiMing$1类么？<br>&nbsp;&nbsp;&nbsp;&nbsp;深入思考下，为什么叫做匿名？<br>&nbsp;&nbsp;&nbsp;&nbsp;对于我们Java层面来说，这个类根本看不到。<br>&nbsp;&nbsp;&nbsp;&nbsp;之所以被称之为内部匿名类，是因为：在编译阶段，编译器帮我们以内部类的形式，帮我们implement我们的接口，因此我们才可以以new的方式使用。</p>
<h2 id="内部匿名类引用外部变量为什么得加final"><a href="#内部匿名类引用外部变量为什么得加final" class="headerlink" title="内部匿名类引用外部变量为什么得加final"></a>内部匿名类引用外部变量为什么得加final</h2><p>先来一段代码。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> static void main(String[] args) &#123;</div><div class="line">    NiMing main = new NiMing();</div><div class="line">    main.<span class="keyword">fun</span>();</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> void <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 这里为什么赋值为null，因为避免String常量对效果的影响</span></div><div class="line">    <span class="keyword">final</span> String nameInner = <span class="literal">null</span>;</div><div class="line">    new FunLisenter() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> void <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</div><div class="line">            System.<span class="keyword">out</span>.println(nameInner);</div><div class="line">        &#125;</div><div class="line">    &#125;.<span class="keyword">fun</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;为什么内部匿名类能够访问到namelnner？一个方法，就是一个栈帧。对于局部变量来说，方法结束，栈帧弹出，局部变量烟消云散。为什么内部匿名类可以访问？<br>&nbsp;&nbsp;&nbsp;&nbsp;直接看反编译的class文件:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiMing</span>$1 <span class="title">implements</span> <span class="title">FunLisenter</span> </span>&#123;</div><div class="line">    NiMing$<span class="number">1</span>(NiMing var1, String var2) &#123;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">val</span>$nameInner = var2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> void <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">this</span>.<span class="keyword">val</span>$nameInner);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这个例子不光解释了内部匿名类为什么能够访问局部变量，还展示了持有外部引用的问题。局部变量nameInner，被我们在编译期在生成匿名内部类的时候以参数的形式赋值给了我们内部持有的外部变量了。因此我们调用fun()方法时，就直接使用<code>this.val$nameInner</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;为什么要加final呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;从Java代码上来看局部变量nameInner和匿名内部类的nameInner是同一个对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;但是我们反编译了字节码，发现这二者并非是同一个对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;设想一下，如果不加final。在Java的这种设计下，一定会造成这种情况：我们在内部匿名类中重新赋值，但是局部变量并不会同步发生变化。因为按照这种设计，重新赋值，完全就是两个变量！因此为了避免这种情况，索性加上了final。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;什么是内部匿名类，为什么它引用外部变量得加final？并且不能重新赋值？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>IDEA资源文件xml</title>
    <link href="http://www.sanstylemc.cn/2018/09/11/IDEA%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6xml/"/>
    <id>http://www.sanstylemc.cn/2018/09/11/IDEA资源文件xml/</id>
    <published>2018-09-11T11:21:20.000Z</published>
    <updated>2018-09-11T11:21:56.075Z</updated>
    
    <content type="html"><![CDATA[<p>偶遇小坑，在此记录下。<br><a id="more"></a></p>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p><code>Cause: java.io.IOException: Could not find resource ***.xml</code></p>
<p>看提示可知是没找到这个xml文件。<br>我的环境是idea+maven，检查配置发现并没有配错路径，后来在pom.xml中加入一段代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>将<code>src/main/java</code>下的xml文件随同Java编译后的class文件一同copy到相应的class目录。</p>
<p>舒服~</p>
<h2 id="Two"><a href="#Two" class="headerlink" title="Two"></a>Two</h2><p><code>Tue Sep 11 19:13:16 CST 2018 WARN: Establishing SSL connection without server&#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#39;false&#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.</code></p>
<p>对于这个问题，有两个解决方法: </p>
<ul>
<li>在数据库连接的url中添加useSSL=false;</li>
<li>url中添加useSSL=true，并且提供服务器的验证证书。</li>
</ul>
<p>如果只是做一个测试的话，没必要搞证书那么麻烦，在连接后面添加一个useSSL=false即可。例如：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">jdbc:</span><span class="string">mysql:</span><span class="comment">//localhost:3306/mybatis?useSSL=false</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶遇小坑，在此记录下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Skill" scheme="http://www.sanstylemc.cn/tags/Skill/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法</title>
    <link href="http://www.sanstylemc.cn/2018/09/09/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://www.sanstylemc.cn/2018/09/09/常用排序算法/</id>
    <published>2018-09-09T10:55:21.000Z</published>
    <updated>2018-10-15T14:55:55.422Z</updated>
    
    <content type="html"><![CDATA[<p>我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。<br><a id="more"></a><br>排序算法答题可分为两种：</p>
<ul>
<li>一种是比较排序，时间复杂度O(nlogn)~ O(n^2)，主要有：<code>冒泡排序</code>,<code>选择排序</code>,<code>插入排序</code>,<code>归并排序</code>,<code>堆排序</code>,<code>快速排序</code>等。</li>
<li>一种是非比较排序，时间复杂度可以达到O(n)，主要有：<code>计数排序</code>,<code>基数排序</code>,<code>桶排序</code>等。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">辅助空间</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">O(nlogn)~O(n^2)</td>
<td style="text-align:center">O(n^1.3)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(logn)~O(n)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
<p>有一点我们很容量忽略的是排序算法的稳定性。<br>&nbsp;&nbsp;&nbsp;&nbsp;排序算法稳定性的简单形式化定义为: 如果Ai= Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。<br>&nbsp;&nbsp;&nbsp;&nbsp;对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。<br>&nbsp;&nbsp;&nbsp;&nbsp;例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i]&gt;=A[i+ 1]，则两个相等的记录就会交换位置，从而编程不稳定的排序算法。<br>&nbsp;&nbsp;&nbsp;&nbsp;其次，说一下排序算法稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;冒泡排序是一种极其简单的排序算法。它重复地走访过要排序的元素，依次比较相邻两个元素，如果它们的顺序错误就把它们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢”浮”到数列的顶端。<br>&nbsp;&nbsp;&nbsp;&nbsp;冒泡排序算法的运作如下：</p>
<ul>
<li>比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素回事最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一堆数字需要比较。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。冒泡排序的代码如下:<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> static void main(<span class="built_in">String</span>[] args) &#123;</div><div class="line">    <span class="built_in">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i= <span class="number">0</span>, <span class="built_in">len</span>= A.length- <span class="number">1</span>; i&lt; <span class="built_in">len</span>; i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j= <span class="number">0</span>, lens= A.length- <span class="number">1</span>- i; j&lt; lens; j++)&#123;</div><div class="line">            <span class="keyword">if</span>(A[j]&gt; A[j+ <span class="number">1</span>])&#123;</div><div class="line">                <span class="built_in">int</span> temp= A[j];</div><div class="line">                A[j]= A[j+ <span class="number">1</span>];</div><div class="line">                A[j+ <span class="number">1</span>]= temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i= <span class="number">0</span>, <span class="built_in">len</span>= A.length; i&lt; <span class="built_in">len</span>; i++)&#123;</div><div class="line">        System.out.print(A[i]+ (i== (<span class="built_in">len</span>- <span class="number">1</span>)? <span class="string">""</span>: <span class="string">" "</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

</div></div><br>上述代码对序列{6, 5, 3, 1, 8, 7, 2, 4}进行冒泡排序的实现过程如下:<br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/1.gif?raw=true" alt="1"></p>
<h2 id="冒泡排序的改进-鸡尾酒排序"><a href="#冒泡排序的改进-鸡尾酒排序" class="headerlink" title="冒泡排序的改进: 鸡尾酒排序"></a>冒泡排序的改进: 鸡尾酒排序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同之处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。它可以得到此冒泡排序稍微好一点的效能。<br>&nbsp;&nbsp;&nbsp;&nbsp;鸡尾酒排序的代码如下:<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> static void main(<span class="built_in">String</span>[] args) &#123;</div><div class="line">    <span class="built_in">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</div><div class="line">    <span class="built_in">int</span> i, temp;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">left</span>= <span class="number">0</span>, <span class="built_in">right</span>= A.length- <span class="number">1</span>, length= A.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="built_in">left</span>&lt; <span class="built_in">right</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(i= <span class="built_in">left</span>; i&lt; <span class="built_in">right</span>; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(A[i]&gt; A[i+ <span class="number">1</span>])&#123;</div><div class="line">                temp= A[i];</div><div class="line">                A[i]= A[i+ <span class="number">1</span>];</div><div class="line">                A[i+ <span class="number">1</span>]= temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">right</span>--;</div><div class="line">        <span class="keyword">for</span>(i= <span class="built_in">right</span>; i&gt; <span class="built_in">left</span>; i--)&#123;</div><div class="line">            <span class="keyword">if</span>(A[i- <span class="number">1</span>]&gt; A[i])&#123;</div><div class="line">                temp= A[i- <span class="number">1</span>];</div><div class="line">                A[i- <span class="number">1</span>]= A[i];</div><div class="line">                A[i]= temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">left</span>++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i= <span class="number">0</span>; i&lt;= length- <span class="number">1</span>; i++)&#123;</div><div class="line">        System.out.print(A[i]+ (i== (length- <span class="number">1</span>)? <span class="string">""</span>: <span class="string">" "</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

</div></div><br>&nbsp;&nbsp;&nbsp;&nbsp;使用鸡尾酒排序为一列数字进行排序的过程如下图所示:<br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/2.gif?raw=true" alt="2"><br>&nbsp;&nbsp;&nbsp;&nbsp;以序列{2, 3, 4, 5, 1}为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小(大)元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小(最大)元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>&nbsp;&nbsp;&nbsp;&nbsp;注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小(大)元素放到合适的位置；而选择排序每遍历一次都记住了当前最小(大)元素的位置，最后仅需一次交换操作即可将其放到合适的位置。<br>&nbsp;&nbsp;&nbsp;&nbsp;选择排序的代码如下:<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>&#125;;</div><div class="line">    <span class="keyword">int</span> i, j, temp;</div><div class="line">    <span class="keyword">int</span> length= A.length;</div><div class="line">    </div><div class="line">    <span class="built_in">for</span>(i= <span class="number">0</span>; i&lt; length- <span class="number">1</span>; i++)&#123;</div><div class="line">        <span class="keyword">int</span> k= i;</div><div class="line">        <span class="built_in">for</span>(j= k+ <span class="number">1</span>; j&lt; length; j++)&#123;</div><div class="line">            <span class="built_in">if</span>(A[j]&lt; A[k])&#123;</div><div class="line">                <span class="comment">//记下目前找到的最小值所在的位置</span></div><div class="line">                k= j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">if</span>(i!= k)&#123;</div><div class="line">            temp= A[i];</div><div class="line">            A[i]= A[k];</div><div class="line">            A[k]= temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">for</span>(i= <span class="number">0</span>; i&lt;= length- <span class="number">1</span>; i++)&#123;</div><div class="line">        System.out.<span class="built_in">print</span>(A[i]+ (i== (length- <span class="number">1</span>)? <span class="string">""</span>: <span class="string">" "</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

</div></div><br>上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7}进行选择排序的实现过程如下图:<br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/3.gif?raw=true" alt="3"><br>&nbsp;&nbsp;&nbsp;&nbsp;使用选择排序为一列数字进行排序的宏观过程。<br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/4.gif?raw=true" alt="4"><br><code>选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。</code><br>比如序列: {5, 8, 5, 2, 9}，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌。<br>对于未排序数据(新抓到的牌)，在已排序序列(排好序的手牌)中从后向前扫描，找到相应位置并插入。<br>&nbsp;&nbsp;&nbsp;&nbsp;插入排序在实现上，通常采用in-place排序(即只需用到O(1)的额外空间的排序)，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>具体算法描述如下: </p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序。</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描。</li>
<li>如果该元素(已排序)大于新元素，将该元素移到下一位置。</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ul>
<p>插入排序的代码如下:<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    int A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;<span class="comment">;</span></div><div class="line">    int i, <span class="keyword">j, </span>temp<span class="comment">;</span></div><div class="line">    int length= A.length<span class="comment">;</span></div><div class="line"></div><div class="line">    for(i= <span class="number">1</span><span class="comment">; i&lt; length; i++)&#123;</span></div><div class="line">        for(<span class="keyword">j= </span>i<span class="comment">; j&gt; 0&amp;&amp; A[j]&lt; A[j- 1]; j--)&#123;</span></div><div class="line">            temp= A[<span class="keyword">j];</span></div><div class="line"><span class="keyword"> </span>           A[<span class="keyword">j]= </span>A[<span class="keyword">j- </span><span class="number">1</span>]<span class="comment">;</span></div><div class="line">            A[<span class="keyword">j- </span><span class="number">1</span>]= temp<span class="comment">;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(i= <span class="number">0</span><span class="comment">; i&lt;= length- 1; i++)&#123;</span></div><div class="line">        System.out.print(A[i]+ (i== (length- <span class="number">1</span>)? <span class="string">""</span>: <span class="string">" "</span>))<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

</div></div><br>&nbsp;&nbsp;&nbsp;&nbsp;上述代码对序列{6, 5, 3, 1, 8, 7, 2, 4}进行插入排序的实现过程如下:<br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/5.gif?raw=true" alt="5"><br>&nbsp;&nbsp;&nbsp;&nbsp;使用插入排序为一列数字进行排序的宏观过程:<br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/6.gif?raw=true" alt="6"><br>&nbsp;&nbsp;&nbsp;&nbsp;插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序(通常为8个或以下)。</p>
<h2 id="插入排序的改进-二分插入排序"><a href="#插入排序的改进-二分插入排序" class="headerlink" title="插入排序的改进: 二分插入排序"></a>插入排序的改进: 二分插入排序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序。代码如下:<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</div><div class="line">    int <span class="type">A</span>[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</div><div class="line">    int i, j, temp;</div><div class="line">    int length= <span class="type">A</span>.length;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(i= <span class="number">1</span>; i&lt; length; i++)&#123;</div><div class="line">        <span class="comment">//抓到一张扑克牌</span></div><div class="line">        int <span class="keyword">get</span>= <span class="type">A</span>[i];</div><div class="line">        <span class="comment">//手牌是排好序的，可以用二分法</span></div><div class="line">        int <span class="keyword">left</span>= <span class="number">0</span>;</div><div class="line">        <span class="comment">//手牌左右边界进行初始化</span></div><div class="line">        int <span class="keyword">right</span>= i- <span class="number">1</span>;</div><div class="line">        <span class="comment">//采用二分法定位新牌的位置</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">left</span>&lt;= <span class="keyword">right</span>)&#123;</div><div class="line">            int mid= (<span class="keyword">left</span>+ <span class="keyword">right</span>)/ <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(<span class="type">A</span>[mid]&gt; <span class="keyword">get</span>)&#123;</div><div class="line">                <span class="keyword">right</span>= mid- <span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">left</span>= mid+ <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将欲插入新牌位置右边的牌整体向右移动一个单位</span></div><div class="line">        <span class="keyword">for</span>(j= i- <span class="number">1</span>; j&gt;= <span class="keyword">left</span>; j--)&#123;</div><div class="line">            <span class="type">A</span>[j+ <span class="number">1</span>]= <span class="type">A</span>[j];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将抓到的牌插入手牌</span></div><div class="line">        <span class="type">A</span>[<span class="keyword">left</span>]= <span class="keyword">get</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(i= <span class="number">0</span>; i&lt;= length- <span class="number">1</span>; i++)&#123;</div><div class="line">        <span class="type">System</span>.out.<span class="built_in">print</span>(<span class="type">A</span>[i]+ (i== (length- <span class="number">1</span>)? <span class="string">""</span>: <span class="string">" "</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

</div></div><br>&nbsp;&nbsp;&nbsp;&nbsp;当长度较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所以当元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p>
<h2 id="插入排序的更高效改进-希尔排序"><a href="#插入排序的更高效改进-希尔排序" class="headerlink" title="插入排序的更高效改进: 希尔排序"></a>插入排序的更高效改进: 希尔排序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。<br>&nbsp;&nbsp;&nbsp;&nbsp;希尔排序是基于插入排序的以下两点性值而提出改进方法的: </p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排号的了(此时插入排序较快)。<br>&nbsp;&nbsp;&nbsp;&nbsp;假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序(冒泡排序或直接插入排序)，可能会进行n次的比较和交换才能将该数据迁移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。<br>&nbsp;&nbsp;&nbsp;&nbsp;希尔排序的代码如下:<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</div><div class="line">    <span class="keyword">int</span> i, j, temp;</div><div class="line">    <span class="keyword">int</span> length= A.length;</div><div class="line">    <span class="keyword">int</span> h= <span class="number">0</span>;</div><div class="line">    <span class="built_in">while</span> (h&lt;= length)&#123;</div><div class="line">        h= h* <span class="number">3</span>+ <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">while</span> (h&gt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="built_in">for</span>(i= h; i&lt; length; i++)&#123;</div><div class="line">            j= i- h;</div><div class="line">            <span class="keyword">int</span> <span class="built_in">get</span>= A[i];</div><div class="line">            <span class="built_in">while</span> (j&gt;= <span class="number">0</span>&amp;&amp; A[j]&gt; <span class="built_in">get</span>)&#123;</div><div class="line">                A[j+ h]= A[j];</div><div class="line">                j= j- h;</div><div class="line">            &#125;</div><div class="line">            A[j+ h]= <span class="built_in">get</span>;</div><div class="line">        &#125;</div><div class="line">        h= (h- <span class="number">1</span>)/ <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">for</span>(i= <span class="number">0</span>; i&lt;= length- <span class="number">1</span>; i++)&#123;</div><div class="line">        System.out.<span class="built_in">print</span>(A[i]+ (i== (length- <span class="number">1</span>)? <span class="string">""</span>: <span class="string">" "</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

</div></div><br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/7.gif?raw=true" alt="7"><br>&nbsp;&nbsp;&nbsp;&nbsp;希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。<br>&nbsp;&nbsp;&nbsp;&nbsp;比如序列: {3, 5, 10, 8, 7, 2, 8, 1, 20, 6}，h= 2时分成两个子序列{3, 10, 7, 8, 20}和{5, 8, 2, 1, 6}，未排序之前第二个子序列中的8在前面，限制对两个子序列进行插入排序，得到{3, 7, 8, 10, 20}和{1, 2, 5, 6, 8}，即{3, 1, 7, 2, 8, 5, 10, 6, 20, 8}，两个8的相对次序发生了改变。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。<br>&nbsp;&nbsp;&nbsp;&nbsp;归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。<br>&nbsp;&nbsp;&nbsp;&nbsp;归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下: </p>
<ul>
<li>申请空间，使其大小为两个已经排好序序列之和，该空间用来存放合并后的序列。</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置。</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</li>
<li>重复步骤3，直到某一指针到达序列尾。</li>
<li>将另一序列剩下的所有元素直接赋值到合并序列尾。</li>
</ul>
<p>归并排序的代码如下:<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class MergeSort &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> []args)&#123;</div><div class="line">        <span class="built_in">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</div><div class="line">        <span class="built_in">sort</span>(arr);</div><div class="line">        System.out.<span class="built_in">println</span>(Arrays.toString(arr));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">sort</span>(<span class="built_in">int</span> []arr)&#123;</div><div class="line">        <span class="built_in">int</span> []temp = <span class="keyword">new</span> <span class="built_in">int</span>[arr.length];<span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></div><div class="line">        <span class="built_in">sort</span>(arr,<span class="number">0</span>,arr.length<span class="number">-1</span>,temp);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">sort</span>(<span class="built_in">int</span>[] arr,<span class="built_in">int</span> left,<span class="built_in">int</span> right,<span class="built_in">int</span> []temp)&#123;</div><div class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</div><div class="line">            <span class="built_in">int</span> mid = (left+right)/<span class="number">2</span>;</div><div class="line">            <span class="built_in">sort</span>(arr,left,mid,temp);<span class="comment">//左边归并排序，使得左子序列有序</span></div><div class="line">            <span class="built_in">sort</span>(arr,mid+<span class="number">1</span>,right,temp);<span class="comment">//右边归并排序，使得右子序列有序</span></div><div class="line">            merge(arr,left,mid,right,temp);<span class="comment">//将两个有序子数组合并操作</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> merge(<span class="built_in">int</span>[] arr,<span class="built_in">int</span> left,<span class="built_in">int</span> mid,<span class="built_in">int</span> right,<span class="built_in">int</span>[] temp)&#123;</div><div class="line">        <span class="built_in">int</span> i = left;<span class="comment">//左序列指针</span></div><div class="line">        <span class="built_in">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></div><div class="line">        <span class="built_in">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></div><div class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</div><div class="line">                temp[t++] = arr[i++];</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                temp[t++] = arr[j++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></div><div class="line">            temp[t++] = arr[i++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//将右序列剩余元素填充进temp中</span></div><div class="line">            temp[t++] = arr[j++];</div><div class="line">        &#125;</div><div class="line">        t = <span class="number">0</span>;</div><div class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></div><div class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</div><div class="line">            arr[left++] = temp[t++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

</div></div><br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/8.gif?raw=true" alt="8"><br>&nbsp;&nbsp;&nbsp;&nbsp;使用归并排序为一列数字进行排序的宏观过程:<br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/9.gif?raw=true" alt="9"><br>&nbsp;&nbsp;&nbsp;&nbsp;归并排序除了可以对数组进行排序，还可以高效的求出数组之和(即单调和)以及数组中的逆序对。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;堆排序是指利用这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构(通常堆是通过一维数组来实现的)，并满足性质: 以最大堆(也叫大根堆、大顶堆)为例，其中父节点的值总是大于它的孩子节点。<br>&nbsp;&nbsp;&nbsp;&nbsp;我们可以很容易的定义堆排序的过程: </p>
<ul>
<li>由输入的无序数组构造一个最大堆，作为初始的无序区。</li>
<li>把堆顶元素(最大值)和堆尾元素互换。</li>
<li>把堆(无序区)的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整。</li>
<li>重复步骤2，直到堆的尺寸为1</li>
</ul>
<p>堆排序的代码如下:<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</div><div class="line">    <span class="keyword">int</span> i, j, temp;</div><div class="line">    <span class="keyword">int</span> length = A.length;</div><div class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line"></div><div class="line">    HeapSort(A, length);</div><div class="line"></div><div class="line">    <span class="built_in">for</span>(i= <span class="number">0</span>; i&lt;= length- <span class="number">1</span>; i++)&#123;</div><div class="line">        System.out.<span class="built_in">print</span>(A[i]+ (i== (length- <span class="number">1</span>)? <span class="string">""</span>: <span class="string">" "</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> Swap(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</div><div class="line">    <span class="keyword">int</span> temp = A[i];</div><div class="line">    A[i] = A[j];</div><div class="line">    A[j] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 从A[i]向下进行堆调整</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> Heapify(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> <span class="built_in">size</span>)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 左孩子索引</span></div><div class="line">    <span class="keyword">int</span> left_child = <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">    <span class="comment">// 右孩子索引</span></div><div class="line">    <span class="keyword">int</span> right_child = <span class="number">2</span> * i + <span class="number">2</span>;</div><div class="line">    <span class="comment">// 选出当前结点与其左右孩子三者之中的最大值</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = i;</div><div class="line">    <span class="built_in">if</span> (left_child &lt; <span class="built_in">size</span> &amp;&amp; A[left_child] &gt; A[<span class="built_in">max</span>]) &#123;</div><div class="line">        <span class="built_in">max</span> = left_child;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">if</span> (right_child &lt; <span class="built_in">size</span> &amp;&amp; A[right_child] &gt; A[<span class="built_in">max</span>]) &#123;</div><div class="line">        <span class="built_in">max</span> = right_child;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">if</span> (<span class="built_in">max</span> != i) &#123;</div><div class="line">        <span class="comment">// 把当前结点和它的最大(直接)子节点进行交换</span></div><div class="line">        Swap(A, i, <span class="built_in">max</span>);</div><div class="line">        <span class="comment">// 递归调用，继续从当前结点向下进行堆调整</span></div><div class="line">        Heapify(A, <span class="built_in">max</span>, <span class="built_in">size</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 建堆，时间复杂度O(n)</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> BuildHeap(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> heap_size = n;</div><div class="line">    <span class="comment">// 从每一个非叶结点开始向下进行堆调整</span></div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = heap_size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</div><div class="line">        Heapify(A, i, heap_size);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> heap_size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> HeapSort(<span class="keyword">int</span> A[], <span class="keyword">int</span> n) &#123;</div><div class="line">    <span class="comment">// 建立一个最大堆</span></div><div class="line">    <span class="keyword">int</span> heap_size = BuildHeap(A, n);</div><div class="line">    <span class="comment">// 堆（无序区）元素个数大于1，未完成排序</span></div><div class="line">    <span class="built_in">while</span> (heap_size &gt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="comment">// 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素</span></div><div class="line">        <span class="comment">// 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法</span></div><div class="line">        Swap(A, <span class="number">0</span>, --heap_size);</div><div class="line">        <span class="comment">// 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)</span></div><div class="line">        Heapify(A, <span class="number">0</span>, heap_size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

</div></div><br>堆排序算法的演示:<br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/10.gif?raw=true" alt="10"><br>&nbsp;&nbsp;&nbsp;&nbsp;动画中在排序过程之前简单的表现了创建堆的过程以及堆的逻辑结构。<br><code>堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。</code><br>&nbsp;&nbsp;&nbsp;&nbsp;比如序列: {9, 5, 7, 5}，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列{5, 5, 7, 9}，再进行堆调整得到{7, 5, 5, 9}，重复之前的操作最后得到{5, 5, 7, 9}从而改变了两个5的相对次序。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。<br>&nbsp;&nbsp;&nbsp;&nbsp;快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为: </p>
<ul>
<li>从序列中挑出一个元素，作为”基准”。</li>
<li>把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面(相同的数可以到任一边)，这个称为分区操作。</li>
<li>对每个分区递归进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。</li>
</ul>
<p>快速排序的代码如下:<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test_2</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        <span class="keyword">int</span> A[] = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</div><div class="line">        <span class="keyword">int</span> i, j, temp;</div><div class="line">        <span class="keyword">int</span> length = A.length;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line"></div><div class="line">        QuickSort(A, <span class="number">0</span>, length- <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(i= <span class="number">0</span>; i&lt;= length- <span class="number">1</span>; i++)&#123;</div><div class="line">            System.<span class="keyword">out</span>.print(A[i]+ (i== (length- <span class="number">1</span>)? <span class="string">""</span>: <span class="string">" "</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>) </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = A[i];</div><div class="line">        A[i] = A[j];</div><div class="line">        A[j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 划分函数</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span>(<span class="params"><span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right</span>)</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">// 这里每次都选择最后一个元素作为基准</span></div><div class="line">        <span class="keyword">int</span> pivot = A[right];</div><div class="line">        <span class="comment">// tail为小于基准的子数组最后一个元素的索引</span></div><div class="line">        <span class="keyword">int</span> tail = left - <span class="number">1</span>;</div><div class="line">        <span class="comment">// 遍历基准以外的其他元素</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 把小于等于基准的元素放到前一个子数组末尾</span></div><div class="line">            <span class="keyword">if</span> (A[i] &lt;= pivot)</div><div class="line">            &#123;</div><div class="line">                Swap(A, ++tail, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组</span></div><div class="line">        Swap(A, tail + <span class="number">1</span>, right);</div><div class="line">        <span class="comment">// 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法</span></div><div class="line">        <span class="comment">// 返回基准的索引</span></div><div class="line">        <span class="keyword">return</span> tail + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span>(<span class="params"><span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right</span>)</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 基准的索引</span></div><div class="line">        <span class="keyword">int</span> pivot_index = Partition(A, left, right);</div><div class="line">        QuickSort(A, left, pivot_index - <span class="number">1</span>);</div><div class="line">        QuickSort(A, pivot_index + <span class="number">1</span>, right);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

</div></div><br>&nbsp;&nbsp;&nbsp;&nbsp;使用快速排序法对一列数字进行排序的过程:<br><img src="https://github.com/sunstady/hexoFirst/blob/master/%E6%8E%92%E5%BA%8F/11.gif?raw=true" alt="11"><br><code>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。</code><br>&nbsp;&nbsp;&nbsp;&nbsp;比如序列: {1, 3, 4, 2, 8, 9, 8, 7, 5}，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。</p>
<blockquote>
<p>Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？</p>
</blockquote>
<p>答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它不是稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap与HashTable的区别</title>
    <link href="http://www.sanstylemc.cn/2018/09/09/HashMap%E4%B8%8EHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.sanstylemc.cn/2018/09/09/HashMap与HashTable的区别/</id>
    <published>2018-09-09T05:03:17.000Z</published>
    <updated>2018-09-09T05:03:52.306Z</updated>
    
    <content type="html"><![CDATA[<p>浅记一下HashMap与HashTable的区别。<br><a id="more"></a></p>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>HashTable的作者：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Arthur van Hoff</div><div class="line"><span class="keyword">Josh </span><span class="keyword">Bloch</span></div><div class="line"><span class="keyword">Neal </span>Gafter</div></pre></td></tr></table></figure></p>
<p>HashMap的作者：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Doug Lea</div><div class="line"><span class="keyword">Josh </span><span class="keyword">Bloch</span></div><div class="line"><span class="keyword">Arthur </span>van Hoff</div><div class="line">Neal Gafter</div></pre></td></tr></table></figure></p>
<p>可以看到HashMap的作者比HashTable的作者多了并发大神<code>Doug Lea</code>。他写了<code>util.concurrent</code>包。</p>
<h2 id="产生时间"><a href="#产生时间" class="headerlink" title="产生时间"></a>产生时间</h2><p>HashTable是Java一开始发布时就提供的键值映射的数据结构，而HashMap产生于JDK1.2。虽然HashTable比HashMap出现的早一些，但是现在HashTable基本上已经被弃用了。而HashMap已经成为应用最为广泛的一种数据类型了。造成这样的原因一方面是因为HashTable是线程安全的，效率比较低，另一方面可能是因为HashTable没有遵循驼峰命名法吧。。。</p>
<h2 id="继承的父类不同"><a href="#继承的父类不同" class="headerlink" title="继承的父类不同"></a>继承的父类不同</h2><p>HashMap是继承字AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了Map、Cloneable(可复制)、Serializable(可序列化)这三个接口。<br>而HashTable还继承了一个父类(Dictionary)，这是一个已经被废弃的类。</p>
<h2 id="对外提供的接口不同"><a href="#对外提供的接口不同" class="headerlink" title="对外提供的接口不同"></a>对外提供的接口不同</h2><p>HashTable比HashMap多提供了elements()和contains()两个方法。<br>elements()方法继承自HashTable的父类Dictionary。elements()方法用于返回此HashTable中的value的枚举。<br>contains()方法判断该HashTable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue()就只是调用了一下contains()方法。</p>
<h2 id="对Null-key-和-Null-value的支持不同"><a href="#对Null-key-和-Null-value的支持不同" class="headerlink" title="对Null key 和 Null value的支持不同"></a>对Null key 和 Null value的支持不同</h2><p>HashTable既不支持Null key 也不支持 Null value。HashTable的put()方法的注释中有说明。<br>当key为Null时，调用put()方法，key值调用hashCode()时候会抛出空指针异常。因为拿一个Null值去调用方法了。<br>当value为null值时，HashTable对其做了限制，也会抛出空指针异常。<br>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用contaionsKey()方法来判断。</p>
<h2 id="线程安全性不同"><a href="#线程安全性不同" class="headerlink" title="线程安全性不同"></a>线程安全性不同</h2><p>HashTable是线程安全的，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用HashTable，不需要自己为它的方法实现同步。<br>HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。使用HashMap时就必须要自己增加同步处理，虽然HashMap不是线程安全的，但是它的效率会比Hashtable要好很多。这样设计是合理的。在我们的日常使用中，大部分时间是单线程操作的。HashMap把这部分操作解放出来了。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比HashTable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p>
<h2 id="遍历方式的内部实现上不同"><a href="#遍历方式的内部实现上不同" class="headerlink" title="遍历方式的内部实现上不同"></a>遍历方式的内部实现上不同</h2><p>HashTable、HashMap都使用了Iterator。而由于历史原因，HashTable还使用了Enumeration的方式。<br>HashMap的Iterator是fail-fast迭代器。当有其它线程改变了HashMap的结构(增加、删除、修改元素)，将会抛出ConcurrentModificationException。不过，通过Iterator的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。<br>JDK1.8之前的版本中，HashTable是没有fast-fail机制的。在JDK1.8及以后的版本中，HashTable也是使用fast-fail的。</p>
<h2 id="初始容量大小和每次扩容大小的不同"><a href="#初始容量大小和每次扩容大小的不同" class="headerlink" title="初始容量大小和每次扩容大小的不同"></a>初始容量大小和每次扩容大小的不同</h2><p>HashTable默认的初始大小为11，之后每次扩容，容量变为原来的2n+1。HashMap默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。<br>但是当HashTable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。而ConcurrentHashMap引入了分割，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。<br>创建时，如果给定了容量初始值，那么HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。也就是说HashTable会尽量使用素数、奇数。而HashMap则总是使用2的幂作为哈希表的大小。<br>之所以会有这样的不同，是因为HashTable和HashMap设计时的侧重点不同。HashTable的侧重点是哈希的结果更加均匀，使得哈希冲突减少。当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀。而HashMap则更加关注hash的计算效率问题。在取模计算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要大大高于做除法。HashMap为了加快hash的速度，将哈希表的大小固定为了2的幂。当然这引入了哈希分布不均匀的问题，所以HashMap为解决这问题，又对hash算法做了一些改动。这从而导致了HashTable和HashMap的计算hash值的方法不同。<br>为了得到元素的位置，首先需要根据元素的key计算出一个hash值，然后再用这个hash值来计算得到最终的位置。<br>HashTable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数法来获得最终的位置。<br>HashTable在计算元素的位置时需要进行一次除法运算，而除法运算是比较耗时的。<br>HashMap为了提高计算效率，将哈希表的大小固定为2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浅记一下HashMap与HashTable的区别。&lt;br&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="http://www.sanstylemc.cn/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>判断数是否存在</title>
    <link href="http://www.sanstylemc.cn/2018/09/04/%E5%88%A4%E6%96%AD%E6%95%B0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"/>
    <id>http://www.sanstylemc.cn/2018/09/04/判断数是否存在/</id>
    <published>2018-09-04T11:07:28.000Z</published>
    <updated>2018-09-04T11:08:03.743Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个数是否在40亿个整数中。<br><a id="more"></a><br>1、我有40亿个整数，再给一个新的整数，我需要判断新的整数是否在40亿个整数中，怎么做呢？假设机器只有2G内存，但是需要尽可能快地得出答案，需要怎么做?</p>
<blockquote>
<p>如果用一个set存储，新来的数判断是否在set中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设整数是32位的，set需要占的空间大约是16GB(一个整数4个字节，40亿个的话，应该是160亿个字节，大概是16GB)。需要的开销太大。如果分八次加载数据的话，占用的时间太长，不可取。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从磁盘加载数据是磁盘IO操作，是非常慢的，比内存中的操作要慢数百倍。每次都要加载这么大的数据，还要8次，找一个数的时间可以达到分钟甚至小时级。</p>
<p><code>可取做法一</code>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用分布式算法，把数据分散在8台机器上，当再来一个新的数据时，8台机器一起找，最后的结果汇总出来就可以。这样时间应该可以达到秒级。</p>
<p><code>可取做法二</code>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32位int的范围是42亿，40亿整数中肯定有一些是连续的，可以先对数据进行一个外部排序，然后用一个初始的数和一个长度构成一个数据结构，来表示一段连续的数，举个例子:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果数据是1、2、3、4、6、7……这种的，那么可以用(1, 4)和(6, 2)来表示。1后面连续4个数，6后面连续2个数。这样一来，所有连续的数都可以用两个数来表示，当有新数进来时候，再采用二分法进行判断。如此最差的情况就是2亿多的断点，也就是2亿多的结构体，每个结构体8个字节，大概16亿字节，1.6GB，这样内存中就可以放下！</p>
<p><code>正确做法</code>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判断一个数存不存在，其实只有两个状态，可以用一个位来代表。32位int的范围，总共就是2的32次方，大概42亿多点。所以可以申请2的32次方个位。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把整个整数范围都覆盖，1代表第一个位，2代表第二个位，2的32次方代表最后一个位。40亿个数中，如果它存在相应的位置，就是1，不存在就是0。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新来一个数就去找相应的位，比如来了一个1234，就找一下第1234位，如果是1就存在，是0就不存在。2的32次方个位，相当于2的29次方个字节，大概500MB。因为原来32位的整数，转化成了1位的布尔，所以数据空间就是原来的32分之一。这就是bitmap算法(位图法)！用位来表示状态，可以节省空间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个数是否在40亿个整数中。&lt;br&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="http://www.sanstylemc.cn/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>a和b相加</title>
    <link href="http://www.sanstylemc.cn/2018/09/04/a%E5%92%8Cb%E7%9B%B8%E5%8A%A0/"/>
    <id>http://www.sanstylemc.cn/2018/09/04/a和b相加/</id>
    <published>2018-09-04T06:40:59.000Z</published>
    <updated>2018-09-04T06:41:35.916Z</updated>
    
    <content type="html"><![CDATA[<p><code>a= a+ b</code>和 <code>a+= b</code>。这两者有什么区别？<br><a id="more"></a></p>
<p>平常我们所说的没区别，应该是这样的:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a= 1;</div><div class="line">int b= 2;</div><div class="line">a= a+ b;</div><div class="line">a+= b;</div></pre></td></tr></table></figure></p>
<p>但是换别的写法，比如把b的类型变一下:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">float b</span>= 2F;</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/sunstady/hexoFirst/blob/master/a%E5%92%8Cb%E7%9B%B8%E5%8A%A0/1.png?raw=true" alt="1"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b提升了类型之后，会发现<code>a= a+ b</code>是没办法编译通过的，需要强制类型转换。但是<code>a+= b</code>却可以。反编译一下这个class文件:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a= <span class="number">1</span>;</div><div class="line">    <span class="keyword">float</span> b= <span class="number">2</span>F;</div><div class="line">    a+= b;</div><div class="line">&#125;</div><div class="line"><span class="comment">//反编译class的内容</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">byte</span> var1= <span class="number">1</span>;</div><div class="line">    <span class="keyword">float</span> var2= <span class="number">2.0</span>F;</div><div class="line">    <span class="keyword">int</span> var10000= (<span class="keyword">int</span>)((<span class="keyword">float</span>)var1+ var2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种a比b类型范围要小的情况下。<code>a= a+ b</code>需要强制类型转换，也就是我们常写的<code>a= (int)(a+ b)</code>，而我们的<code>a+= b</code>被我们的编译器在编译期做了一些小手脚。也就是编译器帮我们进行了强制类型转化。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，强制类型转换会带来什么问题呢？<br><img src="https://github.com/sunstady/hexoFirst/blob/master/a%E5%92%8Cb%E7%9B%B8%E5%8A%A0/2.jpg?raw=true" alt="2"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;强制类型转化，一般会带来精度丢失的问题。这里float的范围太大，用byte和short来演示，强制类型带来的问题:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void fun()&#123;</div><div class="line">    <span class="keyword">byte </span>a= <span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="keyword">short </span><span class="keyword">b= </span><span class="number">127</span><span class="comment">;</span></div><div class="line">    a= (<span class="keyword">byte)(a+ </span><span class="keyword">b);</span></div><div class="line"><span class="keyword"> </span>   System.out.println(a)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以知道输出结果是<code>-128</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本类型在堆中所占的字节如下表:<br><img src="https://github.com/sunstady/hexoFirst/blob/master/a%E5%92%8Cb%E7%9B%B8%E5%8A%A0/3.jpg?raw=true" alt="3"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们常说的基本类型是存放在栈中的，这种说法并不全面。存放在堆中还是在栈中，是取决于这个变量声明的位置。如果是局部变量，则会存放在栈帧中。但是如果是成员变量(全局变量)，那么就会存放在堆中。此外存放在栈中，基本类型所占的字节是固定的: 如果是32位计算机那么就是4字节; 64位便是8字节。<br>由上图可知<code>byte</code>占1字节，也就是8位，如果每一位都为1(11111111)，那么理论上就是它所能表示的最大内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但最大并不是255!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为正负的原因，计算机中使用补码的形式表示二进制，高1位表示符号位(0为正，1为负)。因此对于8位来说，最大只能是<code>01111111</code>，也就是127(0表示它为正)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚才那个计算，不考虑类型转换，那么<code>a+ b</code>等于128。并且对于所占2字节的short来说那就是<code>0000000010000000</code>。但是我们强制类型转化成了byte，这时做了一件事情，那就是高1字节的内容全部砍掉，也就是只剩下了<code>10000000</code>。<br>按照刚才所说的，高1位的内容表示正负。1为负，但结果并不是0!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于含有补码形式的<code>10000000</code>，我们要用补码的方式去计算。计算的套路如下: 高1位为1，那么这个数就是负数。想要知道是负几，我们需要将<code>10000000</code>按位取反，也就是<code>01111111</code>。还没完，此时还要再加1，也就是<code>10000000</code>。现在得到的这个数是几，那么就是负几，<code>10000000</code>是十进制的128，因此补码形式的<code>10000000</code>也就是<code>-128</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;a= a+ b&lt;/code&gt;和 &lt;code&gt;a+= b&lt;/code&gt;。这两者有什么区别？&lt;br&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="http://www.sanstylemc.cn/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>TCP三握四挥手</title>
    <link href="http://www.sanstylemc.cn/2018/09/03/TCP%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5%E6%89%8B/"/>
    <id>http://www.sanstylemc.cn/2018/09/03/TCP三握四挥手/</id>
    <published>2018-09-03T09:08:08.000Z</published>
    <updated>2018-09-03T09:09:13.240Z</updated>
    
    <content type="html"><![CDATA[<p>TCP传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通道协议。<br><a id="more"></a></p>
<ul>
<li>SYN(synchronous建立联机)</li>
<li>ACK(acknowledgement确认)</li>
<li>PSH(push传送)</li>
<li>FIN(finish结束)</li>
<li>RST(reset重置)</li>
<li>URG(urgent紧急)</li>
<li>Sequence number(顺序号码)</li>
<li>Acknowledge number(确认号码)</li>
<li>establish(建立，创建)</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。<br>1）第一次握手: Client将标志位SYN置为1，随机产生一个值为seq= J, 并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。<br>2）第二次握手：Server收到数据包后由标志位SYN= 1知道Client请求建立连接，Server将标志为SYN和ACK都置为1，ack(number)= J+ 1, 随机产生一个值seq= K, 并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。<br>3）第三次握手：Client收到确认后，检查ack是否为J+ 1，ACK是否为1， 如果正确则将标志位ACK置为1， ack= K+ 1，并将该数据包发送给Server，Server检查ack是否为K+ 1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。<br>1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+ 1(与SYN相同，一个FIN占用一个序号)，Server进入CLOSE_WAIT状态。<br>3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST＿ACK状态。<br>4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+ 1， Server进入CLOSED状态，完成四次挥手。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通道协议。&lt;br&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="http://www.sanstylemc.cn/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>IDEA静态资源乱码</title>
    <link href="http://www.sanstylemc.cn/2018/09/01/IDEA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B9%B1%E7%A0%81/"/>
    <id>http://www.sanstylemc.cn/2018/09/01/IDEA静态资源乱码/</id>
    <published>2018-09-01T01:32:44.000Z</published>
    <updated>2018-09-01T02:13:34.430Z</updated>
    
    <content type="html"><![CDATA[<p>昨天使用IDEA测试Web项目，请求转发给一个HTML后，会出现中文乱码问题，但是直接访问该HTML则不会出现。<br><a id="more"></a></p>
<p>1、配置项目启动服务前参数<br><img src="https://github.com/sunstady/hexo/blob/master/idea%E4%B9%B1%E7%A0%81/1.png?raw=true" alt="1"><br>在<code>VM options</code>中加入<code>-Dfile.encoding=UTF-8</code></p>
<p>设置完后再次启动项目会出现控制台乱码，请进入步骤2。</p>
<p>2、修改配置文件<br>在idea的安装目录下，进入<code>bin</code>目录，修改两个<code>*.vmoptions</code>配置文件，在最后加上<code>-Dfile.encoding=UTF-8</code><br><img src="https://github.com/sunstady/hexo/blob/master/idea%E4%B9%B1%E7%A0%81/2.png?raw=true" alt="2"><br><img src="https://github.com/sunstady/hexo/blob/master/idea%E4%B9%B1%E7%A0%81/3.png?raw=true" alt="3"></p>
<p>3、设置一下全局编码<br><code>File-&gt;Other Settings-&gt;Default Settings -&gt;Editor-&gt;File Encodings</code><br><img src="https://github.com/sunstady/hexo/blob/master/idea%E4%B9%B1%E7%A0%81/4.png?raw=true" alt="4"><br><img src="https://github.com/sunstady/hexo/blob/master/idea%E4%B9%B1%E7%A0%81/5.png?raw=true" alt="5"></p>
<p>4、设置一下项目编码<br><code>File-&gt;Settings-&gt;Editor-&gt;File Encodings</code><br><img src="https://github.com/sunstady/hexo/blob/master/idea%E4%B9%B1%E7%A0%81/7.png?raw=true" alt="6"></p>
<p>设置完后重启idea，即可生效。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天使用IDEA测试Web项目，请求转发给一个HTML后，会出现中文乱码问题，但是直接访问该HTML则不会出现。&lt;br&gt;
    
    </summary>
    
    
      <category term="Skill" scheme="http://www.sanstylemc.cn/tags/Skill/"/>
    
  </entry>
  
  <entry>
    <title>Git_Submodules</title>
    <link href="http://www.sanstylemc.cn/2018/08/18/Git-Submodules/"/>
    <id>http://www.sanstylemc.cn/2018/08/18/Git-Submodules/</id>
    <published>2018-08-18T09:22:51.000Z</published>
    <updated>2018-08-18T09:38:58.773Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本例采用两个项目以及两个公共类库演示对<code>submodule</code>的操作。因为在一些资料或者书上的例子都是一个项目对应1~N个lib，但是实际应用往往并不是这么简单。<br><a id="more"></a></p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/1.jpg?raw=true" alt="1"><br>创建需要的本地仓库：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/2.jpg?raw=true" alt="2"><br>初始化工作区：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/3.jpg?raw=true" alt="3"></p>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><h3 id="初始化project1"><a href="#初始化project1" class="headerlink" title="初始化project1:"></a>初始化<code>project1</code>:</h3><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/4.jpg?raw=true" alt="4"><br>我在此用的是相对路径，若有问题请用绝对路径。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/5.jpg?raw=true
![6](https://github.com/sunstady/hexo/blob/master/submodule/6.jpg?raw=true" alt="5"></p>
<h3 id="初始化project2"><a href="#初始化project2" class="headerlink" title="初始化project2:"></a>初始化<code>project2</code>:</h3><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/7.jpg?raw=true" alt="7"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/8.jpg?raw=true" alt="8"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/9.jpg?raw=true" alt="9"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/10.jpg?raw=true" alt="10"></p>
<h2 id="初始化公共类库"><a href="#初始化公共类库" class="headerlink" title="初始化公共类库"></a>初始化公共类库</h2><h3 id="初始化公共类库lib1："><a href="#初始化公共类库lib1：" class="headerlink" title="初始化公共类库lib1："></a>初始化公共类库lib1：</h3><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/11.jpg?raw=true" alt="11"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/12.jpg?raw=true" alt="12"></p>
<h3 id="初始化公共类库lib2"><a href="#初始化公共类库lib2" class="headerlink" title="初始化公共类库lib2:"></a>初始化公共类库lib2:</h3><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/13.jpg?raw=true" alt="13"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/14.jpg?raw=true" alt="14"></p>
<h2 id="为主项目添加Submodules"><a href="#为主项目添加Submodules" class="headerlink" title="为主项目添加Submodules"></a>为主项目添加Submodules</h2><h3 id="为project1添加lib1和lib2"><a href="#为project1添加lib1和lib2" class="headerlink" title="为project1添加lib1和lib2"></a>为project1添加lib1和lib2</h3><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/15.jpg?raw=true" alt="15"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/16.jpg?raw=true" alt="16"></p>
<h3 id="查看已下公共类库的内容"><a href="#查看已下公共类库的内容" class="headerlink" title="查看已下公共类库的内容"></a>查看已下公共类库的内容</h3><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/17.jpg?raw=true" alt="17"><br>好了，到目前为止我们已经使用<code>git submodule add</code>命令为<code>project1</code>成功添加了两个工共类库(lib1、lib2)，查看了当前的状态发现添加了一个新文件<code>.gitmodules</code>和两个文件夹<code>libs/lib1、libs/lib2</code>，那么新增的<code>.gitmodules</code>是做什么用的呢？我们查看以下文件内容便知晓了。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/18.jpg?raw=true" alt="18"><br>原来如此，<code>.gitmodules</code>记录了每个<code>submodule</code>的引用信息，知道在当前项目的位置以及仓库的所在。<br>好的，我们现在把更改提交到仓库。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/19.jpg?raw=true" alt="19"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如你是第一次引入工共类库的开发人员，那么项目组的其他成员怎么<code>Clone</code>带有<code>Submodule</code>的项目呢，下面我们再<code>clone</code>一个项目讲解如何操作。</p>
<h3 id="Clone带有Submodule的仓库"><a href="#Clone带有Submodule的仓库" class="headerlink" title="Clone带有Submodule的仓库"></a>Clone带有Submodule的仓库</h3><p>模拟开发人员B…<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/20.jpg?raw=true" alt="20"><br>看到<code>submodules</code>的状态是<code>hash</code>码和文件目录，但是注意前面有一个<code>减号</code>，含义是该子模块还没有检出。<br>OK，检出<code>project1-b</code>的<code>submodules</code>…<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/21.jpg?raw=true" alt="21"><br>读者可以查看: <code>.git/config</code>文件的内容，最下面有<code>submodule</code>的注册信息！<br>验证一下类库的文件是否存在：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/22.jpg?raw=true" alt="22"><br>上面的两个命令(git submodule init &amp; update)其实可以简化，后面会讲到!</p>
<h3 id="修改Submodule"><a href="#修改Submodule" class="headerlink" title="修改Submodule"></a>修改Submodule</h3><p>我们在开发人员B的项目上修改<code>Submodule</code>的内容。<br>先看一下当前<code>Submodule</code>的状态：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/23.jpg?raw=true" alt="23"><br>我们可以看到HEAD不指向分支。<br>Git对于<code>Submodule</code>有特殊的处理方式，在一个主项目中引入了<code>Submodule</code>其实Git做了3件事：</p>
<ul>
<li>记录引用的仓库</li>
<li>记录主项目中<code>Submodule</code>的目录位置</li>
<li>记录引用<code>Submodule</code>的<code>commit id</code></li>
</ul>
<p>在<code>project1</code>中<code>push</code>之后其实就是更新了引用的<code>commit id</code>,然后<code>project1-b</code>在<code>clone</code>的时候获取到了<code>submodule</code>的<code>commit id</code>，然后当执行<code>git submodule update</code>的时候<code>git</code>就根据<code>gitlink</code>获取<code>submodule</code>的<code>commit id</code>，最后获取<code>submodule</code>的文件，所以<code>clone</code>之后不在任何分支上；但是<code>master</code>分支的<code>commit id</code>和<code>HEAD</code>保持一致。<br>现在我们要修改<code>lib1</code>的文件需要先切换到<code>master</code>分支：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/24.jpg?raw=true" alt="24"><br>在主项目中修改<code>Submodule</code>提交到仓库稍微繁琐一点，在<code>git push</code>之前我们先看看<code>project1-b</code>的状态:<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/25.jpg?raw=true" alt="25"><br><code>libs/lib1(new commits)</code>状态表示<code>libs/lib1</code>有新的提交，这个比较特殊，看看<code>project1-b</code>的状态:<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/26.jpg?raw=true" alt="26"><br>从状态中可以看出<code>libs/lib1</code>的<code>commit id</code>由原来的<code>3ee623ea26cd10ec58c1f1fa4f5869e488e0cfc1</code>更改为<code>d176f81129a28e5cb25c2b285818ed0202be7e58</code><br>注意：如果现在执行了<code>git submodule update</code>操作，那么<code>libs/lib1</code>的<code>commit id</code>又会还原到<code>3ee623ea26cd10ec58c1f1fa4f5869e488e0cfc1</code>，这样的话刚刚的修改是不是就丢死了呢？不会，因为修改已经提交到了<code>master</code>分支，只要再<code>git checkout master</code>就可以了。<br>现在可以把<code>libs/lib1</code>的修改提交到仓库了。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/27.jpg?raw=true" alt="27"><br>现在仅仅只完成了一步，下一步要提交<code>project1-b</code>引用<code>submodule</code>的<code>commit id</code>：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/28.jpg?raw=true" alt="28"><br>OK，大功告成，我们完成了<code>Submodule</code>的修改并把<code>libs/lib1</code>的最新<code>commit id</code>提交到了仓库。<br>接下来要看看<code>project1</code>怎么获取<code>submodule</code>了。</p>
<h3 id="更新主项目的Submodules"><a href="#更新主项目的Submodules" class="headerlink" title="更新主项目的Submodules"></a>更新主项目的<code>Submodules</code></h3><p>好的，让我们进入<code>project1</code>目录同步仓库：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/29.jpg?raw=true" alt="29"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/30.jpg?raw=true" alt="30"><br>我们运行了<code>git pull</code>命令和<code>git status</code>获取了最新的仓库源码，然后看到了状态是<code>modified</code>，这是为什么呢？<br>我们用<code>git diff</code>比较一下不同:<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/31.jpg?raw=true" alt="31"><br>从<code>diff</code>的结果分析出来是因为<code>submodule</code>的<code>commit id</code>更改了，我们前面刚刚讲了要在主项目更新<code>submodule</code>的内容，首先要提交<code>submodule</code>的内容，然后再更新主项目中引用的<code>submodule commit id</code>；现在我们看到的不同就是因为刚刚更改了<code>project1-b</code>的<code>submodule commit id</code>；好的，我们来学习下怎么更新<code>project1</code>的公共类库。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/32.jpg?raw=true" alt="32"><br><code>git submodule update</code>是更新子模块仓库。<br>如果没有更新，是因为子模块是在<code>project1</code>中引入的，<code>git submodule add repos/lib1.git libs/lib1</code>命令的结果，操作之后<code>git</code>只是把<code>lib1</code>的内容<code>clone</code>到了<code>project1</code>中，但是没有在仓库注册。需要输入<code>git submodule init</code>, 再进行<code>git submodule update</code> 在仓库注册后的结果如下：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/33.jpg?raw=true" alt="33"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/34.jpg?raw=true" alt="34"><br>上面的结果足以证明刚刚的推断，所以记得当需要更新子模块的内容时请先确保已经运行过<code>git submodule init</code>。</p>
<h3 id="为project2添加lib1和lib2"><a href="#为project2添加lib1和lib2" class="headerlink" title="为project2添加lib1和lib2"></a>为project2添加lib1和lib2</h3><p>这个操作对于读到这里的你来说应该是很熟的了：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/35.jpg?raw=true" alt="35"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/36.jpg?raw=true" alt="36"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/37.jpg?raw=true" alt="37"><br>我们一次执行了添加<code>submodule</code>并<code>commit</code>和<code>push</code>到仓库，此阶段任务完成。</p>
<h3 id="修改lib1和lib2并同步到project1和project2"><a href="#修改lib1和lib2并同步到project1和project2" class="headerlink" title="修改lib1和lib2并同步到project1和project2"></a>修改lib1和lib2并同步到project1和project2</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如开发人员C同时负责<code>project1</code>和<code>project2</code>，有可能在修改<code>project1</code>的某个功能的时候发现<code>lib1</code>或者<code>lib2</code>的某个组件有bug需要修复，这个需求多模块和大型系统中经常遇到，我们应该怎么解决呢？<br>假如我的需求如下：</p>
<ul>
<li>在<code>lib1</code>中添加一个文件：README，用来描述<code>lib1</code>的功能。</li>
<li>在<code>lib2</code>在的<code>lib2-features</code>文件中添加一些文字：学习Git submodule的修改并同步功能</li>
</ul>
<h4 id="在lib1中添加一个文件：README"><a href="#在lib1中添加一个文件：README" class="headerlink" title="在lib1中添加一个文件：README"></a>在lib1中添加一个文件：README</h4><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/38.jpg?raw=true" alt="38"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/39.jpg?raw=true" alt="39"><br>前面提到过现在仅仅只完成了一部分，我们需要在<code>project2</code>中再更新<code>lib1</code>的<code>commit id</code>：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/40.jpg?raw=true" alt="40"><br>我们暂时不<code>push</code>到仓库，等待和<code>lib2</code>的修改一起<code>push</code>。</p>
<h4 id="在lib2中的lib2-features文件中添加文字"><a href="#在lib2中的lib2-features文件中添加文字" class="headerlink" title="在lib2中的lib2-features文件中添加文字"></a>在lib2中的lib2-features文件中添加文字</h4><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/41.jpg?raw=true" alt="41"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/42.jpg?raw=true" alt="42"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/43.jpg?raw=true" alt="43"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/44.jpg?raw=true" alt="44"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/45.jpg?raw=true" alt="45"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/46.jpg?raw=true" alt="46"></p>
<h3 id="同步project2的lib1和lib2的修改到project1"><a href="#同步project2的lib1和lib2的修改到project1" class="headerlink" title="同步project2的lib1和lib2的修改到project1"></a>同步project2的lib1和lib2的修改到project1</h3><p>既然project1和project2属于同一个风格，或者调用同一个功能，要让这两个(可能几十个)项目保持一致。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/47.jpg?raw=true" alt="47"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看看上面的结果对吗？为什么<code>lib1</code>和<code>lib2</code>更新了但是没有显示<code>new commits</code>呢？为什么我明明提交了但是从<code>project1</code>更新不到任何改动呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帮大家分析一下问题，不过在分析之前先看看当前(<code>project1</code>和<code>project2</code>)的<code>submodule</code>状态：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/48.jpg?raw=true" alt="48"><br>两个项目有两个区别：</p>
<ul>
<li><code>commit id</code> 各不相同</li>
<li><code>libs/lib1</code>所处的分支不同</li>
</ul>
<h4 id="更新project1的lib1和lib2改动"><a href="#更新project1的lib1和lib2改动" class="headerlink" title="更新project1的lib1和lib2改动"></a>更新project1的lib1和lib2改动</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还记得刚刚在<code>project2</code>中修改的时候把<code>lib1</code>和<code>lib2</code>都切换到了<code>master</code>分支，目前<code>project1</code>中的<code>lib1</code>不在任何分支，我们先切换到<code>master</code>分支。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/49.jpg?raw=true" alt="49"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/50.jpg?raw=true" alt="50"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;果不其然，我们看到了刚刚在<code>project2</code>中修改的内容，同步到了<code>project1</code>中，当然现在更新了<code>project1</code>的<code>lib1</code>，<code>commit id</code>也会随之变动。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/51.jpg?raw=true" alt="51"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/52.jpg?raw=true" alt="52"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在最新的<code>commit id</code>和<code>project2</code>目前的状态一致，说明真的同步了；好的，现在可以使用相同的方法更新<code>lib2</code>了。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/53.jpg?raw=true" alt="53"></p>
<h4 id="更新project1的submodule引用"><a href="#更新project1的submodule引用" class="headerlink" title="更新project1的submodule引用"></a>更新project1的submodule引用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面我们更新了<code>project1</code>的<code>lib1</code>和<code>lib2</code>的最新版本，现在要把最新的<code>commit id</code>保存到<code>project1</code>中以保持最新的引用。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/54.jpg?raw=true" alt="54"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/55.jpg?raw=true" alt="55"></p>
<h3 id="更新project1-b项目的子模块-使用脚本"><a href="#更新project1-b项目的子模块-使用脚本" class="headerlink" title="更新project1-b项目的子模块(使用脚本)"></a>更新project1-b项目的子模块(使用脚本)</h3><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/56.jpg?raw=true" alt="56"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/57.jpg?raw=true" alt="57"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git提示<code>lib1</code>和<code>lib2</code>有更新内容，这个判断的依据来源于<code>submodule commit id</code>的引用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在怎么更新呢？难道还是像<code>project1</code>中那样进入子模块的目录然后<code>git checkout master</code>，接着<code>git pull</code>？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且现在仅仅才两个子模块、两个项目，如果在真是的项目中使用的话可能几个到几十个不等，再加上N个<code>submodule</code>，自己算一下要怎么更新多少个<code>submodule</code>？<br>工欲善其事，必先利其器。写一个脚本代替手动任务。</p>
<h4 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h4><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/58.jpg?raw=true" alt="58"><br>我们通过分析<code>.gitmodules</code>文件得出子模块的路径，然后就可以根据这些路径进行更新。</p>
<h4 id="上路"><a href="#上路" class="headerlink" title="上路"></a>上路</h4><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/59.jpg?raw=true" alt="59"><br>把下面的脚本复制到<code>bin/update-submodules.sh</code>中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">grep path .gitmodules | awk <span class="string">'&#123; print $3 &#125;'</span> &gt; /tmp/study-git-submodule-dirs</div><div class="line"> </div><div class="line"><span class="comment"># read</span></div><div class="line"><span class="keyword">while</span> <span class="built_in">read</span> LINE</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$LINE</span></div><div class="line">    (<span class="built_in">cd</span> ./<span class="variable">$LINE</span> &amp;&amp; git checkout master &amp;&amp; git pull)</div><div class="line"><span class="keyword">done</span> &lt; /tmp/study-git-submodule-dirs</div></pre></td></tr></table></figure></p>
<p>解释下上面的脚本执行过程：</p>
<ul>
<li>首先把子模块的路径写入到文件<code>tmp/sutdy-git-submodule-dirs</code>中；</li>
<li>然后读取文件中的子模块路径，一次切换到<code>master</code>分支(修改都是在<code>master</code>分支上进行的)，最后更新最近改动。</li>
</ul>
<h4 id="2018-08-18更新"><a href="#2018-08-18更新" class="headerlink" title="2018-08-18更新"></a><font color="red">2018-08-18更新</font></h4><p>一个命令就可以代替上面的<code>bin/update-submodules.sh</code>的功能。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;pre <span class="keyword">class</span>=<span class="string">"brush:shell"</span>&gt;git submodule <span class="keyword">foreach</span> git pull</div><div class="line">&lt;/pre&gt;</div></pre></td></tr></table></figure></p>
<p>此命令与脚本一样，循环进入(enter)每个子模块的目录，然后执行<code>foreach</code>后面的命令。</p>
<blockquote>
<p>该后面的命令可以任意的，例如<code>git submodule foreach ls -l</code>可以列出每个子模块的文件列表。</p>
</blockquote>
<h4 id="体验工具带来的便利"><a href="#体验工具带来的便利" class="headerlink" title="体验工具带来的便利"></a>体验工具带来的便利</h4><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/60.jpg?raw=true" alt="60"><br>添加执行权限<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/61.jpg?raw=true" alt="61"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/62.jpg?raw=true" alt="62"><br>更新之后的两个变化：</p>
<ul>
<li><code>git submodule</code>的结果和<code>project2</code>的<code>submodule commit id</code>保持一致；</li>
<li><code>project1-b</code>不再显示<code>new commits</code>了。</li>
</ul>
<p>现在可以把工具添加到仓库了。<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/63.jpg?raw=true" alt="63"></p>
<h3 id="新员工加入团队，一次性clone项目和Submodule"><a href="#新员工加入团队，一次性clone项目和Submodule" class="headerlink" title="新员工加入团队，一次性clone项目和Submodule"></a>新员工加入团队，一次性clone项目和Submodule</h3><p>一般人使用的时候都是使用如下命令：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">clone</span> <span class="title">../repos</span>/foo.git</div><div class="line">git submodule init</div><div class="line">git submodule update</div></pre></td></tr></table></figure></p>
<p>新员工不耐烦了，嘴上不说但是心里想，怎么那么麻烦？<br>上面的命令简直弱爆了，直接一行命令搞定：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">clone</span> <span class="title">--recursive</span> ../repos/foo.git</div></pre></td></tr></table></figure></p>
<p><code>recursive</code>参数的含义：可以在clone项目时同时<code>clone</code>关联的<code>submodules</code>。</p>
<h4 id="使用一键方式克隆project2"><a href="#使用一键方式克隆project2" class="headerlink" title="使用一键方式克隆project2"></a>使用一键方式克隆project2</h4><p><img src="https://github.com/sunstady/hexo/blob/master/submodule/64.jpg?raw=true" alt="64"><br>舒服……</p>
<h4 id="移除Submodules"><a href="#移除Submodules" class="headerlink" title="移除Submodules"></a>移除Submodules</h4><p>我们从<code>project1.git</code>克隆一个项目用来练习移除<code>submodule</code>：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/65.jpg?raw=true" alt="65"></p>
<h3 id="Step-by"><a href="#Step-by" class="headerlink" title="Step by"></a>Step by</h3><p>1、删除<code>git cache</code>和物理文件夹<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/66.jpg?raw=true" alt="66"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/67.jpg?raw=true" alt="67"><br>2、删除<code>.gitmodules</code>的内容(或者整个文件)<br>因为本例只有两个子模块，直接删除文件：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/68.jpg?raw=true" alt="68"><br>如果仅仅删除某一个<code>submodule</code>，那么打开<code>.gitmodules</code>文件编辑，删除对应<code>submodule</code>配置即可。<br>3、删除<code>.git/config</code>的<code>submodule</code>配置<br>源文件：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/69.jpg?raw=true" alt="69"><br>删除后：<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/70.jpg?raw=true" alt="70"><br>4、提交更改<br><img src="https://github.com/sunstady/hexo/blob/master/submodule/71.jpg?raw=true" alt="71"><br><img src="https://github.com/sunstady/hexo/blob/master/submodule/72.jpg?raw=true" alt="72"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本例采用两个项目以及两个公共类库演示对&lt;code&gt;submodule&lt;/code&gt;的操作。因为在一些资料或者书上的例子都是一个项目对应1~N个lib，但是实际应用往往并不是这么简单。&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.sanstylemc.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>性能调优方法和原则</title>
    <link href="http://www.sanstylemc.cn/2018/08/17/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E5%88%99/"/>
    <id>http://www.sanstylemc.cn/2018/08/17/性能调优方法和原则/</id>
    <published>2018-08-17T03:25:51.000Z</published>
    <updated>2018-08-17T03:27:14.950Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;性能优化基本是BAT等一线互联网公司程序员必备的技能，以下的性能优化有：Web网站调优、数据库、JVM调优、架构调优等。<br><a id="more"></a></p>
<h2 id="Web网站调优"><a href="#Web网站调优" class="headerlink" title="Web网站调优"></a>Web网站调优</h2><p>1、<code>尽可能减少HTTP请求</code>: 图片合并(css sprites)，Js脚本文件合并、css文件合并。<br>2、<code>减少DNS查询</code><br>3、将<code>css</code>放在页面最上面，将<code>js</code>放在页面最下面。<br>4、<code>压缩js和css</code>: 减少文件体积，去除不必要的空白符、格式符、注释(即对代码进行格式化)<br>5、<code>把js和css提取出来放在外部文件中</code>: 这一条要灵活运用，把<code>js</code>和<code>css</code>提取出来放在外部文件的优点是：减少HTML体积，提高了<code>js</code>和<code>css</code>的复用性，提高日后的可维护性。<br>缺点：增加了HTTP请求，不过这一点可以通过缓存来解决。<br>什么情况下将<code>js</code>和<code>css</code>写在页面内呢，可以分为几种情况：<code>js</code>和<code>css</code>代码比较少；这个页面不怎么会访问。<br>6、<code>避免重定向</code>: 重定向就是用户请求的页面被转移到了别的地方，浏览器向服务请求一个页面，服务器告诉浏览器请求的页面已经被转移到另一个页面，并告知另一个页面地址，浏览器就再发送请求到重定向的地址。这样会增加服务器和浏览器之间的往返次数，影响网站性能。<br>重定向的状态码有：<code>301</code>永久重定向；<code>302</code>临时重定向；<code>304</code>not modified并不是真的重定向，它是用来告诉浏览器<code>get</code>请求的文件在缓存中，避免重新下载。<br>7、<code>移除重复脚本</code>。<br>8、<code>使用Ajax缓存</code>：Ajax的<code>get</code>和<code>post</code>方法：只要是浏览器的<code>get</code>请求，浏览器都会使用缓存，对于同一地址的请求，服务器会发送<code>304</code>状态码到浏览器，浏览器就会使用缓存中的数据。<br><code>post</code>的请求每次都会被执行，浏览器不会缓存。<br>9、<code>使用Gzip压缩</code><br>10、<code>使用CDN(内容分发网络)</code></p>
<h2 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h2><p>数据库的调优，总的来说分为以下三部分：<br>1、<code>SQL调优</code>：主要集中在索引、减少跨表与大数据<code>join</code>查询等。<br>2、<code>数据库端架构设计优化</code>：通过读写分离调整对数据库的写操作，通过垂直拆分以及水平拆分(分库分表)来解决数据库端连接池瓶颈等问题。<br>3、<code>连接池调优</code>：可以通过熟悉连接池的原理，以及具体的连接池监控数据，来不断调试出最终的连接池参数。</p>
<h2 id="通过缓存减少后端压力"><a href="#通过缓存减少后端压力" class="headerlink" title="通过缓存减少后端压力"></a>通过缓存减少后端压力</h2><p>目前分布式缓存已经比较成熟，常见的有<code>redis</code>、<code>memcached</code>以及开源的淘宝分布式<code>tair</code>等。</p>
<h3 id="选型考虑"><a href="#选型考虑" class="headerlink" title="选型考虑"></a>选型考虑</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果数据量小，并且不会频繁地增长又清空(这会导致频繁地垃圾回收)，那么可以选择本地缓存。具体的话，如果需要一些策略的支持(比如缓存满的逐出策略)，可以考虑<code>Ehcache</code>；如果不需要，可以考虑<code>HashMap</code>；如果需要考虑多线程并发的场景，可以考虑<code>ConcurentHashMap</code>。</p>
<h3 id="缓存是否会满，缓存满了怎么办？"><a href="#缓存是否会满，缓存满了怎么办？" class="headerlink" title="缓存是否会满，缓存满了怎么办？"></a>缓存是否会满，缓存满了怎么办？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个缓存服务，理论上来说，随着缓存数据的日益增多，在容量有限的情况下，缓存肯定有一天会满的。如何应对？</p>
<ul>
<li>给缓存服务，选择合适的缓存逐出算法，比如最常见的LRU。</li>
<li>针对当前设置的容量，设置适当的警戒值，比如10G的缓存，当缓存数据达到8G的时候，就开始发出报警，提前排查问题或者扩容。</li>
<li>给一些没有必要长期保存的key，尽量设置过期时间。</li>
</ul>
<h2 id="数据请求改造为异步"><a href="#数据请求改造为异步" class="headerlink" title="数据请求改造为异步"></a>数据请求改造为异步</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户并不关心或者用户不需要立即拿到这些事情的处理结果，这种情况就比较适合用异步的方式处理，这里的原则就是能异步就异步。</p>
<h3 id="常见做法"><a href="#常见做法" class="headerlink" title="常见做法"></a>常见做法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一是额外开辟线程，这里可以采用额外开辟一个线程或者使用线程池的做法，在IO线程(处理请求响应)之外的线程来处理相应的任务，在IO线程中让<code>response</code>先返回。如果异步线程处理的任务设计的数据量非常巨大，那么可以引入阻塞队列<code>BlockingQueue</code>作进一步的优化。具体做法是让一批异步线程不断地往阻塞队列里仍数据，然后额外起一个处理线程。循环批量从队列里拿预设大小的一批数据，来进行批处理(比如发一个批量的远程服务请求)，这样进一步提高了性能。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二是使用消息队列(MQ)中间件服务，MQ天生就是异步的。</p>
<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="什么时候调"><a href="#什么时候调" class="headerlink" title="什么时候调"></a>什么时候调</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过监控系统对一些机器关键指标（gc time、gc count、各个分代的内存大小变化、机器的Load值与CPU使用率、JVM的线程数等）的监控报警，也可以看gc log和jstat等命令的输出，再结合线上JVM进程服务的一些关键接口的性能数据和请求体验，基本上就能定位出当前的JVM是否有问题，以及是否需要调优。</p>
<h3 id="调优工具："><a href="#调优工具：" class="headerlink" title="调优工具："></a>调优工具：</h3><p><code>Jconsole</code>、<code>jProfile</code>、<code>VisualVM</code><br><code>Jconsole</code>: jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。<br><code>jProfile</code>: 商业软件，需要付费。功能强大。<br><code>VisualVM</code>: jdk自带，功能强大，与<code>Jconsole</code>类似。推荐。</p>
<h3 id="如何调优"><a href="#如何调优" class="headerlink" title="如何调优"></a>如何调优</h3><p>观察内存释放情况、集合类检查、对象树。<br>上面这些调优工具都提供了强大的功能，但是总的来说一般分为以下几类功能。</p>
<h4 id="堆信息查看"><a href="#堆信息查看" class="headerlink" title="堆信息查看"></a>堆信息查看</h4><p>可查看堆空间大小分配(年轻代、年老代、持久代分配)<br><img src="https://github.com/sunstady/hexo/blob/master/%E8%B0%83%E4%BC%98/1.jpg?raw=true" alt="1"><br>提供即时的垃圾回收功能。<br>垃圾监控(长时间监控回收情况)<br><img src="https://github.com/sunstady/hexo/blob/master/%E8%B0%83%E4%BC%98/2.jpg?raw=true" alt="2"><br>查看堆内类、对象信息查看：数量、类型等。<br>对象引用情况查看<br>有了对信息查看方面的功能，我们一般可以顺利解决以下问题：</p>
<ul>
<li>年老代年轻代大小划分是否合理。</li>
<li>内存泄漏</li>
<li>垃圾回收算法设置是否合理</li>
</ul>
<h4 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h4><p><img src="https://github.com/sunstady/hexo/blob/master/%E8%B0%83%E4%BC%98/3.jpg?raw=true" alt="3"><br>线程信息监控：系统线程数量。<br>线程状态监控：各个线程都处在什么样的状态下。<br>Dump线程详细信息：查看线程内部运行情况。<br>死锁检查<br>热点分析<br>CPU热点：检查系统哪些方法占用的大量CPU时间。<br>内存热点：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）<br>这两个东西对于系统优化很有帮助。我们可以根据找到的热点，有针对性的进行系统的瓶颈查找和进行系统优化，而不是漫无目的的进行所有代码的优化。</p>
<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快照是系统运行到某一时刻的一个定格。在我们进行调优的时候，不可能用眼睛去跟踪所有系统变化，依赖快照功能，我们就可以进行系统两个不同运行时刻，对象（或类、线程等）的不同，以便快速找到问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例说，我要检查系统进行垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进行垃圾回收前后，分别进行一次堆情况的快照，然后对比两次快照的对象情况。</p>
<h4 id="内存泄漏检查"><a href="#内存泄漏检查" class="headerlink" title="内存泄漏检查"></a>内存泄漏检查</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存泄漏是比较常见的问题，而且解决方法也比较通用，这里可以重点说一下，而线程、热点方面的问题则是具体问题具体分析了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存泄漏对系统危害比较大，因为他可以直接导致系统的崩溃。</p>
<h2 id="性能调优总结"><a href="#性能调优总结" class="headerlink" title="性能调优总结"></a>性能调优总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大型网站的性能瓶颈大部分瓶颈都在数据库端，所以性能调优总是沿着如何减少对后端的压力来操作，数据库端的瓶颈经常会造成应用端的雪崩(比如：sql查询过长，长事务)等，所以需要及时解决后端性能。<br>1、通过读写分离、垂直拆分、水平拆分降低对数据库后端的压力。<br>2、通过优化SQL语句，索引等，缩短对SQL的查询时间。<br>3、通过缓存以及CDN来解决对图片、文件等的操作，避免对数据库产生压力。<br>4、通过对Web端的优化，js、css等压缩，提高大文件读取时间，尽量依赖CDN。<br>5、还有一个重点就是监控：对JVM、线程、SQL查询时间等健康指标进行及时监控，通过监控及时发现瓶颈，及时优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;性能优化基本是BAT等一线互联网公司程序员必备的技能，以下的性能优化有：Web网站调优、数据库、JVM调优、架构调优等。&lt;br&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="http://www.sanstylemc.cn/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Servlet/Http协议</title>
    <link href="http://www.sanstylemc.cn/2018/08/15/Servlet-Http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://www.sanstylemc.cn/2018/08/15/Servlet-Http协议/</id>
    <published>2018-08-15T07:52:29.000Z</published>
    <updated>2018-08-15T11:24:33.280Z</updated>
    
    <content type="html"><![CDATA[<p>RT<br><a id="more"></a></p>
<h2 id="Servlet的生命周期，执行过程"><a href="#Servlet的生命周期，执行过程" class="headerlink" title="Servlet的生命周期，执行过程"></a>Servlet的生命周期，执行过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Servlet生命周期分为实例化、初始化、响应请求调用service()方法、消亡阶段调用destroy()方法。<br>执行过程如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;1）当浏览器发送一个请求地址，tomcat会接收这个请求<br>&nbsp;&nbsp;&nbsp;&nbsp;2）tomcat会读取项目中的web.xml中的配置<br>&nbsp;&nbsp;&nbsp;&nbsp;3）当请求地址符合servlet-mapping标签映射的地址，会进入这个servlet<br>&nbsp;&nbsp;&nbsp;&nbsp;4）servlet首先会实例化(构造)，然后初始化执行init()方法，init()方法至始至终执行一次，servlet对象是单实例。<br>&nbsp;&nbsp;&nbsp;&nbsp;5）根据请求的方式是get或post，在service()方法中调用doget()或dopost()方法，完成此次请求。<br>&nbsp;&nbsp;&nbsp;&nbsp;6）当服务器停止，会调用destroy()方法，销毁实例。</p>
<h2 id="实例化servlet有几种方式"><a href="#实例化servlet有几种方式" class="headerlink" title="实例化servlet有几种方式"></a>实例化servlet有几种方式</h2><p>Servlet实例化有两种方式，如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;1）第一次请求时，实力化servlet对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;2）在web.xml文件中的&lt; Servlet &gt;&lt; /Servlet &gt;之间添加&lt; loadon-startup &gt;1&lt; /loadon-startup &gt;,tomcat启动时就会实例化servlet对象。</p>
<h2 id="对-HTTP协议的理解"><a href="#对-HTTP协议的理解" class="headerlink" title="对 HTTP协议的理解"></a>对 HTTP协议的理解</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;http是超文本传输协议(Hyper Text Transfer Protocol),是用于从WWW服务器传输超文本到本地浏览器的传送协议。<br>&nbsp;&nbsp;&nbsp;&nbsp;HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。大多承载于TCP协议之上。<br>工作流程：<br>一次HTTP操作称为一个事务，其工作过程可分为四步：<br>&nbsp;&nbsp;&nbsp;&nbsp;１）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。<br>&nbsp;&nbsp;&nbsp;&nbsp;２）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;３）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;４）客户端接收服务器返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。<br>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，由显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。<br>一个HTTP请求报文格式：<br>&nbsp;&nbsp;&nbsp;&nbsp;请求报文：HTTP请求报文主要由请求行、请求头部、请求正文三部分组成。<br>&nbsp;&nbsp;&nbsp;&nbsp;响应报文：HTTP响应报文主要由状态行、响应头部、响应正文三部分组成。<br>&nbsp;&nbsp;&nbsp;&nbsp;HTTP协议的请求方法由GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RT&lt;br&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="http://www.sanstylemc.cn/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Java正则忽略大小写</title>
    <link href="http://www.sanstylemc.cn/2018/08/07/Java%E6%AD%A3%E5%88%99%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99/"/>
    <id>http://www.sanstylemc.cn/2018/08/07/Java正则忽略大小写/</id>
    <published>2018-08-07T02:07:21.000Z</published>
    <updated>2018-08-07T02:07:51.527Z</updated>
    
    <content type="html"><![CDATA[<p>Java正则表达式：<br><code>(?i)abc</code>表示abc都忽略大小写。<br><code>a(?i)bc</code>表示bc忽略大小写。<br><code>a((?i)b)c</code>表示只有b忽略大小写。<br>也可以用<code>Pattern.compile(rexp, Pattern.CASE_INSENSITIVE)</code>表示整体都忽略大小写。<br><a id="more"></a><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span> arg[])&#123;</div><div class="line">    <span class="keyword">String</span> ss = <span class="string">"&amp;nbsP;"</span>;</div><div class="line">    System.out.<span class="built_in">println</span>(ss.replaceAll(<span class="string">"(?i)p"</span>, <span class="string">""</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果为：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&amp;nbs;</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java正则表达式：&lt;br&gt;&lt;code&gt;(?i)abc&lt;/code&gt;表示abc都忽略大小写。&lt;br&gt;&lt;code&gt;a(?i)bc&lt;/code&gt;表示bc忽略大小写。&lt;br&gt;&lt;code&gt;a((?i)b)c&lt;/code&gt;表示只有b忽略大小写。&lt;br&gt;也可以用&lt;code&gt;Pattern.compile(rexp, Pattern.CASE_INSENSITIVE)&lt;/code&gt;表示整体都忽略大小写。&lt;br&gt;
    
    </summary>
    
    
      <category term="正则" scheme="http://www.sanstylemc.cn/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Error和Exception的区别</title>
    <link href="http://www.sanstylemc.cn/2018/08/06/Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.sanstylemc.cn/2018/08/06/Error和Exception的区别/</id>
    <published>2018-08-06T13:37:50.000Z</published>
    <updated>2018-08-06T13:39:52.408Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Exception(异常)</code>和<code>Error(错误)</code>, 二者都是Java异常处理的重要子类，各自都包含大量子类。<br><a id="more"></a></p>
<h2 id="Error-错误"><a href="#Error-错误" class="headerlink" title="Error(错误)"></a>Error(错误)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM(Java虚拟机)出现的问题。例如，Java虚拟机运行错误(Virtual MachioneError), 当JVM不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。这些错误表示故障发生于虚拟机自身或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误(Virtual MachioneError)、类定义错误(NoClassDefFoundError)等。这些错误时不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数时程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在Java中，错误通过Error的子类描述。</p>
<h2 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception(异常)"></a>Exception(异常)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是程序本身可以处理的异常。<code>Exception</code>类有一个重要的子类<code>RuntimeException</code>。<code>RuntimeException</code>类及其子类表示<code>JVM常用操作</code>引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常(NullPointerException、ArithmeticException)和ArrayIndexOutOfBoundException。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>异常能被程序本身可以处理，错误是无法处理的</code>。通常，Java是异常(包括Exception和Error)分为可查的异常(checked exceptions)和不可查的异常(unchecked exceptions)。<br>可查异常(编译器要求必须处置的异常)：正确的程序在运行中，很容易出现的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生时可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序种可能出现这类异常，要么用<code>try-cathc</code>语句捕获它，要么用<code>throws</code>子句声明抛出它，否则编译不会通过。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;Exception(异常)&lt;/code&gt;和&lt;code&gt;Error(错误)&lt;/code&gt;, 二者都是Java异常处理的重要子类，各自都包含大量子类。&lt;br&gt;
    
    </summary>
    
    
      <category term="失误锦集" scheme="http://www.sanstylemc.cn/tags/%E5%A4%B1%E8%AF%AF%E9%94%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>三种写文件方法</title>
    <link href="http://www.sanstylemc.cn/2018/08/05/%E4%B8%89%E7%A7%8D%E5%86%99%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/"/>
    <id>http://www.sanstylemc.cn/2018/08/05/三种写文件方法/</id>
    <published>2018-08-05T13:21:58.000Z</published>
    <updated>2018-08-06T06:35:15.608Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java写文件中，通常会使用<code>FileOutputStream</code>和<code>FileWriter</code>, <code>FileWriter</code>只能写文本文件。<code>FileOutputStream</code>也经常结合<code>BufferedOutPutStream</code>。因为实际应用中写文本文件的情况占了大多数。所以下面测试用不同的方式生成一个相同行数、大小相同的三种不同方式。<br><a id="more"></a><br><a href="http://www.codesky.net/article/200912/118652.html" target="_blank" rel="external">转自</a><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> class Main &#123;</div><div class="line">    <span class="keyword">public</span> Main() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        FileOutputStream out = null;</div><div class="line">        FileOutputStream outSTr = null;</div><div class="line">        BufferedOutputStream Buff=null;</div><div class="line">        FileWriter fw = null;</div><div class="line">        <span class="keyword">int</span> count=<span class="number">10000</span>;<span class="comment">//写文件行数</span></div><div class="line">        <span class="built_in">try</span> &#123;</div><div class="line">            out = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"D:\\add.txt"</span>));</div><div class="line">            <span class="keyword">long</span> <span class="built_in">begin</span> = System.currentTimeMillis();</div><div class="line">            <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                out.<span class="built_in">write</span>(<span class="string">"测试java 文件操作\r\n"</span>.getBytes());</div><div class="line">            &#125;</div><div class="line">            out.<span class="built_in">close</span>();</div><div class="line">            <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"FileOutputStream执行耗时:"</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) + <span class="string">" 豪秒"</span>);</div><div class="line"></div><div class="line">            outSTr = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"D:\\add0.txt"</span>));</div><div class="line">            Buff=<span class="keyword">new</span> BufferedOutputStream(outSTr);</div><div class="line">            <span class="keyword">long</span> begin0 = System.currentTimeMillis();</div><div class="line">            <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                Buff.<span class="built_in">write</span>(<span class="string">"测试java 文件操作\r\n"</span>.getBytes());</div><div class="line">            &#125;</div><div class="line">            Buff.<span class="built_in">flush</span>();</div><div class="line">            Buff.<span class="built_in">close</span>();</div><div class="line">            <span class="keyword">long</span> end0 = System.currentTimeMillis();</div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"BufferedOutputStream执行耗时:"</span> + (end0 - begin0) + <span class="string">" 豪秒"</span>);</div><div class="line"></div><div class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"D:\\add2.txt"</span>);</div><div class="line">            <span class="keyword">long</span> begin3 = System.currentTimeMillis();</div><div class="line">            <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                fw.<span class="built_in">write</span>(<span class="string">"测试java 文件操作\r\n"</span>);</div><div class="line">            &#125;</div><div class="line">            fw.<span class="built_in">close</span>();</div><div class="line">            <span class="keyword">long</span> end3 = System.currentTimeMillis();</div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"FileWriter执行耗时:"</span> + (end3 - begin3) + <span class="string">" 豪秒"</span>);</div><div class="line"></div><div class="line">        &#125; <span class="built_in">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        finally &#123;</div><div class="line">            <span class="built_in">try</span> &#123;</div><div class="line">                fw.<span class="built_in">close</span>();</div><div class="line">                Buff.<span class="built_in">close</span>();</div><div class="line">                outSTr.<span class="built_in">close</span>();</div><div class="line">                out.<span class="built_in">close</span>();</div><div class="line">            &#125; <span class="built_in">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下结果取几次不同的数据进行比较：<br>1、当<code>count=1000</code>时，即写文件1000行的时候，写出的文件大小为<code>25KB</code>：<br><img src="https://github.com/sunstady/hexo/blob/master/%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83/1.jpg?raw=true" alt="1"><br>2、当<code>count=10000</code>时，即写文件10000行的时候，写出的文件大小为<code>245KB</code>：<br><img src="https://github.com/sunstady/hexo/blob/master/%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83/2.jpg?raw=true" alt="2"><br>3、当<code>count=100000</code>时，即写文件100000行的时候，写出的文件大小为<code>2442KB</code>：<br><img src="https://github.com/sunstady/hexo/blob/master/%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83/3.jpg?raw=true" alt="3"><br>4、当<code>count=1000000</code>时，即写文件1000000行的时候，写出的文件大小为<code>24415KB</code>：<br><img src="https://github.com/sunstady/hexo/blob/master/%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83/4.jpg?raw=true" alt="4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由以上数据可以看到，如果不用缓冲流<code>BufferedOutputStream</code>，<code>FileOutputStream</code>写文件的性能不是很好。当写百万行的文件的时候，<code>FileOutputStream</code>比<code>FileWriter</code>要慢五千多毫秒，<code>BufferedOutputStream</code>比<code>FileWriter</code>要慢十几秒。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在Java写文件中，通常会使用&lt;code&gt;FileOutputStream&lt;/code&gt;和&lt;code&gt;FileWriter&lt;/code&gt;, &lt;code&gt;FileWriter&lt;/code&gt;只能写文本文件。&lt;code&gt;FileOutputStream&lt;/code&gt;也经常结合&lt;code&gt;BufferedOutPutStream&lt;/code&gt;。因为实际应用中写文本文件的情况占了大多数。所以下面测试用不同的方式生成一个相同行数、大小相同的三种不同方式。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.sanstylemc.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>1235MySQL错误</title>
    <link href="http://www.sanstylemc.cn/2018/08/02/1235MySQL%E9%94%99%E8%AF%AF/"/>
    <id>http://www.sanstylemc.cn/2018/08/02/1235MySQL错误/</id>
    <published>2018-08-02T07:30:13.000Z</published>
    <updated>2018-08-02T08:18:30.678Z</updated>
    
    <content type="html"><![CDATA[<p><code>1235 - This version of MySQL doesn&#39;t yet support &#39;LIMIT &amp; IN/ALL/ANY/SOME subquery&#39;</code><br><a id="more"></a></p>
<h2 id="1235"><a href="#1235" class="headerlink" title="1235"></a>1235</h2><p>今天正在些SQL语句，发现一个从未出现过的问题，在此记录下。<br><code>查询学生信息表中2班及2班之后的所有的学生的信息</code></p>
<p>原本以为很简单，要查询的班级不在一班就可以，但是使用子查询的时候出了问题。<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> class_id <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> class_id <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> class_id <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/sunstady/hexo/blob/master/1235/1.jpg?raw=true" alt="1"></p>
<p>一开始以为是括号里的<code>selectt</code>写错，但是单独拿出来发现并没有错。<br><img src="https://github.com/sunstady/hexo/blob/master/1235/2.jpg?raw=true" alt="2"><br>随后拜访了度娘，说是MySQL子查询不支持<code>limit</code>。<br>随后改了一下。<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> class_id <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> t.class_id <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> class_id <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span>) <span class="keyword">as</span> t);</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/sunstady/hexo/blob/master/1235/3.jpg?raw=true" alt="3"><br>如此可以绕开<code>limit</code>子查询问题。</p>
<p>后来又想有没有一种写法，用来代替<code>limit</code>的第二个参数，让它表示最大值。<br>在低版本中，确实是有的。<br><code>-1</code>表示最大值，用的方法也是如此<code>limit 1, -1</code><br>但是，这样的写法被官方认定是不合理的，在新的版本中被禁用了。<br>详情可以参考<a href="https://bugs.mysql.com/bug.php?id=2037" target="_blank" rel="external">官方报告</a></p>
<h2 id="查询姓李的信息"><a href="#查询姓李的信息" class="headerlink" title="查询姓李的信息"></a>查询姓李的信息</h2><p>两种写法，记录下。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'李%'</span>;</div></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">left</span>(<span class="keyword">name</span>, <span class="number">1</span>)= <span class="string">'李'</span>;</div></pre></td></tr></table></figure>
<p>left(name, 1)即取列字符的第一个字。</p>
<h2 id="查询名称为两个字的"><a href="#查询名称为两个字的" class="headerlink" title="查询名称为两个字的"></a>查询名称为两个字的</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'李_'</span>;</div></pre></td></tr></table></figure>
<h2 id="查询每个班级总人数"><a href="#查询每个班级总人数" class="headerlink" title="查询每个班级总人数"></a>查询每个班级总人数</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select st.class_id as <span class="string">"班级"</span>, count(st.id) as <span class="string">"总人数"</span> <span class="keyword">from</span> student as st<span class="built_in"> group </span>by st.class_id;</div></pre></td></tr></table></figure>
<h2 id="查询每个班有多少人以及男女各多少人"><a href="#查询每个班有多少人以及男女各多少人" class="headerlink" title="查询每个班有多少人以及男女各多少人"></a>查询每个班有多少人以及男女各多少人</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> sc.class_id <span class="keyword">as</span> <span class="string">'班级名称'</span>,</div><div class="line"><span class="keyword">count</span>(sc.id) <span class="keyword">as</span> <span class="string">'总人数'</span> ,</div><div class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> sc.sex=<span class="string">'男'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'男'</span>,</div><div class="line"><span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> sc.Sex=<span class="string">'女'</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'女'</span> </div><div class="line"><span class="keyword">from</span> student <span class="keyword">as</span> sc  <span class="keyword">group</span> <span class="keyword">by</span> sc.class_id</div></pre></td></tr></table></figure>
<h2 id="查询人数少于2的班级-包括2"><a href="#查询人数少于2的班级-包括2" class="headerlink" title="查询人数少于2的班级(包括2)"></a>查询人数少于2的班级(包括2)</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sc.class_id <span class="keyword">from</span> student as sc<span class="built_in"> group </span>by sc.class_id having(count(class_id))&lt;= 2;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;1235 - This version of MySQL doesn&amp;#39;t yet support &amp;#39;LIMIT &amp;amp; IN/ALL/ANY/SOME subquery&amp;#39;&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="失误锦集" scheme="http://www.sanstylemc.cn/tags/%E5%A4%B1%E8%AF%AF%E9%94%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>ClassLoader工作机制</title>
    <link href="http://www.sanstylemc.cn/2018/08/02/ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.sanstylemc.cn/2018/08/02/ClassLoader工作机制/</id>
    <published>2018-08-02T02:58:29.000Z</published>
    <updated>2018-08-02T03:20:34.539Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassLoader翻译过来就是类加载器，ClassLoader的具体作用就是将class文件加载到JVM虚拟机中去，程序就可以正确运行了。但是，JVM启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。<br><a id="more"></a></p>
<h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>class</code>文件时字节码格式文件，Java虚拟机并不能直接识别我们平常编写的Java源文件，所以需要<code>javac</code>这个命令转换成<code>.class</code>文件。另外，如果用C或者python编写的程序正确转换成class文件后，Java虚拟机也是可以识别运行的。</p>
<h2 id="ClassLoader概念"><a href="#ClassLoader概念" class="headerlink" title="ClassLoader概念"></a>ClassLoader概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ClassLoader</code>是用来动态的加载class文件到虚拟机中，并转换成<code>java.lang.class</code>类的一个实例，每个这样的实例用来表示一个Java类，我们可以根据class的实例得到该类的信息，并通过实例的<code>newInstance()</code>方法创建出该类的一个对象，除此之外，<code>ClassLoader</code>还负责加载Java应用所需的资源，如图像文件和配置文件等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ClassLoader</code>类是一个抽象类。如果给定类的二进制名称，那么类加载器会试图查找或生成构成类定义的数据。一般策略是将名称转换为某个文件名，然后从文件系统读取该名称的”类文件”。<code>ClassLoader</code>类使用委托模型来搜索类和资源。每个<code>ClassLoader</code>实例都有一个相关的父类加载器。需要查找类或资源时，<code>ClassLoader</code>实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</p>
<h2 id="JVM平台提供三层classLoader"><a href="#JVM平台提供三层classLoader" class="headerlink" title="JVM平台提供三层classLoader"></a>JVM平台提供三层classLoader</h2><h3 id="Bootstrap-classLoader"><a href="#Bootstrap-classLoader" class="headerlink" title="Bootstrap classLoader"></a>Bootstrap classLoader</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用native code实现，是JVM的一部分，主要加载JVM自身工作需要的类，如<code>java.lang.*</code>、<code>java.util.*</code>等；这些类位于<code>%JAVA_HOME%/jre/lib/rt.jar</code>。<code>Bootstrap ClassLoader</code>不继承自<code>ClassLoader</code>，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，<code>BootStrap ClassLoader</code>也随着启动，负责加载完核心类库后，并构造<code>Extension ClassLoader</code>和<code>App ClassLoader</code>类加载器。</p>
<h3 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="ExtClassLoader"></a>ExtClassLoader</h3><p>扩展的<code>class loader</code>， 加载位于<code>%JAVA_HOME%/jre/lib/ext</code>目录下的扩展<code>jar</code>。</p>
<h3 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统<code>class loader</code>， 父类是<code>ExtClassLoader</code>，加载<code>CLASSPATH</code>下的目录和<code>jar</code>；它负责加载应用程序主函数类。<br>其体系结构如下：<br><img src="https://github.com/sunstady/hexo/blob/master/ClassLoader/1.png?raw=true" alt="1"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要实现自己的类加载器，不管是实现抽象列<code>ClassLoader</code>，还是继承<code>URLClassLoader</code>类，它的父加载器都是<code>AppClassLoader</code>，因为不管调用哪个父类加载器，创建的对象都必须最终调用<code>getSystemClassLoader()</code>作为父加载器，<code>getSystemClassLoader()</code>方法获取到的正是<code>AppClassLoader</code>。</p>
<blockquote>
<p>注：<code>Bootstrap classLoader</code>并不属于JVM的等级层次，它不遵守<code>ClassLoader</code>的加载规则，<code>Bootstrap classLoader</code>并没有子类。</p>
</blockquote>
<h3 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h3><p>1、<code>Bootstrap CLassloder</code><br>2、<code>Extention ClassLoader</code><br>3、<code>AppClassLoader</code></p>
<h2 id="JVM加载class文件到内存有两种方式"><a href="#JVM加载class文件到内存有两种方式" class="headerlink" title="JVM加载class文件到内存有两种方式"></a>JVM加载class文件到内存有两种方式</h2><h3 id="隐式加载"><a href="#隐式加载" class="headerlink" title="隐式加载"></a>隐式加载</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不通过在代码里调用<code>ClassLoader</code>来加载需要的类，而是通过JVM来自动加载需要的类到内存，例如：当类中继承或者引用某个类时，JVM在解析当前这个类不在内存中时，就会自动将这些类加载到内存中。</p>
<h3 id="显式加载"><a href="#显式加载" class="headerlink" title="显式加载"></a>显式加载</h3><p>在代码中通过<code>CLassLoader</code>类来加载一个类，例如调用<code>this.getClass.getClassLoader().loadClass()</code>或者<code>Class.for</code></p>
<h2 id="ClassLoader加载类的过程"><a href="#ClassLoader加载类的过程" class="headerlink" title="ClassLoader加载类的过程"></a>ClassLoader加载类的过程</h2><p>1、找到<code>.class</code>文件并把这个文件加载到内存中。<br>2、字节码验证，<code>Class</code>类数据结构分析，内存分配和符号表的链接。<br>3、类中静态属性和初始化赋值以及静态代码块的执行。</p>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><h3 id="为何要自定义类加载器"><a href="#为何要自定义类加载器" class="headerlink" title="为何要自定义类加载器"></a>为何要自定义类加载器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM提供的类加载器，只能加载指定目录的<code>jar</code>和<code>class</code>，如果我们想加载其他位置的类或者<code>jar</code>时，例如加载网络上的一个<code>class</code>文件，默认的<code>ClassLoader</code>就不能满足我们的需求了，所以需要定义自己的类加载器。</p>
<h3 id="如何实现自定义的类加载器"><a href="#如何实现自定义的类加载器" class="headerlink" title="如何实现自定义的类加载器"></a>如何实现自定义的类加载器</h3><p>我们实现一个<code>ClassLoader</code>，并指定这个<code>ClassLoader</code>的加载路径。有两种方式：</p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>继承<code>CLassLoader</code>，重写父类的<code>findClass()</code>方法，代码如下：<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.<span class="keyword">File</span>;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> PathClassLoader <span class="keyword">extends</span> ClassLoader</div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String drive = <span class="string">"d:/"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String fileType = <span class="string">".class"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception</div><div class="line">    &#123;</div><div class="line">        PathClassLoader loader = <span class="keyword">new</span> PathClassLoader();</div><div class="line">        <span class="keyword">Class</span>&lt;?&gt; objClass = loader.loadClass(<span class="string">"HelloWorld"</span>, <span class="keyword">true</span>);</div><div class="line">        Object obj = objClass.newInstance();</div><div class="line">        System.out.<span class="keyword">println</span>(objClass.getName());</div><div class="line">        System.out.<span class="keyword">println</span>(objClass.getClassLoader());</div><div class="line">        System.out.<span class="keyword">println</span>(obj.getClass().toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; findClass(String name)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">byte</span>[] data = loadClassData(name);</div><div class="line">        <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);<span class="comment">// 将一个 byte 数组转换为 Class// 类的实例</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] loadClassData(String name)</div><div class="line">    &#123;</div><div class="line">        FileInputStream fis = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> <span class="keyword">File</span>(drive + name + fileType));</div><div class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> ((ch = fis.<span class="keyword">read</span>()) != -<span class="number">1</span>)</div><div class="line">            &#123;</div><div class="line">                baos.<span class="keyword">write</span>(ch);</div><div class="line">            &#125;</div><div class="line">            data = baos.toByteArray();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e)</div><div class="line">        &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

</div></div><br>在第13行，我们调用了父类的<code>loadClass()</code>方法，该方法使用指定的二进制名称来加载类，下面是<code>loadClass</code>方法的源代码：<br><div><div class="fold_hider"><div class="close hider_title">点击显/隐</div></div><div class="fold">
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name))</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 第一步先检查这个类是否已经被加载</span></div><div class="line">            <span class="keyword">Class</span>&lt;?&gt; c = findLoadedClass(name);</div><div class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line">                <span class="keyword">try</span></div><div class="line">                &#123;</div><div class="line">                    <span class="comment">//parent为父加载器</span></div><div class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>)</div><div class="line">                    &#123;</div><div class="line">                        <span class="comment">//将搜索类或资源的任务委托给其父类加载器</span></div><div class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                    &#125; <span class="keyword">else</span></div><div class="line">                    &#123;</div><div class="line">                        <span class="comment">//检查该class是否被BootstrapClassLoader加载</span></div><div class="line">                        c = findBootstrapClassOrNull(name);</div><div class="line">                    &#125;</div><div class="line">                &#125; </div><div class="line">                <span class="keyword">catch</span> (ClassNotFoundException e)</div><div class="line">                &#123;</div><div class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></div><div class="line">                    <span class="comment">// from the non-null parent class loader</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>)</div><div class="line">                &#123;</div><div class="line">                    <span class="comment">//如果上述两步均没有找到加载的class，则调用findClass()方法</span></div><div class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line">                    c = findClass(name);</div><div class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></div><div class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (resolve)</div><div class="line">            &#123;</div><div class="line">                resolveClass(c);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> c;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>

</div></div><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法首先检查指定<code>class</code>是否已经被加载，如果已被加载过，则调用<code>resolveClass()</code>方法链接指定的类，如果还未加载，则先将搜索类或资源的任务委托给其他父类加载器，检查该<code>class</code>是否被<code>BootstrapClassLoader</code>加载，如果上述两部均没有找到加载的<code>class</code>，则调用<code>findClass()</code>方法，在我们自定义的加载器中，我们重写了<code>findClass</code>方法，去我们指定的路径下加载<code>class</code>文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，我们自定义的类加载器没有指定父加载器，在JVM规范中不指定父类加载器的情况下，默认采用系统类加载器即<code>AppClassLoader</code>作为其父加载器，所以在使用该自定义类加载器时，需要加载的类不能在类路径中，否则的话根据双亲委派模型的原则，待加载的类会由类加载器加载。如果一定想要把自定义加载器需要加载的类放在类路径中，就要把自定义类加载器的父加载器设置为null。</p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>继承<code>URLClassLoader</code>类，然后设置自定义路径的URL来加载URL下的类。<br>我们将指定的目录转换为URL路径，然后重写<code>findClass</code>方法。</p>
<h2 id="实现类的热部署"><a href="#实现类的热部署" class="headerlink" title="实现类的热部署"></a>实现类的热部署</h2><h3 id="什么是类的热部署"><a href="#什么是类的热部署" class="headerlink" title="什么是类的热部署"></a>什么是类的热部署</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓热部署，就是在应用正在运行的时候升级软件，不需要重新启用应用。<br>对于Java应用程序来说，热部署就是运行时更新Java类文件。在基于Java的应用服务器实现热部署的过程中，类装入器扮演着重要的角色。大多数基于Java的应用服务器，包括EJB服务器和Servlet容器，都支持热部署。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类装入器不能重新装入一个已经装入的类，但只要使用一个新的类装入器实例，就可以将类再次装入一个正在运行的应用程序。</p>
<h3 id="如何实现Java类的热部署"><a href="#如何实现Java类的热部署" class="headerlink" title="如何实现Java类的热部署"></a>如何实现Java类的热部署</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面的分析，我们已经知道，JVM在加载类之前会检查请求的类是否已经被加载过来，也就是要调用findLoadedClass方法查看是否能够返回类实例。如果类已经加载过来，再调用loadClass会导致类冲突。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，JVM判断一个类是否是同一个类有两个条件：一是看这个类的完整类名是否一样(包括包名)，二是看加载这个类的ClassLoader加载器是否是同一个(既是是同一个ClassLoader类的两个实例，加载同一个类也会不一样)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，要实现类的热部署可以创建不同的ClassLoader的实例对象，然后通过这个不同的实例对象来加载同名的类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ClassLoader翻译过来就是类加载器，ClassLoader的具体作用就是将class文件加载到JVM虚拟机中去，程序就可以正确运行了。但是，JVM启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。&lt;br&gt;
    
    </summary>
    
    
      <category term="Interview" scheme="http://www.sanstylemc.cn/tags/Interview/"/>
    
  </entry>
  
</feed>
