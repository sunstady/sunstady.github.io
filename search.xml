<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[公平锁与非公平锁]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在Java并发编程中，公平锁与非公平锁是很常见的概念，ReentrantLock、ReadWriteLock默认都是非公平模式，非公平锁的效率为何高于公平锁呢？公平锁与非公平锁有什么区别呢？&nbsp;&nbsp;&nbsp;&nbsp;首先先简单从名字上来理解，公平锁就是保障了多线程下各种线程取锁的顺序，先到的线程优先获取锁，而非公平锁则无法提供这个保障。看到网上很多说法说非公平锁获取锁时各线程的概率是随机的，这也是一种很不确切的说法。非公平锁并非真正的随机，其获取锁还是有一定顺序的，但其顺序究竟是怎样呢？先看图:公平锁与非公平锁的一个重要区别就在于上图中的2、6、10那个步骤，对应源码如下:123456789101112131415161718192021222324252627282930313233343536373839404142//非公平锁final boolean nonfairTryAcquire(int acquires) &#123; final Thread current= Thread.currentThread(); int c= getState(); if (c== 0) &#123; //区别重点在这里 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current== getExclusiveOwnerThread()) &#123; int nextc= c+ acquires; if (nextc&lt; 0) &#123; throw new Error("Maximum lock count exceeded"); &#125; setState(true); return true; &#125; return false;&#125;//公平锁final boolean nonfairTryAcquire(int acquires) &#123; final Thread current= Thread.currentThread(); int c= getState(); if (c== 0) &#123; //hasQueuedPredecessors这个方法就是最大区别所在 if (!hasQueuedPredecessors()&amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current== getExclusiveOwnerThread()) &#123; int nextc= c+ acquires; if (nextc&lt; 0) &#123; throw new Error("Maximum lock count exceeded"); &#125; setState(true); return true; &#125; return false;&#125; 分析以上代码，我们可以看到公平锁就是在获取锁之前会先判断等待队列是否为空或者自己是否位于队列头部，该条件通过才能继续获取锁。在结合兔子喝水的图分析，非公平锁获取所得顺序基本确定在9、10、11这三个事件发生的先后顺序:1、若在释放锁的时候总是没有新的兔子来打扰，则非公平锁等于公平锁；2、若释放锁的时候，正好一个兔子来喝水，而此时位于队列头的兔子还没有被唤醒(因为线程上下文切换是需要不少开销的)，此时后来的兔子则优先获得锁，成功打破公平，成为非公平锁。其实对于非公平锁，只要线程进入了等待队列， 队列里面依然是FIFO的原则，跟公平锁的顺序是一样的。因为公平锁与非公平锁的release()部分代码是公用AQS的代码。12345678910111213141516171819private void unparkSuccessor(Node node) &#123; int ws= node.waitStatus; if(ws&lt; 0) &#123; compareAndSetWaitStatus(node, ws, 0); &#125; Node s= node.next; if (s== null|| s.waitStatus&gt; 0) &#123; s= null; for(Node t= tail; t!= null&amp;&amp; t!= node; t= t.prev) &#123; if (t.waitStatus&lt;= 0) &#123; s= t; &#125; &#125; &#125; if (s!= null) &#123; //唤醒队列头的线程 LockSupport.unpark(s.thread); &#125;&#125; 上文说到的线程切换的开销，其实就是非公平锁效率高于公平锁的原因，因为非公平锁减少了线程挂起的几率，后来的线程有一定几率逃离被挂起的开销。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py统计单词个数]]></title>
    <url>%2F2018%2F04%2F06%2Fpy%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[任一个英文的纯文本文件，统计其中的单词出现的个数123456789101112131415import stringf= open(r'C:\Users\12905\Desktop\1.txt', 'r+') #从文件中读取内容str1= f.read()str= str1.lower() #全部切换成小写list= str.split() #切片list1= []for i in range(0, len(list)): list[i]= list[i].strip(string.punctuation)for word in list: if word not in list1: list1.append(word)for word in list1: print(word, list.count(word)) 运行结果如下图所示:]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py生成图片验证码]]></title>
    <url>%2F2018%2F04%2F06%2Fpy%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[生成图片二维码，并判断填写的验证码是否正确。1234567891011121314151617181920212223242526272829import randomimport stringimport sysfrom PIL import Image,ImageDraw,ImageFontdef random_text (): #生成一串4位的随机字符串 text= string.digits+ string.ascii_letters str= '' for i in range(0, 4): str= str+ text[random.randint(0, len(text))] return strdef get_code (str): width= 120 height= 60 #设置图片大小 color= (43, 34, 88) #设置图片颜色 image= Image.new('RGB', (width, height), color) #创建图片 fontl= ImageFont.truetype("simsun.ttc", 40, index= 1) #设置字体样式 draw= ImageDraw.Draw(image) #将验证码画到图片上 draw.text((20, 10), str, fill=(355, 0, 0), font= fontl) image.show()s= random_text()get_code(s)code= input("请输入图片中的验证码: ")if s.lower()== code.lower(): print("验证码输入正确")else: print ("验证码输入错误") 运行结果如图所示:]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程地生命周期]]></title>
    <url>%2F2018%2F04%2F06%2F%E7%BA%BF%E7%A8%8B%E5%9C%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;当线程被创建并启动后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)和死亡(Dead)五种状态。尤其事当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。 1、新建状态: 当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。2、就绪状态: 当线程对象调用了start()方法后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。3、运行状态: 如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态。4、阻塞状态: 当处于运行状态的线程失去所占用资源后，便进入阻塞状态。5、死亡状态: 当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能进入就绪状态等待执行。 新建和就绪状态&nbsp;&nbsp;&nbsp;&nbsp;当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。&nbsp;&nbsp;&nbsp;&nbsp;当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。 注意：启动线程使用start()方法，而不是run()方法。永远不要调用线程对象的run()方法。调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理；但如果直按调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。需要指出的是，调用了线程的run()方法之后，该线程已经不再处于新建状态，不要再次调用线程对象的start()方法。只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常。 &nbsp;&nbsp;&nbsp;&nbsp;调用线程对象的start()方法之后，该线程立即进入就绪状态——就绪状态相当于”等待执行”，但该线程并未真正进入运行状态。如果希望调用子线程的start()方法后子线程立即开始执行，程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行。 运行和阻塞状态&nbsp;&nbsp;&nbsp;&nbsp;如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU。那么在任何时刻只有一个线程处于运行状态，当然在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。&nbsp;&nbsp;&nbsp;&nbsp;当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了）。线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。&nbsp;&nbsp;&nbsp;&nbsp;所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机则可能采用协作式调度策略，在这样的系统中，只有当一个线程调用了它的sleep()或yield()方法后才会放弃所占用的资源——也就是必须由该线程主动放弃所占用的资源。&nbsp;&nbsp;&nbsp;&nbsp;当发生如下情况时，线程将会进入阻塞状态 1、线程调用sleep()方法主动放弃所占用的处理器资源。2、线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。3、线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。4、线程在等待某个通知(notify)5、程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。 &nbsp;&nbsp;&nbsp;&nbsp;当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。&nbsp;&nbsp;&nbsp;&nbsp;针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态 1、调用sleep()方法的线程经过了指定时间2、线程调用的阻塞式IO方法已经返回3、线程成功地获得了识图取得地同步监视器4、线程正在等待的某个通知时，其他线程发出了一个通知（signal）5、处于挂起状态地线程被调用了resume()恢复方法 线程死亡&nbsp;&nbsp;&nbsp;&nbsp;线程会以如下三种方式结束，结束以后就处于死亡状态 1、run()或call()方法执行完成，线程正常结束2、线程抛出一个未捕获地Exception或Error3、直接调用该线程stop()方法来结束该线程–该方法容易导致死锁，通常不推荐使用。 注意: 当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，他就拥有和主线程相同地地位，他不会受主线程地影响。为了测试某个线程是否已经死亡，可以调用线程对象的isAlivc()方法，当线程处于就绪、运行、阻塞了种状态时，该方法将返回true；当线程处于新建、死亡状态时，该方法将返回false。 不要试图对一个已经死亡的线程调用start()方法使它重新启动，死亡就是死亡，该线程将不可再次作为线程执行。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sleep()和wait()的区别]]></title>
    <url>%2F2018%2F04%2F06%2Fsleep-%E5%92%8Cwait-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对于sleep()方法，该方法是属于Thread类中的。而wait()方法是属于Object()类中的。&nbsp;&nbsp;&nbsp;&nbsp;sleep()方法导致了程序暂停执行指定的时间，让出cpu改其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。&nbsp;&nbsp;&nbsp;&nbsp;在调用sleep()方法的过程中，线程不会释放对象锁。&nbsp;&nbsp;&nbsp;&nbsp;而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。举个例子说明:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class long1_1 &#123; public static void main(String[] args) &#123; new Thread(new Thread1()).start(); try &#123; Thread.sleep(5000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; new Thread(new Thread2()).start(); &#125; private static class Thread1 implements Runnable &#123; @Override public void run() &#123; synchronized (long1_1.class) &#123; System.out.println("enter thread1..."); System.out.println("thread1 is waiting..."); try &#123; // 调用wait()方法，线程会放弃对象锁，进入等待此对象的等待锁定池 long1_1.class.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("thread1 is going on ...."); System.out.println("thread1 is over!!!"); &#125; &#125; &#125; private static class Thread2 implements Runnable &#123; @Override public void run() &#123; synchronized (long1_1.class) &#123; System.out.println("enter thread2...."); System.out.println("thread2 is sleep...."); // 只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。 long1_1.class.notify(); // ================== // 区别 // 如果我们把代码：TestD.class.notify();给注释掉，即TestD.class调用了wait()方法，但是没有调用notify() // 方法，则线程永远处于挂起状态。 try &#123; // sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程， // 但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。 // 在调用sleep()方法的过程中，线程不会释放对象锁。 Thread.sleep(5000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("thread2 is going on...."); System.out.println("thread2 is over!!!"); &#125; &#125; &#125;&#125; 运行结果如下:如果注释掉long1_1.class.notify();运行结果如下:且程序一直处于挂起状态。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[start和run的区别]]></title>
    <url>%2F2018%2F04%2F06%2Fstart%E5%92%8Crun%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[run()方法:在本线程内调用Runnable对象的run()方法，可以重复多次调用。start()方法:启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程。这个解释看过好多次了，但是理解不够，现在想想，其实run方法并不是启动线程，而是方法调用，在主线程中调用一个对象的run()方法而已，而start才是真的启动来了一个线程。看一下代码:1234567891011121314151617181920public class long1_1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TestThread tt = new TestThread(); tt.run(); &#125; &#125; class TestThread extends Thread &#123; static int i = 0; final static int MAX_I = 10; @Override public void run() &#123; // TODO Auto-generated method stub while (i &lt; MAX_I) &#123; System.out.println(i++); &#125; &#125; &#125; 运行结果如下:或许有人会得出结论，这样启动一个线程是可以的，我们再对程式稍作修改，会发现一个问题:123456789101112131415161718192021public class long1_1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TestThread tt = new TestThread(); tt.run(); System.out.println("Printed by main thread"); &#125; &#125; class TestThread extends Thread &#123; static int i = 0; final static int MAX_I = 10; @Override public void run() &#123; // TODO Auto-generated method stub while (i &lt; MAX_I) &#123; System.out.println(i++); &#125; &#125; &#125; 这里只在主线程中加入了一行代码，打印一行”Printed by main thread”，运行代码，结果如下:熟练多线程的开发的要发现问题了，为什么”Printed by main thread”会打印在最后一行呢？TestThread类中一直持有时间段吗？对上面的代码进行分析，其实非常简单，这只是一个普通的类中方法的调用，其实是一个单线程的执行，我们来修改代码进一步验证下:1234567891011121314151617181920212223public class long1_1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TestThread tt = new TestThread(); tt.run(); System.out.println(Thread.currentThread().getName()); System.out.println("Printed by main thread"); &#125; &#125; class TestThread extends Thread &#123; static int i = 0; final static int MAX_I = 10; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()); while (i &lt; MAX_I) &#123; System.out.println(i++); &#125; &#125; &#125; 这段代码分别在主线程和我们的TestThread的方法中打印当前线程名字，运行结果如下:在TestThread类和主线程中运行的是同一个线程，说明在直接调用run时是不能使用多线程的，那么把上面的run方法调用改为start方法的调动再看一下。1234567891011121314151617181920212223public class long1_1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TestThread tt = new TestThread(); tt.start(); System.out.println(Thread.currentThread().getName()); System.out.println("Printed by main thread"); &#125; &#125; class TestThread extends Thread &#123; static int i = 0; final static int MAX_I = 10; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()); while (i &lt; MAX_I) &#123; System.out.println(i++); &#125; &#125; &#125; 运行结果如下:很明显，这才是我们想看到的结果，所以结论是只有调用Thread的start方法，将线程交由JVM控制，才能产生多线程，而直接调用run方法只是一个普通的单线程程式。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是线程池]]></title>
    <url>%2F2018%2F04%2F06%2F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;到目前为止我们使用多线程应用程序的目的是尽可能多地使用计算机处理器资源。所以，看起来我们仅需要为每个独立的任务分配一个不同的线程，并让处理器确定在任何时间它总会处理其中的某一个任务。额，对小系统来说这样做很好。但是当系统越来越复杂时，线程的数量也会越来越多，操作系统将会花费更多时间处理锁分配，理清线程之间的关系，处理程序指令的时间实际上是很少的。为了让我们的程序具备可扩展性，我们将不得不对线程进行一些控制。&nbsp;&nbsp;&nbsp;&nbsp;对那些生存周期比较短的线程来说，使用线程池来处理任务要比为每个任务都创建一个线程然后顺序地回收它们要高效得多。一个任务，在概念上说，可以是一个单一方法的执行过程或者一系列方法的执行过程。为一个线程预分配一个集合或者一个池来以备未来之需以及能够在一个应用程序中重用的技术称作线程池。 什么是线程池&nbsp;&nbsp;&nbsp;&nbsp;线程池是指在初始化一个多线程应用程序过程中创建一个线程集合，然后在需要执行新的任务时重用这些线程而不是新建一个线程。线程池中线程的数量通常完全取决于可用内存数量和应用程序的需求。然而，增加可用线程数量是可能的。线程池中的每个线程都有被分配一个任务，一旦任务已经完成了，线程回到池子中并等待下一个分配任务。 为什么需要线程池基于以下几个原因在多线程应用程序中使用线程是必须的:1、线程池改进了一个应用程序的响应时间。由于线程池中的线程已经准备好且等待被分配任务，应用程序可以直接拿来使用而不用新建一个线程。2、线程池节省了CLR为每个短生存周期任务创建一个完整的线程的开销并可以在任务完成后回收资源。3、线程池根据当前在系统中运行的进程来优化线程时间片。4、线程池允许我们开启多个任务而不用为每个线程设置属性。5、线程池允许我们为正在执行的任务的程序参数传递一个包含状态信息的对象引用。6、线程池可以用来解决处理一个特定请求最大线程数量限制问题。 线程池的概念&nbsp;&nbsp;&nbsp;&nbsp;影响一个多线程应用程序的相应时间的几个主要因素之一是为每个任务生成一个线程时间。&nbsp;&nbsp;&nbsp;&nbsp;例如，一个web Server是一个多线程应用程序，它可以同时对多个客户端请求提供服务。假设有是个客户端同时访问web Server:1、如果服务执行一个客户端对应一个线程的策略，它将为这些客户端生成十个新线程，从创建第一个线程开始到在线程的整个生命周期管理它们都会增加系统开销。也有可能在某个时间计算机的资源耗尽。2、相反的，如果服务端使用一个线程池来处理这些请求，那么当每次客户端请求来到后都创建一个线程的时间会节省下来。它可以管理已经创建的线程，如果线程池太忙的话也可以拒绝客户端请求。这是线程池背后的概念。&nbsp;&nbsp;&nbsp;&nbsp;.NET CLR 为服务请求维护一个线程池。如果我们的应用程序从线程池中请求一个新线程，CLR 将试着从线程池中取出一个。如果线程池是空的，它将生成一个新线程并把它给我们。当我们的代码使用的线程结束以后，线程由.NET 回收并返回给线程池。线程池中线程的数量由当前可用地内存数量决定。&nbsp;&nbsp;&nbsp;&nbsp;影响设计一个多线程应用程序的因素有:1、一个应用程序的响应时间。2、线程管理资源的分配。3、资源共享。4、线程同步。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo提交文章被killed]]></title>
    <url>%2F2018%2F04%2F06%2Fhexo%E6%8F%90%E4%BA%A4%E6%96%87%E7%AB%A0%E8%A2%ABkilled%2F</url>
    <content type="text"><![CDATA[如图所示，不管如何提交，都是被killed。问题原因:2016年4月15日起，新购买的Linux操作系统CVM，将不再提供2GB的SWAP盘。swap分区是在系统物理内存不够用的时候，由系统内存管理程序将那些很长时间没有操作内存数据，临时保存到Swap分区中，以提高可用内存额度的一种机制。当那些程序要再次重新运行时，会再从Swap分区恢复之前保存的数据到内存中。相关操作会导致额外的IO开销，特别是，如果内存使用率已经非常高，而同时IO性能也不是很好的情况下，该机制其实会起到相反的效果：不仅系统性能提升较小（因为内存使用率已经非常高了），而且由于频繁的内存到SWAP的切换操作，会导致产生大量额外的IO操作，导致IO性能进一步降低，最终反而降低了系统总体性能。内存与磁盘性能有10倍以上的差距，如Mysql等业务，当内存数据临时保存到SWAP分区时，数据库的整体服务质量会大大下降。为了保证您业务的正常运行，当服务器内存不足时，建议您增加内存空间。解决方法:12345free -m //查看系统当前的分区情况dd if=/dev/zero of=/swap bs=4096 count=1572864 //创建用于交换分区的文件mkswap /swap //设置交换分区文件swapon /swap //启用交换分区文件echo “LABEL=SWAP-sda /xxx/swap swap swap defaults 0 0” &gt;&gt; /etc/fstab //若想开机时自启用，则需要修改文件/etc/fstab中的swap行]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程的区别]]></title>
    <url>%2F2018%2F04%2F06%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[进程狭义定义:进程是正在运行的程序的实例。 组成:进程是一个实体。每一个进程都有它自己的地址空间。一般情况下，包括文本区域(text region)、数据区域(data region)和堆栈(stack region)。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。结构:结构特征: 进程由程序、数据和进程控制块三部分组成。 调度算法:实时系统中: FIFO(First Input First Output, 先进先出算法)， SJF(Shortest Job First, 最短作业优先算法)，SRTF(Shortest Remaining Time First, 最短剩余时间优先算法)。交互式系统中: RR(Round Robin, 时间片轮转法)，HPF(Highest Priority First, 最高优先级算法)，多级队列，最短进程优先，保证调度，彩票调度，公平分享调度。 线程的定义及基本概念一个标准的线程由线程ID，当前指令指针(PC)，寄存器集合和堆栈组成。另外，线程式进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。 线程之间的关系:一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。 特点: 轻型实体(线程的实体包括程序、数据和TCB。TCB用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。) 独立调度和分派的基本单位 可并发执行 共享进程资源(所有线程都具有相同的地址空间(进程的地址空间)，这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。) 进程和线程的区别 1、线程是处理器调度的基本单位，但进程不是。2、二者均可并发执行。3、进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元4、同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。5、进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束6、线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的7、线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源8、线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志 线程同步 Mutex(互斥锁): 用来锁住公用的内存，同时只有一个线程访问。 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 总结进程是资源分配的基本单位，线程是调度的基本单位。进程包含线程，线程共用进程的资源。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery技巧]]></title>
    <url>%2F2018%2F04%2F05%2FjQuery%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[这里有几个jQuery代码片段，这些代码可以给JavaScript项目提供一些帮助。 修改jQuery默认编码(例如默认UTF-8改成GB2312)1$.ajaxSetup(&#123;ajaxSettings:&#123; contentType:"application/x-www-form-urlencoded;chartset=GB2312"&#125;&#125;); ##解决jQuery、prototype共存，$全局变量冲突问题1&lt;script src="prototype.js"&gt;&lt;/script&gt;&lt;script src="http://blogbeta.blueidea.com/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;jQuery.noConflict();&lt;/script&gt; 注意：一定要先引入prototype.js再引入jquery.js，先后顺序不可错。 jQuery判断元素上是否绑定了事件12//jQuery event封装支持判断元素上是否绑定了事件，此方法只适用于jQuery绑定的事件var $events = $("#foo").data("events");if( $events &amp;&amp; $events["click"] )&#123;//your code&#125; 使用jQuery来切换样式表12//找出你希望切换的媒体类型（media-type），然后把href设置成新的样式表。$('link[media='screen']').attr('href', 'alternative.css'); 限制选择范围（基于优化目的）123456//尽可能使用标签名来作为类名的前缀//这样jQuery就不需要花费更多的时间来搜索//你想要的元素。还要记住的一点是//针对于你的页面上的元素的操作越具体化//就越能降低执行和搜索的时间。var in_stock = $('#shopping_cart_items input.is_in_stock');&lt;ul id="shopping_cart_items"&gt;&lt;li&gt;&lt;input type="radio" value="Item-X" name="item" class="is_in_stock" /&gt; Item X&lt;/li&gt;&lt;li&gt;&lt;input type="radio" value="Item-Y" name="item" class="3-5_days" /&gt; Item Y&lt;/li&gt;&lt;li&gt;&lt;input type="radio" value="Item-Z" name="item" class="unknown" /&gt; Item Z&lt;/li&gt;&lt;/ul&gt; 正确地使用toggleClass1234//切换（toggle）类允许你根据某个类的//是否存在来添加或是删除该类。//这种情况下有些开发者使用：a.hasClass('blueButton') ? a.removeClass('blueButton') : a.addClass('blueButton');//toggleClass允许你使用下面的语句来很容易地做到这一点a.toggleClass('blueButton'); 设置IE特有的功能1if ($.browser.msie) &#123;// Internet Explorer就是个虐待狂&#125; 使用jQuery来代替一个元素1$('#thatdiv').replaceWith('fnuh'); 验证某个元素是否为空1// 方法一if (! $('#keks').html()) &#123;//什么都没有找到;&#125;// 方法二if ($('#keks').is(":empty")) &#123;//什么都没有找到;&#125; 从一个未排序的集合中找出某个元素的索引号12$("ul &gt; li").click(function () &#123;var index = $(this).prevAll().length; //prevAll([expr]): 查找当前元素之前所有的同辈元素&#125;); 把函数绑定到事件上1234//方法一$('#foo').click(function(event) &#123;alert('User clicked on "foo."');&#125;);//方法二, 支持动态传参$('#foo').bind('click', &#123;test1:"abc", test2:"123"&#125;, function(event) &#123;alert('User clicked on "foo."' + event.data.test1 + event.data.test2 );&#125;); 追加或是添加html到元素中1$('#lal').append('sometext'); 在创建元素时，如何使用对象字面量（literal）来定义属性1var e = $("", &#123; href: "#", class: "a-class another-class", title: "..." &#125;); 使用多个属性来进行过滤123//在使用许多相类似的有着不同类型的input元素时//这种基于精确度的方法很有用var elements = $('#someid input[type=sometype][value=somevalue]').get(); 使用jQuery来预加载图像123jQuery.preloadImages = function() &#123;for(var i = 0; i &lt; arguments.length; i++) &#123;$("&lt;img /&gt;").attr('src', arguments);&#125;&#125;;//用法$.preloadImages('image1.gif', '/path/to/image2.png', 'some/image3.jpg'); 为任何与选择器相匹配的元素设置事件处理程序123456$('button.someClass').live('click', someFunction);//注意，在jQuery1.4.2中，delegate和undelegate选项//被引入代替live，因为它们提供了更好的上下文支持//例如，就table来说，以前你会用$("table").each(function()&#123;$("td", this).live("hover", function()&#123;$(this).toggleClass("hover");&#125;);&#125;);//现在用$("table").delegate("td", "hover", function()&#123;$(this).toggleClass("hover");&#125;); 找到一个已经被选中的option元素1$('#someElement').find('option:selected'); 隐藏一个包含了某个值文本的元素1$("p.value:contains('thetextvalue')").hide(); 创建嵌套的过滤器12345//允许你减少集合中的匹配元素的过滤器//只剩下那些与给定的选择器匹配的部分。在这种情况下//查询删除了任何没（:not）有（:has）//包含class为“selected”（.selected）的子节点。.filter(":not(:has(.selected))") 检测各种浏览器12345678检测Safari (if( $.browser.safari))检测IE6及之后版本 (if ($.browser.msie &amp;&amp; $.browser.version &gt; 6 ))检测IE6及之前版本 (if ($.browser.msie &amp;&amp; $.browser.version &lt;= 6 ))检测FireFox 2及之后版本 (if ($.browser.mozilla &amp;&amp; $.browser.version &gt;= '1.8' )) 任何使用has()来检查某个元素是否包含某个类或是元素123//jQuery 1.4.*包含了对这一has方法的支持。//该方法找出某个元素是否包含了其他另一个元素类或是其他任何的你正在查找并要在其之上进行操作的东东。$("input").has(".email").addClass("email_icon"); 禁用右键单击上下文菜单1$(document).bind('contextmenu',function(e)&#123;return false;&#125;); 定义一个定制的选择器12345678$.expr[':'].mycustomselector = function(element, index, meta, stack)&#123;// element- 一个DOM元素// index – 栈中的当前循环索引// meta – 有关选择器的元数据// stack – 要循环的所有元素的栈// 如果包含了当前元素就返回true// 如果不包含当前元素就返回false &#125;;// 定制选择器的用法：$('.someClasses:test').doSomething(); 检查某个元素是否存在123if ($('#someDiv').length) &#123;//万岁！！！它存在……&#125; 使用jQuery来检测右键和左键的鼠标单击两种情况1$("#someelement").live('click', function(e) &#123;if( (!$.browser.msie &amp;&amp; e.button == 0) || ($.browser.msie &amp;&amp; e.button == 1) ) &#123;alert("Left Mouse Button Clicked");&#125; else if(e.button == 2) &#123;alert("Right Mouse Button Clicked");&#125;&#125;); 替换串中的词1var el = $('#id');el.html(el.html().replace(/word/ig, '')); 在一段时间之后自动隐藏或关闭元素（支持1.4版本）1234//这是1.3.2中我们使用setTimeout来实现的方式setTimeout(function() &#123;$('.mydiv').hide('blind', &#123;&#125;, 500)&#125;, 5000);//而这是在1.4中可以使用delay()这一功能来实现的方式（这很像是休眠）$(".mydiv").delay(5000).hide('blind', &#123;&#125;, 500); 把已创建的元素动态地添加到DOM中1var newDiv = $('&lt;div&gt;&lt;/div&gt;');newDiv.attr('id','myNewDiv').appendTo('body'); 限制“Text-Area”域中的字符的个数12345jQuery.fn.maxLength = function(max)&#123;return this.each(function()&#123;var type = this.tagName.toLowerCase();var inputType = this.type? this.type.toLowerCase() : null;if(type == "input" &amp;&amp; inputType == "text" || inputType == "password")&#123;//Apply the standard maxLengththis.maxLength = max;&#125; else if(type == "textarea")&#123;this.onkeypress = function(e)&#123;var ob = e || event;var keyCode = ob.keyCode;var hasSelection = document.selection? document.selection.createRange().text.length &gt; 0 : this.selectionStart != this.selectionEnd;return !(this.value.length &gt;= max &amp;&amp; (keyCode &gt; 50 || keyCode == 32 || keyCode == 0 || keyCode == 13) &amp;&amp; !ob.ctrlKey &amp;&amp; !ob.altKey &amp;&amp; !hasSelection);&#125;;this.onkeyup = function()&#123;if(this.value.length &gt; max)&#123;this.value = this.value.substring(0,max);&#125;&#125;;&#125;&#125;);&#125;;//用法$('#mytextarea').maxLength(500); jQuery注册和禁用jQuery全局事件123//jQuery注册ajax全局事件ajaxStart，ajaxStop：$(document).ajaxStart(function()&#123;$("#background,#progressBar").show();&#125;).ajaxStop(function()&#123;$("#background,#progressBar").hide();&#125;);//ajax请求禁用全局事件：$.ajax() 有个参数global (默认: true) 是否触发全局 AJAX 事件.设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 Ajax 事件。 在jQuery中克隆一个元素1var cloned = $('#somediv').clone(); 在jQuery中如何测试某个元素是否可见123if($(element).is(':visible')) &#123;//该元素是可见的&#125; 把一个元素放在屏幕的中心位置12jQuery.fn.center = function () &#123;return this.each(function()&#123;$(this).css(&#123;position:'absolute',top, ( $(window).height() - this.height() ) / 2 + $(window).scrollTop() + 'px',left, ( $(window).width() - this.width() ) / 2 + $(window).scrollLeft() + 'px'&#125;);&#125;);&#125;//这样来使用上面的函数： $(element).center(); 把有着某个特定名称的所有元素的值都放到一个数组中1var arrInputValues = new Array();$("input[name='xxx']").each(function()&#123;arrInputValues.push($(this).val());&#125;); 从元素中除去HTML12(function($) &#123;$.fn.stripHtml = function() &#123;var regexp = /&lt;("[^"]*"|'[^']*'|[^'"&gt;])*&gt;/gi;this.each(function() &#123;$(this).html( $(this).html().replace(regexp,'') );&#125;);return $(this);&#125;&#125;)(jQuery);//用法：$('p').stripHtml(); 使用closest来取得父元素1$('#searchBox').closest('div'); 使用Firebug和Firefox来记录jQuery事件日志1234// 允许链式日志记录jQuery.log = jQuery.fn.log = function (msg) &#123;if (console)&#123;console.log("%s: %o", msg, this);&#125;return this;&#125;;// 用法：$('#someDiv').hide().log('div hidden').addClass('someClass'); 强制在弹出窗口中打开链接1$('a.popup').live('click', function()&#123;var newwindow = window.open($(this).attr('href'),'','height=200,width=150');if (window.focus) &#123;newwindow.focus();&#125;return false;&#125;); 强制在新的选项卡中打开链接1$('a.newTab').live('click', function()&#123;var newwindow=window.open(this.href);$(this).target = "_blank";return false;&#125;); 在jQuery中如何使用.siblings()来选择同辈元素1234// 不这样做$('#nav li').click(function()&#123;$('#nav li').removeClass('active');$(this).addClass('active');&#125;);//替代做法是$('#nav li').click(function()&#123;$(this).addClass('active').siblings().removeClass('active');&#125;); 切换页面上的所有复选框123var tog = false;// 或者为true，如果它们在加载时为被选中状态的话$('a').click(function() &#123;$("input[type=checkbox]").attr("checked",!tog);tog = !tog;&#125;); 基于一些输入文本来过滤一个元素列表12//如果元素的值和输入的文本相匹配的话,该元素将被返回$('.someClass').filter(function() &#123;return $(this).attr('value') == $('input#someId').val();&#125;) 获得鼠标垫光标位置x和y1$(document).ready(function() &#123;$(document).mousemove(function(e)&#123;$(’#XY’).html(”X Axis : ” + e.pageX + ” | Y Axis ” + e.pageY);&#125;);&#125;); 扩展String对象的方法1$.extend(String.prototype, &#123;isPositiveInteger:function()&#123;return (new RegExp(/^[1-9]d*$/).test(this));&#125;,isInteger:function()&#123;return (new RegExp(/^d+$/).test(this));&#125;,isNumber: function(value, element) &#123;return (new RegExp(/^-?(?:d+|d&#123;1,3&#125;(?:,d&#123;3&#125;)+)(?:.d+)?$/).test(this));&#125;,trim:function()&#123;return this.replace(/(^s*)|(s*$)| | /g, "");&#125;,trans:function() &#123;return this.replace(/&amp;lt;/g, '&lt;').replace(/&amp;gt;/g,'&gt;').replace(/&amp;quot;/g, '"');&#125;,replaceAll:function(os, ns) &#123;return this.replace(new RegExp(os,"gm"),ns);&#125;,skipChar:function(ch) &#123;if (!this || this.length===0) &#123;return '';&#125;if (this.charAt(0)===ch) &#123;return this.substring(1).skipChar(ch);&#125;return this;&#125;,isValidPwd:function() &#123;return (new RegExp(/^([_]|[a-zA-Z0-9])&#123;6,32&#125;$/).test(this));&#125;,isValidMail:function()&#123;return(new RegExp(/^w+((-w+)|(.w+))*@[A-Za-z0-9]+((.|-)[A-Za-z0-9]+)*.[A-Za-z0-9]+$/).test(this.trim()));&#125;,isSpaces:function() &#123;for(var i=0; i&lt;this.length; i+=1) &#123;var ch = this.charAt(i);if (ch!=' '&amp;&amp; ch!=" " &amp;&amp; ch!=" " &amp;&amp; ch!=" ") &#123;return false;&#125;&#125;return true;&#125;,isPhone:function() &#123;return (new RegExp(/(^([0-9]&#123;3,4&#125;[-])?d&#123;3,8&#125;(-d&#123;1,6&#125;)?$)|(^([0-9]&#123;3,4&#125;)d&#123;3,8&#125;((d&#123;1,6&#125;))?$)|(^d&#123;3,8&#125;$)/).test(this));&#125;,isUrl:function()&#123;return (new RegExp(/^[a-zA-z]+://([a-zA-Z0-9-.]+)([-w ./?%&amp;=:]*)$/).test(this));&#125;,isExternalUrl:function()&#123;return this.isUrl() &amp;&amp; this.indexOf("://"+document.domain) == -1;&#125;&#125;); 规范化写jQuery插件12345(function($)&#123;$.fn.extend(&#123;pluginOne: function()&#123;return this.each(function()&#123;// my code&#125;);&#125;,pluginTwo: function()&#123;return this.each(function()&#123;// my code&#125;);&#125;&#125;);&#125;)(jQuery); 检查图像是否已经被完全加载进来1$('#theImage').attr('src', 'image.jpg').load(function() &#123;alert('This Image Has Been Loaded');&#125;); 使用jQuery来为事件指定命名空间123456//事件可以这样绑定命名空间$('input').bind('blur.validation', function(e)&#123;// ...&#125;);//data方法也接受命名空间$('input').data('validation.isValid', true); 检查cookie是否启用123var dt = new Date();dt.setSeconds(dt.getSeconds() + 60);document.cookie = "cookietest=1; expires=" + dt.toGMTString();var cookiesEnabled = document.cookie.indexOf("cookietest=") != -1;if(!cookiesEnabled) &#123;//没有启用cookie&#125; 让cookie过期1var date = new Date();date.setTime(date.getTime() + (x * 60 * 1000));$.cookie('example', 'foo', &#123; expires: date &#125;); 使用一个可点击的链接来替换页面中任何的URL123$.fn.replaceUrl = function() &#123;var regexp = /((ftp|http|https)://(w+:&#123;0,1&#125;w*@)?(S+)(:[0-9]+)?(/|/([w#!:.?+=&amp;%@!-/]))?)/gi;return this.each(function() &#123;$(this).html($(this).html().replace(regexp,'&lt;a href="$1"&gt;$1&lt;/a&gt;'));&#125;);&#125;//用法 $('p').replaceUrl();]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看内存]]></title>
    <url>%2F2018%2F04%2F05%2FLinux%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[方法一: free直观的展示Linux系统内存使用及交换区的容量大小方法二: top动态实时查看系统中每一个进程的资源使用情况方法三: cat /proc/meminfo方法四: gnome-system-monitor一个显示最近一段时间内的CPU、内存、交换区及网络使用情况的识图工具。方法五: ps aux –sort -rss各个线程的资源使用情况。方法六: vmstat -s vmstat命令显示实时的和平均的统计，覆盖CPU、内存、I/O等内容。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令]]></title>
    <url>%2F2018%2F04%2F05%2FGit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[需要学习的东西太多了，很多命令用到时却忘了，分享一个经典的Git 常用命清单，建议收藏，或者收进你的云笔记中，方便用到时查阅。|名词|翻译||-|:-:||workspace|工作区||Index/Stage|暂存区||Repository|仓库区(本地仓库)||Remote|远程仓库| 新建代码库在当前目录新建一个Git代码库1$ git init 新建一个目录，将其初始化为Git代码库1$ git init [project-name] 下载一个项目和它的整个代码历史1$ git clone [url] 添加或删除文件添加指定文件到暂存区1$ git add [file1] [file2]...... 添加指定目录到暂存区，包括子目录1$ git add [dir] 添加当前目录的所有文件到暂存区1$ git add . 添加每个变化前，都会要求确认。对于同一个文件的多处变化，可以实现分次提交1$ git add -p 删除工作区文件，并且将这次删除放入暂存区1$ git rm [file1] [file2]...... 停止追踪指定文件，但该文件会保留在工作区1$ git rm --cached [file] 改名文件，并且将这个改名放入暂存区1$ git mv [file-original] [file-original] 代码提交到仓库提交暂存区到仓库区1$ git commit -m [message] 提交暂存区的指定文件到仓库区1$ git commit [file1] [file2]... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区1$ git commit -a 提交时显示所有diff信息1git commit -v 使用一次新的commit，替代上一次提交。如果代码没有任何变化，则用来改写上一次commit的提交信息。1$ git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化1$ git commit --amend [file1] [file2]... 分支管理列出所有本地分支1$ git branch 列出所有远程分支1$ git branch -r 列出所有本地分支和远程分支1$ git branch -a 新建一个分支，但依然停留在当前分支1$ git branch [branch-name] 新建一个分支，并切换到该分支1$ git branch -b [branch] 新建一个分支，指向指定commit1$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系1$ git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区1$ git checkout [branch-name] 切换到上一个分支1$ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间1$ git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支1$ git merge [branch] 选择一个commit，合并进当前分支1$ git cherry-pick [commit] 删除分支1$ git branch -d [branch-name] 删除远程分支12$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签管理列出所有tag1$ git tag 新建一个tag在当前commit1$ git tag [tag] 新建一个tag在指定commit1$ git tag [tag] [commit] 删除本地tag1$ git tag -d [tag] 删除远程tag1$ git push origin :refs/tags/[tagname] 查看tag信息1$ git show [tag] 提交指定tag1$ git push [remote] [tag] 提交所有tag1$ git push [remote] --tags 新建一个分支，指向某个tag1$ git checkout -b [branch] [tag] 查看历史或统计信息显示有变更的文件1$ git status 显示当前分支的版本历史1$ git log 显示commit历史，以及每次commit发生变更的文件1$ git log --stat 搜索提交历史，根据关键词1$ git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行1$ git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件1$ git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名12$ git log --follow [file]$ git whatchanged [file] 显示指定文件相关的每一次diff1$ git log -p [file] 显示过去5次提交1$ git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序1$ git shortlog -sn 显示指定文件式什么人在什么时间修改过1$ git blame [file] 显示暂存区和工作区的差异1$ git diff 显示暂存区和上一个commit的差异1$ git diff --cached [file] 显示工作区与当前分支最新commit之间的差异1$ git diff HEAD 显示两次提交之间的差异1$ git diff [first-branch]...[second-branch] 显示今天你写了多少行代码1$ git dirr --shortstat "@&#123;0 day ago&#125;" 显示某次提交的元数据和内容变化1$ git show [commit] 显示某次提交发生变化的文件1$ git show --name-only [commit] 显示某次提交时，某个文件的内容1$ git show [commit]:[filename] 代码远程同步下载远程仓库的所有变动1$ git fetch [remote] 显示所有远程仓库1$ git remote -v 显示某个远程仓库的信息1$ git remote show [remote] 增加一个新的远程仓库，并命名1$ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并1$ git pull [remote] [branch] 上传本地指定分支到远程仓库1$ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突1$ git push [remote] --force 推送所有分支到远程仓库1$ git push [remote] --all 撤销恢复恢复暂存区的指定文件到工作区1$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区1$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区1$ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变1$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致1$ git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变1$ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致1$ git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变1$ git reset --keep [commit] 新建一个commit，用来撤销指定commit。后者的所有变化都将被前者抵消，并且应用到当前分支1$ git revert [commit] 暂时将未提交的变化移除，稍后再植入12$ git stash$ git stash pop]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解]]></title>
    <url>%2F2018%2F04%2F05%2FJava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在本文中，我们将看到五个Java编译器支持的注解，并了解其期望用途。顺便，我们将探索其创建背后的基本原理，围绕其用途的一些特质，以及正确应用的一些例子。 @Override覆盖方法的实现或为抽象方法提供实现的能力是任何面向对象(OO)语言的核心。由于Java是OO语言，具有许多常见的面向对象的抽象机制，所以在非终极超类定义的非最终方法或接口中地任何方法(接口方法不能是最终的)都可以被子类覆盖。虽然开始时覆盖方法看起来很简单，但是如果执行不正确，则可能会引入许多微小的bug。例如，用覆盖类类型的单个参数覆盖Object#equals方法就是一种常见的错误:12345public class Foo &#123; public boolean equals(Foo foo) &#123; // Check if the supplied object is equal to this object &#125;&#125; 由于所有类都隐式地从Object类继承，Foo类的目的是覆盖Object#equals方法， 因此Foo可被测试是否与Java中的任何其他对象相等。虽然我们的意图是正确的，但我们的实现则并非如此。实际上，我们的实现根本不覆盖Object#equals方法。相反，我们提供了方法的重载: 我们不是替换Object类提供的equals方法的实现，而是提供第二个方法来专门接受Foo对象，而不是Object对象。我们的错误可以简单实现来举例说明，该实现对所有的相等检查都返回true，但当提供的对象被视为Object(Java将执行的操作，例如在Java Collections Framework即JCF中)时，就永远不会调用它:12345678public class Foo &#123; public boolean equals(Foo foo) &#123; return true; &#125;&#125;Object foo = new Foo();Object identicalFoo = new Foo();System.out.println(foo.equals(identicalFoo)); // false 这是一个非常微妙但常见的错误，可以被编译器捕获。我们的意图是覆盖Object#equals方法，但因为我们指定了一个类型为Foo而不是Object类型的参数，所以我们实际上提供了重载的Object#equals方法，而不是覆盖它。为了捕获这种错误，我们引入@Override注解，它指示编译器检查覆盖实际有没有执行。如果没有执行有效的覆盖，则会抛出错误。因此，我们可以更新Foo类，如下所示:123456public class Foo &#123; @Override public boolean equals(Foo foo) &#123; return true; &#125;&#125; 如果我们尝试编译这个类，我们现在收到以下错误:12345$ javac Foo.javaFoo.java:3: error: method does not override or implement a method from a supertype@Override^1 error 实质上，我们已经将我们已经覆盖方法的这一隐含的假设转变为由编译器进行的显性验证。如果我们的意图被错误地实现，那么Java编译器会发出一个错误–不允许我们不正确实现的代码被成功编译。通常，如果以下任一条件不满足，则Java编译器将针对使用@Override注解地方法发出错误(引用自Override注解文档): 该方法确实会覆盖或实现在超类中声明地方法。 该方法的签名与在Object中声明的任何公共方法（即equals或hashCode方法）的签名覆盖等价（override-equivalent）。因此，我们也可以使用此注解来确保子类方法实际上也覆盖超类中地非最终具体方法或抽象方法: 12345678910111213141516171819public abstract class Foo &#123; public int doSomething() &#123; return 1; &#125; public abstract int doSomethingElse();&#125;public class Bar extends Foo &#123; @Override public int doSomething() &#123; return 10; &#125; @Override public int doSomethingElse() &#123; return 20; &#125;&#125;Foo bar = new Bar();System.out.println(bar.doSomething()); // 10System.out.println(bar.doSomethingElse()); // 20 @Override注解不仅不限于超类中的具体或抽象方法，而且还可用于确保接口的方法也被覆盖（从JDK 6开始）:1234567891011public interface Foo &#123; public int doSomething();&#125;public class Bar implements Foo &#123; @Override public int doSomething() &#123; return 10; &#125;&#125;Foo bar = new Bar();System.out.println(bar.doSomething()); // 10 通常，覆盖非final类方法、抽象超类方法或接口方法的任何方法都可以使用@Override进行注解。 @Functionallnterface随着JDK 8中lambda表达式的引入，函数式接口在Java中变得越来越流行。这些特殊类型的接口可以用lambda表达式、方法引用或构造函数引用代替。根据@Functionallnterface文档，函数式接口的定义如下: 一个函数式接口只有一个抽象方法。由于默认方法有一个实现，所以它们不是抽象的。 例如，以下接口被视为函数式接口:123456789public interface Foo &#123; public int doSomething();&#125;public interface Bar &#123; public int doSomething(); public default int doSomethingElse() &#123; return 1; &#125;&#125; 因此，下面的每一个都可以用lambda表达式代替，如下所示:1234567891011public class FunctionalConsumer &#123; public void consumeFoo(Foo foo) &#123; System.out.println(foo.doSomething()); &#125; public void consumeBar(Bar bar) &#123; System.out.println(bar.doSomething()); &#125;&#125;FunctionalConsumer consumer = new FunctionalConsumer();consumer.consumeFoo(() -&gt; 10); // 10consumer.consumeBar(() -&gt; 20); // 20 重点要注意的是，抽象类，即使它们只包含一个抽象方法，也不是函数式接口。与@Override注解类似，Java编译器提供了@Functionallnterface注解以确保接口确实是函数式接口。例如，我们可以将此注解添加到上面创建的接口中:1234567891011@FunctionalInterfacepublic interface Foo &#123; public int doSomething();&#125;@FunctionalInterfacepublic interface Bar &#123; public int doSomething(); public default int doSomethingElse() &#123; return 1; &#125;&#125; 如果我们错误地将接口定义为非函数接口并用@Functionallnterface注解了错误地接口，则Java编译器会发出错误。例如，我们可以定义以下带注解地非函数式接口:12345@FunctionalInterfacepublic interface Foo &#123;public int doSomething();public int doSomethingElse();&#125; 如果我们试图编译这个接口，则会收到以下错误:1234567$ javac Foo.javaFoo.java:1: error: Unexpected @FunctionalInterface annotation@FunctionalInterface^Foo is not a functional interfacemultiple non-overriding abstract methods found in interface Foo1 error 使用这个注解，我们可以确保我们不会错误地创建原本打算用作函数式接口地非函数式接口。需要注意地是，即使在@Functionallnterface注解不存在地情况下，接口也可以用作函数式接口(可以替代为lambdas，方法引用和构造函数引用)，正如我们前面地示例中所见地那样。这类似于@Override注解，即一个方法是可以被覆盖地，即使它不包含@Override注解。在这两种情况下，注解都是允许编译器执行期望意图的可选技术。 @SuppressWarnings警告是所有编译器的重要组成部分，为开发人员提供的反馈–可能危险的行为或在未来的编译器版本中可能会出现的错误。例如，在Java中使用泛型类型而没有其关联的正式型参数(称为原始类型)会导致警告，就像使用不推荐使用的代码一样(请参阅下面的@Deprecated部分)。虽然这些警告很重要，但它们可能并不总是适用甚至并不总是正确的。例如，可能会有对不安全的类型转换发生警告的情况，但是基于使用它的上下文，我们可以保证它是安全的。为了忽略某些上下文中的特定警告，JDK 5中引入了@SuppressWarnings注解。此注解接受一个或多个字符串参数–描述要忽略的警告名称。虽然这些警告的名称通常在编译器实现之间有所不同，但又3种警告在Java语言中是标准化的(因此在所有Java编译器实现中都很常见): unchecked: 表示类型转换未经检查的警告(编译器无法保证类型转换是安全的)，导致发生的可能原因有访问原始类型的成员(参见《JLS》4.8章节)、窄参考转换或不安全的向下转换(参见《JLS》5.1.6章节)、未经检查的类型转换(参见《JLS》5.1.9章节)、使用带有可变参数的泛型参数(参见《JLS》8.4.1章节和下面的@SafeVarargs部分)、使用无效的协变返回类型(参见《JLS》8.4.8.3章节)、不确定的参数评估(参见《JLS》15.12.4.2章节)、未经检查的方法引用类型的转换(参见《JLS》15.13.2章节)、或未经检查到的lambda类型的对话(参见《JLS》15.27.3章节)。 deprecation: 表示使用了已弃用的方法、类、类型等的警告(参见《JLS》9.6.4.6章节和下面的@Deprecated部分)。 removal: 表示使用了最终废弃的方法、类、类型等的警告(参见《JLS》9.6.4.6章节和下面的@Deprecated部分)。 为了忽略特定的警告，可以将@SuppressedWarning注解与抑制警告(以字符串数组的形式提供)的一个或多个名字添加到发生警告的上下文中:12345public class Foo &#123; public void doSomething(@SuppressWarnings("rawtypes") List myList) &#123; // Do something with myList &#125;&#125; @SuppressWarnings注解可用于以下任何一种情况: 类型 域 方法 参数 构造函数 局部变量 模块一般来说，@SuppressWarnings注解应该应用于最直接的警告范围。例如，如果方法中的局部变量应忽略警告，则应将@SuppressWarnings注解应用于局部变量，而不是包含局部变量的方法或类: 1234567public class Foo &#123; public void doSomething() &#123; @SuppressWarnings("rawtypes") List myList = new ArrayList(); // Do something with myList &#125;&#125; @SafeVarargs可变参数在Java中是一种很有用的技术手段，但在与泛型参数一起使用时，它们也可能会导致一些严重的问题。由于泛型在Java中式非特定的，所以具有泛型类型的变量的实际(实现)类型不能在运行时被断定。由于无法做出此判断，因此变量可能会存储非其实际类型的引用到类型，如以下代码片段所示:1234List ln = new ArrayList&lt;Number&gt;();ln.add(1);List&lt;String&gt; ls = ln; // unchecked warningString s = ls.get(0); // ClassCastException 在将ln分配给ls后，堆中存在变量ls，该变量具有List的类型，但存储引用到实际为List类型的值。这个无效的引用被称为堆污染。由于直到运行时才确定此错误，因此它会在编译时显示为警告，并在运行时出现ClassCastException。当泛型参数与可变参数组合时，可能会加剧此问题:12345public class Foo &#123; public &lt;T&gt; void doSomething(T... args) &#123; // ... &#125;&#125; 在这种情况下，Java编译器会在调用站点内部创建一个数组来存储可变数量的参数，但是T的类型并未实现，因此在运行时会丢失。实质上，到doSomething的参数实际上式Object[]类型。如果依赖T的运行时类型，那么这会导致严重的问题，如下面的代码片段所示:12345678public class Foo &#123; public &lt;T&gt; void doSomething(T... args) &#123; Object[] objects = args; String string = (String) objects[0]; &#125;&#125;Foo foo = new Foo();foo.&lt;Number&gt;doSomething(1, 2); 如果执行此代码片段，那么将导致ClassCastException，因为在调用站点传递的第一个Number参数不能转换为String（类似于独立堆污染示例中抛出的ClassCastException）。通常，可能会出现以下情况：编译器没有足够的信息来正确确定通用可变参数的确切类型，这会导致堆污染，这种污染可以通过允许内部可变参数数组从方法中转义来传播，如下面摘自《Effective Java》第3版 pp.147的例子：123public static &lt;T&gt; T[] toArray(T... args) &#123; return args;&#125; 在某些情况下，我们知道方法实际上是类型安全的，不会造成堆污染。如果可以在保证的情况下做出这个决定，那么我们可以使用@SafeVarargs注解来注解该方法，从而抑制与可能的堆污染相关的警告。但是，这引出了一个问题：什么时候通用可变参数方法会被认为是类型安全的？Josh Bloch在《Effective Java》第3版第147页的基础上提供了一个完善的解决方案——基于方法与内部创建的用于存储其可变参数的数组的交互： 如果方法没有存储任何东西到数组（这会覆盖参数）且不允许对数组的引用进行转义（这会使得不受信任的代码可以访问数组），那么它是安全的。换句话说，如果可变参数数组仅用于从调用者向方法传递可变数量的参数——毕竟，这是可变参数的目的——那么该方法是安全的。 因此，如果我们创建了以下方法（来自pp.149同上），那么我们可以用@SafeVarags注解来合理地注解我们的方法：12345678@SafeVarargsstatic &lt;T&gt; List&lt;T&gt; flatten(List&lt;? extends T&gt;... lists) &#123;List&lt;T&gt; result = new ArrayList&lt;&gt;();for (List&lt;? extends T&gt; list : lists) &#123;result.addAll(list);&#125;return result;&#125; @Deprecated在开发代码时，有时候代码会变得过时和不应该再被使用。在这些情况下，通常会有个替补的更适合手头的任务，且虽然现存的对过时代码的调用可能会保留，但是所有新的调用都应该使用替换方法。这个过时的代码被称为不推荐使用的代码。在某些紧急情况下，不建议使用的代码可能会被删除，应该在未来的框架或库版本从其代码库中删除弃用的代码之前立即转换为替换代码。了支持不推荐使用的代码的文档，Java包含@Deprecated注解，它会将一些构造函数、域、局部变量、方法、软件包、模块、参数或类型标记为已弃用。如果弃用的元素（构造函数，域，局部变量等）被使用了，则编译器发出警告。例如，我们可以创建一个弃用的类并按如下所示使用它：123@Deprecatedpublic class Foo &#123;&#125;Foo foo = new Foo(); 如果我们编译此代码（在命名为Main.java的文件中），我们会收到以下警告：123$ javac Main.javaNote: Main.java uses or overrides a deprecated API.Note: Recompile with -Xlint:deprecation for details. 通常，每当使用@Deprecated注解的元素时，都会引发警告，除了用于以下五种情况： 声明本身就被声明为是弃用的（即递归调用）。 声明被注解禁止弃用警告（即@SuppressWarnings(“deprecation”）注解，如上所述，应用于使用弃用元素的上下文。 使用和声明都在同一个最外面的类中（即，如果类调用其本身的弃用方法）。 用在import声明中，该声明导入通常不赞成使用的类型或构件（即，在将已弃用的类导入另一个类时）。 exports或opens指令内。 正如前面所说的，在某些情况下，当不推荐使用的元素将被删除，则调用代码应立即删除不推荐使用的元素（称为terminally deprecated code）。在这种情况下，可以使用forRemoval参数提供的@Deprecated注解，如下所示：12@Deprecated(forRemoval = true)public class Foo &#123;&#125; 使用此最终弃用代码会导致一系列更严格的警告：12345678$ javac Main.javaMain.java:7: warning: [removal] Foo in com.foo has been deprecated and marked for removalFoo foo = new Foo();^Main.java:7: warning: [removal] Foo in com.foo has been deprecated and marked for removalFoo foo = new Foo();^2 warnings 除了标准@Deprcated注解所描述的相同异常之外，总是会发出最终弃用的警告。我们还可以通过为注解提供since变量来添加文档到@Deprecated注解中：12@Deprecated(since = "1.0.5", forRemoval = true)public class Foo &#123;&#125; 可以使用@deprecated JavaDoc元素（注意小写字母d）进一步文档化已弃用的元素，如以下代码片段所示：1234567/*** Some test class.* @deprecated Replaced by &#123;@link com.foo.NewerFoo&#125;.* @author Justin Albano*/@Deprecated(since = "1.0.5", forRemoval = true)public class Foo &#123;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS技巧]]></title>
    <url>%2F2018%2F04%2F05%2FCSS%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[这几个CSS技巧，可以用在项目上，帮助自己很好地整理自己的元素并让他们看起来挺不错的。 黑白图像这段代码会让你的彩色照片显示为黑白照片。1img.desaturate &#123; filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%);&#125; 使用:not()在菜单上应用/取消应用边框先给每一个菜单项添加边框1/* add border*/.nav li &#123;border=right: 1px solid #666;&#125; 然后再出去最后一个元素1//remove border /.nav li: last-child &#123;border-right: none;&#125; 可以直接使用:not()伪类来应用元素:1.nav li:not(:last-child) &#123;border-right: 1px solid #666;&#125; 这样代码就干净，易读，易于理解了。当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符(~)：1..nav li: first-child ~ li &#123;border-left: 1px solid #666;&#125; 页面顶部阴影下面这个简单的CSS3代码片段可以给网页加上漂亮的顶部阴影效果:1body:before &#123; content: ""; position: fixed; top: -10px; left: 0; width: 100%; height: 10px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8); -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100;&#125; 给body添加行高你不需要分别添加line-height到每个p, h标记等，只要添加到body即可:1body&#123; line-height: 1;&#125; 这样文本元素就可以很容易地从body继承。 ##所有一切都垂直居中要将所有元素垂直居中，太简单了:1html, body &#123; height: 100%; margin: 0;&#125;body &#123; -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex;&#125; 注意: 在IE11中要小心flexbox。 逗号分隔地列表让HTML列表项看上去像一个真正地，用逗号分隔地列表:1ul &gt; li:not(:last-child)::after &#123; content: ",";&#125; 堆最后一个列表项使用:not()伪类。 使用负地nth-child选择项目在CSS中使用负地nth-child选择项目1到项目n。1li &#123; display: none;&#125;/* select items 1 through 3 and display them */li:nth-child(-n+3) &#123; display: block;&#125; 对图标使用SVG我们没有理由不对图标使用SVG:1.logo &#123; background: url("logo.svg");&#125; SVG对所有地分辨率类型都具有良好地扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。 优化显示文本有时，字体并不能在所有设备上都达到最佳地显示，所以可以让设备浏览器来帮助你:1html &#123; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;&#125; 注: 请负责人地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。 对纯CSS滑块使用max-height使用max-height和溢出隐藏来实现只有CSS地滑块:1.slider ul &#123; max-height: 0; overlow: hidden;&#125;.slider:hover ul &#123; max-height: 1000px; transition: .3s ease;&#125; 继承box-sizing让box-sizing继承html:1html &#123; box-sizing: border-box;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125; 这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。 表格单元格等宽表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽:1.calendar &#123; table-layout: fixed;&#125; 使用Flexbox摆脱外边距地各种hack当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了:1.list &#123; display: flex; justify-content: space-between;&#125;.list .person &#123; flex-basis: 23%;&#125; 现在，列表分隔符就会在均匀间隔地位置出现。 使用属性选择器用于空链接当a元素没有文本值，但 href 属性有链接的时候显示链接:1a[href^="http"]:empty::before &#123; content: attr(href); 检测鼠标双击HTML1&lt;div class="test3"&gt; &lt;span&gt;&lt;input type="text" value=" " readonly="true" /&gt; &lt;a href="http://renpingjun.com"&gt;Double click me&lt;/a&gt;&lt;/span&gt;&lt;/div&gt; CSS1.test3 span &#123; position: relative;&#125;.test3 span a &#123; position: relative; z-index: 2;&#125;.test3 span a:hover, .test3 span a:active &#123; z-index: 4;&#125;.test3 span input &#123; background: transparent; border: 0; cursor: pointer; position: absolute; top: -1px; left: 0; width: 101%; /* Hacky */ height: 301%; /* Hacky */ z-index: 3;&#125;.test3 span input:focus &#123; background: transparent; border: 0; z-index: 1;&#125; CSS写出三角形1/* create an arrow that points up */div.arrow-up &#123; width:0px; height:0px; border-left:5px solid transparent; /* left arrow slant */ border-right:5px solid transparent; /* right arrow slant */ border-bottom:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px;&#125;/* create an arrow that points down */div.arrow-down &#123; width:0px; height:0px; border-left:5px solid transparent; border-right:5px solid transparent; border-top:5px solid #2f2f2f; font-size:0px; line-height:0px;&#125;/* create an arrow that points left */div.arrow-left &#123; width:0px; height:0px; border-bottom:5px solid transparent; /* left arrow slant */ border-top:5px solid transparent; /* right arrow slant */ border-right:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px;&#125;/* create an arrow that points right */div.arrow-right &#123; width:0px; height:0px; border-bottom:5px solid transparent; /* left arrow slant */ border-top:5px solid transparent; /* right arrow slant */ border-left:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px;&#125; CSS3 calc()的使用calc() 用法类似于函数，能够给元素设置动态的值:1/* basic calc */.simpleBlock &#123; width: calc(100% - 100px);&#125;/* calc in calc */.complexBlock &#123; width: calc(100% - 50% / 3); padding: 5px calc(3% - 2px); margin-left: calc(10% + 10px);&#125; 文本渐变文本渐变效果很流行，使用 CSS3 能够很简单就实现:1h2[data-text] &#123; position: relative;&#125;h2[data-text]::after &#123; content: attr(data-text); z-index: 10; color: #e3e3e3; position: absolute; top: 0; left: 0; -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));&#125; 禁用鼠标事件CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。1.disabled &#123; pointer-events: none; &#125; 模糊文本简单但很漂亮的文本模糊效果，简单又好看！1.blur &#123; color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125; 简单的方法调整图片大小1234.content img &#123;height:auto;width:500px;&#125; IE HTML Hack12div#content &#123;width: 580px&#125;* html body div#content &#123;width: 600px&#125; CSS 阴影12345.shadow &#123;-moz-box-shadow: 3px 3px 5px 6px #ccc;-webkit-box-shadow: 3px 3px 5px 6px #ccc;box-shadow: 3px 3px 5px 6px #ccc;&#125; CSS首字放大123456789p:first-letter &#123;display: block;float: left;margin: 5px 5px 0 0;color: red;font-size: 1.4em;background: #ddd;font-family: Helvetica;&#125; 用CSS反转图像12345678#content img &#123;-moz-transform: scaleX(-1);-o-transform: scaleX(-1);-webkit-transform: scaleX(-1);transform: scaleX(-1);filter: FlipH;-ms-filter: "FlipH";&#125; 移除被点链接的点框123a &#123;outline: none&#125;或者a &#123;outline: 0&#125; 在CSS中使用特殊字体1你可以使用CSS来加载特殊字体，你要做的就是把这个TTF格式的字体上传到服务器上，然后使用字体规则在CSS上导入它。 元素透明123456.element &#123;filter:alpha(opacity=50);-moz-opacity:0.5;-khtml-opacity: 0.5;opacity: 0.5;&#125; 使用CSS显示链接之后的URL12a:after&#123;content:" (" attr(href) ") ";&#125;这会在链接锚点后显示URL。你也可以用字体或其他样式定义它。 为手持设备定制特殊样式1&lt;link type="text/css" rel="stylesheet" href="handheldstyle.css" media="handheld"&gt; 文字的水平居中1text-align:center; link状态的设置顺序1234a:linka:visiteda:hovera:active 用图片充当列表标志123456ul &#123;list-style: none&#125;ul li &#123;background-image: url("path-to-your-image");background-repeat: none;background-position: 0 0.5em;&#125; 禁止自动换行1h1 &#123; white-space:nowrap; &#125; 获得焦点的表单元素1input:focus &#123; border: 2px solid green; &#125; user-select 禁止用户选中文本123div &#123;user-select: none; /* Standard syntax */&#125; 清除手机tap事件后element 时候出现的一个高亮123* &#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125; 增强用户体验，使用伪元素实现增大点击热区12345678.btn::befoer&#123;content:"";position:absolute;top:-10px;right:-10px;bottom:-10px;left:-10px;&#125; 伪元素实现换行，替代换行标签1234inline-element ::after&#123;content:"A";white-space: pre;&#125; will-change提高页面滚动、动画等渲染性能12345678910111213141516171819202122232425/* 关键字值 */will-change: auto;will-change: scroll-position;will-change: contents;will-change: transform; /* &lt;custom-ident&gt;示例 */will-change: opacity; /* &lt;custom-ident&gt;示例 */will-change: left, top; /* 两个&lt;animateable-feature&gt;示例 */will-change的使用也要谨慎，遵循最小化影响原则，不要这样直接写在默认状态中，因为will-change会一直挂着：.will-change &#123;will-change: transform;transition: transform 0.3s;&#125;.will-change:hover &#123;transform: scale(1.5);&#125;可以让父元素hover的时候，声明will-change，这样，移出的时候就会自动remove，触发的范围基本上是有效元素范围。.will-change-parent:hover .will-change &#123;will-change: transform;&#125;.will-change &#123;transition: transform 0.3s;&#125;.will-change:hover &#123;transform: scale(1.5);&#125; box-sizing 让元素的宽度、高度包含border和padding123&#123;box-sizing: border-box;&#125; calc() function, 计算属性值1234div &#123;width: calc(100% - 100px);&#125;例子就是让宽度为100%减去100px的值 css实现不换行、自动换行、强制换行1234567//不换行white-space:nowrap;//自动换行word-wrap: break-word;word-break: normal;//强制换行word-break:break-all; perspective 透视1234这个属性的存在决定你看到的元素是2d还是3d。一般设置在包裹元素的父类上。.div-box &#123;perspective: 400px;&#125; 设置图像透明度的两种方式12opcity:0.6；background:rgba(0,0,0,.6)； position定位属性123456position属性指定一个元素(静态的、相对的、绝对或固定)的定位方法的类型。position的属性值：absolute：生成绝对定位的元素；fixed：生成绝对定位的元素，相对于浏览器窗口进行定位；relative：生成相对定位的元素，相对于其正常位置经行定位。z-index：指定一个元素的堆叠顺序。 cursor属性123456789cursor属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状。CSS提供的cursor值：pointer ：小手指；help：箭头加问号；wait：转圈圈；move：移动光标；crosshair：十字光标。通过pointer属性我们可以伪造超链接：&lt;span style="cursor:pointer;color:blue;"&gt;pointer&lt;/span&gt; 隐藏没有静音、自动播放的影片123video[autoplay]:not([muted]) &#123;display: none;&#125; Font-Size 基准1234/* 假设浏览器的默认的大小是 16px ， 首先将其设置为10px (font-size:10/16) */body &#123;font-size:10/16;&#125;/* 然后就可以用em做统一字体单位了 2.4em = 24px */h1 &#123;font-size: 2.4 em&#125; 透明容器123456.element &#123;filter:alpha(opacity=50); /* for ie */-moz-opacity:0.5; /* for ff */-khtml-opacity: 0.5; /* for webkit as chrome */opacity: 0.5; /* for opera */&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多态的实现原理]]></title>
    <url>%2F2018%2F04%2F03%2FJava%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java多态概述&nbsp;&nbsp;&nbsp;&nbsp;多态是面向对象编程语言的重要特性，它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。Java对于方法调用动态绑定的实现主要依赖于方法表，但通过类引用调用(invokevitual)和接口引用调用(invokeinterface)的实现则有所不同。&nbsp;&nbsp;&nbsp;&nbsp;类引用调用的大致过程为:Java编译器将Java源代码编译成class文件，在编译过程中，会根据静态类型将调用的符号引用写到class文件中。在执行时，JVM根据class文件找到调用方法的符号引用，然后在静态类型的方法表中找到偏移量，然后根据this指针确定对象的实际类型，使用实际类型的方法表，偏移量跟静态类型中方法表的偏移量一样，如果在实际类型的方法表中找到该方法，则直接调用，否则，认为没有重写父类该方法。按照继承关系从下往上搜索。&nbsp;&nbsp;&nbsp;&nbsp;从上图可以看出，当程序运行时，需要某个类时，类载入子系统会将相应的class文件载入到JVM中，并在内部建立该类的类型信息（这个类型信息其实就是class文件在JVM中存储的一种数据结构），包含java类定义的所有信息，包括方法代码，类变量、成员变量、以及本博文要重点讨论的方法表。这个类型信息就存储在方法区。&nbsp;&nbsp;&nbsp;&nbsp;注意，这个方法区中的类型信息跟在堆中存放的class对象是不同的。在方法区中，这个class的类型信息只有唯一的实例（所以是各个线程共享的内存区域），而在堆中可以有多个该class对象。可以通过堆中的class对象访问到方法区中类型信息。就像在java反射机制那样，通过class对象可以访问到该类的所有信息一样。方法表是实现动态调用的核心。上面讲过方法表存放在方法区中的类型信息中。为了优化对象 调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表， 方法表中的每一个项都是对应方法的指针。这些方法中包括从父类继承的所有方法以及自身重写（override）的方法。方法区:方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池:它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。方法区的内存回收目标是针对常量池的回收及对类型的卸载。 Java的方法调用方式 1、Java 的方法调用有两类，动态方法调用与静态方法调用。2、静态方法调用是指对于类的静态方法的调用方式，是静态绑定的；而动态方法调用需要有方法调用所作用的对象，是动态绑定的。3、类调用 (invokestatic) 是在编译时就已经确定好具体调用方法的情况。4、实例调用 (invokevirtual)则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。5、JVM 的方法调用指令有四个，分别是 invokestatic，invokespecial，invokesvirtual 和 invokeinterface。前两个是静态绑定，后两个是动态绑定的。本文也可以说是对于JVM后两种调用实现的考察。 方法表与方法调用如有类定义Persion、Girl、Boy123456789101112131415161718192021222324class Person &#123; public String toString()&#123; return "I'm a person."; &#125; public void eat()&#123;&#125; public void speak()&#123;&#125; &#125; class Boy extends Person&#123; public String toString()&#123; return "I'm a boy"; &#125; public void speak()&#123;&#125; public void fight()&#123;&#125; &#125; class Girl extends Person&#123; public String toString()&#123; return "I'm a girl"; &#125; public void speak()&#123;&#125; public void sing()&#123;&#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;当这三个类被载入到Java虚拟机之后，方法区中就包含了各自的类的信息。&nbsp;&nbsp;&nbsp;&nbsp;Girl 和 Boy 的方法表包含继承自 Object 的方法，继承自直接父类Person的方法及各自新定义的方法。注意方法表条目指向的具体的方法地址，如 Girl 继承自Object的方法中，只有 toString()指向自己的实现（Girl 的方法代码），其余皆指向 Object 的方法代码；其继承自于 Person 的方法 eat() 和 speak() 分别指向 Person 的方法实现和本身的实现。&nbsp;&nbsp;&nbsp;&nbsp;如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。&nbsp;&nbsp;&nbsp;&nbsp;因此，方法表的偏移量总是固定的。所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。&nbsp;&nbsp;&nbsp;&nbsp;Person或Object中的任意一个方法，在它们的方法表和其子类 Girl和Boy的方法表中的位置(index)是一样的。这样 JVM在调用实例方法其实只需要指定调用方法表中的第几个方法即可。 接口调用&nbsp;&nbsp;&nbsp;&nbsp;因为 Java 类是可以同时实现多个接口的，而当用接口引用调用某个方法的时候，情况就有所不同了。&nbsp;&nbsp;&nbsp;&nbsp;Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同样的方法在基类和派生类的方法表的位置就可能不一样了。1234567891011121314151617181920212223242526272829interface IDance&#123; void dance(); &#125; class Person &#123; public String toString()&#123; return "I'm a person."; &#125; public void eat()&#123;&#125; public void speak()&#123;&#125; &#125; class Dancer extends Person implements IDance &#123; public String toString()&#123; return "I'm a dancer."; &#125; public void dance()&#123;&#125; &#125; class Snake implements IDance&#123; public String toString()&#123; return "A snake."; &#125; public void dance()&#123; //snake dance &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，由于接口的介入，继承自于接口 IDance 的方法 dance()在类Dancer和Snake的方法表中的位置已经不一样了，显然我们无法仅根据偏移量来进行方法的调用。&nbsp;&nbsp;&nbsp;&nbsp;Java对于接口方法的调用是采用搜索方法表的方式，如，要在Dancer的方法表中找到dance()方法，必须搜索Dancer的整个方法表。&nbsp;&nbsp;&nbsp;&nbsp;因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是慢于类方法的调用的。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悲观锁与乐观锁]]></title>
    <url>%2F2018%2F04%2F02%2F%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在数据库的锁机制中介绍过，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。&nbsp;&nbsp;&nbsp;&nbsp;乐观并发控制(乐观锁)和悲观并发控制(悲观锁)是并发控制主要采用的技术手段。&nbsp;&nbsp;&nbsp;&nbsp;无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。&nbsp;&nbsp;&nbsp;&nbsp;针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。 悲观锁 &nbsp;&nbsp;&nbsp;&nbsp;在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。&nbsp;&nbsp;&nbsp;&nbsp;悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 &nbsp;&nbsp;&nbsp;&nbsp;悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）在数据库中，悲观锁的流程如下: &nbsp;&nbsp;&nbsp;&nbsp;在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。&nbsp;&nbsp;&nbsp;&nbsp;如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。&nbsp;&nbsp;&nbsp;&nbsp;如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。&nbsp;&nbsp;&nbsp;&nbsp;其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 MySQL InnoDB中使用悲观锁 &nbsp;&nbsp;&nbsp;&nbsp;要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0; 12345678910//0.开始事务begin;/begin work;/start transaction; (三者选一就可以)//1.查询出商品信息select status from t_goods where id=1 for update;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;//4.提交事务commit;/commit work; &nbsp;&nbsp;&nbsp;&nbsp;上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 &nbsp;&nbsp;&nbsp;&nbsp;上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 优点与不足&nbsp;&nbsp;&nbsp;&nbsp;悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。 乐观锁 &nbsp;&nbsp;&nbsp;&nbsp;在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。 &nbsp;&nbsp;&nbsp;&nbsp;乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。&nbsp;&nbsp;&nbsp;&nbsp;相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 &nbsp;&nbsp;&nbsp;&nbsp;数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。&nbsp;&nbsp;&nbsp;&nbsp;实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。 使用版本号实现乐观锁&nbsp;&nbsp;&nbsp;&nbsp;使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。12345671.查询出商品信息select (status,status,version) from t_goods where id=#&#123;id&#125;2.根据商品信息生成订单3.修改商品status为2update t_goods set status=2,version=version+1where id=#&#123;id&#125; and version=#&#123;version&#125;; 优点与不足&nbsp;&nbsp;&nbsp;&nbsp;乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的锁机制]]></title>
    <url>%2F2018%2F04%2F02%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在并发访问情况下，可能会出现脏读、不可重复读和幻读等读现象，为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念。 并发控制 在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制是确保及时纠正由并发操作导致的错误的一种机制。 &nbsp;&nbsp;&nbsp;&nbsp;数据库管理系统(DBMS)中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不被破坏事务的隔离性和统一性以及数据库的统一性。下面举例说明并发操作 带来的数据不一致性问题:&nbsp;&nbsp;&nbsp;&nbsp;现有两处火车票售票点，同时读取某一趟列车车票数据库中车票余额为 X。两处售票点同时卖出一张车票，同时修改余额为 X -1写回数据库，这样就造成了实际卖出两张火车票而数据库中的记录却只少了一张。 产生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。&nbsp;&nbsp;&nbsp;&nbsp;封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制(悲观锁)是并发控制主要采用的技术手段。 锁&nbsp;&nbsp;&nbsp;&nbsp;当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。&nbsp;&nbsp;&nbsp;&nbsp;在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。锁的分类12345按操作划分，可分为DML锁、DDL锁按锁的粒度划分，可分为表级锁、行级锁、页级锁(mysql)按锁级别划分，可分为共享锁、排他锁按加锁方式划分，可分为自动锁、显示锁按使用方式划分，可分为乐观锁、悲观锁 &nbsp;&nbsp;&nbsp;&nbsp;DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁))。 DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义。其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程通信]]></title>
    <url>%2F2018%2F04%2F01%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。 如何让两个线程依次执行&nbsp;&nbsp;&nbsp;&nbsp;假设有两个线程，一个是线程A，另一个是线程B，两个线程分别依次打印1-3三个数字即可。代码如下:123456789101112131415161718192021222324252627282930313233public class long1_1&#123; private static void demo1() &#123; Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; printNumber("A"); &#125; &#125;); Thread B = new Thread(new Runnable() &#123; @Override public void run() &#123; printNumber("B"); &#125; &#125;); A.start(); B.start(); &#125; private static void printNumber(String threadName) &#123; int i=0; while (i++ &lt; 3) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadName + "print:" + i); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果:&nbsp;&nbsp;&nbsp;&nbsp;可以看到A和B是同时打印的。&nbsp;&nbsp;&nbsp;&nbsp;那么，如果我们希望B在A全部打印完后再开始打印呢？可以利用thread.join()方法，代码如下:123456789101112131415161718192021222324252627282930313233343536373839public class long1_1&#123; private static void demo1() &#123; Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; printNumber("A"); &#125; &#125;); Thread B = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("B 开始等待 A"); try &#123; A.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; printNumber("B"); &#125; &#125;); B.start(); A.start(); &#125; private static void printNumber(String threadName) &#123; int i=0; while (i++ &lt; 3) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadName + "print:" + i); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果: 如何让两个线程按照指定方式有序交叉运行？&nbsp;&nbsp;&nbsp;&nbsp;A在打印完1后，再让B打印1，2，3，最后再回到A继续打印2，3。这种需求下，显然Thread.join()已经不能满足了。我们需要更细粒度的锁来控制执行顺序。这里可以用object.wait()和object.notify()两个方法来实现。代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class long1_1&#123; private static void demo1() &#123; Object lock = new Object(); Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("INFO: A 等待锁"); synchronized (lock) &#123; System.out.println("INFO: A 得到了锁 lock"); System.out.println("A 1"); try &#123; System.out.println("INFO: A 准备进入等待状态，放弃锁 lock 的控制权"); lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("INFO: 有人唤醒了 A, A 重新获得锁 lock"); System.out.println("A 2"); System.out.println("A 3"); &#125; &#125; &#125;); Thread B = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("INFO: B 等待锁"); synchronized (lock) &#123; System.out.println("INFO: B 得到了锁 lock"); System.out.println("B 1"); System.out.println("B 2"); System.out.println("B 3"); System.out.println("INFO: B 打印完毕，调用 notify 方法"); lock.notify(); &#125; &#125; &#125;); A.start(); B.start(); &#125; private static void printNumber(String threadName) &#123; int i=0; while (i++ &lt; 3) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadName + "print:" + i); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果:&nbsp;&nbsp;&nbsp;&nbsp;那么，这个过程发生了什么呢？ 1、首先创建一个A和B共享的对象锁lock = new Object();2、当A得到锁后，先打印1，然后调用lock.wait()方法，交出锁的控制权，进入wait状态；3、对B而言，由于A最开始得到了锁，导致B无法执行；直到A调用lock.wait()释放控制权后，B才得到了锁；4、B在得到锁后打印1，2，3；然后调用lock.notify()方法，唤醒正在 wait的A;5、A被唤醒后，继续打印剩下的2，3。 四个线程ABCD，其中D要等到ABC全执行完毕后才执行，而且ABC是同步运行的&nbsp;&nbsp;&nbsp;&nbsp;A，B，C三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要A，B，C都运行完了，D再开始运行。针对这种情况，我们可以利用CountdownLatch来实现这类通信方式。它的基本用法是： 1、创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);2、在等待线程里调用countDownLatch.await()方法，进入等待状态，直到计数值变成0；3、在其他线程里，调用countDownLatch.countDown()方法，该方法会将计数值减小1；4、当其他线程的countDown()方法把计数值变成0时，等待线程里的countDownLatch.await()立即退出，继续执行下面的代码。代码如下:12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.CountDownLatch;public class long1_1&#123; private static void demo1() &#123; int worker = 3; CountDownLatch countDownLatch = new CountDownLatch(worker); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("D is waiting for other three threads"); try &#123; countDownLatch.await(); System.out.println("All done, D starts working"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); for (char threadName='A'; threadName &lt;= 'C'; threadName++) &#123; final String tN = String.valueOf(threadName); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(tN + "is working"); try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(tN + "finished"); countDownLatch.countDown(); &#125; &#125;).start(); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果:&nbsp;&nbsp;&nbsp;&nbsp;其实简单点来说，CountDownLatch就是一个倒计数器，我们把初始计数值设置为3，当D运行时，先调用countDownLatch.await()检查计数器值是否为0，若不为0则保持等待状态；当ABC各自运行完后都会利用countDownLatch.countDown()，将倒计数器减1，当三个都运行完后，计数器被减至0；此时立即触发D的await()运行结束，继续向下执行。因此，CountDownLatch适用于一个线程去等待多个线程的情况。 线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行。&nbsp;&nbsp;&nbsp;&nbsp;为了实现线程间互相等待这种需求，我们可以利用 CyclicBarrier 数据结构，它的基本用法是： 1、先创建一个公共CyclicBarrier对象，设置同时等待的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);2、这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用cyclicBarrier.await(); 即可开始等待别人；3、当指定的 同时等待的线程数都调用了。cyclicBarrier.await();时，意味着这些线程都准备完毕好，然后这些线程才 同时继续执行。代码如下:123456789101112131415161718192021222324252627282930313233343536373839import java.util.Random;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class long1_1&#123; private static void demo1() &#123; int runner = 3; CyclicBarrier cyclicBarrier = new CyclicBarrier(runner); final Random random = new Random(); for (char runnerName='A'; runnerName &lt;= 'C'; runnerName++) &#123; final String rN = String.valueOf(runnerName); new Thread(new Runnable() &#123; @Override public void run() &#123; long prepareTime = random.nextInt(10000) + 100; System.out.println(rN + "is preparing for time:" + prepareTime); try &#123; Thread.sleep(prepareTime); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; System.out.println(rN + "is prepared, waiting for others"); cyclicBarrier.await(); // 当前运动员准备完毕，等待别人准备好 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(rN + "starts running"); // 所有运动员都准备好了，一起开始跑 &#125; &#125;).start(); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果: 子线程完成某件任务后，把得到的结果回传给主线程&nbsp;&nbsp;&nbsp;&nbsp;实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？&nbsp;&nbsp;&nbsp;&nbsp;回顾线程的创建，我们一般会把 Runnable 对象传给 Thread 去执行。Runnable定义如下：123public interface Runnable&#123; public abstract void run();&#125; &nbsp;&nbsp;&nbsp;&nbsp;可以看到 run() 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 Callable：123456789@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; &nbsp;&nbsp;&nbsp;&nbsp;可以看出 Callable 最大区别就是返回范型 V 结果。&nbsp;&nbsp;&nbsp;&nbsp;那么下一个问题就是，如何把子线程的结果回传回来呢？在Java里，有一个类是配合Callable使用的：FutureTask，不过注意，它获取结果的 get 方法会阻塞主线程。&nbsp;&nbsp;&nbsp;&nbsp;举例，我们想让子线程去计算从 1 加到 100，并把算出的结果返回到主线程。123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class long1_1&#123; private static void demo1() &#123; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; System.out.println("Task starts"); Thread.sleep(1000); int result = 0; for (int i=0; i&lt;=100; i++) &#123; result += i; &#125; System.out.println("Task finished and return result"); return result; &#125; &#125;; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callable); new Thread(futureTask).start(); try &#123; System.out.println("Before futureTask.get()"); System.out.println("Result:" + futureTask.get()); System.out.println("After futureTask.get()"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果:&nbsp;&nbsp;&nbsp;&nbsp;可以看到，主线程调用 futureTask.get() 方法时阻塞主线程；然后 Callable 内部开始执行，并返回运算结果；此时 futureTask.get() 得到结果，主线程恢复运行。&nbsp;&nbsp;&nbsp;&nbsp;通过 FutureTask 和Callable可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 ExecutorService，把 FutureTask 放到线程池去管理执行。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equal()和hashCode()比较]]></title>
    <url>%2F2018%2F04%2F01%2Fequal-%E5%92%8ChashCode-%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;equal()反映的是对象或变量具体的值，即两个对象里面包含的值–可能是对象的引用，也可能是值类型的值。&nbsp;&nbsp;&nbsp;&nbsp;而hashCode()是对象或变量通过哈希算法计算出的哈希值。&nbsp;&nbsp;&nbsp;&nbsp;之所以有hashCode()方法，是因为在批量的对象比较中，hashCode要比equals来的快，很多集合都用到了hashCode，比如HashTable。 两个obj，如果equals()相等，hashCode()一定相等。两个obj，如果hashCode()相等，equals()不一定相等(Hash散列值由冲突的情况，虽然概率很低)。所以: 可以考虑在集合中，判断两个对象是否相等的规则是:第一步: 如果hashCode()相等，则查看第二步，否则不相等。第二步: 查看equals()是否相等，如果相等，则两obj相等，否则还是不相等。 1、equals()和hashCode()这两个方法都是从Object类中继承过来的 equals()是对两个对象的地址值进行的比较(即比较引用是否相同)。hashCode()是一个本地方法。它的实现是根据本地机器相关的。 2、Java语言对equals()的要求如下，这些要求是必须遵循的: A) 对称性: 如果x.equals(y)返回是”true”，那么y.equals(x)也应该返回是”true”。B) 反射性: x.equals(x)必须返回是”true”。C) 类推性: 如果x.equals(y)返回是”true”，而且y.equals(z)返回是”true”，那么z.equals(x)也应该返回是”true”。D) 一致性: 如果x.equals(y)返回是”true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是”true”。任何情况下，x.euqals(null)，永远返回是”false”；x.equals(和x不同类型的对象)永远返回是”false”。 3、equals()和hashCode() equals()相等的两个对象，hashCode()一定相等；反过来: hashCode()不等，一定能推出equals()也不等；hashCode()相等，equals()可能相等，也可能不等。 1、为什么要重载equal方法？ 因为Object的equal方法默认是两个对象的引用的比较，意思就是指向同一内存，地址则相等；如果你现在需要利用对象里面的值来判断是否相等，则重载equal方法。 2、为什么重置hashCode方法？ 一般的地方不需要重置hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode，那么为什么要重载hashCode呢？就HashMap来说，好比HashMap就是一个大内存块，里面有很多小内存块，小内存块里面是一系列的对象，可以利用hashCode来查找小内存块hashCode%size(小内存块数量)，所以当equal相等时，hashCode必须相等，而且如果是Object对象，必须重载hashCode和equal方法。 3、为什么equal()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等? 1、因为是按照hashCode来访问小内存块，所以hashCode必须相等。2、HashMap获取一个对象是比较key的hashCode相等和equal为true。之所以hashCode相等，却可以equal不等，就比如ObjectA和ObjectB他们都有属性name，那么hashCode都以name计算，所以hashCode一样，但是两个对象属于不同类型，所以equal为false。 4、为什么需要HashCode？ 1、 通过hashCode可以很快的查到小内存块。2、通过hashCode比较比equal方法快，当get时先比较hashCode，如果hashCode不同，直接返回false。 5、hashCode()作用 hashCode()方法使用来提高Map里面的搜索效率的,Map会根据不同的hashCode()来放在不同的桶里面,Map在搜索一个对象的时候先通过hashCode()找到相应的桶,然后再根据equals()方法找到相应的对象。 6、Java中的集合（Collection）有两类，一类是List，再有一类是Set。你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。&nbsp;&nbsp;&nbsp;&nbsp;那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是Object.equals方法了。&nbsp;&nbsp;&nbsp;&nbsp;但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。&nbsp;&nbsp;&nbsp;&nbsp;也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。&nbsp;&nbsp;&nbsp;&nbsp;哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。我们可以认为hashCode方法返回的就是对象存储的物理地址（实际可能并不是,例如:通过获取对象的物理地址然后除以8再求余,余数几是计算得到的散列值,我们就认为返回一个不是物理地址的数值,而是一个可以映射到物理地址的值）。&nbsp;&nbsp;&nbsp;&nbsp;这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类及其常用方法]]></title>
    <url>%2F2018%2F04%2F01%2FObject%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Object类是一个特殊的类，是所有类的父类，如果一个类没有用extends明确指出继承于某个类，那么它默认继承Object类。Object类中三个常用的方法: toString()、equals()、hashCode()。 取得对象信息的方法: toString()该方法在打印对象时候被调用，将对象信息变为字符串返回，默认输出对象地址。12345678910111213class Students&#123; String name= "zhangsan"; int age= 21;&#125;public class long1_1&#123; public static void main(String[] args) &#123; Students students= new Students(); System.out.println("姓名: "+ students.name+ ", 年龄: "+ students.age);//输出对象属性 System.out.println(students);//直接输出对象信息 System.out.println(students.toString());//调用父类方法输出对象信息 &#125;&#125; 输出结果:上述结果可看出编译器默认调用toString()方法输出对象，但输出的是对象的地址，我们并不能看懂它的意思。就要通过重写Object类的toString()方法来输出对象属性信息。12345678910111213141516class Students&#123; String name= "zhangsan"; int age= 21; public String toString() &#123; return "姓名: "+ name+ ", 年龄: "+ age; &#125;&#125;public class long1_1&#123; public static void main(String[] args) &#123; Students students= new Students(); System.out.println("姓名: "+ students.name+ ", 年龄: "+ students.age);//输出对象属性 System.out.println(students);//直接输出对象信息 System.out.println(students.toString());//调用父类方法输出对象信息 &#125;&#125; 输出结果: 对象相等判断方法: equals()该方法用于比较帝乡是否相等，而且此方法必须被重写。1234567891011121314151617class Students&#123; String name; int age; public Students(String name, int age) &#123; this.name= name; this.age= age; &#125;&#125;public class long1_1&#123; public static void main(String[] args) &#123; Students s1= new Students("zhangsang", 21); Students s2= new Students("lisi", 21); System.out.println(s1.equals(s2)); System.out.println(s1.equals(s2)?"s1和s2是同一个人": "s1和s2不是同一个人"); &#125;&#125; 输出结果:很明显输出的结果是错误的，因为equals()方法比较的是两个对象的地址 ，所以必须重写方法才能到达目的。1234567891011121314151617181920212223242526class Student&#123; String name; int age; //重写父类（Object类）中的equals方法 public boolean equals()&#123; boolean temp; Student s1 = new Student(); s1.name="张三";s1.age=12; Student s2 = new Student(); s2.name="张三";s2.age=12; if((s1.name.equals(s2.name))&amp;&amp;(s1.age==s2.age))&#123; temp = true; &#125; else&#123; temp = false; &#125; return temp; &#125;&#125;public class long1_1&#123; public static void main(String[] args)&#123; Student s3 = new Student(); System.out.println(s3.equals()?"是同一人":"不是同一人"); &#125;&#125; 对象签名: hashCode()该方法用来返回其所在对象的物理地址(哈希码值)，常会和equals方法同时重写，确保相等的两个对象拥有相等的hashCode。123456789101112131415161718192021222324252627282930313233class Student&#123; String name; int age; //重写父类（Object类）中的equals方法 public boolean equals()&#123; boolean temp; Student s1 = new Student(); s1.name="张三";s1.age=12; Student s2 = new Student(); s2.name="张三";s2.age=12; System.out.println("s1的哈希码："+s1.hashCode()); System.out.println("s2的哈希码："+s2.hashCode()); if((s1.name.equals(s2.name))&amp;&amp;(s1.age==s2.age))&#123; temp = true; &#125; else&#123; temp = false; &#125; return temp; &#125; //重写hashCode()方法 public int hashCode()&#123; return age*(name.hashCode()); &#125;&#125;public class long1_1&#123; public static void main(String[] args)&#123; Student s3 = new Student(); System.out.println(s3.equals()?"s1和s2是同一人":"s1和s2不是同一人"); &#125;&#125; 输出结果:]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务及其四个特性]]></title>
    <url>%2F2018%2F04%2F01%2FMySQL%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%85%B6%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[事务概念引入&nbsp;&nbsp;&nbsp;&nbsp;现实生活中，我们往往经常会进行转账操作，转账操作可以分为两部分来完成，转入和转出。只有这两部分都完成了才可以认为是转账成功。在数据库中，这个过程是使用两条语句来完成的，如果其中任意一条语句出现了异常没有执行，则会导致两个账号的金额不同步，造成错误。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了防止上面可能出现的情况，MySQL引入了事务，所谓事务就是针对数据库的一组操作，它可以由一条或多条SQL语句组成，同一个事务的操作具备同步的特点，如果其中有一条语句不能执行的话，那么所有的语句都不会执行，也就是说，事务中的语句要么都执行，要么都不执行。&nbsp;&nbsp;&nbsp;&nbsp;在使用数据库时候需要使用事务，必须先开启事务，开启事务的语句具体如下:start transaction;即:上面语句是用来开启事务，事务开启之后就可以执行SQL语句，SQL语句执行成功之后，需要使用相应语句提交事务，提交事务的语句如下:commit;需要注意的是，在MySQL中直接书写SQL语句都是自动提交的，而事务中的操作语句需要使用commit语句手动提交，只有事务提交后其中的操作才会生效。如果不想提交事务，我们还可以使用相关语句取消事务(也称回滚)，具体语句如下:rollback;注: rollback语句只能针对未提交的事务执行的回滚操作，已经提交的事务是不能回滚的。 事务的四个基本要素(ACID)ACID，指数据库事务正确执行的四个基本要素的缩写。包含: 原子性、一致性、隔离性、持久性。1234原子性: 原子性意味着事务的整体性和不可分割性，这就类似化学中的原子，是一个不可分割的单元。一个事务可以是一个（任务）操作，也可以是多个（任务）操作，假设一个事务由多个操作（任务）组成，那么这些操作必须都执行成功这个事务才被认为执行成功，只要其中有一个任务执行失败那么整个事务都会被认为执行失败，导致自动回滚到初始状态，通俗来讲就是“同进退”，这保证了事务的整体性。这就是事物的原子性。 专业来讲，原子的执行是一个全部发生或全部失败的整体过程。在一个原子操作中，如果事务中的任何一个语句失败，前面执行的语句都将被返回，以保证数据的整体性不被破坏。这在常用的系统应用中，为保证数据的安全性起到一定作用。 一致性: 在MySql事务处理过程中，无论事务是完全成功或是在中途因某些环节失败而导致失败，但事务使系统处于一致的状态时，必须保持一致性，用户A向用户B的账户中转入5000元，但用户B在查询转账信息的时候，发现自己的账户只增加了3000元，这样不能使整个事务达到一致性。 在MySql中，一致性主要由MySql的日志机制处理，它记录数据库的所有变化，为事务回复提供跟踪记录。如果系统在事务处理中间发生错误，MySql恢复过程将使用这些日志发现事务是否已经完全成功执行或需要返回。一致性属性保证数据库从不返回一个未处理的事务。隔离性: 它是指每个事务在自己的空间发生，和其他发生在系统中的事务隔离，而且事务的结果只在它完全被执行的时候才能看到，如果该事务未提交，则其他会话看不到执行的结果。这样的话即使一个系统中同时发生多个事务，孤立性也可以保证特定的事务在完成之前，其结果是不被公布的。当系统支持多个同时存在的用户和连接时，系统必须遵守孤立性原则，否则在执行过程中可能导致大量数据被破坏，孤立性保证每个事务完整地在其各自的空间内被顺序的执行，保证事务之间不会相互冲突。持久性: 在MySql中，即使是数据库系统崩溃，一个提交的事务仍然在坚持。当一个事务完成，数据库的日志已经被更新时，持久性即可发挥其特有功效。在MySql中，如果系统崩溃或者数据存储介质被破坏，通过使用日志，系统能够恢复在重启前进行的最后一次成功更新，可以反应系统崩溃时处于执行过程的事务的变化。 MySql的持久性是通过一条记录事务过程中系统变化的二进制事务日志文件来实现的。如果遇到硬件损坏或者系统的异常关机，系统在下一次启动时，通过使用最后的备份和日志就可以恢复丢失数据。 如何使用事务？12345678create databases test;use test;create table accounts(id int primary key auto_increment,name varchar(40),money float);insert into accounts(name, money) values('a', 1000);insert into accounts(name, money) values('b', 1000); 执行效果如下:演示使用事务来实现转账功能:首先开启一个事务，然后通过update语句将a账户的100元转给b账户，然后提交事务，具体语句如下:1234start transaction;update account set money= money- 100 where name= 'a';update account set money= money+ 100 where name= 'b';commit; 执行效果如下:]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程]]></title>
    <url>%2F2018%2F03%2F31%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java多线程实现方式主要有四种:&nbsp;&nbsp;&nbsp;&nbsp;继承Thread类，重写run方法、实现Runnable接口，重写run方法，实现Run nable接口的实现类的实例对象作为Thread构造函数的target、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程(线程池)。&nbsp;&nbsp;&nbsp;&nbsp;其中前两种方式线程执行完后都没有返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果。后两种是带返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中。 继承Thread类的线程123456789101112131415public class long1_1 extends Thread &#123; public long1_1()&#123; //编写子类的构造方法，可缺省 &#125; public void run()&#123; //编写自己的线程代码 System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args)&#123; long1_1 threadDemo01 = new long1_1(); threadDemo01.setName("我是自定义的线程1"); threadDemo01.start(); System.out.println(Thread.currentThread().toString()); &#125;&#125; 输出结果: 通过实现Runnable接口、实现run方法，接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，通过调用start()方法启动线程。12345678910111213141516public class long1_1 &#123; public static void main(String[] args)&#123; System.out.println(Thread.currentThread().getName()); Thread t1 = new Thread(new MyThread()); t1.start(); &#125;&#125;class MyThread implements Runnable&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()+"--&gt;我是通过实现接口的线程实现方式！"); &#125; &#125; 输出结果: 通过Callable和FutureTask创建线程a: 创建Callable接口的实现类，并实现Call方法b: 创建Callable实现类的实现，使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的Call方法的返回值c: 使用FutureTask对象作为Thread对象的target创建并启动线程d: 调用FutureTaske对象的get()来获取子线程执行结束的返回值1234567891011121314151617181920212223242526import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;public class long1_1 &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Callable&lt;Object&gt; oneCallable = new Tickets&lt;Object&gt;(); FutureTask&lt;Object&gt; oneTask = new FutureTask&lt;Object&gt;(oneCallable); Thread t = new Thread(oneTask); System.out.println(Thread.currentThread().getName()); t.start(); &#125;&#125;class Tickets&lt;Object&gt; implements Callable&lt;Object&gt;&#123; //重写call方法 @Override public Object call() throws Exception &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()+"--&gt;我是通过实现Callable接口通过FutureTask包装器来实现的线程"); return null; &#125; &#125; 输出结果: 通过线程池创建线程123456789101112131415161718192021222324252627282930import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class long1_1&#123; private static int POOL_NUM = 10; //线程池数量 /** * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; // TODO Auto-generated method stub ExecutorService executorService = Executors.newFixedThreadPool(5); for(int i = 0; i&lt;POOL_NUM; i++) &#123; RunnableThread thread = new RunnableThread(); //Thread.sleep(1000); executorService.execute(thread); &#125; //关闭线程池 executorService.shutdown(); &#125; &#125;class RunnableThread implements Runnable &#123; @Override public void run() &#123; System.out.println("通过线程池方式创建的线程：" + Thread.currentThread().getName() + " "); &#125; &#125; 输出结果:ExecutorService、Callable都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，还有Future接口也是属于这个框架。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList和LinkedList的区别]]></title>
    <url>%2F2018%2F03%2F31%2FArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ArrayList和LinkedList是常用的两种存储结构。123456ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表的数据结构。这俩都是对List接口的实现。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList是线性的数据存储方式，需要移动指针从前往后依次查找。对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要移动数据。从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。ArrayList主要控件开销在于需要在List列表预留一定空间；而LinkedList主要控件开销在于需要存储结点信息以及结点指针信息。LinkedList需要更多的内存空间，因为它除了要存储数据之外，还需要存储该结点的前后结点信息，而ArrayList索引处就是存的数据。 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class long1_1 &#123; static final int N=50000; static long timeList(List list)&#123; long start=System.currentTimeMillis(); Object o = new Object(); for(int i=0;i&lt;N;i++) &#123; list.add(0, o); &#125; return System.currentTimeMillis()-start; &#125; static long readList(List list)&#123; long start=System.currentTimeMillis(); for(int i=0,j=list.size();i&lt;j;i++)&#123; &#125; return System.currentTimeMillis()-start; &#125; static List addList(List list)&#123; Object o = new Object(); for(int i=0;i&lt;N;i++) &#123; list.add(0, o); &#125; return list; &#125; public static void main(String[] args) &#123; System.out.println("ArrayList添加"+N+"条耗时："+timeList(new ArrayList())); System.out.println("LinkedList添加"+N+"条耗时："+timeList(new LinkedList())); List list1=addList(new ArrayList&lt;&gt;()); List list2=addList(new LinkedList&lt;&gt;()); System.out.println("ArrayList查找"+N+"条耗时："+readList(list1)); System.out.println("LinkedList查找"+N+"条耗时："+timeList(list2)); &#125;&#125; 当我们在集合中装5万条数据，测试运行结果如下:可以看到ArrayList更适合读取数据，LinkedList更多的时候添加或删除数据。 当插入的数据量很小时，两者区别不太大，当插入的数据量大时，大约在容量的1/10之前，LinkedList会优于ArrayList，在其后就劣于ArrayList，且越靠近后面越差。]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机的架构]]></title>
    <url>%2F2018%2F03%2F30%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[类加载子系统: 负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。除了类信息外，方法区中可能还会存放运行时常量池信息，包括字符串字面量和数字量(这部分常量信息是Class文件中常量池部分的内存映射)。当JVM使用类加载器装载某个类时，它首先要定位对应的Class文件，然后读入这个Class文件，最后，JVM提取该文件的内容信息，并将这些信息存储到方法区，最后返回一个Class实例。方法区： 方法区主要存储的是方法，静态成员，常量。方法区中给每个类都规定了空间并且持有this和super的引用。当运行到哪个对象的时候，通过this动态指向该对象，引用该对象的成员变量，然后和方法以及局部变量一起在栈中进行运算。方法区的大小不必是固定的，默认最小值为16MB，最大为64MB，JVM可根据应用需要动态调整。同时，方法区也不一定是连续的，方法区可以在一个堆(甚至是JVM自己的堆)中自由分配。Java堆: Java堆是在JVM启动的时候就建立的，是java程序最主要的内存工作区域。堆空间是所有线程共享的。这块内存区域存放了对象实例及数组(所有new的对象)也就是Object object= new Object();这里object只是一个引用是放在栈里面的，new Object()被放在了堆内存里面。由于现在收集器都是采用分代收集算法，堆被划为新生代和老年代。新生代主要存储所创建的对象和尚未进入老年代的对象，老年代存储经过多次新生代GC(Minor GC)仍然存活的对象。直接内存: Java的NIO库允许Java程序使用直接内存。直接内存是在Java堆外的、直接向系统申请的内存空间。通常，访问直接内存的速度会优于Java堆。因此出于性能考虑，读写频繁的场合应考虑使用直接内存。因为直接内存不在java堆内，因此直接内存的大小不会直接受限于jvm参数-Xmx，而它和java堆的总和，受制于操作系统的内存大小。垃圾回收系统: 这是JVM的重要组成部分，垃圾回收器可以直接对方法区、Java堆和直接内存进行回收。在其中Java堆则是垃圾回收器的重点工作区域，对于不在使用的垃圾对象，垃圾回收系统会在后台查找标识，并且释放这些不用的垃圾对象。Java栈: 每一个线程中都有私有的Java栈，一个线程的Java栈在线程被创建的时候就会被创建。Java栈由许多栈帧组成，一个栈帧包含一个Java方法调用的状态。当线程调用要给Java方法时，虚拟机压入一个新的栈帧到该线程的Java栈中，当该方法返回时，这个栈帧就从Java栈中弹出。Java栈中存储线程中Java方法调用的状态包括：局部变量、方法参数、返回值以及运算的中间结果等，并且对象的引用也存在栈中。Java虚拟机没有寄存器，其指令集使用Java栈来存储中间数据。这样设计的原因是为了保持Java虚拟机的指令集尽量紧凑，同时也便于Java虚拟机在只有很少通用寄存器的平台上实现。另外，基于栈的体系结构，也有助于运行时某些虚拟机实现的动态编译器和即时编译器的代码优化。本地方法栈: 任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的栈，虚拟机只是简单地动态连接并直接调用指定的本地方法。其中方法区和堆由该虚拟机实例中所有线程共享。当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息放到方法区。当程序运行时，虚拟机会把所有该程序在运行时创建的对象放到堆中。像其它运行时内存区一样，本地方法栈占用的内存区可以根据需要动态扩展或收缩。PC寄存器: PC寄存器也是每个线程私有的空间，Java虚拟机会为每个Java线程创建PC寄存器。在任意时刻，一个Java线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向当前正在被执行的指令，若是本地方法，则PC的值就是undefined。执行引擎: 最核心的组件之一，负责执行虚拟机的字节码。现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后再执行。]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重置MySQL密码]]></title>
    <url>%2F2018%2F03%2F29%2F%E9%87%8D%E7%BD%AEMySQL%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)一般这个错误是由密码错误引起的，解决的方法自然是重置密码。假设我们使用的是root账户。1、重置密码的第一步是跳过MySql的密码认证过程。 vim /etc/my.cnf(注: windows下修改的是my.ini) 在文档内搜索mysqld定位到[mysqld]字段:/mysqld(在vim编辑状态下直接输入该命令可搜索文本内容)在[mysqld]后面任意一行添加skip-grant-tables用来跳过密码验证的过程。保存文档并退出。2、接下来重启MySql:/etc/init.d/mysql restart(有些用户可能需要使用/etc/init.d/mysqld restart)3、重启之后输入mysql就可进入mysql。4、接下来就是用sql来修改root的密码。1234use mysql;update user set password=password("你的新密码") where user="root";flush privileges;quit 到这里root账户就已经重置成新的密码了。5、便器my.cnf去掉刚才添加的内容，然后重启MySql。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie和session的区别]]></title>
    <url>%2F2018%2F03%2F28%2Fcookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[对于许多人来说，都知道的是，cookie是存储在客户端的，可以用来放需要长期使用的内容，例如用户密码、用户账户等等，服务器是可以获取到cookie的内容的；而session则是存储在服务器端，通过唯一的session_id来区别用户，用于保存用户的登录状态和请求等，客户是不能获取到其内容的。这对于许多人来说都是比较基础的内容，也是表现形式上的区别，在这里我们深入的了解一下两者。 cookie123cookie是存在于客户端的由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。cookie的内容主要包括: 名字、值、过期时间、路径和域。其中路径与域一起构成cookie的作用范围，若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。cookie是服务器端给客户端分发的一种凭证，客户端要请求服务，就需要在发送数据的同时发送cookie，服务器端通过识别cookie的内容，得知用户身份。 要查看cookie可以在控制台输入javascript: alert(document.cookie);就可以看到网站分发的cookie了。 实际上的cookie有两种，分别是停留在浏览器所占内容的临时性的cookie，在页面窗口关闭之后就被删除，被称为session cookie；而另外一种是通过存放在硬盘空间中长期 存在的cookie，这种cookie被称为persistent cookie，也就是我们通常意义上所讲的cookie。 session123session的出现: 对于cookie是存储在客户端的，这种存储在客户端的信息往往是不安全的，所以后来又有了session，客户端浏览器向服务器发送请求的时候，服务器将客户端的信息以某种形式存储在服务器上，这种存储在服务器端的信息在客户端第二次访问服务器的时候被使用，用来确定用户的状态等信息。session的使用: 服务器会在客户端第一次请求服务的时候创建session对象，与cookie类似，session对象也是以键值对的形式存储的。每个session 对象都有独立的session_id，对于特定的客户，就赋予特定的session，可以区分不同的用户。需要注意的是，通常是在用户请求具体服务的时候才会创建session，单纯的访问静态的内容（如HTML）并不会创建session。而在创建之后的每一次客户访问服务器都会更新session的内容，比如session的最后访问时间等等。还有一点是session的内容应该尽量的精简，因为session是存储在服务器端的，需要占用到宝贵的服务器资源（一般放在服务器内存里），所以这里在有大量客户访问的时候，会导致服务器的资源不够用。此外还会给session设置有效期，对于长时间没有活跃的session会从内存中删除，这也是我们用一些Web应用时会有说“登录超时”的情况出现。session的依赖实现: 对于上面所说的session，它对于用户来说是透明的，在客户请求服务的时候，客户端需要有一个标示自己身份的凭证，但是仅仅是标示自己的身份，所以这个标示会比较小。通过这个身份，服务器才能从内存中的多个session中知道用户是对应于哪一个session。一般来说session是要依赖于cookie来实现，这一点在上面讲到cookie的分类时说到，这时候生成的cookie就是上文提到的session cookie，而cookie的内容就是session的特定的id，这个cookie在浏览器关闭的时候就会失效。因此同一个机器上的两个浏览器窗口访问服务器的时候会生成两个不同的session。但是如果两个窗口是由同一个父窗口打开的话，子窗口会共享父窗口的cookie，所以这时候是共享一个session。 如果禁用了cookie，那要怎么实现session 在浏览器禁用cookie或者不支持cookie的时候，通常会采取一种叫做”URL重写”的方式来实现session，也就是以类似于GET方式，将session_id写在URL的后面，这样服务器也能获取到客户的session_id，通过这个独立的id就能识别特定的用户了。]]></content>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring解析]]></title>
    <url>%2F2018%2F03%2F28%2FSpring%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[什么是Spring1、Spring是一个开源框架，Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。Spring是一个IOC和AOP容器框架。在Java开发领域，SPring相对于EJB来说是一种 轻量级的、非侵入性的Java开发框架。Spring主要核心是:1) 控制反转(IOC): 概念: 控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系核心: bean工厂；在Spring中，bean工厂创建的各个实例称作bean 以前传统的Java开发模式中，当需要一个对象时，我们会自己使用new或getInstance等直接或间接调用构造方法创造一个对象，而在Spring开发模式中，Spring容器使用了工厂模式为我们创建了所需要的对象，我们使用时不需要自己去创建，直接调用Spring为我们提供的对象即可，这就是控制反转思想。实例化一个Java对象由三种方式: 使用类构造器，使用静态工厂方法，使用实例工厂方法。当使用Spring时我们就不需要关心通过何种方式实例化一个对象，Spring通过控制反转机制自动为我们实例化一个对象。2) 依赖注入(DI): Spring使用JavaBean对象的Set方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程就是依赖注入的基本思想。3) 面向切面编程(AOP): 在面向对象编程 (OOP)思想中，我们将事物纵向抽象成一个个的对象。而在面向切面编程中，我们将一个个对象某些类似的方面横向抽象成一个切面，对这个切面进行一些如权限验证，事物管理，记录日志等公用操作初级的过程就是面向切面编程的思想。2、在Spring中，所有管理的对象都是JavaBean对象，而BeanFactory和ApplicationContext就是Spring框架的两个IOC容器，现在一般使用ApplicationContext，其不但包含了BeanFactory的作用，同时还进行更多的扩展。 Spring原理1) 内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 。2) Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过 配置类达到的。3) Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象） 要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。 代理的两种方式静态代理 针对每个具体类分别编写代理类 针对一个接口编写一个代理类 动态代理 针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类。不用写代理类，虚拟机根据真实对象实现的接口产生一个类，通过类实例化一个动态代理，在实例化动态代理时将真实对象及装备注入到动态代理中，向客户端公开的是动态代理，当客户端调用动态代理方法时，动态代理根据类的反射得到真实对象的Method,调用装备的invoke方法，将动态代理、 Method、方法参数传与装备的invoke方法，invoke方法在唤起method方法前或后做一些处理。 产生动态代理的类: java.lang.refect.Proxy装备必须实现InvocationHandler接口实现invoke方法。 Spring的三种注入方式是什么 setterinterfaceconstructor Spring的核心接口及核类配置文件是什么 FactoryBean: 工厂 Bean主要实现ioc/diApplicationContext ac= new FileXmlApplicationContext(“applicationContext.xml”);Object obj= ac.getBean(“id值”); Spring框架的7个模块Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String中加号和字符串拼接]]></title>
    <url>%2F2018%2F03%2F28%2FString%E4%B8%AD%E5%8A%A0%E5%8F%B7%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[字符串常量是编译时确定的，编译完成，生成class文件，那就不会再变了。在编译的时候，编译器会将字符串常量直接放在一起，然后查找常量池里面，有没有对应的字符串。12345678910String str1= new String("abc");String str2= "abc";String str3= "a"+ "b"+ "c";System.out.println(str1== str2); //输出falseSystem.out.println(str1.intern()== str2); //输出true//intern()方法返回字符串对象的规范化表示形式。System.out.println(str2== str3); //输出trueString str4= "ab";String str5= str4+ "c";System.out.println(str2== str5); //输出false 第一个str1== str2对比的是引用的地址是否相同，由于str1采用的是new String方式定义的，所以地址引用一定不相等。 第二个str1.intern()== str2，当str1调用intern的时候，会检查字符串池中是否含有 该字符串。由于定义的str2已经进入字符串池中，所以会得到相同的引用。 定义str3，在编译的时候，编译器会将字符串常量直接放在一起，然后查找常量池里面，有没有对应的字符串，所以str2和str3是相等的，也就是指向相同的内存区域。 看一下下面的代码123456789101112String a = new String("ab");String b = new String("ab");String c = "ab";String d = "a" + "b";String e = "b";String f = "a" + e;System.out.println(b.intern() == a); //输出falseSystem.out.println(b.intern() == c); //输出trueSystem.out.println(b.intern() == d); //输出trueSystem.out.println(b.intern() == f); //输出falseSystem.out.println(b.intern() == a.intern()); //输出true 由运行结果可以看出来，b.intern() == a和b.intern() == c可知，采用new 创建的字符串对象不进入字符串池，并且通过b.intern() == d和b.intern() == f可知，字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如f中的e）则不会进入字符串池中。但是字符串一旦进入字符串池中，就会先查找池中有无此对象。如果有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py常识]]></title>
    <url>%2F2018%2F03%2F28%2Fpy%E5%B8%B8%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一些基础的python知识。 python特性 1) python是一种解释型语言，这意味着，与C、C++不同，python不需要在运行之前进行编译，它是边运行边解释。2) python是动态类型化的，这意味着当你声明它们或类似的东西时，你不需要声明变量的类型。你可以x= 1，然后x= “abc”没有错误。3) python非常适合面向对象编程，因为它允许定义类以及组合和继承。python没有访问修饰符(例C++大的public，private)。4) 在python中函数是一等对象，这意味着它们可以在运行时动态创建，能赋值给变量或者作为参数传给函数，还能作为函数的返回值。5) python代码容易上手，开发速度很快，但运行速度通常比编译语言慢。幸运的是，python允许包含基于C的扩展，所以瓶颈可以被优化掉。比如，numpy包就是一个很好的例子，它非常快，因为它所做的很多运算在底部都是用C编写的。 python中的赋值、浅拷贝和深拷贝的区别 1) 对象的赋值python中对象的赋值实际上是简单的对象引用，也就是说，当你创建一个对象，然后把它复制给另一个变量的时候，python并没有拷贝这个对象，而是拷贝了这个对象的引用。 2) 浅拷贝 对于可变对象深浅拷贝 Name 值 地址 =浅拷贝 值相等 地址相等 copy浅拷贝 值相等 地址不相等 deepcopy深拷贝 值相等 地址不相等 一般引用copy.copy()，可以进行对象的浅拷贝。它复制了对象但对于对象中的元素，依然使用原始的引用。使用copy对a进行浅拷贝，b复制了a的对象，但是b里面的[2, 3, 4]和a里面的[2, 3, 4]其实都是指向同一块内存地址，所以改变了a[1]之后，b里面的b[1]也发生了改变。 对于不可变对象的深浅拷贝不可变对象类型，没有被拷贝的说法，即便是用深拷贝，查看id的话也是一样的，如果对其重新赋值，也只是新创建一个对象，替换掉旧的而已。一句话就是，不可变类型，不管是深拷贝还是浅拷贝，地址值和拷贝后的值都是一样的。3) 深拷贝深拷贝需要用copy.deepcopy()进行拷贝。它是复制一个容器对象，以及它里面的所有元素(包含元素的子元素)当对a列表进行深度拷贝之后，b复制了a的对象，但是b里面的[2, 3, 4]和a里面的[2, 3, 4]其实都是指向不同的内存地址。 python中的==和is的区别 is也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是id是否相同。而==是python标准操作符中的比较操作符，用来比较判断两个对象的value(值)是否相等。 线程如何在python中实现 python有一个多线程包threading，可以使用多线程来加快你的代码。但是python有一个叫做Global Interpreter Lock(GIL)的构造。GIL确保只有一个”线程”可以在任何时候执行。线程获取GIL，做一些工作，然后将GIL传递到下一个线程。这种情况发生得非常快，所以对于人眼而言，它可能看起来像你的线程并行执行，但它们实际上只是轮流使用相同的CPU内核。因此GIL的存在是得python中的多线程无法真正的利用多核的优势来提高性能。对于IO密集型操作，在等待操作系统返回的时候会释放GIL；再比如爬虫因为有等待的服务器的响应时间，可以利用多线程来加速。但是对于CPU密集型操作，只能通过多进程Multiprocess来加速。 python中的猴子补丁式是什么 考虑下面的例子:猴子补丁:是一种非常pythonic的用法，即函数再python中可以像使用变量一样对它进行赋值等操作，我们可以再运行时动态替换模块，俗称手法，称为猴子补丁。我们通过对MyClass.f重新赋值，动态的改变了输出的结果。 python中的负数index python中的负数index是用来做什么的？python中的序列是索引的，它由正数和负数组成。正的数字使用’0’作为第一个索引，’1’作为第二个索引。负数的索引从’-1’开始，表示序列中的最后一个索引，’-2’作为倒数第二个索引，序列像整数一样向前。负数索引也可以用来非常方便的切片，比如: 类里面的new和init的区别 1) __init__为初始化方法，而__new__方法才是真正的构造函数。只有继承了object的新式类才有__new__。2) ——new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由python解释器自动提供，__new__必须要有返回值，返回实例化出来的实例。3) __init__有一个参数self，就是这个__new__返回的实例，先运行__new__然后才运行__init__。4) __init__在__new__的基础上可以完成一些其它初始的动作，__init__不需要返回值。 python中的参数*args和**kwargs *args是可变参数，一般用来表示我们不能确定多少参数将被传递给函数，或者如果我们想用列表或元组的方式传递给函数。**kwargs是可变关键字参数，当我们不知道有多少关键字参数会传递给一个函数时，或者想把一个字典作为关键字参数时使用。注: *args和**kwargs可以同时在函数的定义中，但是*args必须在**kwargs前面。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禁止U盘拷贝]]></title>
    <url>%2F2018%2F03%2F27%2F%E7%A6%81%E6%AD%A2U%E7%9B%98%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[经常会有人在我们电脑上拷贝一些东西，那我们不想让别人拷贝怎么办呢？1、键入win + r键，打开运行，输入gpedit.msc，打开本地组策略编辑器。2、点击计算机配置–&gt;管理模板–&gt;系统，找到右侧可移动存储访问。3、双击后可看到右侧有五个可移动磁盘项目，我们不想让别人从我们电脑拷贝的话，双击拒绝写入权限。4、选中已启用，点击确定。5、打开U盘，将文件放入U盘，可以看到提示需要管理员权限。6、我们点击继续，发现没有办法将文件放入U盘。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py使用itchat发送微信消息]]></title>
    <url>%2F2018%2F03%2F25%2Fpy%E4%BD%BF%E7%94%A8itchat%E5%8F%91%E9%80%81%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[环境：Windows、python3.6、itchat库代码参考于奇幻果园。itchat使用需要事先下载安装，命令如下: pip install itchat这个代码的作用就是在指定时间给微信好友发送信息，并且可以间隔特定时间再次发送，类似于短信轰炸？学习！嗯，用来学习。12345678910111213141516171819202122232425262728293031#!usr/bin/python# -*- coding: UTF-8 -*-import itchatimport datetime, os, platform,timedef timerfun(sched_time) : flag = 0 while True: now = datetime.datetime.now() if now &gt; sched_time and now &lt; sched_time + datetime.timedelta(seconds=1) : #因为时间秒之后的小数数据部分不一定相等，要标记一个范围判断 send_move() time.sleep(2) #每次判断间隔2s, 避免多次触发事件 flag = 1 else : if flag == 1 : sched_time = sched_time + datetime.timedelta(hours=24) #把目标时间增加一个小时，24小时后触发再次执行 flag = 0def send_move(): users= itchat.search_friends(name= 'Love') #使用备注名来查找实际用户名 print(users) #获取好友全部信息，返回一个列表，列表内是一个字典 userName= users[0]['UserName'] #获取UserName，用来发送消息 itchat.send("It's time to take a rest. 宝贝, 该睡觉啦!", toUserName= userName) print('succeed')if __name__=='__main__': itchat.auto_login(hotReload=True) #首次扫描登录后后续自动登录 sched_time = datetime.datetime(2018,3,25,23,40,00) #设定初次触发时间的事件点 print('run the timer task at &#123;0&#125;'.format(sched_time)) timerfun(sched_time) 有些地方需要注意下:1、第11行判断时间是否到达指定时间处，因为now = datetime.datetime.now()返回的时间精确到了ms, 所以直接拿精确到s的特定时间去比较会出现False。所以改用判断时间是否在范围内。并且判断完后会用time.sleep(2)延时2s再次比较，避免多次命中或多次判断。2、第17行内，每次时间判断满足指定时间范围时，将指定时间往后延一定时间。这里+ datetime.timedelta(hours=24)表示延后24小时，达到每过24小时触发一次send_move函数的目的。3、第28行内，itchat.auto_login(hotReload=True)如注释说明的一样，避免每次都要扫描二维码登录，在登录一次之后”保持在线状态”4、第27行，if __name__==&#39;__main__&#39;:表示当前模块仅在自己运行时才运行后续的语句，否则当该模块被其他模块引用时，不会运行后续语句。每个模块都有__name__属性，当它等于__main__时，表示该模块被用户单独运行，可以执行特殊的操作。5、第30行，注意一下这里的print函数对sched_time字符串的使用方式。为了按照一般时间格式打印输出，对sched_time进行了format格式化处理，我理解就是保持sched_time原本的时间形式不变，而按照字符串的方法进行处理。这里用{0}来表示格式化后的sched_time，让其能够以原来时间格式与前面待打印的字符串进行字符串拼接。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下py脚本后台运行]]></title>
    <url>%2F2018%2F03%2F25%2FWindows%E4%B8%8Bpy%E8%84%9A%E6%9C%AC%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[环境: Windows、python3.6py脚本在Linux的后台运行网上教程很多，而在Windows中的介绍不多。下面说一种可行方法： 将wx.py文件改为wx.pyw。cmd进入到pythonw目录下, 输入pythonw wx.pyw 1&gt;stdout.txt 2&gt;stderr.txt 由于代码原因，要进行故障排除，即在调用时使用输出重定向。这将print()在文件中捕获stdout输出，例如来自file stdout.txt, stderr输出(例如来自未处理的异常)stderr.txt。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py脚本打包成exe]]></title>
    <url>%2F2018%2F03%2F25%2Fpy%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E6%88%90exe%2F</url>
    <content type="text"><![CDATA[输入pyinstaller -F wx_dingshi.py有可能会出现错误PyInstaller cannot check for assembly dependencies.并且提示Please install PyWin32 or pywin32-ctypes.问题很明显了，缺少这俩库输入pip install PyWin32和 pip install pywin32-ctypes静等安装。安装完后再次输入pyinstaller -F wx_dingshi.py打包完成。同目录下的dist文件夹中的wx_dingshi.exe就是目标exe。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程同步]]></title>
    <url>%2F2018%2F03%2F20%2F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[什么是进程同步？列举两个生活中的进程同步的实例，详细说明同步的过程。 在多道程序环境下，进程是并发进行的，不同进程之间存在着不同的相互制约关系，这就叫进程同步。例一：理发师-顾客问题在一个理发店里有一个理发师，一个理发椅和N个沙发，理发椅是一个临界资源，沙发相当于等待队列。当一个顾客进入理发店占用理发椅时，其他顾客必须在沙发上等待。理发师和顾客必须保持同步，既不允许理发师在没有顾客时理发，也不允许顾客在理发椅被占用时理发。例二：厨师-食堂问题在一个饭店里有一个厨师，一个桌子和N个椅子，桌子是一个临界资源。当一个食客进入饭店占用桌子时，假设桌子已满，其他食客必须等待。厨师和食客必须保持同步，既不允许厨师在没有食客时做饭，也不允许食客在桌子被占满时吃饭。 什么是记录型信号量机制？举实例说明wait操作（P操作）中当信号量值小于0和不小于0时会发生什么？signal操作（V操作）中当信号量值小于等于0和不小于等于0时会发生什么？记录型信号量机制是在整形信号量机制的基础上增加了一个用于代表资源数目的整型变量和一个等待队列（用链表）。实例：理发师-顾客问题在实例中理发椅的数目就相当于资源信号量，当执行P操作时，信号量小于0时，表示资源已经分配完毕，因此进程BLOCK并插入等待队列中；信号量不小于0时（即大于等于0），表示资源还未分配完毕，因此进程继续执行。当执行V操作时，信号量小于0时，表示在等待队列中还有进程在被阻塞，因此应执行唤醒语句；信号量不小于0时（即大于等于0），等于0时，由于0是由-1变来的，所以表示等待队列中还有最后一个进程在被阻塞，因此应执行唤醒语句，大于0时说明等待队列中还没有进程在被阻塞，因此直接释放处理机即可。 解释什么是FIFO？什么是优先级高者优先调度？什么是抢占式调度和非抢占式调度？FIFO即FIRSTINPUTFIRSTOUTPUT，就是先进先出的意思，先执行先进入的进程，该进程完成后再执行下一个进程。优先级高者优先调度：说的是在执行若干个进程或作业的时候选取其中优先级最高的那一个先执行。抢占式调度：这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将以分配给该进程的处理机重新分配给另一个进程。此调度方法遵循一定的原则：1&gt;优先权原则，2&gt;短进程优先原则，3&gt;时间片原则。非抢占式调度：采用这种方式时，一旦处理机分配给某进程后，就让他一直运行下去，决不会因为时钟中断或任何其他原因去抢占当前正在运行程序的处理机，直至该进程完成或发生某事件而被阻塞时，才把处理机分配给别人。 设有两个优先级相同的进程P、Q，进入就绪队列的先后顺序为Q，P，各自运行的程序段如下： P 进程P： 进程Q： P1 Y=1; Q1 X=2; P2 Y=Y+A; Q2 A=X+1; P3 V(S1); Q3 P(S1); P4 A=Y+X; Q4 X=A+Y; P5 P(S2); Q5 V(S2); P6 A=Y+A; Q6 A=X+A; 说明：其中S1、S2为信号量，初值为0；已知X、Y、A为共享变量，A、X、Y的初值为0，若调度程序执行的策略为FIFO（先进先出）问题：请写出进程P、Q的实际执行序列（用代码Pi，Qi表示，i=1，…,6）及变量X、Y、A的中间值和运行结果？12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个优先级相同的进程P、Q，进入就绪队列的先后顺序为Q、P。根据先进先出的原则先进行Q操作。答案：A=20、 X= 10、Y= 4、S1= 0、S2= 0 将上述问题中的“进入就绪队列的先后顺序为Q、P”改为“进入就绪队列的先后顺序为P、Q”，其它不变。12：A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个优先级相同的进程P、Q，进入就绪队列的先后顺序为P、Q，根据先进先出原则先执行P操作。答案： A= 8、X= 4、Y= 1、S1= 0、S2= 0 将上述问题改为“P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P”，按优先级高者优先调度，采用非抢占式调度12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P。根据优先级高者优先调度的原则先进行Q操作。答案：A= 20、X= 10、Y= 4、S1= 0、S2= 0 将上述问题改为“P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P”，按优先级高者优先调度，采用抢占式调度12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个同时进入就绪队列的进程P、Q，进程Q的优先级高于进程P。根据优先级高者优先调度的原则先进行Q操作。答案：A= 15、X= 7、Y=4、S1= 0、S2= 0 将上述问题改为“P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P”，按优先级高者优先调度，采用抢占式调度。12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个同时进入就绪队列的进程P、Q，进程Q的优先级高于进程P。根据优先级高者优先调度的原则先进行Q操作。答案：A= 15、X= 7、Y=4、S1= 0、S2= 0]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储管理]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是虚拟存储器？ 虚拟存储器是由硬件和操作系统自动实现存储信息调度和管理的，是在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理贮存容量大的多，可寻址的“主存储器”。 为什么要引入虚拟存储器？1) 能提高操作系统的内存利用率和系统吞吐量2) 在计算机系统中，主存的容量有一定的限制，不可能大大满足各种用户的需要，而在技术上辅助存储器却可以做的相当大。为了给大作业提供方便，使它们不再承担对主存和辅存的具体分配和管理工作，而由操作系统把主存和辅存统一管理起来。 虚拟存储器的特征？虚拟存储器具有虚拟性、离散性、多次性及强对换性等特征，其中最重要的特征是虚拟性。1&gt; 虚拟性。虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际的内存容量，这是虚拟存储器所表现出的最重要的特征，也是虚拟存储器最重要的目标。2&gt; 离散性。离散性是指内存分配时采用离散分配的方式，没有离散性就不可能实现虚拟存储器。采用连续分配方式，需要将作业装入到连续的内存区域，这样需要连续地一次性申请一部分内存空间，以便将整个作业先后多次装入内存。如果仍然采用连续装入的方式，则无法实现虚拟存储功能，只有采用离散分配方式，才能为它申请内存空间，以避免浪费内存空间。3&gt; 多次性。多次性是指一个作业被分成多次调入内存运行。作业在运行时，只将当前运行的那部分程序和数据装入内存，以后再陆续从外存将需要的部分调入内存。4&gt; 对换性。对换性是指允许在作业运行过程中换进换出。允许将暂时不用的程序和数据从内存调至外存的对换区，以后需要时再从外存调入到内存。 设置你自己计算机上的虚存，并截图说明设置的过程1、右键我的电脑, 选择属性2、选择高级系统设置3、选择高级, 点性能中的设置4、选择高级, 选虚拟内存中的更改5、选择自定义大小, 输入初始大小和最大值, 推荐设置自己内存大小的1.5~ 3倍, 在这输入2048, 点击设置, 根据提示选择确定。 虚存可以建立在分区分配管理的基础上吗？为什么？不可以。在虚拟存储器中，允许将一个作业分多次调入内存。如果采用连续分配方式时，应将作业装入一个连续的内存区域中。为此，需事先为它一次性地申请足够的内存空间，以便将整个作业先后分多次装入内存，这不仅会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟存储器的实现都是建立在离散分配存储管理方式的基础上。 页面置换算法的应用题干：在请求分页存储管理系统中，若为进程分配的物理块为4，开始执行时内存中没有装入任何页面，若进程依次访问的页面号为：3,1,2,6,0,7,4,6,7,2,0,4,3,2,0,7,0,2,6,5,1,5,4,3，请按照下面的页面置换算法完成作业（低物理地址优先）1、OPT页面置换算法1234567891011*为发生缺页中断~为发生页面置换页面被置换顺序 1 3 0 6 4 7 2 0 6缺页率13/241、2、3、4内存为空，页面不在内存中发生缺页5 选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，页面1最长时间不被访问，因此被替换6 同理，页面3最长时间不被访问被替换7 同理，页面0最长时间不被访问被替换8 同理，页面6最长时间不被访问被替换9 同理，页面4最长时间不被访问被替换10 页面0,2,6在后续的访问中没有出现以此按照内存块的顺序（从上往下）依次替换 2、FIFO页面置换算法123456789101112131415161718192021222324252627282930FIFO：(按顺序置换)（1）详细执行过程1.刚开始内存并没有这个作业，所以发生缺页中断一次。页3进入内存。(1次缺页中断) 2.页1进入内存，页1又不在内存，又发生缺页中断一次。(2次缺页中断) 3.页2进入内存，页2又不在内存，缺页中断。(3次缺页中断) 4.页6进入内存，页6又不在内存，发生缺页中断（内存中为3、1、2、6）。 (4次缺页中断) 5.页0进入内存，页0又不在内存，发生缺页中断（内存中为1、2、6、0）。 (5次缺页中断) 6.页7进入内存，页7又不在内存，发生缺页中断（内存中2、6、0、7）(6次缺页中断)7.页4进入内存，页4又不在内存，发生缺页中断（内存中为6、0、7、4）。 (7次缺页中断) 8.页6在内存内不发生中断。9.页7在内存内不发生中断。10.页2进入内存，页2又不在内存，发生缺页中断（内存中为0、7、4、2）。 (8次缺页中断) 11.页0在内存内不发生中断12.页4在内存内不发生中断 13.页3进入内存，页3又不在内存，发生缺页中断（内存中为7、4、2、3）。 (9次缺页中断) 14.页2在内存内不发生中断 15.页0进入内存，页0又不在内存，发生缺页中断（内存中为4、2、3、0）。 (10次缺页中断) 16.页7进入内存，页7又不在内存，发生缺页中断（内存中为2、3、0、7）。 (11次缺页中断)17.页0在内存内不发生中断。18.页2在内存内不发生中断。19.页6进入内存，页6又不在内存，发生缺页中断（内存中为3、0、7、6）。 (12次缺页中断)20.页5进入内存，页5又不在内存，发生缺页中断（内存中为0、7、6、5）。 (13次缺页中断)21.页1进入内存，页1又不在内存，发生缺页中断（内存中为7、6、5、1）。 (14次缺页中断)22.页5在内存内不发生中断。23. 页4进入内存，页4又不在内存，发生缺页中断（内存中6、5、1、4）。 (15次缺页中断)24.页3进入内存，页3又不在内存，发生缺页中断（内存中为5、1、4、3）。 (16次缺页中断)（2）缺页次数：16（3）缺页频率：66.7％（4）置换次数：12（5）被置换出的页面依次为：3,1,2,6,0,7,4,2,3,0,7,6 3、LRU页面置换算法12345678910111213141516171819*为发缺页中断（1）1、2、3、4内存为空，页面不在内存中发生缺页5选择的被淘汰页面将是最近最久未使用的页面，页面3最长时间不被访问，因此被替换6同理，页面1最长时间不被访问被替换7 同理，页面2最长时间不被访问被替换8 同理，页面0最长时间不被访问被替换9 同理，页面4最长时间不被访问被替换10 同理，页面6最长时间不被访问被替换11 同理，页面7最长时间不被访问被替换12 同理，页面4最长时间不被访问被替换13 同理，页面3最长时间不被访问被替换14 同理，页面7最长时间不被访问被替换15 同理，页面0最长时间不被访问被替换16 同理，页面2最长时间不被访问被替换16 同理，页面6最长时间不被访问被替换（2）缺页次数：17（3）缺页频率：70.8%（4）置换次数：13（5）被置换出的页面依次为：3 1 2 0 4 6 7 4 3 7 0 2 6 4、CLOCK页面置换算法12345678910111213红色代表访问位为1，星号表示替换指针的位置缺页次数：15次缺页率：15/24=62.5％置换次数：11次依次被置换出的页号：3,1,2,6,7,4,3,2,0,7,6语言描述：1：进程分配的物理块为4，开始执行时内存中没有装入任何页面，当访问3号页面是，内存中没有，则将页面直接调入内存，根据低物理地址优先，将页面存入第一个物理块，并把访问位置为1。2：访问1号页面时，内存中没有，且内存中还有空位，直接将1号页面放入内存即可，并把访问位置为1。3：当访问0号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查3号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查1号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查2号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查6号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，这时检查到最后一位，发现访问位仍为1，则返回队首去检查第一个页面3，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。4：当访问7号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查1号页面，访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。5：当访问6号页面时，发现内存中存在，则将其访问位置为1，替换指针不动。6：当访问2号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查6号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查0号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查7号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查4号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查6号页面，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。7：当访问3号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查0号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查7号页面，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。8：当访问7号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查4号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查2号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查0号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查3号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查4号页面，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。 5、CLOCK页面置换算法 第5题中进程依次访问的页面号为：其它条件、要求与前面的题干一样7,1,6,4,6,2,3,0,3,1,0,7,6,0,1,3,6,3,0,7,2,0,51234567891011121314151617181920212223242526红色代表访问位为1，星号表示替换指针的位置缺页次数: 14次缺页率: 14/23=60.9%置换次数: 10次依次被置换的页号: 7 1 6 4 2 3 0 1 7 67号页面：进程分配的物理块为4，开始执行的时候没有装入任何页面，当开始访问7号页面的时候，内存中没有该页面号，将页面直接调入内存，低物理地址优先，将页面放入第一个物理块，把访问位置为1.1、6、4号页面：访问1号页面的时候，内存中没有该页面号，且内存中还有空位，将1、6、4号页面放入内存，把访问位置为1，替换指针指向最高地址的物理块。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查4号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查4号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。7号页面：访问7号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查2号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查9号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查3号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。7号页面：访问7号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。5号页面：访问5号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程四]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Arrays;import java.util.Scanner; public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入总人数。"); int num = in.nextInt(); boolean[] man = new boolean[num]; for(int i = 0; i &lt; man.length; i++) &#123; man[i] = true; &#125; int t = 0, len = man.length; while(len &gt; 1) &#123; for(int i = 0; i &lt; man.length; i++) &#123; if(man[i]) &#123; t++; if(t == 3) &#123; t = 0; //重置 man[i] = false; //去掉此人 len--; //人数减 1 &#125; &#125; &#125; &#125; System.out.println("最后的情况：" + Arrays.toString(man));//返回指定数组的字符串表示形式 for(int i = 0; i &lt; man.length; i++) &#123; if(man[i]) //最后留下来的人没有被flase &#123; System.out.println("原来剩下的数：" + (i + 1)); //i + 1 是因为数组从 0 开始 &#125; &#125; &#125;&#125; 写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。123456789101112131415161718import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个字符串"); String str = in.next(); int len = lenOfstr(str); System.out.println(str + " 的长度为 " + len); &#125; private static int lenOfstr(String str) &#123; // TODO Auto-generated method stub return str.length(); &#125;&#125; 编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n(利用指针函数)。1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个整数"); int n = in.nextInt(); if(n % 2 == 0) System.out.println("1/2 + 1/4 + ... + 1/"+ n+ "= " + evenSum(n)); else System.out.println("1 + 1/3 + ... + 1/"+ n+ "= " + oddSum(n)); &#125; private static float oddSum(int n) &#123; // TODO Auto-generated method stub float sum = 0.0f; //记得用 float 或 double 型 for(float i = 1.0f; i &lt;= n;) &#123; // i 用 int 就会把结果也强转为 int sum += 1 / i; i += 2; &#125; return sum; &#125; private static float evenSum(int n) &#123; // TODO Auto-generated method stub float sum = 0.0f; for(float i = 2.0f; i &lt;= n;) &#123; sum += 1 / i; i += 2; &#125; return sum; &#125;&#125; 字符串排序。123456789101112import java.util.Arrays;public class class_name &#123; public static void main(String[] args) &#123; String[] strs = &#123;"abfds1", "advesd2", "dasfdsa3", "cdsaew1", "abbdsa2", "abbdsa"&#125;; //直接用了 java 里有的 sort 方法 Arrays.sort(strs); for(String str : strs) &#123; System.out.println(str); &#125; &#125;&#125; 海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的,问海滩上原来最少有多少个桃子？法一123456789101112131415161718192021222324252627282930313233public class class_name &#123; public static void main(String[] args) &#123; int num = 6; //分五份多一个，至少6个 while( true) &#123; if(func(num)) &#123; break; //找到答案，跳出循环 &#125; num++; &#125; System.out.println("符合要求的最小数是：" + num); &#125; //判断这个数是否能被分5次 static boolean func(long n) &#123; int i = 0; //被分次数0-4共5次 while(i &lt; 5 &amp;&amp; n &gt; 0) &#123; if((n - 1) % 5 == 0) &#123; long temp = (n - 1) / 5 + 1; n -= temp; //减去被一只猴子拿走和丢掉的 i ++; &#125; else return false; &#125; return true; &#125;&#125; 法二123456789101112131415161718192021222324public class class_name &#123; public static void main(String[] args) &#123; int i= 0, m= 1, x= 1; while(true) &#123; m= x; for(i= 0; i&lt; 5; i++) &#123; if((m- 1)% 5== 0) &#123; m= (m- 1)/ 5* 4; //System.out.println(m); &#125;else &#123; break; &#125; &#125; if (i== 5 &amp;&amp; m&gt; 0) &#123; break; &#125; x++; System.out.println(x); &#125; System.out.println("符合要求的最小数是：" + x); &#125;&#125; 809*??=800*??+9*??+1其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。1234567891011121314151617181920public class class_name&#123; public static void main(String[] args) &#123; int number = 0; boolean flag = false; for (int i=10; i&lt;100; i++) &#123; if(809*i == (800*i+9*i)) &#123; if(((8* i)&gt; 10)&amp;&amp; ((8* i) &lt; 100)&amp;&amp; ((9* i) &gt; 99)&amp;&amp; ((9* i)&lt; 1000)) &#123; flag = true; number = i; &#125; &#125; &#125; if (flag) &#123; System.out.println("??是: "+ number); System.out.println("809*"+number+"="+(809*number)); &#125;else &#123; System.out.println("无符合要求的数!"); &#125; &#125; &#125; 求0—7所能组成的奇数个数。12345678910111213141516171819public class class_name &#123; public static void main(String[] args) &#123; long total = 0L; //可以把 76543210 变成 10 或 100 来检查该代码输出结果的正确性 for(int i = 0; i &lt;= 76543210; i++)&#123; if(i % 2 == 0) &#123; continue; &#125; //把其中含有 8 和 9 的数去掉 if((i + "").indexOf("8") != -1 || (i + "").indexOf("9") != -1)&#123; continue; &#125; total++;// System.out.println(i + " "); //输入每一个奇数 &#125; System.out.println("共有 " + total + "个奇数"); &#125;&#125; 一个偶数总能表示为两个素数之和。12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个大于等于4偶数。"); int num = in.nextInt(); if(num &lt; 4) System.out.println("输入错误！"); if(num % 2 == 0) &#123; int i , j; for(i = 2; i &lt;= num /2; i++) &#123; if(isPrime(i)) &#123; j = num - i; if(isPrime(j)) System.out.println(num + " = " + i + " + " + j); &#125; &#125; &#125; &#125; public static boolean isPrime(int k) &#123; for(int i = 2; i &lt; Math.sqrt(k); i++) &#123; if(k % i == 0) return false; &#125; return true; &#125;&#125; 读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的＊。12345678910111213141516171819import java.util.Random;public class class_name &#123; public static void main(String[] args) &#123; Random rm = new Random(); for(int n = 0; n &lt; 7; n++) &#123; int i = rm.nextInt(50); //50以内的随机数 System.out.print(i + " : "); for(int m = 0; m &lt; i; m++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; 某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5,然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。123456789101112131415161718192021222324252627282930import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个四位整数"); int num = in.nextInt(); System.out.println("加密后数据为：" + encrypt(num)); &#125; private static int encrypt(int num) &#123; // TODO Auto-generated method stub int a, b, c, d; //从左到右分别为第一到第四位 //分解 a = num / 1000; b = (num / 100) % 10; c = (num / 10) % 10; d = num % 10; //取余 a = (a + 5) % 10; b = (b + 5) % 10; c = (c + 5) % 10; d = (d + 5) % 10; //交换,其实这里只要换一下重组会整数的顺序就行了 num = d *1000 + c * 100 + b * 10 + a; return num; &#125;&#125; 计算字符串中子串出现的次数。123456789101112131415161718192021222324252627282930import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern; public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个字符串"); String sen = in.next(); System.out.println("请输入要查找的子字符串"); String str = in.next(); /* //一般方法 int count = 0; int start = 0; while (sen.indexOf(str, start) &gt;= 0 &amp;&amp; start &lt; sen.length()) &#123; count++; start = sen.indexOf(str, start) + str.length(); &#125;*/ //正则表达式 第二个参数为忽略大小写 Pattern p = Pattern.compile(str, Pattern.CASE_INSENSITIVE); Matcher m = p.matcher(sen); int count = 0; while(m.find())&#123; count ++; &#125; System.out.println(str + "在" + sen + "出现的次数为" + count); &#125;&#125; 有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，将原有的数据和计算出的平均分数存放在磁盘文件”stud”中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.util.Scanner; public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String[][] stu = new String[2][6]; //为了快速测试，5个同学变成了2个同学 for(int i = 0; i &lt; 2; i++)&#123; System.out.printf("请输入第%d个学生的姓名", i + 1); stu[i][0] = in.next(); System.out.printf("请输入第%d个学生第学号", i + 1); stu[i][1] = in.next(); for(int j = 2; j &lt; 5; j++)&#123; System.out.printf("请输入该同学的第%d门课程成绩", j - 1); stu[i][j] = in.next(); &#125; &#125; for(int i = 0; i &lt; 2; i++)&#123; int sum = 0; for(int j = 2; j &lt; 5; j++)&#123; sum += Integer.parseInt(stu[i][j]); &#125; stu[i][5] = Float.toString((float)sum / 3); &#125; String s; try&#123; File file = new File("E:/home/stu"); //要存放的路径 if(file.exists())&#123; System.out.println("文件存在"); &#125; else&#123; System.out.println("文件不存在，正在创建...."); file.createNewFile(); &#125; BufferedWriter output = new BufferedWriter(new FileWriter(file)); for(int i = 0; i &lt; 2; i++)&#123; for(int j = 0; j &lt; 6; j++)&#123; s = stu[i][j] + "\r\t"; output.write(s);// System.out.print(stu[i][j]); //被注释的这三行用来格式化输出到控制台（屏幕）// System.out.printf("\t", ""); &#125;// System.out.println(); &#125; output.close(); System.out.println("数据已写入"); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程三]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E4%B8%89%2F</url>
    <content type="text"><![CDATA[求1+2!+3!+…+20!的和 123456789101112131415161718192021222324252627import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("你想计算到哪个数的阶乘的和"); int num = in.nextInt(); long temp = 0L; long sum = 0L; for(int i = 1; i &lt;= num; i++)&#123; temp = recursion(i); sum += temp; &#125; System.out.println("计算到" + num + "的阶乘和是 " + sum); &#125; //计算某个数 num 的阶乘 private static long recursion(int num) &#123; // TODO Auto-generated method stub if(num &gt; 1)&#123; return num * recursion(num - 1); &#125; return 1; &#125;&#125; 给一个不多于5位的正整数，要求: 一、求它是几位数；二、逆序打印出各位数字123456789101112131415161718192021import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个不多于5位的整数"); int num = in.nextInt(); int n = 1; System.out.print("这个数的逆序为："); while(num / 10 &gt; 0)&#123; n++; int tmp = num % 10; System.out.print(tmp); num /= 10; &#125; System.out.println(num); System.out.println("这个数共有" + n + "位数"); &#125;&#125; 请输入星期几的第一个字母来判断以下是星期几，如果第一个字母一样，则继续判断第二个字符。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); char firstletter, secondletter; //存放第一第二个字母 System.out.println("请输入第一字母"); String letter = in.next(); firstletter = letter.charAt(0); switch(firstletter)&#123; case 'm': case 'M': System.out.println("是星期一");break; case 'w': case 'W': System.out.println("是星期三");break; case 'f': case 'F': System.out.println("是星期五");break; case 't': case 'T': System.out.println("仅由该字母无法判断出星期几，请输入第二个字母"); letter = in.next(); secondletter = letter.charAt(0); if(secondletter == 'u' || secondletter == 'U')&#123; System.out.println("是星期二"); break; &#125;else if(secondletter == 'h' || secondletter == 'H')&#123; System.out.println("是星期四"); break; &#125;else&#123; System.out.println("输入错误"); &#125; case 's': case 'S': System.out.println("仅由该字母无法判断出星期几，请输入第二个字母"); letter = in.next(); secondletter = letter.charAt(0); if(secondletter == 'a' || secondletter == 'A')&#123; System.out.println("是星期六"); break; &#125;else if(secondletter == 'u' || secondletter == 'U')&#123; System.out.println("是星期天"); break; &#125;else&#123; System.out.println("输入错误"); &#125; &#125; &#125;&#125; 求一个3*3矩阵对角线元素之和123456789101112131415161718192021222324252627282930import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); //输入数据 int[][] mat = new int[3][3]; for(int i = 1; i &lt;= 3; i++)&#123; for(int j = 1; j &lt;= 3; j++)&#123; System.out.println("请输入第" + i + "行第" + j + "列的整数"); mat[i -1][j - 1] = in.nextInt(); &#125; &#125; //显示数据 for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; 3; j++) System.out.printf("%d\t",mat[i][j]); // \t是制表符 System.out.println(); &#125; //计算对角线元素和 //从左上至右下的数归为主对角线，从左下至右上的数归为副对角线。 int sum1 = mat[0][0] + mat[1][1] + mat[2][2]; int sum2 = mat[2][0] + mat[1][1] + mat[0][2]; System.out.println("主对角线上元素和为 " + sum1); System.out.println("副对角线上元素和为 " + sum2); &#125;&#125; 有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int[] ary = &#123;10, 15, 20, 25, 30, 35, 40, 45, 50&#125;; int[] changedAry = new int[ary.length + 1]; System.out.print("初始数组："); for(int i = 0; i &lt; ary.length; i++)&#123; changedAry[i] = ary[i]; System.out.print(ary[i] + " "); &#125; System.out.println(); System.out.println("请输入一个整数"); int num = in.nextInt(); System.out.print("插入数字后的数组："); insort(changedAry, num); &#125; private static void insort(int[] changedAry, int num) &#123; // TODO Auto-generated method stub for(int i = 0; i &lt; changedAry.length; i++)&#123; if(num &lt; changedAry[i])&#123; //找到插入位置 for(int j = changedAry.length - 1; j &gt; i;j--)&#123; changedAry[j] = changedAry[j - 1]; //待插入位置及以后的数后退一个位置 &#125; changedAry[i] = num; break; &#125; &#125; if(num &gt; changedAry[changedAry.length - 1]) //待插入数大于所有数 changedAry[changedAry.length - 1] = num; for(int k = 0; k &lt; changedAry.length; k++) System.out.print(changedAry[k] + " "); &#125;&#125; 将一个数组逆序输出1234567891011121314151617public class class_name &#123; public static void main(String[] args) &#123; //这里直接初始化一个数组 int[] ary = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// String[] ary = &#123;"i", "love", "you"&#125;; //字符（串）数组也可以 System.out.print("数组初始顺序为："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); //换行 System.out.print("数组的逆序为："); for(int i = ary.length - 1; i &gt;= 0; i--) System.out.print(ary[i] + " "); System.out.println(); &#125;&#125; 取一个整数a从右端开始的4~7位。123456789101112import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个大于等于 7 位的整数"); long sum = in.nextLong(); Long sum1 = new Long(sum); //Long是 long 的包装类 String sum2 = sum1.toString(); System.out.println(sum2.substring(sum2.length() - 7, sum2.length() - 3)); &#125; // substring 截取两参数间的字符串&#125; 打印出杨辉三角形123456789101112131415161718192021222324252627public class class_name &#123; public static void main(String[] args) &#123; int i, j; int[][] num = new int[10][10]; for (i = 0; i &lt; 10; i++) &#123;// 把所有的 1 放入数组 num[i][0] = 1; num[i][i] = 1; &#125; for (i = 2; i &lt; 10; i++) &#123;// 计算数组的其他数 for (j = 1; j &lt; i; j++) &#123; num[i][j] = num[i - 1][j - 1] + num[i - 1][j]; &#125; &#125; for (i = 0; i &lt; 10; i++) &#123; // k &lt; 4 倍的空格是因为输出每个数字时用了 4 个占位符 for (int k = 0; k &lt; 4 * (10 - i) / 2; k++) // 输出空格 System.out.printf(" "); for (j = 0; j &lt;= i; j++) &#123; System.out.printf("%4d", num[i][j]); // 每个数字 4 个占位符 &#125; System.out.println(); &#125; &#125;&#125; 输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入数组长度"); int arylen = in.nextInt(); int[] num = new int[arylen]; for(int i = 0; i &lt; num.length; i++) &#123; System.out.printf("请输入第 %d 个数：", i + 1); num[i] = in.nextInt(); &#125; System.out.println("变化前的数组："); outArray(num); //循环找出最大值、最小值 int max = num[0]; int min = num[0]; for(int i = 1; i &lt; num.length; i++) &#123; if(num[i] &gt; max) max = num[i]; if(num[i] &lt; min) min = num[i]; &#125; //替换 num[0] = max; num[num.length - 1] = min; System.out.println("变化后的数组："); outArray(num); &#125; private static void outArray(int[] num) &#123; // TODO Auto-generated method stub for(int i = 0; i &lt; num.length; i++) System.out.print(num[i] + " "); System.out.println(); &#125;&#125; 有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数。1234567891011121314151617181920212223242526272829import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int[] num = &#123;14, 32, 5, 42, 36, 80&#125;; int[] temp = new int[num.length]; System.out.println("移动前的数组："); for(int i = 0; i &lt; num.length; i++)&#123; temp[i] = num[i]; System.out.print(num[i] + " "); &#125; System.out.println(); System.out.println("需要向后移动几个位置"); int m = in.nextInt(); for(int i = 0; i &lt; num.length; i++)&#123; int t = (i + m) % num.length; num[t] = temp[i]; //这行的 t 和 i 互换一下就变成了（1） &#125; System.out.println("移动后的数组："); for(int i: num) System.out.print(i + " "); System.out.println(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程二]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[【程序11】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ 12345678910111213141516171819202122public class class_name &#123; public static void main(String[] args) &#123; int i, j, k; //分别代表个、十、百位 int num; //用来输出符合要求的三位数 int count = 0; //用来统计符合要求的三位数有多少个 System.out.println("符合要求的三位数有："); for(i = 1; i &lt;= 4; i++)&#123; for(j = 1; j &lt;= 4; j++)&#123; if(i != j) //提前把有重复的部分情况过滤掉，减少运行次数，优化性能 for(k = 1; k &lt;= 4; k++)&#123; if(i != k &amp;&amp; j != k)&#123; num = i + j * 10 + k * 100; System.out.println(num); count++; &#125; &#125; &#125; &#125; System.out.println("符合要求的三位数共有" + count + "个"); &#125;&#125; 【程序12】一个整数，它加上100后是一个完全平方数，再加上168又是一个完平方数，请问该数是多少？1234567891011121314151617181920public class class_name &#123; public static void main(String[] args) &#123; long i, j, k; for(i = 1; i &lt; 100000; i ++) &#123; for(j = 0; j &lt; 1000; j++) &#123; if(j * j == i + 100) &#123; for(k = j; k &lt; 1000; k++) &#123; if(k * k == i + 268) System.out.println(i); &#125; &#125; &#125; &#125; &#125;&#125; 【程序13】输入年月日，判断这一天是这一年的第几天？1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入年份。"); int year = in.nextInt(); System.out.println("请输入月份。"); int month = in.nextInt(); System.out.println("请输入日期。"); int day = in.nextInt(); int sum = 0;; switch(month - 1) &#123; case 0: sum = 0; break; case 1: sum = 31; break; case 2: sum = 59; break; case 3: sum = 90; break; case 4: sum = 120; break; case 5: sum = 151; break; case 6: sum = 181; break; case 7: sum = 212; break; case 8: sum = 243; break; case 9: sum = 273; break; case 10: sum = 304; break; case 11: sum = 334; break; &#125; if((month &gt; 2)&amp;&amp;isLeap(year)) System.out.printf("这天是这年第%d天。", sum + day + 1); else System.out.printf("这天是这年第%d天。", sum + day); &#125; private static boolean isLeap(int year) &#123; if(((year % 100 != 0)&amp;&amp;(year % 4 == 0)) || (year % 400 == 0)) return true; else return false; &#125;&#125; 【程序14】输入三个整数x,y,z，请把这三个数由小到大输出。1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入三个整数"); System.out.println("请输入第1个整数"); int a = in.nextInt(); System.out.println("请输入第2个整数"); int b = in.nextInt(); System.out.println("请输入第3个整数"); int c = in.nextInt(); System.out.print("从小到大的顺序为："); if(a &lt; b)&#123; if(b &lt; c)&#123; System.out.printf("%d&lt;%d&lt;%d", a, b, c); &#125;else&#123; if(a &lt; c) System.out.printf("%d&lt;%d&lt;%d", a, c, b); else System.out.printf("%d&lt;%d&lt;%d", c, a, b); &#125; &#125;else&#123; if(c &lt; b)&#123; System.out.printf("%d&lt;%d&lt;%d", c, b, a); &#125;else&#123; if(c &lt; a) System.out.printf("%d&lt;%d&lt;%d", b, c, a); else System.out.printf("%d&lt;%d&lt;%d", b, a, c); &#125; &#125; &#125;&#125; 【程序15】排序算法以下代码只写了一个输出，所以当你要测试哪个排序算法时记得把调用另外三个排序算法的那几行代码注释掉。如果你想同时测试这四个排序算法，可以在每行调用排序方法的后面加入输出语句就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class class_name &#123; public static void main(String[] args) &#123; int[] num = &#123;23, 64, 15, 3, 93, 30, 51, 28, 49, 66&#125;; System.out.println("排序前： "); showArray(num); System.out.println(); //换行，控制格式 num = BubbleSort(num); // num = ChoiceSort(num); // num = InsertSort(num); // num = QuickSort(num, 0, num.length - 1); System.out.println("排序后："); showArray(num); System.out.println(); //换行，控制格式 &#125; private static void showArray(int[] num) &#123; for(int i = 0; i &lt; num.length; i++) &#123; System.out.print(num[i] + " "); &#125; &#125; private static int[] BubbleSort(int[] num) &#123; for(int i = 0; i &lt; num.length; i++) &#123; for(int j = 0; j &lt; num.length - 1; j++) &#123; if(num[j] &gt; num[j + 1]) &#123; int temp = num[j]; num[j] = num[j + 1]; num[j +1] = temp; &#125; &#125; &#125; return num; &#125; //插入排序 private static int[] InsertSort(int[] num) &#123; for(int i = 1; i &lt; num.length; i++) &#123; int temp = num[i]; for(int j = i; j &gt; 0; j--) &#123; if(num[j - 1] &gt; temp) &#123; num[j] = num[j - 1]; num[j - 1] = temp; &#125; &#125; &#125; return num; &#125; //优化后的选择排序 private static int[] ChoiceSort(int[] num) &#123; for (int i = 0; i &lt; 9; i++) &#123; int min = i; int j; for (j = i + 1; j &lt; num.length; j++) &#123; if (num[min] &gt; num[j]) &#123; min = j; &#125; &#125; if (min != i) &#123; int temp = num[i]; num[i] = num[min]; num[min] = temp; &#125; &#125; return num; &#125; /* //选择排序 private static int[] ChoiceSort(int[] num) &#123; for(int i = 0; i &lt; num.length - 1; i++) &#123; for(int j = i + 1; j &lt; num.length; j++) &#123; if(num[i] &gt; num[j]) &#123; int temp = num[i]; num[i] = num[j]; num[j] = temp; &#125; &#125; &#125; return num; &#125; */ // 快速排序 private static int[] QuickSort(int[] num, int i, int j) &#123; // TODO Auto-generated method stub if(i &lt; j) &#123; int middle = portition(num, i, j); QuickSort(num, i, middle - 1); QuickSort(num, middle + 1, j); &#125; return num; &#125; private static int portition(int[] num, int low, int high) &#123; int i = low, j = high; int temp = num[i]; if (low &lt; high) &#123; while (i &lt; j) &#123; while ((num[j] &gt;= temp) &amp;&amp; (i &lt; j)) &#123; j--; &#125; num[i] = num[j]; while ((num[i] &lt;= temp) &amp;&amp; (i &lt; j)) &#123; i++; &#125; num[j] = num[i]; &#125; num[i] = temp; &#125; return i; &#125; &#125; 【程序16】输出9*9口诀12345678910111213141516public class class_name &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt; 10; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; int total = 0; total = i * j; System.out.printf("%d * %d = %-5d", j, i, total); &#125; System.out.println(); &#125; &#125;&#125; 【程序17】猴子吃桃问题猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下 的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。12345678910111213public class class_name &#123; public static void main(String[] args) &#123; int total = 1; //day = 1的时候，算出来的total其实是第9天有的桃子 //day = 9的时候，算出来的total就是第1天的桃子 for(int day = 1; day &lt; 10; day++)&#123; total = 2 * (total + 1); &#125; System.out.println("一开始共有 " + total + " 桃子"); &#125;&#125; 【程序18】乒乓球比赛名单两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。1234567891011121314151617public class class_name &#123; public static void main(String[] args) &#123; char i, j, k; //i,j,k分别是a,b,c的对手 for(i = 'X'; i &lt;= 'Z'; i++)&#123; for(j = 'X'; j &lt;= 'Z'; j++)&#123; if(i != j)&#123; for(k = 'X'; k &lt; 'Z'; k++)&#123; if(i != k &amp;&amp; j != k)&#123; if(i != 'X' &amp;&amp; k != 'X' &amp;&amp; k != 'Z') System.out.printf("a -- %c\nb -- %c\nc -- %c", i, j, k); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 【程序19】打印图案打印出如下图案（菱形）1234567891011121314151617181920212223public class class_name &#123; public static void main(String[] args) &#123; for(int i = 0; i &lt; 4; i++)&#123; //1到4行 for(int j = 1; j &lt;= (6 - 2 * i) / 2; j++)&#123; //每行前面的空格数 System.out.print(" "); &#125; for(int k = 1; k &lt;= 2 * i + 1; k++)&#123; System.out.print("*"); //每行的*号 &#125; System.out.println(); //换行 &#125; //下半部分 for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; i + 1; j++)&#123; System.out.print(" "); &#125; for(int k = 0; k &lt; 5 - 2 * i; k++)&#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; 【程序20】有一分数序列: 2/1，3/2，5/3，8/5，13/8…求这个数列的前20项之和。123456789101112131415public class class_name &#123; public static void main(String[] args) &#123; float i = 2.0f, j = 1.0f; //i为分子，j为分母 float num = 2.0f; //num是分数，sum是分数的和 float sum = 2.0f; for(int m = 1; m &lt; 20; m++)&#123; //m = 1时，num已经是第2个加数了，所以m &lt; 20 i = i + j; j = i - j; //变化前的 i 赋值给 j num = i / j; sum += num; &#125; System.out.println("前20个分数的和为 " + sum); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程一]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[【程序1】兔子总数问题有一对兔子，从出生后第3个月起 每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？123456789101112131415161718192021import java.util.Scanner;public class tuzi &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("你想知道第几个月的兔子的数量"); int month = in.nextInt(); //使用输入流对象，调用nextInt()方法输入一个整数到month中 int[] mon = new int[month]; if(month &lt; 3)&#123; System.out.println("第" + month + "个月有 1 对兔子，共 2 只"); &#125;else &#123; for(int i = 2; i &lt; month; i++)&#123; mon[0] = mon[1] = 1; mon[i] = mon[i - 1] + mon[i - 2]; System.out.printf("第 %d 个月有 %d 对兔子，共 %d 只兔子\n", i + 1, mon[i], 2 * mon[i]); &#125; &#125; &#125;&#125; 【程序2】判断两数之间素数个数判断101-200之间有多少个素数，并输出所有素数。12345678910111213141516171819public class class_name &#123; public static void main(String[] args) &#123; System.out.print("101--200中的素数有："); for(int i = 101; i &lt;= 200; i++)&#123; if(isPrime(i)) System.out.print(" " + i); &#125; &#125; //isPrime方法用来判断一个数是否是素数 private static boolean isPrime(int i) &#123; // TODO Auto-generated method stub for(int j = 2; j &lt;= Math.sqrt(i); j++)&#123; if(i % j == 0) return false; &#125; return true; &#125;&#125; 【程序3】打印”水仙花数”所谓”水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如: 153是一个”水仙花数”，因为153=1的三次方+5的三次方+3的三次方。1234567891011121314151617181920212223public class class_name &#123; public static void main(String[] args) &#123; System.out.print("水仙花数有："); for(int num = 100; num &lt; 1000; num++)&#123; if(isNarcissisticNum(num)) System.out.println(" " + num); &#125; &#125; //一个判断正整数是否为水仙花数的方法 private static boolean isNarcissisticNum(int num) &#123; // TODO Auto-generated method stub int a = num / 100; //分离出百位 a int b = (num / 10) % 10; //分离出十位 b int c = num % 10; //分离出个位 c int sum = a * a * a + b * b * b + c * c * c; if(sum == num) return true; else return false; &#125;&#125; 【程序4】正整数分解质因数将一个正整数分解质因数。例如: 输入90，打印出90=2*3*3*5。(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。(2)如果n&gt;k，但n能被k整除，则打印出k的值，并用n除以k的商，作为新的正整数n，重复执行第一步。(3)如果n不能被k整除，则用k+1作为k的值，重复执行第一步。123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println("请输入一个大于 3 的正整数"); int num = input.nextInt(); System.out.print(num + "的素因数:"); factor(num); &#125; private static void factor(int num) &#123; // TODO Auto-generated method stub for(int i = 2; i &lt;= Math.sqrt(num); i++)&#123; if(num % i == 0)&#123; System.out.print(i + " * "); if(isPrime(num / i))&#123; System.out.println(num / i); &#125; else factor(num / i); break; &#125; &#125; &#125; private static boolean isPrime(int i) &#123; // TODO Auto-generated method stub for(int j = 2; j &lt;= Math.sqrt(i); j++)&#123; if(i % j == 0) return false; &#125; return true; &#125;&#125; 【程序5】条件运算符的嵌套利用条件运算符的嵌套来完成此题: 学习成绩&gt;=90分的同学用A表示，60-89分之间用B表示，60分以下的用C表示。1234567891011121314151617181920import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入你的分数"); int score = in.nextInt(); if(score &gt;= 90)&#123; System.out.println("A 恭喜"); &#125; else if(score &gt;= 60)&#123; System.out.println("B 不错"); &#125; else&#123; System.out.println("C 加油"); &#125; &#125;&#125; 【程序6】最大公约数和最小公倍数输入两个正整数m和n，求其最大公约数和最小公倍数。1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入第一个数"); int a = in.nextInt(); System.out.println("请输入第二个数"); int b = in.nextInt(); System.out.println("这两个数的最大公约数是 " + MaxCommonDivisor(a, b)); System.out.println("这两个数的最小公倍数是 " + MinCommonMultiple(a, b)); &#125; private static int MaxCommonDivisor(int a, int b) &#123; // TODO Auto-generated method stub if(a &lt; b)&#123; int temp = a; a = b; b = temp; &#125; while(a % b != 0)&#123; int temp = a % b; a = b; b = temp; &#125; return b; &#125; private static int MinCommonMultiple(int a, int b) &#123; // TODO Auto-generated method stub return a * b / MaxCommonDivisor(a, b); &#125;&#125; 【程序7】统计英文字母、空格、数字和其它字符个数输入一行字符，分别统计出其中英文字母、空格、数字和其它字符个数。1234567891011121314151617181920212223242526272829import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("Input one sentance."); String s = in.nextLine(); int letter = 0, symbol = 0, space = 0, number = 0; char[] strArray = s.toCharArray(); for (int i = 0; i &lt; strArray.length; i++) &#123; char c = strArray[i]; if(('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z')) letter++; else if(48 &lt;= c &amp;&amp; c &lt;= 57) //注意！数字0-9的ASCII码是48-57 number++; else if(c == ' ') space++; else symbol++; &#125; System.out.println("This sentance have " + letter + " letters, "); System.out.println("have "+ number + " numbers, "); System.out.println("have " + space + " spaces, " + "and " + symbol + " symbols."); &#125;&#125; 【程序8】求s=a+aa+aaa+aaaa+…的值求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222(此时共有4个数相加)，几个数相加有键盘控制。1234567891011121314151617181920import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println("请输入相加的基数"); int n = input.nextInt(); System.out.println("请输入要相加的个数"); int i = input.nextInt(); long total = 0L; long temp = n; for(int j = 0; j &lt; i; j++)&#123; total += temp; temp = temp * 10 + n; &#125; System.out.println("和为" + total); &#125;&#125; 【程序9】完数一个数如果恰好等于它的因子之和，这个数就称为”完数”。例如: 6=1+2+3。编程: 找出1000以内的所有完数。12345678910111213141516public class class_name &#123; public static void main(String[] args) &#123; System.out.println("1000以内的完数有："); for(int i = 1; i &lt; 1000; i++)&#123; int sum= 0; for(int j= 1; j&lt; i; j++) &#123; if (i% j== 0) &#123; sum+= j; &#125; &#125; if (sum== i) &#123; System.out.println(i); &#125; &#125; &#125;&#125; 【程序10】球落地一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第10次落地时，共经过多少米？第10次反弹多高？1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入原始高度。"); double s = in.nextDouble(); System.out.println("要求第几次落地后的距离。"); int n = in.nextInt(); double total = s; System.out.printf("第%d次落地后共走的距离是：" , n); if(n == 1) &#123; System.out.println(total); System.out.printf("第%d次反弹的距离是%f。", n, s / 2); &#125; else &#123; for(int i = 1; i &lt; n; i++) &#123; s = s / 2; total += 2 * s; //一上一下共两倍的弹跳距离 &#125; System.out.print(total); System.out.println(); System.out.printf("第%d次反弹的距离是%f。", n, s / 2); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse安装JBoss Tools]]></title>
    <url>%2F2018%2F03%2F04%2Feclipse%E5%AE%89%E8%A3%85JBoss-Tools%2F</url>
    <content type="text"><![CDATA[进入JBoss Tools插件下载页面，点击Download。style的eclipse版本是4.7.2，选择相对应版本的插件下载。点击Update Site，复制对应的更新地址。打开eclipse，点击Help–&gt;Install New Software。进入插件安装界面，点击Add。输入name和url。确定后选择Select All，点击Next。]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP自动提示]]></title>
    <url>%2F2018%2F02%2F26%2FJSP%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[1、Window–&gt;Preferences–&gt;Java–&gt;Editor–&gt;Content Assist修改Auto activation triggers for Java的值为:1.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 2、JavaScript–&gt;Editor–&gt;Content Assist修改Auto activation triggers for JavaScript的值为:1.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3、Web–&gt;Html Files–&gt;Editor–&gt;Content Assist修改Prompt when these characters are inserted的值为:1&lt;=.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp编码]]></title>
    <url>%2F2018%2F02%2F25%2Fjsp%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在eclipse中修改jsp页面的默认编码。1、Window–&gt;Preferences。2、点击Web，选择JSP Files，将右边的Encoding选为UTF-8。3、新建一个jsp页面，页面编码就是修改后的。]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse Java EE配置Tomcat]]></title>
    <url>%2F2018%2F02%2F25%2Feclipse%E9%85%8D%E7%BD%AETomcat%2F</url>
    <content type="text"><![CDATA[配置Tomcat1、打开eclipse，单击Window菜单，选择下方的Preferences。2、单击Server选项，选择下方的Runtime Environments。3、点击Add，添加 Tomcat。4、点击Next， 选中自己安装的Tomcat路径。5、点击Finish完成。 建立一个Web应用1、File–&gt;New–&gt;Dynamic Web Project。2、创建一个Dynamic Web Project。3、连续点击两下Next。4、点击Finish完成。 让Tomcat服务器显示在控制台上，将Web应用部署到Tomcat1、Window–&gt;Show View–&gt;Servers2、右键Server面板中的Add and Remove。3、添加项目到Configured，选中项目并点击Add或者双击都可以添加到右边。4、点击Finish完成。返回下方的Servers面板，右键单击该面板中的Tomcat v9.0 Server at localhost节点，在弹出的快捷菜单中单击Start即可启动指定的Web服务器。如果此时直接访问http://localhost:8080/test_first ,会发现报404的错误。这是因为我们没有添加主页，下面添加主页(index.jsp)的内容。5、右键WebContent–&gt;New–&gt;JSP File。1注意: Web资源一定要在WebContent目录下添加。 此时，再一次来访问http://localhost:8080/test_first ，效果如下:]]></content>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Tomcat]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%AE%89%E8%A3%85Tomcat%2F</url>
    <content type="text"><![CDATA[Tomcat是Apache软件基金会的Jakarta项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成，成为目前比较流行的Web应用服务器。一、下载登录http://tomcat.apache.org 站点，下载合适的Tomcat版本。单击左边的Download下的Tomcat 9 超链接，在打开的新页面中，下载Tomcat的最新版9.0.5版的所有安装包。选择合适的版本下载即可。style选择下载的是64位的Windows下的64-bit Windows zip(pgp, md5, sha1, sha512)安装包。把下载得到的apache-tomcat-9.0.5-windows-x64.zip文件解压到合适的位置。可以看到如图的文件结构。style将其解压到了F:\apache-tomcat-9.0.5目录。各个文件目录的说明如下所示。1234567/bin: 存放Windows或Linux平台上启动和关闭Tomcat的脚本文件。/conf: 存放Tomcat服务器的各种全局配置文件，其中，最重要的是server.xml和web.xml。/lib: 存放Tomcat服务器所需的各种JAR文件。/logs: 存放Tomcat执行时的日志文件。/temp: 存放Web运行过程中生成的临时文件。/webapps: Tomcat的主要Web发布目录，默认情况下把Web应用文件放于此目录。/work: 存放JSP编译后产生的class文件。 二、Tomcat的配置要想运行Tomcat，还需要配置环境变量以及配置管理员。(1) 添加环境变量，如图所示，在”环境变量”里新建系统变量，变量名为CATALINA_HOME，变量值为F:\apache-tomcat-9.0.5(Tomcat解压到的目录)。(2) 如图所示，在系统变量Path的最后面添加:%CATALINA_HOME%\lib;%CATALINA_HOME%\lib\servlet-api.jar;%CATALINA_HOME%\lib\jsp-api.jar。注意不同系统变量之间的分号一定是英文的分号。(3) 如图所示，为Tomcat 9.0的管理员的配置，进入F:\apache-tomcat-9.0.5下的conf目录，编辑tomcat-users.xml,找到最后的1234567&lt;!-- &lt;role rolename="tomcat"/&gt; &lt;role rolename="role1"/&gt; &lt;user username="tomcat" password="&lt;must-be-changed&gt;" roles="tomcat"/&gt; &lt;user username="both" password="&lt;must-be-changed&gt;" roles="tomcat,role1"/&gt; &lt;user username="role1" password="&lt;must-be-changed&gt;" roles="role1"/&gt;--&gt; 在上面这段后面添加上1234&lt;role rolename="manager-gui"/&gt;&lt;role rolename="admin-gui"/&gt;&lt;user username="admin" password="123" roles="admin-gui"/&gt;&lt;user username="admin" password="123" roles="manager-gui"/&gt; 保存并关闭tomcat-users.xml。(4) 进入Tomcat目录下的bin目录，双击startup.bat启动Tomcat，在命令行窗口会显示出英文提示，如图所示。(5) 在浏览器中输入http://localhost:8080/ 出现Tomcat的欢迎页面就说明配置成功了，如图所示。(6) 单机右上角的Manager App按钮，输入上面配置的用户名和密码，就可以进入管理页面，如图所示。(7) 至此，Tomcat安装配置完成。]]></content>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py之计算器]]></title>
    <url>%2F2018%2F01%2F23%2Fpy%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[某大佬的作品，在此学习一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#!usr/bin/python# -*- coding: UTF-8 -*-import re,os,sys'''计算这表达式的值：1 - 2 * ((60-30 +(-40.0/5) * (9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 )) - (-4*3)/ (16-3*2)))'''def format_mark(express): ''' 表达式替换过程中可能出现一些组合符号， 机器无法辨别，此函数负责处理这些组合符号 ''' express = express.replace('+-', '-') express = express.replace('-+', '-') express = express.replace('++', '+') express = express.replace('--', '+') express = express.replace('*+', '*') express = express.replace('+*', '*') express = express.replace('+/', '/') express = express.replace('/+', '/') return expressdef com_jiajian(express): ''' :param express: :return: ''' expr = express sub_expr = re.search(r"\-?\d+\.?\d*[\+\-]\d+\.?\d*", expr) #print (sub_expr) #re.search()函数将对整个字符串进行搜索，并返回第一个匹配的字符串的match对象。 if not sub_expr: return expr else: sub_expr2 = sub_expr.group() #group()用来提出分组截获的字符串，（）用来分组 # print('sub_expr1',sub_expr1,'19行结果express:',div_express) if len(sub_expr2.split('+')) &gt; 1: #通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 n1, n2 = sub_expr2.split('+') result = float(n1)+float(n2) else: n1, n2 = sub_expr2.split('-') result = float(n1) - float(n2) re_sub_expr = re.sub(r"\-?\d+\.?\d*[\+\-]\d+\.?\d*", str(result), expr, count=1) # 反复调用除法 print('加减运算：',re_sub_expr) bb = com_jiajian(str(re_sub_expr)) return bbdef com_chengchu(expr_div): ''' :param expr_div: :return: ''' expr=expr_div sub_expr = re.search(r"\d+\.?\d*[\/\*]\-?\d+\.?\d*",expr) if not sub_expr: return expr else: sub_expr2 = sub_expr.group() if len(sub_expr2.split('/')) &gt; 1: n1, n2 = sub_expr2.split('/') result = float(n1)/float(n2) if len(sub_expr2.split('*')) &gt; 1: n1, n2 = sub_expr2.split('*') result = float(n1)*float(n2) else: #只计算乘除，加减直接pass，放入加减函数执行 pass re_sub_expr=re.sub(r"\d+\.?\d*[\/\*]\-?\d+\.?\d*",str(result),expr,count=1) #反复调用除法 print('乘除运算：',re_sub_expr) bb=com_chengchu(format_mark(re_sub_expr)) return bbdef compute(express): express = com_chengchu(format_mark(express)) express = com_jiajian(format_mark(express)) return expressdef delkuohao(express): #检测表达式是否存在括号，如果存在就去括号，否则直接执行 res=re.compile(r'[()]') #将一个字符串编译为字节代码。 sub_expr1 = re.search('(\([\+\-\*\/\.0-9]+\))', express) if not sub_expr1: return express else: sub_expr1=sub_expr1.group() #delkuohao(express) #匹配括号，将计算结果替换到表达式 sub_expr2=sub_expr1[1:len(sub_expr1)-1] sub_expr3=compute(sub_expr2) sub_expr3 = re.sub('(\([\+\-\*\/\.0-9]+\))', str(sub_expr3),express,count=1) print('括号运算：',sub_expr3) delkuohao_expr=delkuohao(format_mark(sub_expr3)) return delkuohao_exprif __name__=="__main__": #while True: #express=input("请输入要计算的表达式：") print('\n================================') print('\033[33m 混合运算计算器\033[0m') print('================================') #express ='1-2*((60-30+(-40.0/5)*(9-2*5/3+7/3*99/4*2998+10*568/14))-(-4*3)/(16-3*2))' while True: express = input('\033[32m请输入表达式,规范点哦 | (退出:q)\033[0m') express = re.sub('\s*', '', express) if len(express) == 0: continue elif express == 'q': sys.exit('退出程序') elif re.search('[^0-9\.\-\+\*\/\(\)]',express): print('\033[31m 不是有效的算数表达式哦，请重新输入!!!\033[0m') else: express = express.replace(' ', '') print('您输入的表达式：',express) '''调用删除括号的函数''' express2 = delkuohao(express) #删除括号 express2 = compute(format_mark(express2)) #删除括号后再调用一次计算函数 print('\033[31m表达式:%s'%express,'=', str(express2),'\033[0m')]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py基础四之异常处理]]></title>
    <url>%2F2018%2F01%2F20%2Fpy%E5%9F%BA%E7%A1%80%E5%9B%9B%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[python基础语法之异常处理12345678910111213141516171819202122232425262728293031#!/usr/bin/python# -*- coding: UTF-8 -*-try: 1 / 0except Exception as e: '''异常的父类，可以捕获所有的异常''' print "0不能被除"else: '''保护不抛出异常的代码''' print "没有异常"finally: print "最后总是要执行我"'''try： code #需要判断是否会抛出异常的代码，如果没有异常处理，python会直接停止执行程序except: #这里会捕捉到上面代码中的异常，并根据异常抛出异常处理信息#except ExceptionName，args： #同时也可以接受异常名称和参数，针对不同形式的异常做处理 code #这里执行异常处理的相关代码，打印输出等else： #如果没有异常则执行else code #try部分被正常执行后执行的代码finally： code #退出try语句块总会执行的程序''']]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py基础三]]></title>
    <url>%2F2018%2F01%2F20%2Fpy%E5%9F%BA%E7%A1%80%E4%B8%89%2F</url>
    <content type="text"><![CDATA[python基础语法(三)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!usr/bin/python# -*- coding: UTF-8 -*-#打开一个文件fo= open("4.txt", "r+")#fo.write( "www.runoob.com!\nVery good site!\n");str= fo.read(10)print "文件名: ", fo.nameprint "是否已关闭: ", fo.closedprint "访问模式: ", fo. modeprint "末尾是否强制加空格: ", fo.softspaceprint "读取的字符串是: ", strposition= fo.tell()print "当前文件位置: ", positionposition= fo.seek(0, 0)str= fo.read(10)print "重新读取字符串: ", strfo.close()#重命名文件import osos.rename("4.txt", "1.txt")#删除文件os.remove("1.txt")#创建目录os.mkdir("test")#改变目录#将当前目录改为"/home/newdir"os.chdir("/home/newdir")#显示当前目录os.getcwd()#删除目录os.rmdir("/tmp/test")#在 write 内容后，直接 read 文件输出会为空，是因为指针已经在内容末尾。#两种解决方式: 其一，先 close 文件，open 后再读取，其二，可以设置指针回到文件最初后再 readdocument = open("testfile.txt", "w+");print "文件名: ", document.name;document.write("这是我创建的第一个测试文件！\nwelcome!");print document.tell();#输出当前指针位置document.seek(os.SEEK_SET);#设置指针回到文件最初context = document.read();print context;document.close();]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py基础二]]></title>
    <url>%2F2018%2F01%2F18%2Fpy%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[python基础语法(二)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#!usr/bin/python# -*- coding: UTF-8 -*-import timelocaltime = time.localtime(time.time())print "本地时间为 :", localtime#获取格式化的时间localtime = time.asctime( time.localtime(time.time()) )print "本地时间为 :", localtime# 格式化成2016-03-20 11:45:39形式print time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 格式化成Sat Mar 28 22:24:24 2016形式print time.strftime("%a %b %d %H:%M:%S %Y", time.localtime()) # 将格式字符串转换为时间戳a = "Sat Mar 28 22:24:24 2016"print time.mktime(time.strptime(a,"%a %b %d %H:%M:%S %Y"))#获取某月日历import calendarcals = calendar.month(2018, 1)print "以下输出2018年1月份的日历:"print cals;import datetimei = datetime.datetime.now()print ("当前的日期和时间是 %s" % i)print ("ISO格式的日期和时间是 %s" % i.isoformat() )print ("当前的年份是 %s" %i.year)print ("当前的月份是 %s" %i.month)print ("当前的日期是 %s" %i.day)print ("dd/mm/yyyy 格式是 %s/%s/%s" % (i.day, i.month, i.year) )print ("当前小时是 %s" %i.hour)print ("当前分钟是 %s" %i.minute)print ("当前秒是 %s" %i.second)#函数#缺省参数#可写函数说明def printinfo( name, age = 35 ): "打印任何传入的字符串" print "Name: ", name; print "Age ", age; return; #调用printinfo函数printinfo( age=50, name="miki" );printinfo( name="miki" );#不定长参数#加了星号（*）的变量名会存放所有未命名的变量参数。# 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print "输出: " print arg1, '我是arg1' for var in vartuple: print var return; # 调用printinfo 函数printinfo( 10 );printinfo(70, 60, 50, 66);#全局变量想作用于函数内，需加globalglobvar = 0def set_globvar_to_one(): global globvar # 使用 global 声明全局变量 globvar = 1def print_globvar(): print(globvar) # 没有使用 globalset_globvar_to_one()print globvar # 输出 1print_globvar() # 输出 1，函数内的 globvar 已经是全局变量#列表反转函数def reverse(li): for i in range(0, len(li)/2): temp = li[i] li[i] = li[-i-1] li[-i-1] = templ = [1, 2, 3, 4, 5]reverse(l)print(l)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ie11降级]]></title>
    <url>%2F2018%2F01%2F17%2Fie11%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[中小学教师资格证考试有点坑…上图说是使用IE6-IE10系列浏览器或“搜狗浏览器(兼容模式)”！对于我这种不太使用IE系列浏览器的人来说，确实有点…下面说下解决方法：打开你的IE按照流程进入到报名系统处发现系统提示使用IE6-IE10系列浏览器或“搜狗浏览器(兼容模式)”！检查了下发现自家的IE是11，降级就行。在此网页下，点右上角的齿轮，选择F12开发人员工具将文档模式和用户代理字符串改为11以下的就行，比如10然后将上方网址的/memapp/ieNote删除再回车，就可以登录了。]]></content>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行管理系统修改一]]></title>
    <url>%2F2018%2F01%2F17%2F%E9%93%B6%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[之前写过一个银行管理系统，现在对它进行了一些完善。增加了主界面的背景图片。增加了管理员功能管理员登陆成功管理员界面点击查询按钮可以将数据库中的账户信息显示在上方表中。选中一行，可以对一些信息进行修改，比如删除或修改。完善了账户退出功能用户登陆账户，点第一次退出会退出当前账户，再次点击退出会退出程序。源码下载]]></content>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础一]]></title>
    <url>%2F2018%2F01%2F16%2Fpython%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[python的基本语法(一)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#!usr/bin/python# -*- coding: UTF-8 -*-print range(1, 5) #代表从1到5（不包括5）print range(1, 5, 2) #代表从1到5，间隔2（不包括5）print range(5) #代表从0到5（不包括5）print ord('b') #convert char to intprint chr(100) #convert int to charprint unichr(100) #return a unicode byte#abs()和 fabs()区别#abs()是一个内置函数， 而fabs()是在math模块中定义的。#fabs()函数只适用于float和 integer类型，而abs()也适用于复数print abs(-10)import mathprint math.fabs(-10)print type(abs(-10))print type(math.fabs(-10))#多行语句total= 'item_one '+ \'item_two '+ \'item_three'print total#字符串str = 'Hello World!' print str # 输出完整字符串print str[0] # 输出字符串中的第一个字符print str[2:5] # 输出字符串中第三个至第五个之间的字符串print str[2:] # 输出从第三个字符开始的字符串print str * 2 # 输出字符串两次print str + "TEST" # 输出连接的字符串print str[:2] # 输出从开始到第二个字符的字符串print "更新字符串: ", str[:3]+ 'sanstyle' #更新字符串print "My name is %s and age is %d!" % ('style', 21)# %s格式化字符串 %d格式化整数# %c格式化字符及其ASCII码#列表list1 = ['physics', 'chemistry', 1997, 2000];print list1print len(list1) #返回列表元素个数print list1[-2] #读取列表中倒数第二个元素print list1[-2:] #从倒数第二个元素开始读取print list1[:-2] #读到倒数第二个前(不包括倒数第二个)del list1[2] #删除第三个print list1list1.append('3e3e') #在列表末尾添加新的对象print list1.count('3e3e') #统计出现的次数print list1.index('3e3e') #从列表重找出第一个匹配项的索引位置list1.remove('3e3e') #移除列表中这个值的第一个匹配项list1.reverse() #反向列表中元素print list1list2=[123,["das","aaa"],234]print 'aaa' in list2 #in只能判断一个层次的元素 print 'aaa' in list2[1] #选中列表中的二层列表进行判断#元组(元素不能修改)#元组中只包含一个元素时，需要在元素后面添加逗号tup= (50, )print tuptup1= (12, 34, 56)tup2= ('abc', 'xyz')#以下修改元组元素的操作是非法的#tup1[0]= 100#任意无符号的对象，以逗号隔开，默认为元组print 'abc', -4.24e93, 18+6.6j, 'xyz';x, y = 1, 2;print "Value of x , y : ", x,y;#字典(可存储任意类型对象)dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; print "dict['Name']: ", dict['Name'];print "dict['Age']: ", dict['Age'];dict['Age'] = 8; # update existing entrydict['School'] = "DPS School"; # Add new entryprint "dict['Age']: ", dict['Age'];print "dict['School']: ", dict['School'];print dictdel dict['Name']; # 删除键是'Name'的条目print dict#dict.clear(); # 清空词典所有条目#print dict#del dict ; # 删除词典print dict.keys() #以列表返回一个字典所有的键print dict.values() #以列表返回一个字典所有的值#字典值可以是任意数值类型dict1= &#123;"a":[1,2]&#125; # 值为列表print dict1['a'][1]dict2= &#123;"a":&#123;"c":"d"&#125;&#125; # 值为字典 print dict2['a']['c']]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditPlus运行py编码问题]]></title>
    <url>%2F2018%2F01%2F15%2FEditPlus%E8%BF%90%E8%A1%8Cpy%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[文本编辑器是EditPlus，运行python时候报出如下错误: SyntaxError: (unicode error) &#39;utf-8&#39; codec can&#39;t decode byte 0xc4 in position 0: invalid continuation byte。非常普通的Hello World，编码格式是utf-8解决方法：用notepad++打开python1_1.py发现存储格式是ANSI。保存的时候默认是保存成ANSI格式。发现问题就好解决啦，保存文件的时候将文件格式换成UTF-8就好了。成功输出！]]></content>
      <tags>
        <tag>python</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javax/xml/bind/DatatypeConverter]]></title>
    <url>%2F2018%2F01%2F15%2Fjavax-xml-bind-DatatypeConverter%2F</url>
    <content type="text"><![CDATA[话不多说，上图。重装系统后，想调试下实训的代码，发现一样的代码竟然运行不了。后来发现，重装后安装的jdk版本是9.0，并不是完全兼容。看错误提示是java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter。这是因为Java虚拟机在编译时候能找到这个类，而在运行时没能找到这个类。按照错误提示，下载这个类的jar包就行。jar包下载地址]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.length和.length()的区别]]></title>
    <url>%2F2017%2F12%2F31%2Flength%E5%92%8C-length-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[java中的length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了length这个属性。java中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到length()这个方法。如何获取一个数组的长度？以及，如何获取一个字符串的长度？ 12345int[] arr = new int[3];System.out.println(arr.length);//使用length获取数组的程度 String str = "abc";System.out.println(str.length());//使用length()获取字符串的长度 为什么数组有length属性？ 数组是一个容器对象，其中包含固定数量的同一类型的值。一旦数组被创建，他的长度就是固定的了。数组的长度可以作为final实例变量的长度。因此，长度可以被视为一个数组的属性。 为什么String有length()方法？ String背后的数据结构是一个char数组,所以没有必要来定义一个不必要的属性（因为该属性在char数值中已经提供了）。和C不同的是，Java中char的数组并不等于字符串，虽然String的内部机制是char数组实现的。 注: 要想把char[]转成字符串有以下方式：1234char []s = &#123;'a','b','c'&#125;;String string1 = s.toString();String string2 = new String(s);String string3 = String.valueOf(s);]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识点一]]></title>
    <url>%2F2017%2F12%2F31%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1、面向对象的特征有哪些方面 1、抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。2、继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 3、封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 4、多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 2、什么是接口？写出接口与抽象类的区别。 接口是你在写程序时所有方法的一个声明，只设计，无实现。区别：1、都没有方法体2、通过接口可以支持多重继承，抽象类不支持3、抽象类可以包含已经实现的方法而接口不可以 3、写出String和StringBuffer的区别，int和Integer有什么区别。 String类创建的对象不可修改，StringBuffer创建的的对象是内存空间可以改变的大小的，可以调用append方法追加到字符串序列;Int是java的原始数据类型，Integer是java为int提供的封装类,引用数据类型。 4、sleep() 和 wait() 有什么区别?sleep()不释放同步锁,wait()释放同步锁。 sleep方法是Thread类的静态方法,线程在占用CPU资源期间，通过调用Sleep方法来使自己放CPU资源，休眠一段时间。wait是object类的方法，可以中断方法的执行，使本线程等待，暂时让出cpu的使用权，并允许其他线程使用这个同步方法。 5、简述线程的生命周期 新建、运行、中断、死亡 6、举例说明如何获取当前的年月日，时分秒以及从1970年到现在的毫秒数。1234567Date nowtime=new Date();System.out.println(nowtime);SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date currentTime=new Date(); Date beginTime=sdf.parse("1970-01-01 12:53:30"); long interval=(currentTime.getTime()-beginTime.getTime());]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[窗口程序]]></title>
    <url>%2F2017%2F12%2F31%2F%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[编写一个程序，生成一个窗口。标题为记事本，有一个文件菜单，正中显示一个TextArea,默认值为“我是TextArea！”。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.awt.*;import java.awt.event.*;import java.io.*;class WindowJiShiBen extends Frameimplements ActionListener&#123; MenuBar menubar; Menu menu; MenuItem itemExit; MenuItem itemSave; TextArea text1; FileWriter tofile; BufferedWriter out; FileDialog filedialog_save; WindowJiShiBen(String s) &#123; super(s); text1 =new TextArea("我是TextArea"); menubar =new MenuBar(); menu =new Menu("文件"); itemExit =new MenuItem("退出"); itemExit.setShortcut(new MenuShortcut(KeyEvent.VK_E)); itemSave=new MenuItem("保存"); itemSave.setShortcut(new MenuShortcut(KeyEvent.VK_S)); filedialog_save=new FileDialog(this,"保存文件话框",FileDialog.SAVE); menu.add(itemExit); menubar.add(menu); menu.add(itemSave); setMenuBar(menubar); add(text1); itemExit.addActionListener(this); itemSave.addActionListener(this); setBounds(100,100,150,150); setVisible(true); validate(); filedialog_save.addWindowListener(new WindowAdapter() &#123;public void windowClosing(WindowEvent e) &#123; filedialog_save.setVisible(false); &#125; &#125;); &#125; public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==itemExit) &#123;System.exit(0);&#125; else if(e.getSource()==itemSave) &#123;filedialog_save.setVisible(true); if(filedialog_save.getFile()!=null) &#123; try &#123; File file=new File(filedialog_save.getDirectory(),filedialog_save.getFile()); tofile=new FileWriter(file); out=new BufferedWriter(tofile); out.write(text1.getText(),0,(text1.getText()).length()); out.close(); tofile.close(); &#125; catch(IOException e2)&#123;&#125; &#125; &#125; &#125;&#125;public class jishiben&#123; public static void main(String args[]) &#123; WindowJiShiBen win=new WindowJiShiBen("记事本"); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见问题一]]></title>
    <url>%2F2017%2F12%2F29%2FJava%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[错误: 找不到或无法加载主类 Test8.Main解决方法：右键你的项目，选最后一个properties，把properties属性里的java compiler–&gt;building–&gt;abort build when build path errors occur前的勾去掉就好了。好像还有其他的解决方法。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行管理系统]]></title>
    <url>%2F2017%2F12%2F29%2F%E9%93%B6%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[此次的项目是银行管理系统，要求连接数据库，在此记录下。 总界面在此界面除了开户和退出两个功能能实现外，其它功能都需要登录后才能使用。 开户界面此界面需要用户输入个人信息来进行开户操作，用户输入的信息将会保存到数据库中。开户成功后系统会反馈一个开户账号。这个账号是使用的System.currentTimeMillis()产生一个当前的毫秒，这个毫秒其实就是自1970年1月1日0时起的毫秒数。 登录界面此界面需要用户输入开户的账号和密码，系统会从数据库中读取信息与之比对，无误则成功登录。 存款界面此界面需要用户输入存款金额，完成后系统会显示当前账号的余额。此操作记录将会存到数据库中。 取款界面此界面需要用户输入取款金额，完成后系统会显示当前账号的余额。此操作记录将会保存到数据库中。 转账界面此界面需要用户输入对方的账号和转账金额，完成后系统会显示当前账号的余额。此操作记录将会保存到数据库中。 销户界面进入此界面，系统会判断账户余额是否为零，如果不是，不能销户。用户将余额取出，销户完成。 修改密码界面用户需要输入两次相同的六位数字或字母密码，此操作记录将会保存到数据库中。 查看个人信息界面此界面将会显示查询到的当前账户的信息包括账号，姓名，性别，身份证号，联系电话以及开户时间。源码可在这里下载。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Four_or_six]]></title>
    <url>%2F2017%2F12%2F13%2FFour-or-six%2F</url>
    <content type="text"><![CDATA[嗯…没错，就是四六级！]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS填空题]]></title>
    <url>%2F2017%2F12%2F12%2FOS%E5%A1%AB%E7%A9%BA%E9%A2%98%2F</url>
    <content type="text"><![CDATA[操作系统填空题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869影响文件安全的主要因素: `人为因素`, `系统因素`, `自然因素`。程序执行时呈现出局部性规律: `时间局限性`, `空间局限性`。操作系统的主要功能有: `处理机管理`, `存储器管理`, `设备管理`, `文件管理`, `用户接口`。解决通道“瓶颈”问题最有效的方法是增加设备到主机间的: `通路`。进程三种基本状态: `就绪状态`, `执行状态`, `阻塞状态`。目录管理的主要功能: `实现按名存取`, `提高检索速度`, `文件共享`, `允许文件重名`。在操作系统中，实现进程同步的机制有: `信号量机制`, `管程机制`。进程同步机制应遵循的准则: `空闲让进`, `忙则等待`, `有限等待`, `让权等待`。抢占式进程调度方式基于的主要原则有: `优先权原则`, `短进程优先原则`, `时间片原则`。请求分页系统的主要硬件支持有: `请求分页页表机制`, `缺页中断机构`, `地址变换机构`。进程死锁原因: `竞争资源`, `进程间推进顺序非法`。通常采用解除死锁的两种方法是: `剥夺资源`, `撤消进程`。设备分配中的主要数据结构(英文缩写): `DCT`, `COCT`, `CHCT`, `SDT`。进程、文件、线程在系统中是否存在的唯一标志(英文缩写): `PCB`, `FCB`, `TCB`。产生进程死锁的必要条件: `互斥条件`, `请求和保持条件`, `不剥夺条件`, `环路等待条件`。目前比较流行的操作系统(实例): `Windows`, `UNIX`, `Linux`。OS(操作系统)的基本特征: `并发性`, `共享性`, `虚拟性`, `异步性`。OS(操作系统)的基本类型: `批处理系统`, `分时系统`, `实时系统`。外存分配条件: `连续分配`, `链接分配`, `索引分配`。文件物理结构: `顺序文件`, `链接文件`, `索引文件`。设备的独立性: `LUT`。按设备的固有属性分类，将I/O设备分为: `独占设备`, `共享设备`, `虚拟设备`。虚拟存储理论: `局部性原理`。虚拟设备技术: `SPOOLing`。将一台物理I/O设备虚拟为多台逻辑I/O设备的技术: `SPOOLing`。UNIX本质特征: `OSI`。UNIX内核结构: `进程控制子系统`, `文件子系统`。OS(操作系统)设计目标: `方便性`, `有效性`, `可扩充性`, `开放性`。OS(操作系统)用户接口: `命令接口`, `程序接口`, `图形用户接口`。`方便性`和`有效性`是操作系统设计中最重要的两个目标1990年后，`开放性`已成为新系统或软件能否被广泛应用的至关重要的因素。`并发性`和`共享性`是多用户、多任务操作系统两个最基本的特征。`并发性`是多用户、多任务操作系统最重要的特征。在OS基本特征中，`异步性`是指进程是以人们不可预知的速度向前推进的。在操作系统基本类型中，`可靠性`是实时系统最重要的特征。在操作系统接口中，`程序接口`亦称为`系统调用`。进程所请求的一次I/O完成后，将使进程状态从`阻塞状态`变为`就绪状态`。操作系统中处于执行状态的进程时间片用完后，进程状态将转变为`就绪状态`。操作系统中处于执行状态的进程提出I/O后请求后，进程状态将转变为`阻塞状态`。进程三种基本状态中，`就绪状态`是指进程已分配到除CPU以外的所有必要资源。同步机制准则中，`让权等待`是指当进程不能进入自己的临界区时，应立即释放处理机。在文件系统中，文件属性信息存储在`数据结构(英文缩写)FCB`中。操作系统利用`数据结构(英文缩写)PCB`描述进程的基本情况和活动过程。系统将被中断进程的CPU现场信息保存在该进程的`数据结构(英文缩写)PCB`中。1965年，荷兰学者Dijkstra提出的`信号量机制`是一种卓有成效的进程同步工具。在死锁的条件中，`不剥夺条件`是指进程已获得的资源只能在使用完时由自己释放。在死锁的条件中，`互斥条件`是指在一段时间内，某资源只能被一个进程占用。`资源的按序分配法`是摒弃死锁条件中的`环路等待条件`来预防死锁的发生。现代操作系统产生死锁的条件中，`互斥条件`是不能被摒弃来预防死锁的发生。在局部性原理中，产生`时间局限性`的典型原因是在程序中存在着大量的循环操作。在局部性原理中，产生`空间局限性`的典型情况是程序的顺序执行。在请求分页系统的硬件支持中，当所要访问的页面不在内存时，由`缺页中断机构`实现。在请求分页系统的硬件支持中，页面置换算法需要应用`请求页表机制`实现。为了实现设备的独立性，系统必须设置(英文缩写): `LUT`。在设备分配中，用于记录每一个设备情况的数据结构(英文缩写): `DCT`。在设备分配中，用于记录全部设备情况的数据结构(英文缩写): `SDT`。在设备分配中，用于记录每一个控制器情况的数据结构(英文缩写): `COCT`。在设备的固有属性分类中，`独占设备`属于临界资源，即进程临界区访问的资源。在设备的固有属性分类中，典型的独占设备有`打印机`、`磁带机`等。在设备的固有属性分类中，典型的共享设备有`磁盘`、`光盘`。在假脱机打印机系统中，在设备的固有属性分类，是将`独占设备`改造为`共享设备`。在假脱机打印机系统中，在设备的固有属性分类，实现了`虚拟设备`功能。`SPOOLing`技术是对脱机I/O系统的模拟，或称为`假脱机技术`。在索引节点中设置链接引用(links)计数的目的是为了实现目录管理的`文件共享功能`。实现`按名存取`是文件系统目录管理中最基本的功能。实现`按名存取`是文件系统向用户提供的最基本的服务。通过`建立后备系统`，防止由`自然因素`所造成的文件系统的不安全性。通过`存取控制机制`，防止由`人为因素`所造成的文件系统的不安全性。通过`采取容错技术`，防止由`系统因素`所造成的文件系统的不安全性。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐写之图片隐藏]]></title>
    <url>%2F2017%2F12%2F08%2F%E9%9A%90%E5%86%99%E4%B9%8B%E5%9B%BE%E7%89%87%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[在图片中插入其他的文件，例如一段音乐，一段视频，或是某个文件。1、准备一张图片和要隐藏的资料信息比如这里，style准备了一张壁纸和一个txt文件。现在需要将一个文件隐藏在这张图片里。2、选择需要隐藏的文件，右键压缩成一个rar文件，文件名字可以随便起，在这里style将其压缩成1.rar。3、新建一个文本文档，名字随便起，style这里将其命名为2.txt,，在里面输入以下代码copy /b 1.jpg+1.rar 222.jpg4、接着另存为这个文本文档，重要的是文件类型得是bat类型，也就是批处理命令。style这里命名为2.bat。5、双击这个bat命令，得到一个最终的文件222.jpg。6、这个图片打开看的话和正常的图片一样，但是大小与封面图片相比是不一样的，其实这里面包含了刚刚隐藏的那些重要信息。将得到的新的图片的后缀改为rar，然后解压就可得到我们刚刚隐藏的文件。也可以用二进制编辑器查看，发现在后面有个zip的文件头，可以将这个压缩包提取出来，再解压。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[情报搜集技术]]></title>
    <url>%2F2017%2F12%2F07%2F%E6%83%85%E6%8A%A5%E6%90%9C%E9%9B%86%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[#外围信息搜集网站的IP地址查询kali中使用nslookup工具对testfire.net这个网站进行查询root@bt:~# nslookup回车后输入set type=A回车后输入testfire.net就可以了。 IP2Location地理位置查询查询IP地址，可以在http://www.maxmind.com 网站上使用该服务。如果是国内的IP地址，推荐使用“QQ纯真数据库”。 IP2Domain反查域名一台物理服务器上面可能运行多个虚拟主机，这些虚拟主机具有不同的域名，但通常公用一个IP地址。如果你要知道有哪些网站公用这台服务器，就有可能通过此台服务器上其他网站的漏洞获取服务器控制权，进而迂回获取渗透目标的权限，这种攻击技术也称为旁注。可以使用http://www.ip-adress.com/reverse_ip/ 提供的服务查询有哪些域名指向同一个IP地址。国内也有一些类似的网站可用于IP反查，如http://www.7c.com/ ,该网站针对国内的IP查询结果更为准确。 探索网站的目录结构如果管理员允许，Web服务器会将没有默认页面的目录以文件列表的方式显示出来，而这些开放了浏览功能的网站目录往往会透露一些网站可供浏览的页面之外的信息，甚至能够再这些目录中发现网站源代码甚至后端数据库的连接口令。可以再Google中输入parent directory site:testfire.net来查找testfire.net上的此类目录。打开第一个链接，网站的bank目录中的文件内容一览无余。在浏览网站目录时，应当对以下几种文件特别留意: 1、扩展名为inc的文件:可能会包含网站的配置信息，如数据库用户名/口令等。2、扩展名为bak的文件：通常是一些文本编辑器在编辑源代码后留下的备份文件，可以让你知道与其对应的程序脚本文件中的大致内容。3、扩展名为txt或sql的文件：一般包含网站运行的SQL脚本，可能会透露类似数据库结构等信息。 检索特定类型的文件在Google中输入site:testfire.net filetype:xls，可以查询testfire.net这个网站中xls类型文件。 搜索网站中的E-mail地址使用Metasploit中一个非常棒的辅助模块search_email_collector，进行有针对性的右键地址搜集。search_email_collector模块要求提供一个邮箱后缀（域名），它并不是通过直接遍历网站页面获取邮件地址，而是通过多个搜索引擎的查询结果分析使用此后缀的邮件地址，使用它就能够很方便地获取某个机构地大量邮件地址。msf&gt; use auxiliary/gather/search_email_collectormsf auxiliary(search_email_collector)&gt; set DOMAIN altoromutual.com回车后输入runtestfire网站模拟了一个名为altoromutual地电子银行站点，用它来做测试。 搜索易存在SQL注入点地页面使用Google可以筛选出网站中容易出现SQL注入漏洞的页面，如网站登录页面。例如在google.com中输入site:testfire.net inurl:login关键字进行搜索，得到了其后台登录URL。 #主机探测与端口扫描Metasploit的主机发现模块Metasploit中提供了一些辅助模块可用于活跃主机的发现，这些模块位于Metasploit源码路径的modules/auxiliary/scanner/discovery/目录中。其中两个常用模块的主要功能为: 1、arp_sweep使用ARP请求枚举本地局域网络中的所有活跃主机。2、udp_sweep通过发送UDP数据包探查指定主机是否活跃，并发现主机上的UDP服务。 Metasploit的arp_sweep模块是一个ARP扫描器。如下演示使用方法。首先需要输入RHOSTS来对扫描目标进行设置，设置好后输入run命令启动扫描器。从代码中可以看到，arp_sweep模块很快发现了192.168.2.0/24网段上拥有3台活跃主机，其中前两个IP地址为宿主主机上模拟的虚拟网卡IP地址。arp_sweep模块只能探测同一子网中的活跃主机，对于远程网络，可以使用更为强大的Nmap扫描器进行探测。 使用Nmap进行主机探测通常一个Nmap命令格式如下所示:nmap &lt;扫描选项&gt; &lt;扫描目标&gt;如果仅是在一个内部网中发现存活主机，可以使用-sn，这个选项会使用ICMP的Ping扫描获取网络中的存活主机情况，而不会进一步探测主机的详细情况。如果是在Internet环境中，推荐使用-Pn选项，它会告诉Nmap不要使用Ping扫描，因为ICMP数据包通常无法穿透Internet上的网络边界(通常是被防火墙过滤掉了)。在Internet环境中，可以使用nmap-PU通过对开放的UDP端口进行探测以确定存活的主机，其功能类似Metasploit中的udp_sweep辅助模块。Nmap在进行UDP主机探测时，默认会列出开放的TCP端口，如果想加快扫描速度，可以使用-sn告诉Nmap仅探测存活主机，不对开放的TCP端口进行扫描。 操作系统辨识可以使用-O选项让Nmap对目标的操作系统进行识别。使用nmap -A命令可以获取更详细的服务和操作系统信息。 #端口扫描与服务类型探测Metasploit中的端口扫描器Metasploit的辅助模块中提供了几款实用的端口扫描器。可以输入search portscan命令找到相关的端口扫描器。 1、ack: 通过ACK扫描的方式对防火墙上未被屏蔽的端口进行探测。2、ftpbounce: 通过FTP bounce攻击的原理对TCP服务进行枚举，一些新的FTP服务器软件能够很好的防范FTP bounce攻击，但在一些旧的Solaris及FreeBSD系统的FTP服务中此类攻击方式仍能够被利用。3、syn: 通过一次完整的TCP连接来判断端口是否开放，这种扫描方式最精确，但扫描速度慢。4、xmas: 一种更为隐秘的扫描方式，通过发送FIN、PSH和URG标志，能够躲避一些高级的TCP标记监测器的过滤。 一般情况下，推荐使用syn端口扫描器，因为它的扫描速度较快、结果精确且不容易被对方察觉。 Nmap的端口扫描功能Nmap对端口的状态分为六个层次: open(开放)、cloase(关闭)、filtered(被过滤)、unfiltered(未过滤)、open|filtered(开放或被过滤)、closed|filtered(关闭或被过滤)。下面对这几种端口状态进行说明: 1、open: 一个应用程序正在此端口上进行监听，以接收来自TCP、UDP或SCTP协议的数据。这是在渗透测试中最关注的一类端口，开放端口往往能够为我们提供一条能够进入系统的攻击路径。2、closed: 关闭的端口指的是主机已响应，但没有应用程序监听的端口。这些信息并非毫无价值，扫描出关闭端口至少说明主机是活跃的。3、filtered: 指Nmap不能确认端口是否开放，但根据响应数据猜测该端口可能被防火墙等设备过滤。4、unfiltered: 仅在使用ACK扫描时，Nmap无法确定端口是否开放，会归为此类。可以使用其他类型的扫描(如WIndow扫描、SYN扫描、FIN扫描)进一步确认端口的信息。 常用的Nmap扫描类型参数主要有: 1、-sT: TCP connect扫描，类似Metasploit中的tcp扫描模块。2、-sS: TCP SYN扫描，类似Metasploit中的syn扫描模块。3、-sF/-sX/-sN: 这些扫描通过发送一些特殊的标志位以避开设备或软件的监测，4、-sP: 通过发送ICMP echo请求探测主机是否存活，原理同ping。5、-sU: 探测目标主机开放了哪些UDP端口。6、-sA: TCP ACK扫描，类似Metasploit中的ack扫描模块。 常用的Nmap扫描选项有: 1、-Pn: 在扫描之前，不发送ICMP echo请求测试目标是否活跃。2、-O: 启用对于TCP/IP协议栈的指纹特征扫描以获取远程主机的操作系统类型等信息。3、-F: 快速扫描模式，只扫描在nmap-services中列出的端口。4、-p&lt;端口范围&gt;: 可以使用这个参数指定希望扫描的端口，也可以使用一段端口范围(例如1~1023).在IP协议扫描中(使用-sO参数)，该参数的意义是指定想要扫描的协议号(0~255)。 使用Nmap对192.168.2.2进行一次端口扫描的结果，其中用到了-sS选项，该选项指定使用TCP SYN扫描，这种扫描方式不等待打开一个完全的TCP连接，所以执行速度会更快，而且这种扫描通常不会被IDS等设备记录。如果想同时列出UDP端口，可以加上-sU，但执行速度就会变得比较慢。 使用Nmap探测更详细的服务信息如果想获取更加详细的服务版本等信息，需要使用-sV选项。 #服务扫描与查点在Metasploit的Scanner辅助模块中，有很多用于服务扫描和查点的工具，这些工具常以[service_name]_version和[service_name]_login命令。 1、[service_name]_version可用于遍历网络中包含了某种服务的主机，并进一步确定服务的版本。2、[service_name]_login可对于某种服务进行口令探测攻击。 在MSF终端中，可以输入search name:_version命令查看所有可用的服务查点模块。 SSH服务扫描与telnet不同的是，ssh采用安全的加密信息传输方式。通常管理员会使用ssh对服务器进行远程管理，服务器会向ssh客户端返回一个远程的Shell连接。 Oracle数据库服务查点使用mssql_ping模块查找网络中的Microsoft SQL Server，使用tnslsnr_version模块查找网络中开放端口的Oracle监听器服务。 开放代理探测与利用避免被对方的入侵监测系统跟踪，需要隐藏自己的身份，最简单和最常见的是使用代理服务器。Metasploit提供了open_proxy模块，能够让你更加方便地获取免费地HTTP代理服务器地址。获取免费开放代理后，就可以在浏览器或者一些支持配置代理地渗透软件中配置代理，这可以在进行渗透测试时隐藏你的真实IP地址。比开放代理更保险地隐藏攻击源方法是利用开放的或自主架设VPN服务，可以自己架设OpenVPN。使用这些VPN可以采用加密方式转发路由你的渗透测试数据包，而无需担心你的攻击发起源被跟踪到。 #口令猜测与嗅探SSH服务口令猜测载入ssh_login模块后，首先需要设置RHOSTS参数指定口令攻击的对象，可以是一个IP地址，或一段IP地址，同样也可以使用CIDR表示的地址区段。然后使用USERNAME参数指定一个用户名(或者使用USER_FILE参数指定一个包含多个用户名的文本文件，每个用户名占一行)，并使用PASSWORD指定一个特定的口令字符串(或者使用PASS_FILE参数指定一个包含多个口令的字典文件，每个口令占一行)，也可以使用USER PASS_FILE指定一个用户名和口令的配对文件(用户名和口令之间用空格隔开，每对用户名和口令占一行)。默认情况下，ssh_login模块还会尝试空口令，以及与用户名相同的弱口令进行登录测试。 psnuffle口令嗅探psnuffle是目前Metasploit中唯一用于口令嗅探的工具，可以使用它截获常见协议的身份认证过程，并将用户名和口令信息记录下来。 #网络漏洞扫描OpenVAS漏洞扫描器可以用来识别远程主机、Web应用存在的各种漏洞，使用NVT脚本对多种远程系统的安全问题进行监测。在kali中安装openVAS，输入命令: apt-get install openvas，安装过程中可能会出现错误，输入openvas-check-setpu查看安装到哪步出错，以及缺少什么东西。配置OpenVAS的过程如下:1、输入以下命令生成OpenVAS运行所需的证书文件，生成证书过程中，系统会询问一些信息，可以按回车键使用其默认值: root@bt:~# openvas-mkcert -qroot@bt:~# openvas-mkcert-client -n om -i 2、升级NVT库: root@bt:~# openvas-nvt-sync 3、对OpenVAS的扫描引擎进行一些初始化的操作，依次输入如下命令: root@bt:~# openvassdroot@bt:~# openvasmd –migrateroot@bt:~# openvasmd –rebuild 4、使用openvasad命令添加一个管理员角色的OpenVAS登录用户: root@bt:~# openvasad -c ‘add_user’ -n admin -r ‘Admin’Enter password:admain:MESSAGE:2327:2017-12-07 03h37.44 EDT: No rules file provided, the new user will have no restrictions.admin:MESSAGE:2327:2017-12-07 03h37.44 EDT: User admin has been successfully created. 5、在终端输入如下命令启动OpenVAS Scanner: root@bt:~# openvassd –listen=127.0.0.1 –port=9391All plugins loaded 6、最后启动OpenVAS Manager，在终端中运行如下命令: root@bt:~# openvasmd –database=/usr/local/var/lib/openvas/mgr/tasks.db –slisten=127.0.0.1 –sport=9391 –listen=0.0.0.0 –port=9390 如果在启动OpenVAS各部件时报错，可以运行以下脚本确认OpenVAS已经安装配置无误，如果脚本运行检测出错误，请按照屏幕提示进行修正。 root@bt:~# /pentest/misc/openvas/openvas-check-setup Nmap扫描漏洞如果服务器开启了SMB服务，可以使用Nmap的SMB服务漏洞扫描模块对它进行探测。]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读写文件二]]></title>
    <url>%2F2017%2F12%2F05%2Fjava%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[使用Java的输入流、输出流将一个文本文件的内容按行读出，每读出一行就顺序添加行号，并写入到另一个文件中。1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class Test4 &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub BufferedReader br = null; BufferedWriter bw = null; try &#123; br = new BufferedReader(new FileReader("Input.txt")); bw = new BufferedWriter(new FileWriter("Output.txt")); String str = ""; int i = 1; while((str = br.readLine()) != null)&#123; bw.write(i+" "); bw.write(str); System.out.println(i+ " "+ str); bw.newLine(); //换行，换行后可以使用readline()来一行行读取数据 i++; &#125; bw.flush(); //清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再用数据写到文件中， //当数据读完时，如果调用close()方法关闭读写流，就可能造成数据丢失， //原因是一部分的数据可能留在缓存区 bw.close(); br.close(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block System.out.println("找不到指定文件！"); &#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读写文件一]]></title>
    <url>%2F2017%2F12%2F05%2Fjava%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E4%B8%80%2F</url>
    <content type="text"><![CDATA[写入文件后可逆序输出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.io.*;import java.util.Scanner;public class Test3 &#123; public static void main(String[] args) &#123; //创建文件对象 File file= new File("2.txt"); if (file.exists()) &#123; //文件存在 String name= file.getName(); long len= file.length(); //判断文件隐藏属性 boolean hidden= file.isHidden(); System.out.println("文件名称: "+ name+ "\n文件长度: "+ len+ "\n隐藏属性: "+ hidden); writefile(file); readfile(file); &#125;else &#123; //文件不存在，创建文件 try &#123; file.createNewFile(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; System.out.println("文件已创建"); &#125; &#125; &#125; private static void readfile(File file) &#123; // TODO Auto-generated method stub try &#123; FileInputStream fileInputStream= new FileInputStream(file); byte[] b= new byte[1024]; int len= fileInputStream.read(b); fileInputStream.close(); StringBuilder ab = new StringBuilder(new String(b, 0, len)); System.out.println("文件读出的内容是: \n"+ ab.reverse().toString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; private static void writefile(File file) &#123; // TODO Auto-generated method stub Scanner in= new Scanner(System.in); System.out.println("请输入要写入得内容"); String string= in.next(); //建立文件传输管道 try &#123; FileOutputStream fileOutputStream= new FileOutputStream(file); //写文件 fileOutputStream.write(string.getBytes()); //关闭管道 fileOutputStream.close(); System.out.println("文件写入完成"); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP简单大文件传送]]></title>
    <url>%2F2017%2F12%2F04%2FUDP%E7%AE%80%E5%8D%95%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%2F</url>
    <content type="text"><![CDATA[话不多说，直接上代码。运行的时候先运行You.java, 再运行My.javaMy.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.net.*;import java.util.concurrent.TimeoutException;import java.awt.event.*;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import javax.swing.*;public class My&#123; public static void main(String[] args) &#123; new MyFrame(); &#125;&#125;class MyFrame extends JFrame implements ActionListener &#123; JTextField out_message = new JTextField(16); JTextArea in_message = new JTextArea(); JButton cfile = new JButton("选择文件"); JFileChooser chooser = new JFileChooser(); public MyFrame() &#123; setTitle("My"); // setSize(600, 600); setVisible(true); setBounds(300, 200, 350, 300); cfile.addActionListener(this); // send.addActionListener(this); // out_message.addKeyListener(this); JPanel pSouth = new JPanel(); pSouth.add(out_message); pSouth.add(cfile); // pSouth.add(send); add(pSouth, "South"); add(new JScrollPane(in_message), "Center"); validate(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void actionPerformed(ActionEvent event) &#123; chooser.setFileSelectionMode(0); int status = chooser.showOpenDialog(null); if (status == 1) &#123; return; &#125; else &#123; File file = chooser.getSelectedFile(); out_message.setText(file.getAbsolutePath()); out_message.grabFocus(); long startTime = System.currentTimeMillis();// 获取当前时间 byte[] buf = new byte[UDPUtils.BUFFER_SIZE];// 发送文件的字节数组 byte[] receiveBuf = new byte[Math.max(UDPUtils.successData.length, UDPUtils.exitData.length)];// 传送验证信息的字节数组 RandomAccessFile accessFile = null; DatagramPacket dpk = null; DatagramSocket dsk = null; int readSize = -1; try &#123; accessFile = new RandomAccessFile(file.getAbsolutePath(), "r");// 创建一个只读的文件流 dpk = new DatagramPacket(buf, buf.length, new InetSocketAddress(InetAddress.getByName("192.168.199.143"), UDPUtils.PORT + 1));// 创建一个待发送数据包 dsk = new DatagramSocket(UDPUtils.PORT);// 接收.... dsk.setSoTimeout(1000);// 设置确认报文超时重传 int sendCount = 0;// 记录发送的数据包的数量 while ((readSize = accessFile.read(buf, 0, buf.length)) != -1) &#123;// 将文件的数据读满字节数组，返回读入数组的总字节数，如果到文件尾则等于-1 // 未读到文件尾 dpk.setData(buf, 0, readSize);// 设置包的缓冲区长度为读入的字节数 dsk.send(dpk);// 发送包 // 等待服务端回应 &#123; while (true) &#123; dpk.setData(receiveBuf, 0, receiveBuf.length);// UDPUtils.successData.length); try &#123; dsk.receive(dpk);// 接收数据包 if (!UDPUtils.isEqualsByteArray(UDPUtils.successData, receiveBuf, dpk.getLength())) &#123;// 返回的不是成功标志 throw new TimeoutException("数据没有收到！"); &#125; else &#123; break; &#125; &#125; catch (SocketTimeoutException | TimeoutException e) &#123;//没有收到数据包或返回的不是成功标志 // TODO 超时重传 System.out.println("resend ..."); dpk.setData(buf, 0, readSize); dsk.send(dpk); continue; &#125; &#125; &#125; System.out.println("send count of " + (++sendCount) + "!"); &#125; // 发送退出标志等待回应 System.out.println("客户端退出 ...."); dpk.setData(UDPUtils.exitData, 0, UDPUtils.exitData.length); dsk.send(dpk); while (true) &#123; dpk.setData(receiveBuf, 0, receiveBuf.length); // byte[] receiveData = dpk.getData(); try &#123; dsk.receive(dpk); if (!UDPUtils.isEqualsByteArray(UDPUtils.exitData, receiveBuf, dpk.getLength())) &#123; throw new TimeoutException("Msg not equal"); &#125; else &#123; break; &#125; &#125; catch (SocketTimeoutException | TimeoutException e) &#123; // TODO 超时重传 System.out.println("client Resend exit message ...."); dsk.send(dpk); continue; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (accessFile != null) accessFile.close(); if (dsk != null) dsk.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; long endTime = System.currentTimeMillis(); System.out.println("time:" + (endTime - startTime)); &#125; &#125;&#125; You.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.InetSocketAddress;public class You &#123; private static final String SAVE_FILE_PATH = "C:/Users/马冲/Desktop/flag.zip";//接收文件存储的路径 public static void main(String[] args) &#123; byte[] buf = new byte[UDPUtils.BUFFER_SIZE]; DatagramPacket dpk = null;//定义一个数据包 DatagramSocket dsk = null;//定义一个接收数据包 BufferedOutputStream bos = null;//定义一个缓冲的文件输出流 try &#123; dpk = new DatagramPacket(buf, buf.length, new InetSocketAddress(InetAddress.getByName("127.0.0.1"), UDPUtils.PORT)); dsk = new DatagramSocket(UDPUtils.PORT + 1);//创建一个数据包由于接收 bos = new BufferedOutputStream(new FileOutputStream(SAVE_FILE_PATH));//创建一个缓冲的文件输出流 System.out.println("等待客户端...."); dsk.receive(dpk);//等待客户端发送文件 int readSize = 0; int readCount = 0; int flushSize = 0; while ((readSize = dpk.getLength()) != 0) &#123; // 验证客户端发送退出标志 if (UDPUtils.isEqualsByteArray(UDPUtils.exitData, buf, readSize)) &#123; System.out.println("服务器退出 ..."); dpk.setData(UDPUtils.exitData, 0, UDPUtils.exitData.length);//设置包中数据为退出标志 dsk.send(dpk);//发送退出标志 break;//退出 &#125; bos.write(buf, 0, readSize);//将字节数组中的数据写入缓冲流 if (++flushSize % 1000 == 0) &#123; flushSize = 0; bos.flush(); &#125; dpk.setData(UDPUtils.successData, 0, UDPUtils.successData.length);//设置包中数据为接收成功标志 dsk.send(dpk);//返回一个接收成功标志 dpk.setData(buf, 0, buf.length);//重新设置包用于接收下一个数据包 System.out.println("receive count of " + (++readCount) + " !"); dsk.receive(dpk);//等待客户端发送文件 &#125; // last flush bos.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (bos != null) bos.close(); if (dsk != null) dsk.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; UDPUtils.java1234567891011121314151617181920212223242526272829303132333435363738394041424344public class UDPUtils &#123; private UDPUtils() &#123; &#125; /** transfer file byte buffer **/ public static final int BUFFER_SIZE = 50 * 1024; /** controller port **/ public static final int PORT = 50000; /** mark transfer success **/ public static final byte[] successData = "success data mark".getBytes(); /** mark transfer exit **/ public static final byte[] exitData = "exit data mark".getBytes(); /** * compare byteArray equest successData * * @param compareBuf * src * @param buf * target * @return */ public static boolean isEqualsByteArray(byte[] compareBuf, byte[] buf, int len) &#123; if (buf == null || buf.length == 0 || compareBuf.length &lt; len) return false; boolean flag = true; int innerMinLen = Math.min(compareBuf.length, len); // if(buf.length == compareBuf.length)&#123; for (int i = 0; i &lt; innerMinLen; i++) &#123; if (buf[i] != compareBuf[i]) &#123; flag = false; break; &#125; &#125; // &#125;else // return false; return flag; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP通信-AES和Base64加解密]]></title>
    <url>%2F2017%2F12%2F04%2FUDP%E9%80%9A%E4%BF%A1-AES%E5%92%8CBase64%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[基于UDP的通信和基于TCP的通信不同，基于UDP的信息传递更快，但不提供可靠性保证。也就是说，数据在传输时，用户无法知道能否正确地到达目的地主机，也不能确定数据到达目的地地顺序是否和发送地顺序相同。基于UDP通信地基本模式如下:(1)将数据打包，称为数据包，然后将数据包发往目的地。(2)接收别人发来地数据包，然后查看数据包中地内容。 发送数据包用DatagramPacket类将数据打包，即用DatagramPacket类创建一个对象，称为数据包。用DatagramPacket地以下两个构造方法创建待发送地数据包: DatagramPacket(byte data[], int length, InetAddtress address, int port);使用该构造方法创建地数据包对象具有下列两个性质：(1)含有data数组指定地数据(2)该数据包将发送到地址是adress、端口号是port的主机上。用DatagramSocket类的不带参数的构造方法DatagramSocket()创建一个对象，该对象负责发送数据包。例如: DatagramSocket mail_out= new DatagramSocket();mail_out.send(data_pack); 下面附上Mac.java, 其中使用了AES和Base64加解密。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import java.net.*;import java.text.SimpleDateFormat;import java.util.Date;import java.awt.event.*;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import javax.swing.*;import org.apache.commons.codec.binary.Base64;public class Mac&#123; public static void main(String[] args) &#123; MaCs maC= new MaCs(); &#125; &#125;class MaCs extends JFrame implements Runnable, ActionListener, KeyListener&#123; SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); JTextField out_message1= new JTextField(12); JTextArea in_message= new JTextArea(); JButton send= new JButton("发送"); String password = "ABCDEFGHIJKLMNOP"; MaCs()&#123; setTitle("SS"); setSize(400, 200); setBounds(700, 200, 350, 300); setVisible(true); send.addActionListener(this); out_message1.addKeyListener(this); JPanel pSouthJPanel= new JPanel(); pSouthJPanel.add(out_message1); pSouthJPanel.add(send); add(pSouthJPanel, "South"); add(new JScrollPane(in_message), "Center"); in_message.setEditable(false); validate(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Thread thread= new Thread(this); thread.start();//线程负责接收数据包 &#125; /** * 使用参数中的密钥加密 */ public static String Encrypt(String sSrc, String sKey) &#123; try&#123; if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); //SecretKeySpec类是KeySpec接口的实现类，用于构建秘密密钥规范 //构造一个用AES算法加密的密钥 Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//"算法/模式/补码方式，创建密码器" cipher.init(Cipher.ENCRYPT_MODE, skeySpec);//初始化为加密模式的密码器 //Cipher为加密解密提供密码功能 byte[] encrypted = cipher.doFinal(sSrc.getBytes("utf-8"));//加密 return new Base64().encodeToString(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用。 &#125;catch(Exception e)&#123; e.printStackTrace(); //在命令行打印异常信息在程序中出错的位置及原因 return null; &#125; &#125; /** * 使用参数中的密钥解密 */ public static String Decrypt(String sSrc, String sKey) &#123; try &#123; // 判断Key是否正确 if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, skeySpec); byte[] encrypted1 = new Base64().decode(sSrc);//先用base64解密 try &#123; byte[] original = cipher.doFinal(encrypted1); String originalString = new String(original,"utf-8"); return originalString; &#125; catch (Exception e) &#123; System.out.println(e.toString()); return null; &#125; &#125; catch (Exception ex) &#123; System.out.println(ex.toString()); return null; &#125; &#125; //回车发送 public void keyPressed(KeyEvent e) &#123; // TODO Auto-generated method stub if (e.getKeyCode()== 10) &#123; (this).actionPerformed(null); &#125; &#125; @Override public void actionPerformed(ActionEvent event) &#123; // TODO Auto-generated method stub String content1 = Encrypt(out_message1.getText(), password); byte buffer[]= content1.trim().getBytes(); try &#123; InetAddress address= InetAddress.getByName("192.168.199.143"); DatagramPacket datagramPacket= new DatagramPacket(buffer, buffer.length, address, 888); DatagramSocket mailDatagramSocket= new DatagramSocket(); mailDatagramSocket.send(datagramPacket); String content2 = Decrypt(content1, password); in_message.append("----------"+ df.format(new Date())+ "----------\nss: "+ content2+ "\n"); out_message1.setText(null); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; @Override public void run() &#123; // TODO Auto-generated method stub DatagramPacket packet= null; DatagramSocket mailDatagramSocket=null; byte data[]= new byte[8192];//定义数据包的大小 try&#123; packet= new DatagramPacket(data, data.length); mailDatagramSocket= new DatagramSocket(666); &#125; catch(Exception e)&#123; &#125; while(true)&#123; if (mailDatagramSocket== null) &#123; break; &#125; else &#123; try &#123; mailDatagramSocket.receive(packet);//可能会发生堵塞，直到收到数据包 String mesString= new String(packet.getData(), 0, packet.getLength()); String content3 = Decrypt(mesString, password); //System.out.println("123"); in_message.append("**********"+ df.format(new Date())+ "**********\n"); in_message.append("mc: "+ content3+ "\n"); &#125; catch (Exception e1) &#123; // TODO: handle exception &#125; &#125; &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; // TODO Auto-generated method stub &#125; @Override public void keyTyped(KeyEvent e) &#123; // TODO Auto-generated method stub &#125; &#125; 接收数据包用DatagramSocket的另一个构造方法DatagramSocket(int port)创建一个对象，其中的参数必须和待接收的数据包的端口号相同。例如，如果发送方发送的数据包的端口是5666，那么如下创建DatagramSocket对象:DatagramSocket mail_in= new DatagramSocket(5666);然后对象maill_in使用方法receive(DatagramPacket pack)接收数据包。该方法有一个数据包参数pack，方法receive把收到的数据包传递给该参数。因此，用户必须预备一个数据包，以便收取数据包。这时需使用DatagramPack类的另一个构造方法DatagramPacket(byte data[], int length)创建一个数据包，用于接收数据包，例如: byte data[]= new byte[100];int length= 90;DatagramPacket pack= new DatagramPacket(data, length);mail_in.receive(pack); 该数据包pack将接收长度是length字节的数据放入data。值得注意的是: receive方法可能会堵塞，直到收到数据包。下面附上Shens.java, 其中同样使用了AES、Base64加解密。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183import java.net.*;import java.text.SimpleDateFormat;import java.util.Date;import java.awt.event.*;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import javax.swing.*;import org.apache.commons.codec.binary.Base64;public class Shens&#123; public static void main(String[] args) &#123; ShenSs shenS= new ShenSs(); &#125;&#125;class ShenSs extends JFrame implements Runnable, ActionListener, KeyListener&#123; SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); JTextField out_message= new JTextField(12); JTextArea in_message= new JTextArea(); JButton send=new JButton("发送"); String password = "ABCDEFGHIJKLMNOP"; ShenSs()&#123; setTitle("MC"); //setSize(400, 200); setBounds(300, 200, 350, 300); setVisible(true); send.addActionListener(this); out_message.addKeyListener(this); JPanel panel= new JPanel();//创建一个面板，里面可以布局 panel.add(out_message); panel.add(send); add(panel, "South"); add(new JScrollPane(in_message), "Center"); in_message.setEditable(false); validate();//验证此容器及所有组件 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Thread thread= new Thread(this); thread.start();//线程负责接收数据包 &#125; /** * 使用参数中的密钥加密 */ public static String Encrypt(String sSrc, String sKey) &#123; try&#123; if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8");//字节型数组 SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); //SecretKeySpec类是KeySpec接口的实现类，用于构建秘密密钥规范 Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//"算法/模式/补码方式" cipher.init(Cipher.ENCRYPT_MODE, skeySpec); //Cipher为加密解密提供密码功能 byte[] encrypted = cipher.doFinal(sSrc.getBytes("utf-8")); return new Base64().encodeToString(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用。 &#125;catch(Exception e)&#123; e.printStackTrace(); //在命令行打印异常信息在程序中出错的位置及原因 return null; &#125; &#125; /** * 使用参数中的密钥解密 */ public static String Decrypt(String sSrc, String sKey) &#123; try &#123; // 判断Key是否正确 if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); //SecretKeySpec类是KeySpec接口的实现类，用于构建秘密密钥规范 Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//只实例化一次 //Cipher为加密解密提供密码功能 cipher.init(Cipher.DECRYPT_MODE, skeySpec); //初始化为解密模式的密码器 byte[] encrypted1 = new Base64().decode(sSrc);//先用base64解密 try &#123; byte[] original = cipher.doFinal(encrypted1);//解密 String originalString = new String(original,"utf-8"); return originalString;//明文 &#125; catch (Exception e) &#123; System.out.println(e.toString()); return null; &#125; &#125; catch (Exception ex) &#123; System.out.println(ex.toString()); return null; &#125; &#125; //回车发送 public void keyPressed(KeyEvent e) &#123; // TODO Auto-generated method stub if (e.getKeyCode()== 10) &#123; (this).actionPerformed(null); &#125; &#125; @Override public void actionPerformed(ActionEvent event) &#123;//单击按钮发送数据包 // TODO Auto-generated method stub String content1 = Encrypt(out_message.getText(), password); byte buffer[]= content1.trim().getBytes(); try &#123; InetAddress address= InetAddress.getByName("127.0.0.1"); DatagramPacket datagramPacket= new DatagramPacket(buffer, buffer.length, address, 666); //存放数据的数据报 DatagramSocket mailDatagramSocket= new DatagramSocket(); //接受或发送数据报的套接字 mailDatagramSocket.send(datagramPacket); String content2 = Decrypt(content1, password); in_message.append("**********"+ df.format(new Date())+ "**********\nmc: "+ content2+ "\n"); out_message.setText(null); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; @Override public void run() &#123; // TODO Auto-generated method stub DatagramPacket packet= null; DatagramSocket mailDatagramSocket=null; byte data[]= new byte[8192];//指定数据包的大小 try&#123; packet= new DatagramPacket(data, data.length); mailDatagramSocket= new DatagramSocket(888); &#125; catch(Exception e)&#123; &#125; while(true)&#123; if (mailDatagramSocket== null) &#123; break; &#125; else &#123; try &#123; mailDatagramSocket.receive(packet); String mesString= new String(packet.getData(), 0, packet.getLength()); String content3 = Decrypt(mesString, password); in_message.append("----------"+ df.format(new Date())+ "----------\n"); in_message.append("ss: "+ content3+ "\n"); &#125; catch (Exception e1) &#123; // TODO: handle exception &#125; &#125; &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; // TODO Auto-generated method stub &#125; @Override public void keyTyped(KeyEvent e) &#123; // TODO Auto-generated method stub &#125;&#125; 由于使用了Base64加解密，会出现Base64 cannot be resolved to a type这个错误。可以参考我的上一篇博文，那里有解决的方法。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java解决Base64包问题]]></title>
    <url>%2F2017%2F11%2F28%2FJava%E8%A7%A3%E5%86%B3Base64%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[java中使用AES对数据进行加解密算法模式：ECB 密钥 长度：128bits 16位长 偏移量： 默认 补码方式：PKCS5Padding 解密串编码方式：base64密钥为16位长度的字符串1234567891011121314151617181920212223242526272829/** * 使用参数中的密钥加密 * @param 明文 * @param 密钥 * @return 密文 */public static String Encrypt(String sSrc, String sKey) &#123; try&#123; if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//"算法/模式/补码方式" cipher.init(Cipher.ENCRYPT_MODE, skeySpec); byte[] encrypted = cipher.doFinal(sSrc.getBytes("utf-8")); return new Base64().encodeToString(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用。 &#125;catch(Exception e)&#123; e.printStackTrace(); return null; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/** * 使用参数中的密钥解密 * @param 密文 * @param 密钥 * @return 明文 */public static String Decrypt(String sSrc, String sKey) &#123; try &#123; // 判断Key是否正确 if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, skeySpec); byte[] encrypted1 = new Base64().decode(sSrc);//先用base64解密 try &#123; byte[] original = cipher.doFinal(encrypted1); String originalString = new String(original,"utf-8"); return originalString; &#125; catch (Exception e) &#123; System.out.println(e.toString()); return null; &#125; &#125; catch (Exception ex) &#123; System.out.println(ex.toString()); return null; &#125;&#125; 12345678测试方法String password = "ABCDEFGHIJKLMNOP";String content1 = "我的博客名是geekfly";System.out.println("加密前：" + content1); String content2 = Encrypt(content1, password);System.out.println("加密后：" + content2);String content3 = Decrypt(content2, password);System.out.println("解密后：" + content3); 在这个过程中出现个问题，base64 cannot be resolved to a type,问题显示: The import org.apache cannot be resolved.解决方法: 去 http://hc.apache.org/downloads.cgi 下载， HttpClient4.5.3.zip, 解压后得到\httpcomponents-client-4.5.3\lib, 里面有很多jar包加进来这样就好了！总结下：org.apache, 不是标准的java中的库。所以eclipse中，无法自动识别。org.apache下包括了一堆相关的库，此处用到的是org.apache.http, 所以：需要找到对应的org.apache.http相关的jar包，然后加到当前的项目中。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java获取本机外网IP]]></title>
    <url>%2F2017%2F11%2F28%2FJava%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E5%A4%96%E7%BD%91IP%2F</url>
    <content type="text"><![CDATA[一种可行的获取方法，是通过http请求从网站中取出ip字段。例如: http://ip.chinaz.com/通过这个网址，加上简单的正则表达式，即可得到123456789101112131415161718192021222324252627282930313233343536373839404142public static String getV4IP()&#123; String ip = ""; String chinaz = "http://ip.chinaz.com"; StringBuilder inputLine = new StringBuilder(); String read = ""; URL url = null; HttpURLConnection urlConnection = null; BufferedReader in = null; try &#123; url = new URL(chinaz); urlConnection = (HttpURLConnection) url.openConnection(); in = new BufferedReader( new InputStreamReader(urlConnection.getInputStream(),"UTF-8")); while((read=in.readLine())!=null)&#123; inputLine.append(read+"\r\n"); &#125; //System.out.println(inputLine.toString()); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(in!=null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; Pattern p = Pattern.compile("\\&lt;dd class\\=\"fz24\"&gt;(.*?)\\&lt;\\/dd&gt;"); Matcher m = p.matcher(inputLine.toString()); if(m.find())&#123; String ipstr = m.group(1); ip = ipstr; //System.out.println(ipstr); &#125; return ip;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CLOCK置换算法]]></title>
    <url>%2F2017%2F11%2F13%2FCLOCK%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在请求分页存储管理系统中，若为进程分配的物理块为4，开始执行时内存中没有装入任何页面，若进程依次访问的页面号为：7，1，6，4，6，2，3，0，3，1，0，7，6，0，1，3，6，3，0，7，2，0，5请用CLOCK算法完成作业(低物理地址优先)红色代表访问位为1，星号表示替换指针的位置 缺页次数: 14次缺页率: 14/23= 60.9%置换次数: 10次依次被置换的页号: 7 1 6 4 2 3 0 1 7 61234567891011121314151617181920217号页面：进程分配的物理块为4，开始执行的时候没有装入任何页面，当开始访问7号页面的时候，内存中没有该页面号，将页面直接调入内存，低物理地址优先，将页面放入第一个物理块，把访问位置为1.1、6、4号页面：访问1号页面的时候，内存中没有该页面号，且内存中还有空位，将1、6、4号页面放入内存，把访问位置为1，替换指针指向最高地址的物理块。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查4号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查4号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。7号页面：访问7号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查2号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查9号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查3号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。7号页面：访问7号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。5号页面：访问5号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟存储器]]></title>
    <url>%2F2017%2F11%2F12%2F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1、什么是虚拟存储器？（虚存）1解答：虚拟存储器是由硬件和操作系统自动实现存储信息调度和管理的，是在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理贮存容量大的多，可寻址的“主存储器”。 2、为什么要引入虚拟存储器？12解答：1&gt;能提高操作系统的内存利用率和系统吞吐量 2&gt;在计算机系统中，主存的容量有一定的限制，不可能大大满足各种用户的需要，而在技术上辅助存储器却可以做的相当大。为了给大作业提供方便，使它们不再承担对主存和辅存的具体分配和管理工作，而由操作系统把主存和辅存统一管理起来。 3、虚拟存储器的特征？12345解答：虚拟存储器具有虚拟性、离散性、多次性及强对换性等特征，其中最重要的特征是虚拟性。1&gt; 虚拟性。虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际的内存容量，这是虚拟存储器所表现出的最重要的特征，也是虚拟存储器最重要的目标。2&gt; 离散性。离散性是指内存分配时采用离散分配的方式，没有离散性就不可能实现虚拟存储器。采用连续分配方式，需要将作业装入到连续的内存区域，这样需要连续地一次性申请一部分内存空间，以便将整个作业先后多次装入内存。如果仍然采用连续装入的方式，则无法实现虚拟存储功能，只有采用离散分配方式，才能为它申请内存空间，以避免浪费内存空间。3&gt; 多次性。多次性是指一个作业被分成多次调入内存运行。作业在运行时，只将当前运行的那部分程序和数据装入内存，以后再陆续从外存将需要的部分调入内存。4&gt; 对换性。对换性是指允许在作业运行过程中换进换出。允许将暂时不用的程序和数据从内存调至外存的对换区，以后需要时再从外存调入到内存。 4、虚存可以建立在分区分配管理的基础上吗？为什么？1解答：不可以。在虚拟存储器中，允许将一个作业分多次调入内存。入宫采用连续分配方式时，应将作业装入一个连续的内存区域中。为此，需事先为它一次性地申请足够的内存空间，以便将整个作业先后分多次装入内存，这不仅会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟存储器的实现都是建立在离散分配存储管理方式的基础上。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生苦短]]></title>
    <url>%2F2017%2F11%2F10%2F%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%2F</url>
    <content type="text"><![CDATA[用Wireshark打开这个流量包点文件中的导出对象，选HTTP，发现其中有如下文件在010编辑器中打开，发现flagaa中有压缩包的头部，flagaf中有压缩包的尾部，猜测应该是压缩包分解成aa-af，拼凑一下，导出压缩包解压此压缩包，发现有密码先尝试用Ziperello爆破下没有加密文件，发现它是伪加密压缩包打开，得flag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RGB]]></title>
    <url>%2F2017%2F11%2F10%2FRGB%2F</url>
    <content type="text"><![CDATA[python脚本之RGB，将其转化为图片12345678910111213141516#!/usr/bin/env pythonfrom PIL import ImageMAX = 280pic = Image.new("RGB",(MAX, MAX))file = open("flag.txt",'r')m = file.read().split('\n')i=0for y in range (0,MAX): for x in range (0,MAX): if(m[i] == '(0, 0, 0)'): pic.putpixel([x,y],(0, 0, 0)) else: pic.putpixel([x,y],(255,255,255)) i = i+1pic.show()pic.save("flag.png")]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base混合解密]]></title>
    <url>%2F2017%2F11%2F10%2Fbase%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[Base64和Base32混合解密脚本12345678910111213import base64file = open('base.txt','r')st = file.read()while True: try: st = base64.b16decode(st) except: try: st = base64.b32decode(st) except: st = base64.b64decode(st) if(st.find('flag') == 0): print(st)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware Workstation 14黑屏问题及密钥]]></title>
    <url>%2F2017%2F11%2F08%2FVMware-Workstation-14%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98%E5%8F%8A%E5%AF%86%E9%92%A5%2F</url>
    <content type="text"><![CDATA[今儿个升级VM到14，完事后打开VM，想用下kali，却发现进入黑屏，如论如何都不能解决，没办法，拜访了下度娘。首先上VM的密钥：VMware Workstation Pro 14 许可证序列号：FF590-2DX83-M81LZ-XDM7E-MKUT4CG54H-D8D0H-H8DHY-C6X7X-N2KG6ZC3WK-AFXEK-488JP-A7MQX-XL8YFAC5XK-0ZD4H-088HP-9NQZV-ZG2R4ZC5XK-A6E0M-080XQ-04ZZG-YF08DZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8 黑屏问题解决:1以管理员身份进入cmd，输入`netsh winsock reset`, 重启，问题解决 网上也有其他的解决方法，不过没试过：123以管理员身份运行命令提示符（cmd.exe），输入命令 netsh winsock show catalog可以看到VMware注册了两个LSP：vSockets DGRAM、vSockets STREAM，路径是%windir%\system32\vsocklib.dll观察有没有其他模块也注册了vSockets DGRAM、vSockets STREAM，如果有，就卸载掉这个模块所属的软件。]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example5_10]]></title>
    <url>%2F2017%2F10%2F31%2FExample5-10%2F</url>
    <content type="text"><![CDATA[写一个类，该类有一个方法，public int ff(int a, int b), 该方法返回a 和b 的最大公约数。然后再编写一个该类的子类，要求子类重写方法ff，而且重写的方法将返回a 和b 的最小公约数；要求在重写的方法的方法体中首先调用被隐藏的方法返回a 和b 的最大公约数m ，然后将乘积(a* b)/ m返回；要求在应用的程序的主类中分别使用父类和子类创建对象，并分别调用方法f 计算两个正整数的最大公约数和最小公约数。123456789101112131415161718192021222324252627282930313233class AAb&#123; public int f(int a, int b)&#123; if(b&lt; a)&#123; int temp= 0; temp= a; a= b; b= temp; &#125; int r= b% a; while(r!= 0)&#123; b= a; a= r; r= b% a; &#125; return a; &#125;&#125;class BBb extends AAb&#123; public int f(int a, int b)&#123; int division= super.f(a, b); return (a* b)/ division; &#125;&#125;public class Example5_10 &#123; public static void main(String[] args) &#123; AAb aAb= new AAb(); BBb bBb= new BBb(); System.out.println("最大公约数: "+ aAb.f(36, 24)); System.out.println("最小公倍数: "+ bBb.f(36, 24)); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example5_9]]></title>
    <url>%2F2017%2F10%2F31%2FExample5-9%2F</url>
    <content type="text"><![CDATA[写一个类Aa， 该类创建的对象可以调用方法k输出英文字母表，然后再编写一个该类的子类Bb，要求子类Bb必须继承Aa类的方法k(不允许重写)，子类创建的对象不仅可以调用方法k输出英文字母表，而且可以调用子类新增的方法g输出希腊字母表。1234567891011121314151617181920212223242526class Ab&#123; public final void k()&#123; char cStart= 'a', cEnd= 'z'; for(char c= cStart; c&lt;= cEnd; c++)&#123; System.out.print(" "+ c); &#125; &#125;&#125;class Ba extends Ab&#123; public void g()&#123; char cStart= 'α', cEnd= 'ω'; for(char c= cStart; c&lt;= cEnd; c++)&#123; System.out.print(" "+ c); &#125; &#125;&#125;public class Example5_9 &#123; public static void main(String[] args) &#123; Ba ba=new Ba(); ba.k(); System.out.println(""); ba.g(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java连接MySQL数据库]]></title>
    <url>%2F2017%2F10%2F29%2FJava%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[工具：eclipseMySQL5.5MySQL连接驱动：mysql-connector-java-5.1.44-bin.jar Java编译器是eclipse，下载mysql-connector-java-5.1.44-bin.jar，我下的是最新版。加载驱动：1、在工程目录中创建lib文件夹，将下载好的JDBC放到该文件夹下，如图所示：2、右键工程名，点击Properties 选择Java Build Path中的Libraries，点击Add JARs…, 选择刚才添加的JDBC，如下图:3、配置好MySQL，添加一个用户，用户名是style,密码是1234, 创建一个数据库, 数据库名是student。创建表： create table students( -&gt; sno int(10) not null, -&gt; sname varchar(8) not null, -&gt; sex char(2) not null, -&gt; bdate date not null, -&gt; height dec(5,2) default 000.00, -&gt; primary key(sno)); 然后插入一条数据： insert into students(sno,sname,sex,bdate,height) values(‘1’,’gfa’,’男’,’2017-10-29’,’fwef’); 创建好数据库后, 编写Java文件来访问MySQL数据库。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package sqldemo;import java.sql.*;public class mains &#123; public static void main(String[] args) &#123; //声明Connection对象 Connection con; //驱动程序名 String driver = "com.mysql.jdbc.Driver"; //URL指向要访问的数据库名student String url = "jdbc:mysql://localhost:3306/student"; //MySQL配置时的用户名 String user = "style"; //MySQL配置时的密码 String password = "1234"; //遍历查询结果集 try &#123; //加载驱动程序 Class.forName(driver); //1.getConnection()方法，连接MySQL数据库！！ con = DriverManager.getConnection(url,user,password); if(!con.isClosed()) System.out.println("Succeeded connecting to the Database!"); //2.创建statement类对象，用来执行SQL语句！！ Statement statement = con.createStatement(); //要执行的SQL语句 String sql = "select * from students"; //3.ResultSet类，用来存放获取的结果集！！ ResultSet rs = statement.executeQuery(sql); System.out.println("-----------------"); System.out.println("执行结果如下所示:"); System.out.println("-----------------"); System.out.println("姓名" + "\t" + "性别"); System.out.println("-----------------"); String job = null; String id = null; while(rs.next())&#123; //获取stuname这列数据 job = rs.getString("sname"); //获取stuid这列数据 id = rs.getString("sex"); //输出结果 System.out.println(job + "\t" + id); &#125; rs.close(); con.close(); &#125; catch(ClassNotFoundException e) &#123; //数据库驱动类异常处理 System.out.println("Sorry,can`t find the Driver!"); e.printStackTrace(); &#125; catch(SQLException e) &#123; //数据库连接失败异常处理 e.printStackTrace(); &#125;catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally&#123; System.out.println("数据库数据获取成功！"); &#125; &#125;&#125; 运行结果如图所示：]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[txt文件导入MySQL]]></title>
    <url>%2F2017%2F10%2F28%2Ftxt%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5MySQL%2F</url>
    <content type="text"><![CDATA[创建数据表 CRETE TABLE tes(NAME VARCHAR(20) NULL,SEX VARCHAR(5) NULL,STUDENTID INT(20) NULL);txt文件中的内容如下你好 男 123世界 女 456啦啦啦 男 485 中间空格部分是TAB键, 保存为UTF-8编码.导入txt文件 load data local infile ‘C:/文件名.txt’ into table 数据表名; 如果第一行开头出现特殊符号，我的解决方法是在第一行中增加一行可以删去的信息，等导入数据库后，DELETE FROM 数据库表 WHERE 字段=&#39;字段对应的唯一信息&#39;;删除第一行就行。但这只是治标不治本，希望大家能提出宝贵的建议，共同学习。 导入数据库到MySQL mysql -u root -p &lt; 数据库文件名 回车后输入数据库密码，即可导入成功。 导出数据库 mysqldump -u root -p 数据库名 &gt; 要保存的数据库文件名 回车后输入数据库密码，导出的数据库在当前目录。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地连接腾讯云MySQL]]></title>
    <url>%2F2017%2F10%2F28%2F%E6%9C%AC%E5%9C%B0%E8%BF%9E%E6%8E%A5%E8%85%BE%E8%AE%AF%E4%BA%91MySQL%2F</url>
    <content type="text"><![CDATA[在腾讯云的MySQL中先新建一个用户，用于远程登录账号。环境是centos7登录MySQL mysql -u root -p 回车后输入密码 创建用户 允许本地IP访问localhost create user ‘style’@’localhost’ identified by ‘123456’; 用户名是style，密码是123456; 允许外网IP访问 create user ‘style’@’%’ identified by ‘123456’; 刷新授权 flush privileges; 为用户创建数据库 数据库名是student create database student DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 为新用户分配权限 授予用户通过外网IP对于该数据库的全部权限 grant all privileges on student.* to ‘style’@’%’ identified by ‘1234’; 授予用户在本地服务器对该数据库的全部权限 grant all privileges on student.* to ‘style’@’localhost’ identified by ‘1234’; 刷新权限 flush privileges; 退出root重新登录 exit 用新账号style重新登录，由于使用的是 % 任意IP连接， 所以需要指定外部访问IP mysql -h 腾讯云的公网IP -u用户名 -p密码 登录成功！ 查询用户权限 show grants for style 赋予权限 grant all privileges on . to ‘style’@’%’ identified by ‘1234’; 授予style用户在所有数据库上的所有权限 如果此时发现刚刚给的权限太大了，如果我们只想授予它在某个数据库上的权限，那么需要切换到root用户撤销刚才的权限，重新授权 revoke all privileges on . from ‘style’@’%’;grant all privileges on student.* to ‘style`@’%’ identified by ‘1234’; 甚至还可以指定该用户只能执行select和update命令 grant select, update on student.* to ‘style’@’%’ identified by ‘1234’; 这样一来，再次以style用户登录MySQL，只有student数据库是对其可见的，并且如果你只授权它select权限，那么它就不能执行delete语句 每当调整权限后，通常需要执行以下语句来刷新权限 flush privileges; 删除创建的用户 drop user style@’%’; 可用如下命令查看相应用户及对应的host select host, user from user; MarkSown语法用的不是很好，有些符号没有显示，以下图为准]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改MySQL密码]]></title>
    <url>%2F2017%2F10%2F27%2F%E4%BF%AE%E6%94%B9MySQL%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在DOS下执行：mysql -u root -p然后输入旧的密码，如果是第一次进入，则直接回车mysql&gt;show databases;mysql&gt;use mysql;注意一定先执行use mysql;再执行下面命令设置密码，如新密码123456mysql&gt;UPDATE user SET password=PASSWORD(&#39;123456&#39;) WHERE user=&#39;root&#39;;mysql&gt;FLUSH PRIVILEGES;mysql&gt;exit; 附上常用mysql命令(win8.1以管理员身份执行win+x+a):安装mysql服务：mysqld -install卸载mysql服务：mysqld -remove启动mysql服务：net start mysql停止mysql服务：net stop mysql 如果启动mysql服务出现1067错误码尝试清理datadir目录下的以下文件：auto.cnf、Cryhelyxx-pc.err、Cryhelyxx-pc.pid、ib_logfile0、ib_logfile1、ibdata1、ibtmp1注意：在清理之前请备份好数据库，否则后果自负，并再次启动mysql服务：net start mysql。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 安装问题]]></title>
    <url>%2F2017%2F10%2F10%2FAndroid-Studio-%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装android studio的时候，出现几个错误，在此记录下。第一个是出现这个解决方法：在自己的android studio安装目录下找到这个文件idea.properties,在最后面添加一行disable.android.first.run=true 第二个是出现这个(图是百度的==当时没保存下来)解决方法：SDK的目录名称不能有汉字，换个路径 第三个是出现这个解决方法：点击右下角的Configure点击project Defaults,点击Project Structure,填入SDK的地址 第四个是出现这个解决方法：SDK的目录不能有空格，换路径]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[super关键字]]></title>
    <url>%2F2017%2F09%2F28%2Fsuper%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[使用super调用父类的构造方法子类不继承父类的构造方法，因此，子类如果想使用父类的构造方法，必须在子类的构造方法中使用，必须使用关键字super来表示，而且super必须是子类构造方法中的头一条语句Student5_6.java1234567891011121314151617public class Student5_6 &#123; int number; String name; Student5_6()&#123; &#125; Student5_6(int number, String name)&#123; this.number= number; this.name= name; &#125; public int getNumber()&#123; return number; &#125; public String getName() &#123; return name; &#125;&#125; UniverStudent.java123456789public class UniverStudent extends Student5_6 &#123; boolean isNarriage;//子类新增的结婚属性 UniverStudent(int number, String name, boolean v)&#123; super(number, name);//调用父类的构造方法 &#125; public boolean getIsNarriage()&#123; return isNarriage; &#125;&#125; Example5_6.java123456789101112131415public class Example5_6 &#123; public static void main(String[] args) &#123; UniverStudent zhangStudent= new UniverStudent(20111, "张三", false); int number= zhangStudent.getNumber(); String name= zhangStudent.getName(); boolean marriage= zhangStudent.getIsNarriage(); System.out.println(name+ "的学号是: "+ number); if(marriage== true)&#123; System.out.println(name+ "已婚"); &#125; else &#123; System.out.println(name+ "未婚"); &#125; &#125;&#125; 使用super操作被隐藏的成员变量和方法如果在子类中想使用被子类隐藏的成员变量或方法，可以使用关键字super，super.x、super.play()，就是访问和调用被子类隐藏的成员变量x和方法play()Sum.java12345678910public class Sum &#123; int n; public double f()&#123; double sum= 0; for(int i= 1; i&lt;= n;i++)&#123; sum= sum+ i; &#125; return sum; &#125;&#125; Average.java1234567891011121314public class Average extends Sum &#123; double nm; public double fq()&#123; double c; super.n= (int)nm; c= super.f(); return c+ nm; &#125; public double g()&#123; double c; c= super.f(); return c- nm; &#125;&#125; Example5_7.java12345678910public class Example5_7 &#123; public static void main(String[] args) &#123; Average average= new Average(); average.nm= 100.5678; double result1= average.fq(); double result2= average.g(); System.out.println("result1= "+ result1); System.out.println("result2= "+ result2); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法内部类]]></title>
    <url>%2F2017%2F09%2F26%2F%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。1234567891011121314151617181920212223242526//外部类public class HelloWorld &#123; private String name = "爱慕课"; // 外部类中的show方法 public void show() &#123; // 定义方法内部类 class MInner &#123; int score = 83; public int getScore() &#123; return score + 10; &#125; &#125; // 创建方法内部类的对象 MInner mi= new MInner(); // 调用内部类的方法 int newScore= mi.getScore(); System.out.println("姓名：" + name + "\n加分后的成绩：" + newScore); &#125; // 测试方法内部类 public static void main(String[] args) &#123; // 创建外部类的对象 HelloWorld mo= new HelloWorld(); // 调用外部类的方法 mo.show(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成员内部类与静态内部类]]></title>
    <url>%2F2017%2F09%2F26%2F%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类中最常见的就是成员内部类，也称为普通内部类123456789101112131415161718192021222324252627//外部类HelloWorldpublic class HelloWorld&#123; //外部类的私有属性name private String name = "imooc"; //外部类的成员属性 int age = 20; //成员内部类Inner public class Inner &#123; String name = "爱慕课"; //内部类中的方法 public void show() &#123; System.out.println("外部类中的name：" + HelloWorld.this.name); System.out.println("内部类中的name：" + name); System.out.println("外部类中的age：" + age); &#125; &#125; //测试成员内部类 public static void main(String[] args) &#123; //创建外部类的对象 HelloWorld o = new HelloWorld (); //创建内部类的对象 Inner inn = o.new Inner(); //调用内部类对象的show方法 inn.show(); //外部类不能直接使用内部类的成员何方法，如show(); &#125;&#125; 静态内部类是static修饰的内部类，这种内部类的特点是:静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员； 如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();123456789101112131415161718192021//外部类public class HelloWorld &#123; // 外部类中的静态变量score private static int score = 84; // 创建静态内部类 public static class SInner &#123; // 内部类中的变量score int score = 91; public void show() &#123; System.out.println("访问外部类中的score：" + HelloWorld.score); System.out.println("访问内部类中的score：" + score); &#125; &#125; // 测试静态内部类 public static void main(String[] args) &#123; // 直接创建内部类的对象 SInner si= new SInner(); // 调用show方法 si.show(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2017%2F09%2F26%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类内部类的方法可以直接访问外部类的所有数据，包括私有的数据内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便内部类分为：成员内部类、静态内部类、方法内部类、匿名内部类1234567891011121314151617public class neibulei &#123; //内部类Inner，类Inner在类neibulei的内部 public class Inner&#123; //内部类的方法 public void show()&#123; System.out.println("Hello World!"); &#125; &#125; public static void main(String[] args)&#123; //创建外部类对象 neibulei neibulei= new neibulei(); //创建内部类对象 Inner inner= neibulei.new Inner(); //调用内部类对象的方法 inner.show(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可变参数]]></title>
    <url>%2F2017%2F09%2F26%2F%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[x是可变参数的代表，代表若干哥int型参数x.length是x代表的参数的个数x[i]是x代表的第i个参数(类似数组)123456789101112public class Example4_11 &#123; public static void main(String[] args) &#123; f(1,2); f(-1, -2, -3, -4); f(9, 7, 6); &#125; public static void f(int ... x)&#123; for(int i=0; i&lt; x.length; i++)&#123; System.out.println(x[i]); &#125; &#125;&#125; 上面的方法输出的是一个数字一行，觉得不好看，改版如下print输出不换行，println输出换行12345678910111213public class Example4_11 &#123; public static void main(String[] args) &#123; f(1,2); f(-1, -2, -3, -4); f(9, 7, 6); &#125; public static void f(int ... x)&#123; for(int i=0; i&lt; x.length-1; i++)&#123; System.out.print(x[i]); &#125; System.out.println(x[x.length-1]); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static]]></title>
    <url>%2F2017%2F09%2F26%2Fstatic%2F</url>
    <content type="text"><![CDATA[static存在的时候，调用b2.setN(5)，sum=6，去掉static，sum从0开始123456789101112131415161718192021222324252627class B&#123; int n; static int sum= 0; void setN(int n)&#123; this.n= n; System.out.println("this.n= "+ this.n); &#125; int getSum()&#123; for(int i= 1;i&lt;= n; i++)&#123; sum= sum+ i; &#125; System.out.println(sum); return sum; &#125; &#125;public class Example4_9 &#123; public static void main(String[] args) &#123; B b1=new B(), b2= new B(); b1.setN(3); b2.setN(5); int a1= b1.getSum(); int a2= b2.getSum(); System.out.println(a1+ a2); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[enum问题]]></title>
    <url>%2F2017%2F09%2F23%2Fenum%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天有个想法，是输出每个月的天数，正好最近学了enum，就想用这个来做。 &lt;!--more--&gt; 说干就干，啪啪啪啪...咦~有个错误，我改我改我改！ 然而改了多次，还是没成功，最后根据错误提示问了下度娘，说是格式有误。 我就想，是不是不能重复内容，我改我改，改到enum里面的内容只有两位31，30，还真是！ 但还是有相同的错误，又想了想，前面加上月份呢？ 啪！问题解决123456789101112enum Tian&#123; 一月31天, 二月28天, 三月31天, 四月30天, 五月31天, 六月30天, 七月31天, 八月31天, 九月30天, 十月31天, 十一月30天, 十二月31天&#125;public class Java &#123; public static void main(String[] args) &#123; for(Tian a: Tian.values())&#123; System.out.println(a); &#125; &#125;&#125; 总结: enum中的内容不能重复，enum中的内容不能只是数字,不然会出现Syntax error on token(s), misplaced constructs(s)这个错误]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse快捷键]]></title>
    <url>%2F2017%2F09%2F23%2Feclipse%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[eclipse常用快捷键12345678910Syso+alt+/ 快速输出代码Ctrl+shift+f 快速调整代码格式Ctrl+D 快速删除光标所在的行shift+回车 当输入代码较长的时候换行ctrl+F11 运行Alt+上下箭头 快速移动光标所在的行代码Ctrl+alt+上下箭头 快速复制光标所在行代码Alt+/ 快速补全代码Ctrl+/ 快速添加单行注释Ctrl+shift+/ 添加多行注释 小常识 打开eclipse，在上方的菜单栏中找到Window选中Preferences，点击Java–&gt;Editor–&gt;Content在红框中输入下面一行字符串，点击OK，退出。1.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 输入这一串，敲代码的时候可以智能提示 包的命名规则123456**.**(对应项目的名字).**（项目功能）com 公司 org 组织model 模型util 工具edu 教育]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小型通讯录]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%B0%8F%E5%9E%8B%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[定义Friend类，编写它具有的属性：姓名(name)、电话(phone)、邮箱(email)和公司(comp)以及它的方法showInfo()。编写测试类AddFriend，实现添加联系人的功能(从键盘输入)1234567891011121314151617181920212223242526272829303132//AddFriend.javaimport java.util.Scanner;public class AddFried &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Friend friend= new Friend(); Scanner inputScanner= new Scanner(System.in); System.out.println("请输入联系人姓名: "); friend.setName(inputScanner.next()); System.out.println("请输入联系人电话: "); friend.setPhone(inputScanner.next()); System.out.println("请输入联系人电子邮箱: "); friend.setEmail(inputScanner.next()); System.out.println("请输入联系人公司: "); friend.setComp(inputScanner.next()); friend.showInfo(); // friend.name= "花千骨";// friend.showInfo(); /* * 没有封装，将String name等四个变量封装为private就行 * 封装：把不想或不该告诉别人的事情隐藏起来 * 具体做法：将属性私有化，提供公有化的方法来访问属性 * */ inputScanner.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940//Friend.javapublic class Friend &#123; String name;// 默认private String phone; String email; String comp; public void setName(String name) &#123; this.name= name;// 访问本类中的属性和方法 &#125; public String getName()&#123; return name; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getComp() &#123; return comp; &#125; public void setComp(String comp) &#123; this.comp = comp; &#125; public void showInfo()&#123; System.out.println("新朋友的联系信息为: "); System.out.println("姓名: "+ this.getName()); System.out.println("电话: "+ this.getPhone()); System.out.println("电子邮箱: "+ this.getEmail()); System.out.println("公司: "+ this.hashCode()); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[竞猜商品]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%AB%9E%E7%8C%9C%E5%95%86%E5%93%81%2F</url>
    <content type="text"><![CDATA[电视商品价格竞猜活动， 活动规则是：随机出现一个商品名，用户猜测它的价格，连续猜测5次，如果猜对便可获得此商品提示：(1)定义GuessMachine，编写它的initial方法，预定义商品信息根据产生的随机数字，选定一款竞猜商品(2)编写GuessMachine的guess方法，如果猜测正确，返回“猜对了，恭喜中奖！”，价格偏高，提示高了，偏低，提示低了。(3)编写测试类模拟竞猜，产生随机数 Math.radom();只产生0.0~1.0之间的数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//GuessMachineimport java.util.Scanner;public class GuessMachine &#123; String mach= null; int price= 0; public void initial()&#123; int data= (int)(Math.random()* 4); switch(data)&#123; case 0: mach= "电视机"; price= 3359; break; case 1: mach= "电冰箱"; price= 1243; break; case 2: mach= "油烟机"; price= 4654; break; case 3: mach= "ipthone"; price= 2324; break; case 4: mach= "洗衣机"; price= 5643; break; default: break; &#125;// System.out.println(data);// System.out.println("请输出"+ mach+ "的价格: "); &#125; public void guess() &#123; Scanner inpScanner= new Scanner(System.in); int guess= 0;//用户输入的价格 int i= 0;//用户猜价格的次数 while(i&lt; 5)&#123; System.out.println("请输入您竞猜的价格: "); guess= inpScanner.nextInt(); if(price== guess)&#123; System.out.println("猜对了，恭喜中奖！"); &#125;else if(price&gt; guess) &#123; System.out.println("低了，请高一点。"); &#125;else if (price&lt; guess) &#123; System.out.println("高了， 请低一点。"); &#125; i++; &#125; if(i&gt;= 5)&#123; System.out.println("您已经猜奖5次，欢迎下次光临！"); &#125; inpScanner.close(); &#125; &#125; 123456789101112//Test.javapackage com.cnstrong.com;public class Test &#123; public static void main(String[] args)&#123; GuessMachine gMachine= new GuessMachine(); gMachine.initial();//初始化 gMachine.guess(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base32解密]]></title>
    <url>%2F2017%2F09%2F23%2Fbase32%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[运行环境python2.712import base64print base64.b32decode("NNSXS63JONRWGY3GOJTGO5DBMVTGCZ3SNB2H2===")]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列置换]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%88%97%E7%BD%AE%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[运行环境python2.7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#!usr/bin/env python#-*- coding:utf-8 -*-from itertools import *from optparse import *def start(): opt = OptionParser() opt.add_option('-c',dest='content',help='Input your content') opt.add_option('-o',dest='output',help='File to save the result') get,args = opt.parse_args() if get.content is None or get.output is None: print 'Use \'help\' to get help' exit(0) return get.content,get.outputdef Exp(content,output): for i in range(2,len(content)): if len(content)%i == 0: filename = open(output,'a+') getList = Code(i) getCo = SplitStr(i,content) for num in getList: get = '' for s in getCo: for one in num: get = get + s[int(one):int(one)+1] filename.write(get+'\n') filename.close() print 'The result is saved as ' + outputdef SplitStr(num,content): result = [] for i in range(len(content)/num): result.append(content[i*num:(i+1)*num]) return resultdef Code(num): number = '' result = [] for i in range(num): number = number + str(i) for i in permutations(number,num): result.append(i) return resultdef main(): content,output = start() Exp(content,output)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大小写转换]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[运行环境python31234567891011121314151617181920def UCaseChar(ch): if ord(ch) in range(97, 122): return chr(ord(ch) - 32) else: return ch def LCaseChar(ch): if ord(ch) in range(65, 91): return chr(ord(ch) + 32) else: return ch def UCase(str): return ''.join(map(UCaseChar, str)) def LCase(str): return ''.join(map(LCaseChar, str)) print (LCase('ABC我abc')) print (UCase('ABC我abc'))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移位]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%A7%BB%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[运行环境python2.7123456789key='CRL'.upper()for i in range(0,26): flag='' for j in key: if j.isalpha(): flag+=chr(((ord(j)-ord('A')+i)%26)+ord('A')) else: flag+=j print str(i).zfill(2),flag]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串转莫尔斯]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E8%8E%AB%E5%B0%94%E6%96%AF%2F</url>
    <content type="text"><![CDATA[运行环境python3123456789101112131415161718192021222324252627CODE = &#123;'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' &#125;def main(): msg = input('MESSAGE: ') for char in msg: if char == ' ': print else: print (CODE[char.upper()] + ' ',)if __name__ == "__main__": main()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转换字符串为莫尔斯]]></title>
    <url>%2F2017%2F09%2F23%2F%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BA%E8%8E%AB%E5%B0%94%E6%96%AF%2F</url>
    <content type="text"><![CDATA[请在python3环境下运行12345678chars = ",.0123456789?abcdefghijklmnopqrstuvwxyz"codes = """--..-- .-.-.- ----- .---- ..--- ...-- ....- ..... -.... --... ---.. ----. ..--.. .- -... -.-. -... . ..-. --. .... .. .--- -.- .-.. -- -. --- .--. --.- .-. ... - ..- ...- .-- -..- -.-- --.."""keys = dict(zip(chars, codes.split()))def char2morse(char): return keys.get(char.lower(), char)print (' '.join(char2morse(c) for c in 'SOS'))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[维吉尼亚]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%2F</url>
    <content type="text"><![CDATA[运行环境python312345678910111213141516171819key='helloworld'plaintext='whereisthekey'#key='relations'#plaintext='tobeornottobeth' ascii='abcdefghijklmnopqrstuvwxyz'keylen=len(key)ptlen=len(plaintext)ciphertext = ''i = 0while i &lt; ptlen: j = i % keylen k = ascii.index(key[j]) m = ascii.index(plaintext[i]) ciphertext += ascii[(m+k)%26] i += 1 print (ciphertext)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n次base64解密]]></title>
    <url>%2F2017%2F09%2F23%2Fn%E6%AC%A1base64%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[运行环境python31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import base64str = '''Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSWFJteFZVMjA1VjAxV2JETlhhMk0xVmpKS1NHVkVRbUZXVmxsM1ZtcEJlRll5U2tWVWJHaG9UVlZ3VlZacVFtRlRNbEpJVm10a1dHSkdjSEJXYTFwaFpWWmFkRTFVVWxSTmF6RTFWa2QwYzJGc1NuUmhSemxWVmpOT00xcFZXbUZrUjA1R1drWlNUbUpGY0VwV2JURXdZVEZrU0ZOclpHcFNWR3hoV1d4U1IyUnNXbGRYYlhSWFRWaENSbFpYZUhkV01ERkZVbFJDVjAxdVVuWldha3BIVmpGT2RWVnNXbWhsYlhob1ZtMXdUMkl5UmtkalJtUllZbGhTV0ZSV2FFTlNiRnBZWlVoa1YwMUVSa1pWYkZKRFZqSkdjbUV6YUZaaGExcG9WakJhVDJOdFJrZFhiV2hzWWxob2IxWnRNWGRVTVZWNVVtdGtWMWRIYUZsWmJGWmhZMVphZEdONlJteFNiSEJaV2xWb2ExWXdNVVZTYTFwV1lrWktSRlpxU2tabFZsSlpZVVprVTFKV2NIbFdWRUpoVkRKT2MyTkZhR3BTYkVwVVZteG9RMWRzV25KWGJHUmFWakZHTkZaSGRHdFdiVXBIVjJ4U1dtSkhhRlJXTUZwVFZqRmtkRkp0ZUZkaVZrbzFWbXBLTkZReFdsaFRiRnBxVWxkU1lWUlZXbmRsYkZweFVtMUdUMkpGV2xwWlZWcHJWVEZLVjJOSWJGZFdSVXBvVmtSS1QyUkdTbkphUm1ocFZqTm9WVmRXVWs5Uk1XUkhWMjVTVGxaRlNsaFVWbVEwVjBaYVdHUkhkRmhTTUhCSlZsZDRjMWR0U2toaFJsSlhUVVp3VkZacVNrZFNiRkp6Vlcxc1UwMHhSalpXYWtvd1ZURlZlRmR1U2s1WFJYQnhWVzB4YjFZeFVsaE9WemxzWWtad2VGVnRNVWRVTWtwR1YyeHdXbFpXY0hKV1ZFWkxWMVpHY21KR1pHbFhSVXBKVm10U1MxVXhXWGhXYmxaV1lsaENWRmxyVm5kV1ZscDBaVWM1VWsxWFVucFdNV2h2VjBkS1JrNVdVbFZXTTJoSVZHdGFjMk5zWkhSa1IyaHBVbGhCZDFkV1ZtOVVNVnAwVTJ4V1YyRXhTbUZhVjNSaFYwWndSbFpZYUZkTlZrcDVWR3hhVDJGV1NuUlBWRTVYVFc1b1dGbHFTa1psUm1SWldrVTFWMVpzY0ZWWFZsSkhaREZrUjJKSVRtaFNlbXhQVkZaYWQyVkdWblJsU0dScFVqQndWMVl5ZEhkV01ERnhVbXRvVjFaRldreFdNVnBIWTIxS1IxcEdaRTVOUlhCS1ZtMTBVMU14VlhoWFdHaGhVMFphVmxscldrdGpSbHB4VkcwNWEySkhVbnBYYTFKVFYyeFpkMkpFVWxkTmFsWlVWa2Q0WVZKc1RuTmhSbkJZVTBWS1NWWnFRbUZXYlZaWVZXdG9hMUp0YUZSWmJGcExVMnhrVjFadFJtcE5WMUl3Vld4b2MyRkdTbGRUYlVaaFZqTlNhRmxWV25OT2JFcHpXa2R3YVZORlNrbFdiR040WXpGVmQwMUliR2hTYlhoWVdXeG9RMVJHVW5KYVJWcHNVbTFTZWxsVldsTmhSVEZ6VTI1b1YxWjZSVEJhUkVaclVqSktTVlJ0YUZObGJYaFFWa1phWVdReVZrZFdibEpPVmxkU1YxUlhkSGRXTVd4eVZXMUdXRkl3VmpSWk1HaExWMnhhV0ZWclpHRldWMUpRVldwS1MxSXlSa2hoUlRWWFltdEtNbFp0TVRCVk1VMTRWVzVTVjJKSFVsVlpiWFIzWWpGV2NWTnRPVmRTYlhoYVdUQmFhMkV3TVZkalJteGhWbGROTVZaWGMzaGpNVTUxWTBaa1RtRnNXbFZXYTJRMFV6RktjMXBJVmxSaVJscFlXV3RhZG1Wc1drZFdiVVphVmpGS1IxUnNXbUZWUmxsNVlVaENWbUpIYUVSVWJYaHJWbFpHZEZKdGNFNVdNVWwzVmxkNGIyTXlSa2RUYkdSVVlsVmFWbFp1Y0Zka2JGcHlWMjFHYWxacmNEQmFSV1F3VlRKRmVsRllaRmhpUmxwb1dWUktSMVl4VG5OYVIyaE9UV3hLV1ZkWGVHOVJNVTE0WTBaYVdHRXpRbk5WYlRGVFpXeHNWbGRzVG1oV2EzQXhWVmMxYjFZeFdYcGhTRXBYVmtWYWVsWnFSbGRqTVdSellVZG9UazFWY0RKV2JHTjRUa2RSZVZaclpGZGlSMUp2Vlc1d2MySXhVbGRYYm1Sc1ZteHNOVlJzYUd0V01rcEhZa1JhV2xaV1NsQldNakZHWlZaV2NscEhSbGRXTVVwUlZsUkNWazVXV1hsU2EyaG9VbFJXV0ZsdGRFdE5iRnAwVFZSQ1ZrMVZNVFJXVnpWVFZqSktTRlZzV2xwaVdGSXpXV3BHVjJOV1RuUlBWbVJUWWxob1lWZFVRbUZoTVZwelUyNU9hbEp0ZUZaV2JGcExVMFphV0dNemFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRmxVUms5U01WcDFWR3hvYVZKc2NGbFhWM1JoWkRGa1YxZHJhR3hTTUZwaFZtcEdTMUl4VW5OWGJVWldVbXhzTlZsVldsTldNa1Y0VjJ0MFZWWnNjSEpaZWtaaFpFVTVWMVpyTlZkaWEwWXpWbXhqZDAxV1RYaFZXR2hZWW1zMVZWbHNWbUZXYkZwMFpVaGtUazFXY0hsV01qRkhZV3hhY21ORVJsaGhNWEJRVmtkNFlXTnRUa1ZYYkdST1lteEtlVmRZY0VkV2JWWlhWRzVXVkdKRk5XOVpXSEJYVjFaa1YxVnJaR3ROYTFwSVdXdGFiMkZ0Vm5KWGJHaFZWbTFTVkZZeWVHdGpiRnBWVW14b1UyRXpRbUZXVm1NeFlqRlplRmRxV2xKWFIyaFhWbXRXWVdWc1duRlNiWFJyVm14S01GVnRlRTloUjFaelYyeGtWMkpIVGpSVWEyUlNaVlphY2xwR1pGaFNNMmg1Vmxkd1ExbFhUa2RXYmxKc1UwZFNjMWxyV2xkT1ZsSnpXWHBXVjAxRVJsaFphMUpoVjJ4YVYyTklXbGROYm1ob1ZtcEdZV05XVm5OYVJUVlhZbXRLU2xZeGFIZFNNVmw1VkZoc1UyRXlhSEJWYlhNeFkwWnNWVkZ1WkU1aVJuQXdXbFZqTldFd01WWk5WRkpYWWtkb2RsWXdXbXRUUjBaSFlVWndhVmRIYUc5V2JURTBZekpPYzFwSVZtRlNNMEpVV1d0YWQwNUdXbGhOVkVKT1VteHNORll5TlZOV2JVcElaVWRvVm1KSFVsUlZNRnBoWTFaT2NscEZPV2xTV0VJMlZtdGtORmxXVlhsVGExcFlWMGhDV0Zac1duZFNNVkY0VjJ0T1ZtSkZTbFpVVlZGM1VGRTlQUT09'''for i in range(1,16): str = base64.b64decode(str)print (str)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相册]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[老规矩，先贴上index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;精品相册1&lt;/title&gt; &lt;link rel="stylesheet" href="css/img_style.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="picList"&gt; &lt;!--&lt;div id="Left"&gt;&lt;/div&gt;--&gt; &lt;span&gt;&lt;img src="img/main/1.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/2.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/3.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/4.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/5.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/6.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/7.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/8.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/9.jpg"/&gt;&lt;/span&gt; &lt;!--&lt;div id="Right"&gt;&lt;/div&gt;--&gt; &lt;/div&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：添加挡板 --&gt; &lt;div id="pan"&gt;&lt;/div&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：显示特效图片的位置 包含图片以及按钮 --&gt; &lt;div id="show"&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：中间显示图片容器的位置 --&gt; &lt;div id="showimage"&gt; &lt;span&gt;&lt;img src="img/show/0/1.jpg" title="1"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/2.jpg" title="2"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/3.jpg" title="3"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/4.jpg" title="4"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/5.jpg" title="5"/&gt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：切换图片的按钮 --&gt; &lt;span id="pre"&gt; &lt;p&gt;&lt;&lt;/p&gt;&lt;/span&gt; &lt;span id="next"&gt;&lt;p&gt;&gt;&lt;/p&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：导入js文件 --&gt; &lt;script type="text/javascript" src="js/jquery-1.11.3.js" &gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; //点击每一张图片容器的时候 $("#picList span").click(function()&#123; //获取showimage中的所有img标签 var $img = $("#showimage img"); //获取点击的那一个图片 //$(this).index();返回指定元素在相对应的集合中下标的位置 var index = $(this).index();//0 for(var i=0;i&lt;5;i++)&#123; //获取图片路径 //img/show/0/1.jpg var url="img/show/"+index+"/"+(i+1)+".jpg"; //更换图片 $img.eq(i).attr("src",url); &#125; //让特效显示 //淡入效果、600毫秒的执行时间 $("#pan").fadeIn(600); $("#show").fadeIn(600).show(); &#125;); //点击挡板的事件，让特效消失 $("#pan").click(function()&#123; //淡出的效果 $("#pan").fadeOut(600); $("#show").fadeOut(600); &#125;); //点击下一张按钮 $("#next").click(function()&#123; //索引到最后 一张图片 $("#showimage span:last-child").animate( &#123;left:"680px"&#125;,500,function()&#123; $(this).animate(&#123;left:"0px"&#125;,500); //更换位置 //将指定的元素，插入到当前集合中的开头位置 $("#showimage").prepend(this); &#125;); &#125;); //点击上一张按钮 $("#pre").click(function()&#123; //索引到第一张图片 $("#showimage span:first-child").animate( &#123;left:"-680px"&#125;,500,function()&#123; $(this).animate(&#123;left:"0px"&#125;,500); //更换位置 //将指定的元素，插入到当前集合中的结尾位置 $("#showimage").append(this); &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/html&gt; /img目录下的图片放在ghthub /js目录下的jquery-1.11.3.js /css目录下的img_style.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109*&#123; margin: 0; padding: 0; &#125;/*添加背景*/body&#123; background: url(../img/bg.jpg); /*隐藏滚动栏*/ overflow: hidden;&#125;#picList&#123; width: 750px; height: 600px; /*margin:第一个上下距离 第二个左右距离 auto 自适应*/ margin: 100px auto;&#125;img&#123; width: 230px; height: 160px; padding: 5px; margin: auto auto;&#125;/*行内元素不支持宽高的设置*/span&#123; background-color: #FFFFFF; width: 240px; height: 170px; /*把行内元素改变成块元素，支持宽高的设置*/ display: block; float: left; margin: 5px; /*加入外阴影*/ box-shadow: 0px 0px 20px #FFFFFF;&#125;/*遮光挡板*/#pan&#123; position: absolute; left: 0px; top: 0px; width: 100%; height: 100%; /*前三个参数：设置颜色编码 第四个参数：设置透明度*/ background: rgba(0,0,0,0.8); /*设置默认隐藏*/ display: none;&#125;#showimage&#123; /*设置中间容器的显示位置*/ position: absolute; top: 150px; left: 50%; margin-left: -330px; /*设置层级显示关系*/ z-index: 10;&#125;/*设置每一张大图的容器边框*//*派生选择器控制绝对路径的属性*/#showimage span&#123; width: 650px; height: 440px; background: #FFFFFF; box-shadow: 0px 0px 0px #FFFFFF; position: absolute; &#125;#showimage img&#123; width: 640px; height: 430px;&#125;#show p&#123; color: white; font-size: 60px; text-align: center; margin-top: -5px; /*设置粗体*/ font-weight: bold;&#125;/*上一张图片的按钮*/#pre&#123; position: absolute; width: 50px; height: 80px; top: 320px; left: 10%; background: rgba(0,0,0,0.5); /*设置圆角*/ border-radius: 10px; z-index: 20px;&#125;#next&#123; position: absolute; width: 50px; height: 80px; top: 320px; right: 10%; background: rgba(0,0,0,0.5); /*设置圆角*/ border-radius: 10px; z-index: 20px;&#125;/*让这个显示特效的区域隐藏*/#show&#123; display: none;&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打砖块]]></title>
    <url>%2F2017%2F09%2F22%2F%E6%89%93%E7%A0%96%E5%9D%97%2F</url>
    <content type="text"><![CDATA[style在北京实训的时候，跟着培训老师做的一个小游戏，有不足之处请指教！先放上index.html 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;打砖块游戏&lt;/title&gt; &lt;link rel="stylesheet" href="css/new_file.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-07-12 描述：创建一个画布 --&gt; &lt;canvas id="gameCanvas" width="1024px" height="768px"&gt;&lt;/canvas&gt; &lt;audio id="bgmp3" src="img/happy.mp3" autoplay="autoplay"&gt;&lt;/audio&gt; &lt;audio id="breakermp3" src="img/bucket1.mp3"&gt;&lt;/audio&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-07-13 描述：得分 --&gt; &lt;span id="kuangjia"&gt;&lt;p id="p_number"&gt;得分:0&lt;/p&gt;&lt;/span&gt; &lt;img id="start_game" src="img/image/4.png" onclick="Start_game()" /&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-07-12 描述：导入js文件 --&gt; &lt;script type="text/javascript" src="js/game_style.js" &gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; /img目录下的的图片和音频在github /js目录下的game_style.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243window.onload = init;//小括号写不写都行//window.onload = init();window.onmousemove = mouseMoveHandler;//获取鼠标移动的属性//画板设置成全局变量var canvas;//画笔设置成全局变量var context;var gamebg;//背景var board;//挡板var ball;//小球//挡板的坐标var boardY = 650;var boardX = 0;var it = 0;//定义画布的宽高var cW = 1024;var cH = 768;//设置小球的初始化坐标var ballX = 400;var ballY = 500;//定义小球XY轴的速度var vx = 8;var vy = -8;//定义一个数组用于存储砖块var Breaders;var breakermp3;//得分var score = 0;var p;var Tick;//游戏入口function init()&#123; //方法的调用 log("进入游戏中..."); //找到画布 canvas = document.getElementById("gameCanvas"); //找到声音控件 breakermp3 = document.getElementById("breakermp3"); //找到得分文字 p = document.getElementById("p_number"); //相当于画笔 context = canvas.getContext("2d");// gamebg = new Image();//创建一个image对象，用于加载图片// gamebg.src="img/image/bg.png";// //三个参数：第一个绘制的对象；第二个第三个绘制的起始坐标；// context.drawImage(gamebg,0,0); gamebg = AddImg("img/image/bg.png"); board = AddImg("img/image/board.png"); ball = AddImg("img/image/ball.png"); createrBreaders();//创建砖块 //删除数组中的参数 //Breaders.splice(0,1); //调用刷新机制 Tick = setInterval(gameTick,1000/60);//一秒刷新60次,1000毫秒等于1秒&#125;//创建一个刷新界面的方法function gameTick()&#123; log("刷新次数:"+(it++)); //清空当前屏幕 cleanScreen();//调用清空屏幕的方法 //绘制背景 context.drawImage(gamebg,0,0); //绘制的挡板 context.drawImage(board,boardX,boardY); //刷新砖块 updateBreaker(); //调用刷新小球位置 updateBall(); //调用检查碰撞 TextBallandBoread(); //调用检查小球与砖块碰撞 TextBallandBreaker();&#125;//检查小球跟砖块的碰撞function TextBallandBreaker()&#123; for(var i = Breaders.length-1;i&gt;=0 ;i--)&#123; var item = Breaders[i];//先提取最后一个 var hit = hitTextpoint(item.x,item.y,200,66,(ballX+ball.width/2),ballY); if(hit)&#123; breakermp3.play(); Breaders.splice(i,1); vy *= -1; p.innerText = "得分:"+(++score); if(score&gt;=25)&#123; RestartandClean(); &#125; &#125; &#125;&#125;//重新开始游戏的方法function Start_game()&#123; window.location.reload();//让界面重新刷新&#125;//游戏结束，清空屏幕function RestartandClean()&#123; clearInterval(Tick); cleanScreen(); context.drawImage(gamebg,0,0); var gamestart = document.getElementById("start_game"); gamestart.style.display = "block";//游戏结束，出现砖块&#125;//检查小球跟挡板的碰撞function TextBallandBoread()&#123; var hit = hitTextpoint(boardX-ball.width,boardY-ball.height,board.width+ball.width,board.height+ball.height,ballX,ballY); if(hit)&#123; ballY = boardY-ball.height; vy *= -1;//取反 &#125;else&#123; &#125;&#125;//碰撞满足的条件//x1、y1障碍物的坐标//w1、h1障碍物的宽高//x2、y2小球的坐标function hitTextpoint(x1,y1,w1,h1,x2,y2)&#123; if(x2&gt;=x1&amp;&amp;x2&lt;=x1+w1&amp;&amp;y2&gt;y1&amp;&amp;y2&lt;=y1+h1)&#123; return true; &#125;else&#123; return false; &#125;&#125;//刷新砖块function updateBreaker()&#123; //循环提取数组中的砖块 for(var i = 0; i&lt; Breaders.length; i++)&#123; var items = Breaders[i]; context.drawImage(items.bimg,items.x,items.y); &#125;&#125;//创建砖块function createrBreaders()&#123; Breaders = new Array(); for(var j=0; j&lt;5; j++)&#123; for(var i = 0; i &lt; 5; i++)&#123; var item = AddImg("img/image/"+(4+j)+".png"); //item.x = 20+200*i; //item.y = 100+70*j; Breaders.push(&#123; bimg:item, x: 20 + 200 * i, y: 100 + 72 * j &#125;); &#125; &#125; &#125;//小球位置刷新的方法function updateBall()&#123; ballX += vx; ballY += vy; log("小球的坐标为:X"+ballX+",Y轴坐标:"+ballY); //上边 if(ballY&lt;=80)&#123; ballY = 80; vy *= -1; &#125; //下方 if(ballY&gt;=cH)&#123;// ballY = cH - ball.height;// vy *= -1; log("游戏结束。。。"); RestartandClean(); &#125; //右边 if(ballX&gt;=cW - ball.width)&#123; ballX = cW -ball.width; vx *= -1; &#125; //左边 if(ballX&lt;=0)&#123; ballX = 0; vx *= -1; &#125; //绘制小球 context.drawImage(ball,ballX,ballY);&#125;//鼠标滑动触发的事件function mouseMoveHandler(e)&#123; //获取鼠标的X轴的数值 //将中心点设置为挡板的中心 boardX = e.x - board.width/2; //判断挡板不超出左边屏幕 if(e.x&lt;=0+board.width/2)&#123; boardX = 0; &#125; //判断挡板不超出右边屏幕 if(e.x&gt;cW - board.width/2)&#123; boardX = cW - board.width; &#125;&#125;//创建一个清空屏幕的方法function cleanScreen()&#123; /* * 第一个参数：X 坐标 * 第二个参数：Y 坐标 * 第三个参数：画板的宽度 * 第四个参数：画板的高度 * */ context.clearRect(0,0,cW,cH);&#125;//加载图片的方法 url 图片的路径function AddImg(url)&#123; var img = new Image();//创建一个Image对象 img.src = url; return img;&#125;//后台控制面板游戏进度数据输出function log(msg)&#123; //打印到控制台 console.log(msg);&#125; /css目录下的new_file.css 123456789101112131415161718192021222324#p_number&#123; /*设置绝对定位*/ position: absolute; left: 10px; top: -15px; font-size: 20px; padding: 5px; border-radius:5px;&#125;#kuangjia&#123; position: absolute; left: 100px; top: 20px; background: orange; width: 100px; height: 50px; border-radius:5px;&#125;#start_game&#123; position: absolute; top: 400px; left:300px; display: none;&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this用法(二)]]></title>
    <url>%2F2017%2F09%2F22%2FJava%E4%B8%ADthis%E7%94%A8%E6%B3%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[/* 关键字this： 1，在普通方法中，关键字this代表方法的调用者，即本次调用了该方法的对象 2，在构造方法中，关键字this代表了该方法本次运行所创建的那个新对象 */12345678910111213141516171819202122232425262728class A&#123; private int i; public A(int i) &#123; this.i = i; //将形参 i 赋给该构造方法本次运行所创建的那个新对象的i数据成员 &#125; public void show()&#123; System.out.println("i = " + this.i); //this表示当前时刻正在调用show方法的对象 //this可以省略 &#125; public void show1()&#123; System.out.println("i = " + i); //this表示当前时刻正在调用show方法的对象 //this可以省略 &#125;&#125;public class TestThis &#123; public static void main(String[] args)&#123; A aa1 = new A(100); aa1.show(); A aa2 = new A(300); aa2.show1(); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this用法(一)]]></title>
    <url>%2F2017%2F09%2F22%2FJava%E4%B8%ADthis%E7%94%A8%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[/* 作为参数传递 需要在某些完全分离的类中调用一个方法，并将当前对象的一个引用作为参数传递时 */12345678910111213141516171819202122232425262728public class Demo &#123; public static void main(String[] args) &#123; B b = new B(new AB()); System.out.println(b); &#125;&#125;class AB&#123; public AB()&#123; new B(this).print(); // 匿名对象 /*匿名对象就是没有名字的对象。 * 如果对象只使用一次，就可以作为匿名对象，代码中 new B(this).print(); * 等价于 ( new B(this) ).print();， * 先通过 new B(this) 创建一个没有名字的对象，再调用它的方法。*/ &#125; public void print()&#123; System.out.println("Hello from A!"); &#125;&#125;class B&#123; AB a; public B(AB a)&#123; this.a = a; &#125; public void print() &#123; a.print(); System.out.println("Hello from B!"); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断输入的字符串是否为数字]]></title>
    <url>%2F2017%2F09%2F21%2F%E5%88%A4%E6%96%AD%E8%BE%93%E5%85%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[传入的str1包含中文、负数,位数很长的数字的字符串也能正常匹配12345678910111213141516171819202122232425262728293031import java.math.BigDecimal;import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern;public class jisuanqiceshi &#123; public static void main(String[] args) &#123; Scanner str1= new Scanner(System.in); System.out.println("请输入您要判断的字符串: "); String str2 = str1.next(); System.out.println(isNumeric(str2)); str1.close(); &#125; //用正则表达式判断字符串是否为数字（含负数） public static boolean isNumeric(String str) &#123; String regEx = "-?[0-9]+\\.?[0-9]*"; Pattern pat = Pattern.compile(regEx); try&#123; regEx= new BigDecimal(str).toString(); &#125; catch (Exception e)&#123; return false;//异常 说明包含非数字 &#125; Matcher mat = pat.matcher(str); if (mat.find()) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 多组输入试过，没成功，希望大家多多指教！]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_9]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-9%2F</url>
    <content type="text"><![CDATA[求满足1+ 2!+ 3!+ ... +n!&lt;= 9999的最大整数N12345678910111213141516public class Example3_9 &#123; public static void main(String[] args) &#123; int n= 1; long sum= 0, t= 1; t= n* t; while(true)&#123; sum= sum+ t; if(sum&gt; 9999)&#123; break; &#125; n++; t= n* t; &#125; System.out.println("满足条件的最大整数："+ (n- 1)); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_8]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-8%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，计算两个非零正整数的最大公约数和最小公约数，要求两个非零正整数从键盘输入1234567891011121314151617181920212223public class Example3_8 &#123; public static void main(String[] args) &#123; System.out.println("请输入两个非零正整数，每输入一个数回车确认"); Scanner reader= new Scanner(System.in); int m= 0, n= 0, t= 0, gy= 0, gb= 0; m= reader.nextInt(); n= reader.nextInt(); if(m&gt; n)&#123; t= m; m= n; n= t; &#125; for(int i= 1; i&lt;= m; i++)&#123; if(m% i== 0 &amp;&amp; n% i== 0)&#123; gy= i; &#125; &#125; gb= m* n/ gy; System.out.println(m+ "和"+ n+ "的最大公约数为: "+ gy); System.out.println(m+ "和"+ n+ "的最小公倍数为: "+ gb); reader.close(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_7]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-7%2F</url>
    <content type="text"><![CDATA[一个数如果恰好等于它的因子之和，这个数就称为“完数”，编写一个应用程序，求1000之内的所有完整完数123456789101112131415public class Example3_7 &#123; public static void main(String[] args) &#123; int sum= 0, i, j; for(i= 1; i&lt;=1000; i++)&#123; for(j= 1, sum= 0; j&lt; i; j++)&#123; if(i% j== 0)&#123; sum+= j; &#125; &#125; if(sum== i)&#123; System.out.println("完数: "+ i); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_6]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-6%2F</url>
    <content type="text"><![CDATA[分别用while和for循环计算1+ 1/2!+ 1/3!+ 1/4!+ ... 的前20项之和1234567891011121314151617public class Example3_6 &#123; public static void main(String[] args) &#123; double sum= 0, a= 1, i= 1; while(i&lt;= 20)&#123; a= (1.0/i)* a; i++; sum= sum+ a; &#125; System.out.println("使用while循环计算的sum= "+ sum); for(sum= 0, i= 1, a= 1; i&lt;= 20; i++)&#123; a= a*(1.0/ i); sum= sum+ a; &#125; System.out.println("使用for循环计算的sum= "+ sum); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_5]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-5%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，求100以内的全部素数法一:123456789101112131415public class Example3_5 &#123; public static void main(String[] args) &#123; int i, j; for(j= 2; j&lt;= 100; j++)&#123; for(i= 2; i&lt;= j/2; i++)&#123; if(j%i== 0)&#123; break; &#125; &#125; if(i&gt; j/ 2)&#123; System.out.print(" "+ j); &#125; &#125; &#125;&#125; 法二:1234567891011121314public class demos &#123; public static void main(String[] args) &#123; int i, n; for(n= 2; n&lt;= 100; n++)&#123; for(i= 2; i&lt;= n- 1; i++)&#123; if (n% i== 0) &#123; break; &#125; &#125;if (i== n) &#123; System.out.print(n+ " "); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_4]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-4%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，求1!+ 2!+ ... + 20!123456789101112public class Example3_4 &#123; public static void main(String[] args) &#123; double sum= 0, a= 1; int i= 1; while (i&lt;= 20)&#123; sum= sum+ a; i++; a= a*i; &#125; System.out.println("sum= "+ sum); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_3]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-3%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，用for循环输出俄文的字母表1234567891011121314151617public class Example3_3&#123; public static void main (String args[]) &#123; int startPosition=0,endPosition=0; char cStart='А',cEnd='Я'; startPosition=(int)cStart;//cStart做int型转换运算，并将结果赋值给startPosition endPosition=(int)cEnd;//cEnd做int型转换运算，并将结果赋值给endPosition System.out.println("俄文字母共有:"+(endPosition-startPosition+1)+"个"); for(int i=startPosition;i&lt;=endPosition;i++) &#123; char c='\0'; c=(char)i;//i做char型转换运算，并将结果赋值给c System.out.print(" "+c); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays类中binarySearch()的问题]]></title>
    <url>%2F2017%2F09%2F10%2FArrays%E7%B1%BB%E4%B8%ADbinarySearch-%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近新上手了Java，学习的过程中发现在binarySearch()方法中有点地方不明，so~google了一下。binarySearch()方法的返回值有两种情况：1、如果找到关键字，则返回值为关键字在数组中的位置索引，且索引从0开始； 2、如果没有找到关键字，返回值为负的插入点值，插入点值就是第一个比关键字大的元素在数组中的位置索引，而且这个位置索引从1开始。 注：调用binarySearch()方法前要先调用sort方法对数组进行排序，否则得出的返回值不定，这是二分搜索算法决定的。 如下一个小例1234567891011121314151617181920212223242526272829303132import java.util.Arrays;public class Example2_7 &#123; public static void main(String[] args) &#123; int[] a= new int[] &#123;12, 34, 9, 23, 45, 6, 45, 90, 123, 19, 34&#125;; int[] b= &#123;12, 34, 9, 23, 45, 6, 45, 90, 123, 19, 34&#125;; //两种定义方法都可 Arrays.sort(b); System.out.println(Arrays.toString(b)); Arrays.sort(a); System.out.println(Arrays.toString(a)); int number= 45; int index= Arrays.binarySearch(a, number); System.out.println(index); if( index&gt;= 0)&#123; System.out.println(number+ "和数组中索引为"+ index+ "的元素值相同"); &#125; else &#123; System.out.println(number+ "不与数组中的任何元素值相同"); &#125; int numberd= 89; //此时没有找到关键字，返回值为-10，第一个比89大的数是90，位置是第十个，此时位置索引从1开始 int indexd= Arrays.binarySearch(a, numberd); System.out.println(indexd); if( indexd&gt;= 0)&#123; System.out.println(numberd+ "和数组中索引为"+ indexd+ "的元素值相同"); &#125; else &#123; System.out.println(numberd+ "不与数组中的任何元素值相同"); &#125; &#125;&#125; 运行结果为123456[6, 9, 12, 19, 23, 34, 34, 45, 45, 90, 123][6, 9, 12, 19, 23, 34, 34, 45, 45, 90, 123]845和数组中索引为8的元素值相同-1089不与数组中的任何元素值相同]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FengCms上传Webshell]]></title>
    <url>%2F2017%2F08%2F31%2FFengCms%E4%B8%8A%E4%BC%A0Webshell%2F</url>
    <content type="text"><![CDATA[今天拿一个演示站做测试 首页很平常，有一个输入框，可能有注入漏洞。查看源代码后，在最底下有一行注释，提示一些信息，有门！ 上网搜查下FengCms，发现FengCms是由地方网络工作室完全知识产权打造的一套适用于个人、企业建站的内容管理系统。在这个网页上有相关的漏洞https://www.seebug.org/appdir/FengCMS这次使用的是任意文件下载漏洞 通过扫描发现这段PHP代码有明显的漏洞。 通过找到这个文件名，base64编码后获取文件内容，将其下载到本地。 演示站证明: http://guf521656.h163.92hezu.org/?controller=down&amp;file=Y29uZmlnLnBocA 打开后发现MySQL的用户名和密码 用nmap扫描到演示站开着3306端口 利用所得的账号密码，进入数据库根据phpinfo.php中，找到的绝对路径/var/www/htmldocument_root的值，得到网站的绝对路径利用MySQL上传一句话木马 就会发现/upload/下多出1.php文件，上传成功随后可用中国菜刀链接到网站，提取里面的信息~]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP提数据]]></title>
    <url>%2F2017%2F08%2F30%2FSQLMAP%E6%8F%90%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[查询数据库中信息的sqlmap语句SQLMAP读取数据： -u 漏洞url-data “vul” POST内容 –dbs 罗列所有数据库 -D 指定数据库 –tables列表 -D 指定数据库 -T 指定表 –columns 列所有字段 -D 指定数据库 -T 指定表 -C 指定字段 –dump 获取数据 –random-agent 随机ua头 –level -risk 设置扫描等级 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ - -dbs查询数据库 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ - -current-db查询当前使用的数据库 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ -D security - -tables查询所有的表 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ -D security -T users - -columns查询表中所有字段 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ -D security -T users -C username,password - -dump指定查询的列 两条-之间没有空格，style在编辑的时候，两条-之间没加空格，它们会连在一起，不容易看出，额，markdown用的不是很熟~]]></content>
      <tags>
        <tag>SQLMAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos + Hexo + Github]]></title>
    <url>%2F2017%2F08%2F30%2FCentos-Hexo-Github%2F</url>
    <content type="text"><![CDATA[本文只介绍style安装的过程，其他版本请另行借鉴！(万变不离其宗)必需品： 注册有腾讯有以及域名 腾讯云中安装Centos 7 注册有Github ###Centos 7 中 下载并安装LNMP 我安装的是稳定版 wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp 安装成功后， 下一步 ###Centos 7 中 安装Hexo这个茬可真不好弄==，style第一次安装的时候出了许多的错误，无奈之下只能一点一点解决。安装过程中借鉴了许多资料，另行总结才搭配好，总觉得网上的教程不是很全面。在root下安装 ####首先安装Node.js找到最新的下载地址，用 wget 命令下载到本地 wget https://nodejs.org/dist/v4.4.4/node-v4.4.4-linux-x64.tar.xz 下载完后解压，因为是xz文件， 所以如下 xz -d node-v4.4.4-linux-x64.tar.gz tar -xvf node-v4.4.4-linux-x64.tar 文件被解压到当前文件夹下 mv node-v4.4.4-linux-x64 node-v4.4.4 mv node-v4.4.4 /usr/local/node ####配置环境变量 #编辑 /etc/profile (使用 vim) vim /etc/profile #在底部添加PATH变量 export PATH=$PATH:/usr/local/node/bin*#保存退出， 先按Esc键， 再按Shift + : 输入wq即可保存退出 最后保存并使其生效即可 source /etc/profile ###安装Hexo 创建目录 mkdir hexo 切换目录 cd hexo 安装Git(已安装， 跳过) yum install git-core 安装Hexo npm install -g hexo-cli 初始化Hexo hexo init 这里可能有个问题，就是在安装Hexo的时候， 输入安装Hexo的安装指令npm install -g hexo-cli，可能会出现错误，如果出错，可将官方源替换成淘宝源 npm install -g hexo –registry=https://registry.npm.taobao.org ####安装插件 npm install hexo-generator-index –save npm install hexo-generator-archive –save npm install hexo-generator-category –save npm install hexo-generator-tag –save npm install hexo-server –save npm install hexo-deployer-git –save npm install hexo-deployer-heroku –save npm install hexo-deployer-rsync –save npm install hexo-deployer-openshift –save npm install hexo-renderer-marked –save npm install hexo-renderer-stylus –save npm install hexo-generator-feed –save npm install hexo-generator-sitemap –save 安装结束后，进行下一步修改Hexo配置文件(站点文件，即hexo/config._yml,, hexo/themes/next/_config.yml是主题文件)注： key值没有对应的value值的时候，冒号后面一定要有空格！否则会报错，例如：timezone:会报错，，timezone: 不会 ###部署到Github这个简单 ####配置本机全局git变量(如果已经配置过请忽略)在VPS(你的服务器)上设置你的Git git config –global user.email “你的github注册时的邮箱” git config –global user.name “你的名字” ####生成ssh和密钥输入下面一段指令 less ~/.ssh/id_rsa.pub 如果出现一堆密码，则证明你已经生成ssh，可跳过下面一步，如果报错，请进行下一步。 ssh-keygen -t rsa -C example@126.com注： -C后面跟你在github注册的用户名邮箱，这样公钥才会被github认可回车后，不用输入文件夹路径和名字，自动选择默认的路径，存储新的ssh密钥连续回车，结束查看公钥内容，稍后加入github账户的sshkey中 less ~/.ssh/id_rsa.pub ###创建博客工程 创建一个新的仓库，仓库名为用户名.github.io，比如我的github用户名是sunstady，则创建的项目名为sunstady.github.io ###将ssh密钥添加到github中生成后，需要将密钥放到github上去，登录你的github账号，进入密钥设置面板：https://github.com/settings/ssh在执行less ~/.ssh/id_rsa.pub后，会有一堆长的密码，把这一堆密码全部复制到github上 ####配置Hexo， 编译与部署在站点文件_config.yml里第一段 #Site 站点信息设置title: Sanstyle #站名subtitle: 世界， 你好 #这是副标题description: #站描述autor: MC #作者language: zh-CN #语言timezone: 在站点文件_config.yml里最后一段 deploy:type: git repo:git@github.com:sunstady/sunstady.github.io.git branch: master message: &apos;站点更新:{{now("YYYY-MM-DD HH/mm/ss")}}&apos; 这里， 就是你创建的博客工程最后一步，编译， 上传静态代码 编译 hexo generate 在主机的hexo目录下，执行以下命令将自动更新到github hexo d ###修改主题和配置文件 ####安装主题NEXT切换到目录hexo下 git clone https://github.com/iissnan/hexo-theme-next themes/next在站点文件_config.yml中 找到 theme: 修改后面的参数，默认是 landscape theme: next ####验证主题首先启动Hexo站点， 并开启调试模式，整个命令是hexo s --debug。在启动服务的过程中，注意观察命令行输出是否有任何异常信息，当命令行提示：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问http://localhost:4000，检查站点是否正确运行。 ###主题设定 ####选择SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认Scheme， 这是NexT最初的版本，黑白主调，大量留白 Mist - Muse的紧凑版本， 整洁有序的单栏外观 Pisces - 双栏Scheme， 小家碧玉似的清新 Scheme的切换通过更改主题文件，搜索scheme关键字(用 vim 打开后，输入/scheme就可搜索)你会看到三行scheme的配置，将你启用的scheme前面注释#去掉即可。 scheme: Pisces ####设置菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑主题文件， 修改如下： menu:home: / archives: /archives about: /about categories: /categories tags: /tags commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的/去掉 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 menu_icons: enable: true home: home about: about categories: th tags: tags archives: archive commonweal: heartbeat ####设置头像编辑主题文件，修改字段avatar, 值设置成头像的链接地址 avatar: http://xxxx.com/xxxxx.jpg ###访问：现在可以通过用户名.github.io访问博客]]></content>
      <tags>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
