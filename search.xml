<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[禁止U盘拷贝]]></title>
    <url>%2F2018%2F03%2F27%2F%E7%A6%81%E6%AD%A2U%E7%9B%98%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[经常会有人在我们电脑上拷贝一些东西，那我们不想让别人拷贝怎么办呢？1、键入win + r键，打开运行，输入gpedit.msc，打开本地组策略编辑器。2、点击计算机配置–&gt;管理模板–&gt;系统，找到右侧可移动存储访问。3、双击后可看到右侧有五个可移动磁盘项目，我们不想让别人从我们电脑拷贝的话，双击拒绝写入权限。4、选中已启用，点击确定。5、打开U盘，将文件放入U盘，可以看到提示需要管理员权限。6、我们点击继续，发现没有办法将文件放入U盘。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py使用itchat发送微信消息]]></title>
    <url>%2F2018%2F03%2F25%2Fpy%E4%BD%BF%E7%94%A8itchat%E5%8F%91%E9%80%81%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[环境：Windows、python3.6、itchat库代码参考于奇幻果园。itchat使用需要事先下载安装，命令如下: pip install itchat这个代码的作用就是在指定时间给微信好友发送信息，并且可以间隔特定时间再次发送，类似于短信轰炸？学习！嗯，用来学习。12345678910111213141516171819202122232425262728293031#!usr/bin/python# -*- coding: UTF-8 -*-import itchatimport datetime, os, platform,timedef timerfun(sched_time) : flag = 0 while True: now = datetime.datetime.now() if now &gt; sched_time and now &lt; sched_time + datetime.timedelta(seconds=1) : #因为时间秒之后的小数数据部分不一定相等，要标记一个范围判断 send_move() time.sleep(2) #每次判断间隔2s, 避免多次触发事件 flag = 1 else : if flag == 1 : sched_time = sched_time + datetime.timedelta(hours=24) #把目标时间增加一个小时，24小时后触发再次执行 flag = 0def send_move(): users= itchat.search_friends(name= 'Love') #使用备注名来查找实际用户名 print(users) #获取好友全部信息，返回一个列表，列表内是一个字典 userName= users[0]['UserName'] #获取UserName，用来发送消息 itchat.send("It's time to take a rest. 宝贝, 该睡觉啦!", toUserName= userName) print('succeed')if __name__=='__main__': itchat.auto_login(hotReload=True) #首次扫描登录后后续自动登录 sched_time = datetime.datetime(2018,3,25,23,40,00) #设定初次触发时间的事件点 print('run the timer task at &#123;0&#125;'.format(sched_time)) timerfun(sched_time) 有些地方需要注意下:1、第11行判断时间是否到达指定时间处，因为now = datetime.datetime.now()返回的时间精确到了ms, 所以直接拿精确到s的特定时间去比较会出现False。所以改用判断时间是否在范围内。并且判断完后会用time.sleep(2)延时2s再次比较，避免多次命中或多次判断。2、第17行内，每次时间判断满足指定时间范围时，将指定时间往后延一定时间。这里+ datetime.timedelta(hours=24)表示延后24小时，达到每过24小时触发一次send_move函数的目的。3、第28行内，itchat.auto_login(hotReload=True)如注释说明的一样，避免每次都要扫描二维码登录，在登录一次之后”保持在线状态”4、第27行，if __name__==&#39;__main__&#39;:表示当前模块仅在自己运行时才运行后续的语句，否则当该模块被其他模块引用时，不会运行后续语句。每个模块都有__name__属性，当它等于__main__时，表示该模块被用户单独运行，可以执行特殊的操作。5、第30行，注意一下这里的print函数对sched_time字符串的使用方式。为了按照一般时间格式打印输出，对sched_time进行了format格式化处理，我理解就是保持sched_time原本的时间形式不变，而按照字符串的方法进行处理。这里用{0}来表示格式化后的sched_time，让其能够以原来时间格式与前面待打印的字符串进行字符串拼接。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下py脚本后台运行]]></title>
    <url>%2F2018%2F03%2F25%2FWindows%E4%B8%8Bpy%E8%84%9A%E6%9C%AC%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[环境: Windows、python3.6py脚本在Linux的后台运行网上教程很多，而在Windows中的介绍不多。下面说一种可行方法： 将wx.py文件改为wx.pyw。cmd进入到pythonw目录下, 输入pythonw wx.pyw 1&gt;stdout.txt 2&gt;stderr.txt 由于代码原因，要进行故障排除，即在调用时使用输出重定向。这将print()在文件中捕获stdout输出，例如来自file stdout.txt, stderr输出(例如来自未处理的异常)stderr.txt。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py脚本打包成exe]]></title>
    <url>%2F2018%2F03%2F25%2Fpy%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E6%88%90exe%2F</url>
    <content type="text"><![CDATA[输入pyinstaller -F wx_dingshi.py有可能会出现错误PyInstaller cannot check for assembly dependencies.并且提示Please install PyWin32 or pywin32-ctypes.问题很明显了，缺少这俩库输入pip install PyWin32和 pip install pywin32-ctypes静等安装。安装完后再次输入pyinstaller -F wx_dingshi.py打包完成。同目录下的dist文件夹中的wx_dingshi.exe就是目标exe。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程同步]]></title>
    <url>%2F2018%2F03%2F20%2F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[什么是进程同步？列举两个生活中的进程同步的实例，详细说明同步的过程。 在多道程序环境下，进程是并发进行的，不同进程之间存在着不同的相互制约关系，这就叫进程同步。例一：理发师-顾客问题在一个理发店里有一个理发师，一个理发椅和N个沙发，理发椅是一个临界资源，沙发相当于等待队列。当一个顾客进入理发店占用理发椅时，其他顾客必须在沙发上等待。理发师和顾客必须保持同步，既不允许理发师在没有顾客时理发，也不允许顾客在理发椅被占用时理发。例二：厨师-食堂问题在一个饭店里有一个厨师，一个桌子和N个椅子，桌子是一个临界资源。当一个食客进入饭店占用桌子时，假设桌子已满，其他食客必须等待。厨师和食客必须保持同步，既不允许厨师在没有食客时做饭，也不允许食客在桌子被占满时吃饭。 什么是记录型信号量机制？举实例说明wait操作（P操作）中当信号量值小于0和不小于0时会发生什么？signal操作（V操作）中当信号量值小于等于0和不小于等于0时会发生什么？记录型信号量机制是在整形信号量机制的基础上增加了一个用于代表资源数目的整型变量和一个等待队列（用链表）。实例：理发师-顾客问题在实例中理发椅的数目就相当于资源信号量，当执行P操作时，信号量小于0时，表示资源已经分配完毕，因此进程BLOCK并插入等待队列中；信号量不小于0时（即大于等于0），表示资源还未分配完毕，因此进程继续执行。当执行V操作时，信号量小于0时，表示在等待队列中还有进程在被阻塞，因此应执行唤醒语句；信号量不小于0时（即大于等于0），等于0时，由于0是由-1变来的，所以表示等待队列中还有最后一个进程在被阻塞，因此应执行唤醒语句，大于0时说明等待队列中还没有进程在被阻塞，因此直接释放处理机即可。 解释什么是FIFO？什么是优先级高者优先调度？什么是抢占式调度和非抢占式调度？FIFO即FIRSTINPUTFIRSTOUTPUT，就是先进先出的意思，先执行先进入的进程，该进程完成后再执行下一个进程。优先级高者优先调度：说的是在执行若干个进程或作业的时候选取其中优先级最高的那一个先执行。抢占式调度：这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将以分配给该进程的处理机重新分配给另一个进程。此调度方法遵循一定的原则：1&gt;优先权原则，2&gt;短进程优先原则，3&gt;时间片原则。非抢占式调度：采用这种方式时，一旦处理机分配给某进程后，就让他一直运行下去，决不会因为时钟中断或任何其他原因去抢占当前正在运行程序的处理机，直至该进程完成或发生某事件而被阻塞时，才把处理机分配给别人。 设有两个优先级相同的进程P、Q，进入就绪队列的先后顺序为Q，P，各自运行的程序段如下： P 进程P： 进程Q： P1 Y=1; Q1 X=2; P2 Y=Y+A; Q2 A=X+1; P3 V(S1); Q3 P(S1); P4 A=Y+X; Q4 X=A+Y; P5 P(S2); Q5 V(S2); P6 A=Y+A; Q6 A=X+A; 说明：其中S1、S2为信号量，初值为0；已知X、Y、A为共享变量，A、X、Y的初值为0，若调度程序执行的策略为FIFO（先进先出）问题：请写出进程P、Q的实际执行序列（用代码Pi，Qi表示，i=1，…,6）及变量X、Y、A的中间值和运行结果？12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个优先级相同的进程P、Q，进入就绪队列的先后顺序为Q、P。根据先进先出的原则先进行Q操作。答案：A=20、 X= 10、Y= 4、S1= 0、S2= 0 将上述问题中的“进入就绪队列的先后顺序为Q、P”改为“进入就绪队列的先后顺序为P、Q”，其它不变。12：A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个优先级相同的进程P、Q，进入就绪队列的先后顺序为P、Q，根据先进先出原则先执行P操作。答案： A= 8、X= 4、Y= 1、S1= 0、S2= 0 将上述问题改为“P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P”，按优先级高者优先调度，采用非抢占式调度12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P。根据优先级高者优先调度的原则先进行Q操作。答案：A= 20、X= 10、Y= 4、S1= 0、S2= 0 将上述问题改为“P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P”，按优先级高者优先调度，采用抢占式调度12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个同时进入就绪队列的进程P、Q，进程Q的优先级高于进程P。根据优先级高者优先调度的原则先进行Q操作。答案：A= 15、X= 7、Y=4、S1= 0、S2= 0 将上述问题改为“P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P”，按优先级高者优先调度，采用抢占式调度。12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个同时进入就绪队列的进程P、Q，进程Q的优先级高于进程P。根据优先级高者优先调度的原则先进行Q操作。答案：A= 15、X= 7、Y=4、S1= 0、S2= 0]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储管理]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是虚拟存储器？ 虚拟存储器是由硬件和操作系统自动实现存储信息调度和管理的，是在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理贮存容量大的多，可寻址的“主存储器”。 为什么要引入虚拟存储器？1) 能提高操作系统的内存利用率和系统吞吐量2) 在计算机系统中，主存的容量有一定的限制，不可能大大满足各种用户的需要，而在技术上辅助存储器却可以做的相当大。为了给大作业提供方便，使它们不再承担对主存和辅存的具体分配和管理工作，而由操作系统把主存和辅存统一管理起来。 虚拟存储器的特征？虚拟存储器具有虚拟性、离散性、多次性及强对换性等特征，其中最重要的特征是虚拟性。1&gt; 虚拟性。虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际的内存容量，这是虚拟存储器所表现出的最重要的特征，也是虚拟存储器最重要的目标。2&gt; 离散性。离散性是指内存分配时采用离散分配的方式，没有离散性就不可能实现虚拟存储器。采用连续分配方式，需要将作业装入到连续的内存区域，这样需要连续地一次性申请一部分内存空间，以便将整个作业先后多次装入内存。如果仍然采用连续装入的方式，则无法实现虚拟存储功能，只有采用离散分配方式，才能为它申请内存空间，以避免浪费内存空间。3&gt; 多次性。多次性是指一个作业被分成多次调入内存运行。作业在运行时，只将当前运行的那部分程序和数据装入内存，以后再陆续从外存将需要的部分调入内存。4&gt; 对换性。对换性是指允许在作业运行过程中换进换出。允许将暂时不用的程序和数据从内存调至外存的对换区，以后需要时再从外存调入到内存。 设置你自己计算机上的虚存，并截图说明设置的过程1、右键我的电脑, 选择属性2、选择高级系统设置3、选择高级, 点性能中的设置4、选择高级, 选虚拟内存中的更改5、选择自定义大小, 输入初始大小和最大值, 推荐设置自己内存大小的1.5~ 3倍, 在这输入2048, 点击设置, 根据提示选择确定。 虚存可以建立在分区分配管理的基础上吗？为什么？不可以。在虚拟存储器中，允许将一个作业分多次调入内存。如果采用连续分配方式时，应将作业装入一个连续的内存区域中。为此，需事先为它一次性地申请足够的内存空间，以便将整个作业先后分多次装入内存，这不仅会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟存储器的实现都是建立在离散分配存储管理方式的基础上。 页面置换算法的应用题干：在请求分页存储管理系统中，若为进程分配的物理块为4，开始执行时内存中没有装入任何页面，若进程依次访问的页面号为：3,1,2,6,0,7,4,6,7,2,0,4,3,2,0,7,0,2,6,5,1,5,4,3，请按照下面的页面置换算法完成作业（低物理地址优先）1、OPT页面置换算法1234567891011*为发生缺页中断~为发生页面置换页面被置换顺序 1 3 0 6 4 7 2 0 6缺页率13/241、2、3、4内存为空，页面不在内存中发生缺页5 选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，页面1最长时间不被访问，因此被替换6 同理，页面3最长时间不被访问被替换7 同理，页面0最长时间不被访问被替换8 同理，页面6最长时间不被访问被替换9 同理，页面4最长时间不被访问被替换10 页面0,2,6在后续的访问中没有出现以此按照内存块的顺序（从上往下）依次替换 2、FIFO页面置换算法123456789101112131415161718192021222324252627282930FIFO：(按顺序置换)（1）详细执行过程1.刚开始内存并没有这个作业，所以发生缺页中断一次。页3进入内存。(1次缺页中断) 2.页1进入内存，页1又不在内存，又发生缺页中断一次。(2次缺页中断) 3.页2进入内存，页2又不在内存，缺页中断。(3次缺页中断) 4.页6进入内存，页6又不在内存，发生缺页中断（内存中为3、1、2、6）。 (4次缺页中断) 5.页0进入内存，页0又不在内存，发生缺页中断（内存中为1、2、6、0）。 (5次缺页中断) 6.页7进入内存，页7又不在内存，发生缺页中断（内存中2、6、0、7）(6次缺页中断)7.页4进入内存，页4又不在内存，发生缺页中断（内存中为6、0、7、4）。 (7次缺页中断) 8.页6在内存内不发生中断。9.页7在内存内不发生中断。10.页2进入内存，页2又不在内存，发生缺页中断（内存中为0、7、4、2）。 (8次缺页中断) 11.页0在内存内不发生中断12.页4在内存内不发生中断 13.页3进入内存，页3又不在内存，发生缺页中断（内存中为7、4、2、3）。 (9次缺页中断) 14.页2在内存内不发生中断 15.页0进入内存，页0又不在内存，发生缺页中断（内存中为4、2、3、0）。 (10次缺页中断) 16.页7进入内存，页7又不在内存，发生缺页中断（内存中为2、3、0、7）。 (11次缺页中断)17.页0在内存内不发生中断。18.页2在内存内不发生中断。19.页6进入内存，页6又不在内存，发生缺页中断（内存中为3、0、7、6）。 (12次缺页中断)20.页5进入内存，页5又不在内存，发生缺页中断（内存中为0、7、6、5）。 (13次缺页中断)21.页1进入内存，页1又不在内存，发生缺页中断（内存中为7、6、5、1）。 (14次缺页中断)22.页5在内存内不发生中断。23. 页4进入内存，页4又不在内存，发生缺页中断（内存中6、5、1、4）。 (15次缺页中断)24.页3进入内存，页3又不在内存，发生缺页中断（内存中为5、1、4、3）。 (16次缺页中断)（2）缺页次数：16（3）缺页频率：66.7％（4）置换次数：12（5）被置换出的页面依次为：3,1,2,6,0,7,4,2,3,0,7,6 3、LRU页面置换算法12345678910111213141516171819*为发缺页中断（1）1、2、3、4内存为空，页面不在内存中发生缺页5选择的被淘汰页面将是最近最久未使用的页面，页面3最长时间不被访问，因此被替换6同理，页面1最长时间不被访问被替换7 同理，页面2最长时间不被访问被替换8 同理，页面0最长时间不被访问被替换9 同理，页面4最长时间不被访问被替换10 同理，页面6最长时间不被访问被替换11 同理，页面7最长时间不被访问被替换12 同理，页面4最长时间不被访问被替换13 同理，页面3最长时间不被访问被替换14 同理，页面7最长时间不被访问被替换15 同理，页面0最长时间不被访问被替换16 同理，页面2最长时间不被访问被替换16 同理，页面6最长时间不被访问被替换（2）缺页次数：17（3）缺页频率：70.8%（4）置换次数：13（5）被置换出的页面依次为：3 1 2 0 4 6 7 4 3 7 0 2 6 4、CLOCK页面置换算法12345678910111213红色代表访问位为1，星号表示替换指针的位置缺页次数：15次缺页率：15/24=62.5％置换次数：11次依次被置换出的页号：3,1,2,6,7,4,3,2,0,7,6语言描述：1：进程分配的物理块为4，开始执行时内存中没有装入任何页面，当访问3号页面是，内存中没有，则将页面直接调入内存，根据低物理地址优先，将页面存入第一个物理块，并把访问位置为1。2：访问1号页面时，内存中没有，且内存中还有空位，直接将1号页面放入内存即可，并把访问位置为1。3：当访问0号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查3号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查1号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查2号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查6号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，这时检查到最后一位，发现访问位仍为1，则返回队首去检查第一个页面3，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。4：当访问7号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查1号页面，访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。5：当访问6号页面时，发现内存中存在，则将其访问位置为1，替换指针不动。6：当访问2号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查6号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查0号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查7号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查4号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查6号页面，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。7：当访问3号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查0号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查7号页面，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。8：当访问7号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查4号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查2号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查0号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查3号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查4号页面，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。 5、CLOCK页面置换算法 第5题中进程依次访问的页面号为：其它条件、要求与前面的题干一样7,1,6,4,6,2,3,0,3,1,0,7,6,0,1,3,6,3,0,7,2,0,51234567891011121314151617181920212223242526红色代表访问位为1，星号表示替换指针的位置缺页次数: 14次缺页率: 14/23=60.9%置换次数: 10次依次被置换的页号: 7 1 6 4 2 3 0 1 7 67号页面：进程分配的物理块为4，开始执行的时候没有装入任何页面，当开始访问7号页面的时候，内存中没有该页面号，将页面直接调入内存，低物理地址优先，将页面放入第一个物理块，把访问位置为1.1、6、4号页面：访问1号页面的时候，内存中没有该页面号，且内存中还有空位，将1、6、4号页面放入内存，把访问位置为1，替换指针指向最高地址的物理块。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查4号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查4号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。7号页面：访问7号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查2号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查9号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查3号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。7号页面：访问7号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。5号页面：访问5号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程四]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Arrays;import java.util.Scanner; public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入总人数。"); int num = in.nextInt(); boolean[] man = new boolean[num]; for(int i = 0; i &lt; man.length; i++) &#123; man[i] = true; &#125; int t = 0, len = man.length; while(len &gt; 1) &#123; for(int i = 0; i &lt; man.length; i++) &#123; if(man[i]) &#123; t++; if(t == 3) &#123; t = 0; //重置 man[i] = false; //去掉此人 len--; //人数减 1 &#125; &#125; &#125; &#125; System.out.println("最后的情况：" + Arrays.toString(man));//返回指定数组的字符串表示形式 for(int i = 0; i &lt; man.length; i++) &#123; if(man[i]) //最后留下来的人没有被flase &#123; System.out.println("原来剩下的数：" + (i + 1)); //i + 1 是因为数组从 0 开始 &#125; &#125; &#125;&#125; 写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。123456789101112131415161718import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个字符串"); String str = in.next(); int len = lenOfstr(str); System.out.println(str + " 的长度为 " + len); &#125; private static int lenOfstr(String str) &#123; // TODO Auto-generated method stub return str.length(); &#125;&#125; 编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n(利用指针函数)。1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个整数"); int n = in.nextInt(); if(n % 2 == 0) System.out.println("1/2 + 1/4 + ... + 1/"+ n+ "= " + evenSum(n)); else System.out.println("1 + 1/3 + ... + 1/"+ n+ "= " + oddSum(n)); &#125; private static float oddSum(int n) &#123; // TODO Auto-generated method stub float sum = 0.0f; //记得用 float 或 double 型 for(float i = 1.0f; i &lt;= n;) &#123; // i 用 int 就会把结果也强转为 int sum += 1 / i; i += 2; &#125; return sum; &#125; private static float evenSum(int n) &#123; // TODO Auto-generated method stub float sum = 0.0f; for(float i = 2.0f; i &lt;= n;) &#123; sum += 1 / i; i += 2; &#125; return sum; &#125;&#125; 字符串排序。123456789101112import java.util.Arrays;public class class_name &#123; public static void main(String[] args) &#123; String[] strs = &#123;"abfds1", "advesd2", "dasfdsa3", "cdsaew1", "abbdsa2", "abbdsa"&#125;; //直接用了 java 里有的 sort 方法 Arrays.sort(strs); for(String str : strs) &#123; System.out.println(str); &#125; &#125;&#125; 海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的,问海滩上原来最少有多少个桃子？法一123456789101112131415161718192021222324252627282930313233public class class_name &#123; public static void main(String[] args) &#123; int num = 6; //分五份多一个，至少6个 while( true) &#123; if(func(num)) &#123; break; //找到答案，跳出循环 &#125; num++; &#125; System.out.println("符合要求的最小数是：" + num); &#125; //判断这个数是否能被分5次 static boolean func(long n) &#123; int i = 0; //被分次数0-4共5次 while(i &lt; 5 &amp;&amp; n &gt; 0) &#123; if((n - 1) % 5 == 0) &#123; long temp = (n - 1) / 5 + 1; n -= temp; //减去被一只猴子拿走和丢掉的 i ++; &#125; else return false; &#125; return true; &#125;&#125; 法二123456789101112131415161718192021222324public class class_name &#123; public static void main(String[] args) &#123; int i= 0, m= 1, x= 1; while(true) &#123; m= x; for(i= 0; i&lt; 5; i++) &#123; if((m- 1)% 5== 0) &#123; m= (m- 1)/ 5* 4; //System.out.println(m); &#125;else &#123; break; &#125; &#125; if (i== 5 &amp;&amp; m&gt; 0) &#123; break; &#125; x++; System.out.println(x); &#125; System.out.println("符合要求的最小数是：" + x); &#125;&#125; 809*??=800*??+9*??+1其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。1234567891011121314151617181920public class class_name&#123; public static void main(String[] args) &#123; int number = 0; boolean flag = false; for (int i=10; i&lt;100; i++) &#123; if(809*i == (800*i+9*i)) &#123; if(((8* i)&gt; 10)&amp;&amp; ((8* i) &lt; 100)&amp;&amp; ((9* i) &gt; 99)&amp;&amp; ((9* i)&lt; 1000)) &#123; flag = true; number = i; &#125; &#125; &#125; if (flag) &#123; System.out.println("??是: "+ number); System.out.println("809*"+number+"="+(809*number)); &#125;else &#123; System.out.println("无符合要求的数!"); &#125; &#125; &#125; 求0—7所能组成的奇数个数。12345678910111213141516171819public class class_name &#123; public static void main(String[] args) &#123; long total = 0L; //可以把 76543210 变成 10 或 100 来检查该代码输出结果的正确性 for(int i = 0; i &lt;= 76543210; i++)&#123; if(i % 2 == 0) &#123; continue; &#125; //把其中含有 8 和 9 的数去掉 if((i + "").indexOf("8") != -1 || (i + "").indexOf("9") != -1)&#123; continue; &#125; total++;// System.out.println(i + " "); //输入每一个奇数 &#125; System.out.println("共有 " + total + "个奇数"); &#125;&#125; 一个偶数总能表示为两个素数之和。12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个大于等于4偶数。"); int num = in.nextInt(); if(num &lt; 4) System.out.println("输入错误！"); if(num % 2 == 0) &#123; int i , j; for(i = 2; i &lt;= num /2; i++) &#123; if(isPrime(i)) &#123; j = num - i; if(isPrime(j)) System.out.println(num + " = " + i + " + " + j); &#125; &#125; &#125; &#125; public static boolean isPrime(int k) &#123; for(int i = 2; i &lt; Math.sqrt(k); i++) &#123; if(k % i == 0) return false; &#125; return true; &#125;&#125; 读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的＊。12345678910111213141516171819import java.util.Random;public class class_name &#123; public static void main(String[] args) &#123; Random rm = new Random(); for(int n = 0; n &lt; 7; n++) &#123; int i = rm.nextInt(50); //50以内的随机数 System.out.print(i + " : "); for(int m = 0; m &lt; i; m++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; 某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5,然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。123456789101112131415161718192021222324252627282930import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个四位整数"); int num = in.nextInt(); System.out.println("加密后数据为：" + encrypt(num)); &#125; private static int encrypt(int num) &#123; // TODO Auto-generated method stub int a, b, c, d; //从左到右分别为第一到第四位 //分解 a = num / 1000; b = (num / 100) % 10; c = (num / 10) % 10; d = num % 10; //取余 a = (a + 5) % 10; b = (b + 5) % 10; c = (c + 5) % 10; d = (d + 5) % 10; //交换,其实这里只要换一下重组会整数的顺序就行了 num = d *1000 + c * 100 + b * 10 + a; return num; &#125;&#125; 计算字符串中子串出现的次数。123456789101112131415161718192021222324252627282930import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern; public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个字符串"); String sen = in.next(); System.out.println("请输入要查找的子字符串"); String str = in.next(); /* //一般方法 int count = 0; int start = 0; while (sen.indexOf(str, start) &gt;= 0 &amp;&amp; start &lt; sen.length()) &#123; count++; start = sen.indexOf(str, start) + str.length(); &#125;*/ //正则表达式 第二个参数为忽略大小写 Pattern p = Pattern.compile(str, Pattern.CASE_INSENSITIVE); Matcher m = p.matcher(sen); int count = 0; while(m.find())&#123; count ++; &#125; System.out.println(str + "在" + sen + "出现的次数为" + count); &#125;&#125; 有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，将原有的数据和计算出的平均分数存放在磁盘文件”stud”中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.util.Scanner; public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String[][] stu = new String[2][6]; //为了快速测试，5个同学变成了2个同学 for(int i = 0; i &lt; 2; i++)&#123; System.out.printf("请输入第%d个学生的姓名", i + 1); stu[i][0] = in.next(); System.out.printf("请输入第%d个学生第学号", i + 1); stu[i][1] = in.next(); for(int j = 2; j &lt; 5; j++)&#123; System.out.printf("请输入该同学的第%d门课程成绩", j - 1); stu[i][j] = in.next(); &#125; &#125; for(int i = 0; i &lt; 2; i++)&#123; int sum = 0; for(int j = 2; j &lt; 5; j++)&#123; sum += Integer.parseInt(stu[i][j]); &#125; stu[i][5] = Float.toString((float)sum / 3); &#125; String s; try&#123; File file = new File("E:/home/stu"); //要存放的路径 if(file.exists())&#123; System.out.println("文件存在"); &#125; else&#123; System.out.println("文件不存在，正在创建...."); file.createNewFile(); &#125; BufferedWriter output = new BufferedWriter(new FileWriter(file)); for(int i = 0; i &lt; 2; i++)&#123; for(int j = 0; j &lt; 6; j++)&#123; s = stu[i][j] + "\r\t"; output.write(s);// System.out.print(stu[i][j]); //被注释的这三行用来格式化输出到控制台（屏幕）// System.out.printf("\t", ""); &#125;// System.out.println(); &#125; output.close(); System.out.println("数据已写入"); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程三]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E4%B8%89%2F</url>
    <content type="text"><![CDATA[求1+2!+3!+…+20!的和 123456789101112131415161718192021222324252627import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("你想计算到哪个数的阶乘的和"); int num = in.nextInt(); long temp = 0L; long sum = 0L; for(int i = 1; i &lt;= num; i++)&#123; temp = recursion(i); sum += temp; &#125; System.out.println("计算到" + num + "的阶乘和是 " + sum); &#125; //计算某个数 num 的阶乘 private static long recursion(int num) &#123; // TODO Auto-generated method stub if(num &gt; 1)&#123; return num * recursion(num - 1); &#125; return 1; &#125;&#125; 给一个不多于5位的正整数，要求: 一、求它是几位数；二、逆序打印出各位数字123456789101112131415161718192021import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个不多于5位的整数"); int num = in.nextInt(); int n = 1; System.out.print("这个数的逆序为："); while(num / 10 &gt; 0)&#123; n++; int tmp = num % 10; System.out.print(tmp); num /= 10; &#125; System.out.println(num); System.out.println("这个数共有" + n + "位数"); &#125;&#125; 请输入星期几的第一个字母来判断以下是星期几，如果第一个字母一样，则继续判断第二个字符。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); char firstletter, secondletter; //存放第一第二个字母 System.out.println("请输入第一字母"); String letter = in.next(); firstletter = letter.charAt(0); switch(firstletter)&#123; case 'm': case 'M': System.out.println("是星期一");break; case 'w': case 'W': System.out.println("是星期三");break; case 'f': case 'F': System.out.println("是星期五");break; case 't': case 'T': System.out.println("仅由该字母无法判断出星期几，请输入第二个字母"); letter = in.next(); secondletter = letter.charAt(0); if(secondletter == 'u' || secondletter == 'U')&#123; System.out.println("是星期二"); break; &#125;else if(secondletter == 'h' || secondletter == 'H')&#123; System.out.println("是星期四"); break; &#125;else&#123; System.out.println("输入错误"); &#125; case 's': case 'S': System.out.println("仅由该字母无法判断出星期几，请输入第二个字母"); letter = in.next(); secondletter = letter.charAt(0); if(secondletter == 'a' || secondletter == 'A')&#123; System.out.println("是星期六"); break; &#125;else if(secondletter == 'u' || secondletter == 'U')&#123; System.out.println("是星期天"); break; &#125;else&#123; System.out.println("输入错误"); &#125; &#125; &#125;&#125; 求一个3*3矩阵对角线元素之和123456789101112131415161718192021222324252627282930import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); //输入数据 int[][] mat = new int[3][3]; for(int i = 1; i &lt;= 3; i++)&#123; for(int j = 1; j &lt;= 3; j++)&#123; System.out.println("请输入第" + i + "行第" + j + "列的整数"); mat[i -1][j - 1] = in.nextInt(); &#125; &#125; //显示数据 for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; 3; j++) System.out.printf("%d\t",mat[i][j]); // \t是制表符 System.out.println(); &#125; //计算对角线元素和 //从左上至右下的数归为主对角线，从左下至右上的数归为副对角线。 int sum1 = mat[0][0] + mat[1][1] + mat[2][2]; int sum2 = mat[2][0] + mat[1][1] + mat[0][2]; System.out.println("主对角线上元素和为 " + sum1); System.out.println("副对角线上元素和为 " + sum2); &#125;&#125; 有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int[] ary = &#123;10, 15, 20, 25, 30, 35, 40, 45, 50&#125;; int[] changedAry = new int[ary.length + 1]; System.out.print("初始数组："); for(int i = 0; i &lt; ary.length; i++)&#123; changedAry[i] = ary[i]; System.out.print(ary[i] + " "); &#125; System.out.println(); System.out.println("请输入一个整数"); int num = in.nextInt(); System.out.print("插入数字后的数组："); insort(changedAry, num); &#125; private static void insort(int[] changedAry, int num) &#123; // TODO Auto-generated method stub for(int i = 0; i &lt; changedAry.length; i++)&#123; if(num &lt; changedAry[i])&#123; //找到插入位置 for(int j = changedAry.length - 1; j &gt; i;j--)&#123; changedAry[j] = changedAry[j - 1]; //待插入位置及以后的数后退一个位置 &#125; changedAry[i] = num; break; &#125; &#125; if(num &gt; changedAry[changedAry.length - 1]) //待插入数大于所有数 changedAry[changedAry.length - 1] = num; for(int k = 0; k &lt; changedAry.length; k++) System.out.print(changedAry[k] + " "); &#125;&#125; 将一个数组逆序输出1234567891011121314151617public class class_name &#123; public static void main(String[] args) &#123; //这里直接初始化一个数组 int[] ary = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// String[] ary = &#123;"i", "love", "you"&#125;; //字符（串）数组也可以 System.out.print("数组初始顺序为："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); //换行 System.out.print("数组的逆序为："); for(int i = ary.length - 1; i &gt;= 0; i--) System.out.print(ary[i] + " "); System.out.println(); &#125;&#125; 取一个整数a从右端开始的4~7位。123456789101112import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个大于等于 7 位的整数"); long sum = in.nextLong(); Long sum1 = new Long(sum); //Long是 long 的包装类 String sum2 = sum1.toString(); System.out.println(sum2.substring(sum2.length() - 7, sum2.length() - 3)); &#125; // substring 截取两参数间的字符串&#125; 打印出杨辉三角形123456789101112131415161718192021222324252627public class class_name &#123; public static void main(String[] args) &#123; int i, j; int[][] num = new int[10][10]; for (i = 0; i &lt; 10; i++) &#123;// 把所有的 1 放入数组 num[i][0] = 1; num[i][i] = 1; &#125; for (i = 2; i &lt; 10; i++) &#123;// 计算数组的其他数 for (j = 1; j &lt; i; j++) &#123; num[i][j] = num[i - 1][j - 1] + num[i - 1][j]; &#125; &#125; for (i = 0; i &lt; 10; i++) &#123; // k &lt; 4 倍的空格是因为输出每个数字时用了 4 个占位符 for (int k = 0; k &lt; 4 * (10 - i) / 2; k++) // 输出空格 System.out.printf(" "); for (j = 0; j &lt;= i; j++) &#123; System.out.printf("%4d", num[i][j]); // 每个数字 4 个占位符 &#125; System.out.println(); &#125; &#125;&#125; 输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入数组长度"); int arylen = in.nextInt(); int[] num = new int[arylen]; for(int i = 0; i &lt; num.length; i++) &#123; System.out.printf("请输入第 %d 个数：", i + 1); num[i] = in.nextInt(); &#125; System.out.println("变化前的数组："); outArray(num); //循环找出最大值、最小值 int max = num[0]; int min = num[0]; for(int i = 1; i &lt; num.length; i++) &#123; if(num[i] &gt; max) max = num[i]; if(num[i] &lt; min) min = num[i]; &#125; //替换 num[0] = max; num[num.length - 1] = min; System.out.println("变化后的数组："); outArray(num); &#125; private static void outArray(int[] num) &#123; // TODO Auto-generated method stub for(int i = 0; i &lt; num.length; i++) System.out.print(num[i] + " "); System.out.println(); &#125;&#125; 有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数。1234567891011121314151617181920212223242526272829import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int[] num = &#123;14, 32, 5, 42, 36, 80&#125;; int[] temp = new int[num.length]; System.out.println("移动前的数组："); for(int i = 0; i &lt; num.length; i++)&#123; temp[i] = num[i]; System.out.print(num[i] + " "); &#125; System.out.println(); System.out.println("需要向后移动几个位置"); int m = in.nextInt(); for(int i = 0; i &lt; num.length; i++)&#123; int t = (i + m) % num.length; num[t] = temp[i]; //这行的 t 和 i 互换一下就变成了（1） &#125; System.out.println("移动后的数组："); for(int i: num) System.out.print(i + " "); System.out.println(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程二]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[【程序11】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ 12345678910111213141516171819202122public class class_name &#123; public static void main(String[] args) &#123; int i, j, k; //分别代表个、十、百位 int num; //用来输出符合要求的三位数 int count = 0; //用来统计符合要求的三位数有多少个 System.out.println("符合要求的三位数有："); for(i = 1; i &lt;= 4; i++)&#123; for(j = 1; j &lt;= 4; j++)&#123; if(i != j) //提前把有重复的部分情况过滤掉，减少运行次数，优化性能 for(k = 1; k &lt;= 4; k++)&#123; if(i != k &amp;&amp; j != k)&#123; num = i + j * 10 + k * 100; System.out.println(num); count++; &#125; &#125; &#125; &#125; System.out.println("符合要求的三位数共有" + count + "个"); &#125;&#125; 【程序12】一个整数，它加上100后是一个完全平方数，再加上168又是一个完平方数，请问该数是多少？1234567891011121314151617181920public class class_name &#123; public static void main(String[] args) &#123; long i, j, k; for(i = 1; i &lt; 100000; i ++) &#123; for(j = 0; j &lt; 1000; j++) &#123; if(j * j == i + 100) &#123; for(k = j; k &lt; 1000; k++) &#123; if(k * k == i + 268) System.out.println(i); &#125; &#125; &#125; &#125; &#125;&#125; 【程序13】输入年月日，判断这一天是这一年的第几天？1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入年份。"); int year = in.nextInt(); System.out.println("请输入月份。"); int month = in.nextInt(); System.out.println("请输入日期。"); int day = in.nextInt(); int sum = 0;; switch(month - 1) &#123; case 0: sum = 0; break; case 1: sum = 31; break; case 2: sum = 59; break; case 3: sum = 90; break; case 4: sum = 120; break; case 5: sum = 151; break; case 6: sum = 181; break; case 7: sum = 212; break; case 8: sum = 243; break; case 9: sum = 273; break; case 10: sum = 304; break; case 11: sum = 334; break; &#125; if((month &gt; 2)&amp;&amp;isLeap(year)) System.out.printf("这天是这年第%d天。", sum + day + 1); else System.out.printf("这天是这年第%d天。", sum + day); &#125; private static boolean isLeap(int year) &#123; if(((year % 100 != 0)&amp;&amp;(year % 4 == 0)) || (year % 400 == 0)) return true; else return false; &#125;&#125; 【程序14】输入三个整数x,y,z，请把这三个数由小到大输出。1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入三个整数"); System.out.println("请输入第1个整数"); int a = in.nextInt(); System.out.println("请输入第2个整数"); int b = in.nextInt(); System.out.println("请输入第3个整数"); int c = in.nextInt(); System.out.print("从小到大的顺序为："); if(a &lt; b)&#123; if(b &lt; c)&#123; System.out.printf("%d&lt;%d&lt;%d", a, b, c); &#125;else&#123; if(a &lt; c) System.out.printf("%d&lt;%d&lt;%d", a, c, b); else System.out.printf("%d&lt;%d&lt;%d", c, a, b); &#125; &#125;else&#123; if(c &lt; b)&#123; System.out.printf("%d&lt;%d&lt;%d", c, b, a); &#125;else&#123; if(c &lt; a) System.out.printf("%d&lt;%d&lt;%d", b, c, a); else System.out.printf("%d&lt;%d&lt;%d", b, a, c); &#125; &#125; &#125;&#125; 【程序15】排序算法以下代码只写了一个输出，所以当你要测试哪个排序算法时记得把调用另外三个排序算法的那几行代码注释掉。如果你想同时测试这四个排序算法，可以在每行调用排序方法的后面加入输出语句就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class class_name &#123; public static void main(String[] args) &#123; int[] num = &#123;23, 64, 15, 3, 93, 30, 51, 28, 49, 66&#125;; System.out.println("排序前： "); showArray(num); System.out.println(); //换行，控制格式 num = BubbleSort(num); // num = ChoiceSort(num); // num = InsertSort(num); // num = QuickSort(num, 0, num.length - 1); System.out.println("排序后："); showArray(num); System.out.println(); //换行，控制格式 &#125; private static void showArray(int[] num) &#123; for(int i = 0; i &lt; num.length; i++) &#123; System.out.print(num[i] + " "); &#125; &#125; private static int[] BubbleSort(int[] num) &#123; for(int i = 0; i &lt; num.length; i++) &#123; for(int j = 0; j &lt; num.length - 1; j++) &#123; if(num[j] &gt; num[j + 1]) &#123; int temp = num[j]; num[j] = num[j + 1]; num[j +1] = temp; &#125; &#125; &#125; return num; &#125; //插入排序 private static int[] InsertSort(int[] num) &#123; for(int i = 1; i &lt; num.length; i++) &#123; int temp = num[i]; for(int j = i; j &gt; 0; j--) &#123; if(num[j - 1] &gt; temp) &#123; num[j] = num[j - 1]; num[j - 1] = temp; &#125; &#125; &#125; return num; &#125; //优化后的选择排序 private static int[] ChoiceSort(int[] num) &#123; for (int i = 0; i &lt; 9; i++) &#123; int min = i; int j; for (j = i + 1; j &lt; num.length; j++) &#123; if (num[min] &gt; num[j]) &#123; min = j; &#125; &#125; if (min != i) &#123; int temp = num[i]; num[i] = num[min]; num[min] = temp; &#125; &#125; return num; &#125; /* //选择排序 private static int[] ChoiceSort(int[] num) &#123; for(int i = 0; i &lt; num.length - 1; i++) &#123; for(int j = i + 1; j &lt; num.length; j++) &#123; if(num[i] &gt; num[j]) &#123; int temp = num[i]; num[i] = num[j]; num[j] = temp; &#125; &#125; &#125; return num; &#125; */ // 快速排序 private static int[] QuickSort(int[] num, int i, int j) &#123; // TODO Auto-generated method stub if(i &lt; j) &#123; int middle = portition(num, i, j); QuickSort(num, i, middle - 1); QuickSort(num, middle + 1, j); &#125; return num; &#125; private static int portition(int[] num, int low, int high) &#123; int i = low, j = high; int temp = num[i]; if (low &lt; high) &#123; while (i &lt; j) &#123; while ((num[j] &gt;= temp) &amp;&amp; (i &lt; j)) &#123; j--; &#125; num[i] = num[j]; while ((num[i] &lt;= temp) &amp;&amp; (i &lt; j)) &#123; i++; &#125; num[j] = num[i]; &#125; num[i] = temp; &#125; return i; &#125; &#125; 【程序16】输出9*9口诀12345678910111213141516public class class_name &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt; 10; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; int total = 0; total = i * j; System.out.printf("%d * %d = %-5d", j, i, total); &#125; System.out.println(); &#125; &#125;&#125; 【程序17】猴子吃桃问题猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下 的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。12345678910111213public class class_name &#123; public static void main(String[] args) &#123; int total = 1; //day = 1的时候，算出来的total其实是第9天有的桃子 //day = 9的时候，算出来的total就是第1天的桃子 for(int day = 1; day &lt; 10; day++)&#123; total = 2 * (total + 1); &#125; System.out.println("一开始共有 " + total + " 桃子"); &#125;&#125; 【程序18】乒乓球比赛名单两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。1234567891011121314151617public class class_name &#123; public static void main(String[] args) &#123; char i, j, k; //i,j,k分别是a,b,c的对手 for(i = 'X'; i &lt;= 'Z'; i++)&#123; for(j = 'X'; j &lt;= 'Z'; j++)&#123; if(i != j)&#123; for(k = 'X'; k &lt; 'Z'; k++)&#123; if(i != k &amp;&amp; j != k)&#123; if(i != 'X' &amp;&amp; k != 'X' &amp;&amp; k != 'Z') System.out.printf("a -- %c\nb -- %c\nc -- %c", i, j, k); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 【程序19】打印图案打印出如下图案（菱形）1234567891011121314151617181920212223public class class_name &#123; public static void main(String[] args) &#123; for(int i = 0; i &lt; 4; i++)&#123; //1到4行 for(int j = 1; j &lt;= (6 - 2 * i) / 2; j++)&#123; //每行前面的空格数 System.out.print(" "); &#125; for(int k = 1; k &lt;= 2 * i + 1; k++)&#123; System.out.print("*"); //每行的*号 &#125; System.out.println(); //换行 &#125; //下半部分 for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; i + 1; j++)&#123; System.out.print(" "); &#125; for(int k = 0; k &lt; 5 - 2 * i; k++)&#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; 【程序20】有一分数序列: 2/1，3/2，5/3，8/5，13/8…求这个数列的前20项之和。123456789101112131415public class class_name &#123; public static void main(String[] args) &#123; float i = 2.0f, j = 1.0f; //i为分子，j为分母 float num = 2.0f; //num是分数，sum是分数的和 float sum = 2.0f; for(int m = 1; m &lt; 20; m++)&#123; //m = 1时，num已经是第2个加数了，所以m &lt; 20 i = i + j; j = i - j; //变化前的 i 赋值给 j num = i / j; sum += num; &#125; System.out.println("前20个分数的和为 " + sum); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程一]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[【程序1】兔子总数问题有一对兔子，从出生后第3个月起 每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？123456789101112131415161718192021import java.util.Scanner;public class tuzi &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("你想知道第几个月的兔子的数量"); int month = in.nextInt(); //使用输入流对象，调用nextInt()方法输入一个整数到month中 int[] mon = new int[month]; if(month &lt; 3)&#123; System.out.println("第" + month + "个月有 1 对兔子，共 2 只"); &#125;else &#123; for(int i = 2; i &lt; month; i++)&#123; mon[0] = mon[1] = 1; mon[i] = mon[i - 1] + mon[i - 2]; System.out.printf("第 %d 个月有 %d 对兔子，共 %d 只兔子\n", i + 1, mon[i], 2 * mon[i]); &#125; &#125; &#125;&#125; 【程序2】判断两数之间素数个数判断101-200之间有多少个素数，并输出所有素数。12345678910111213141516171819public class class_name &#123; public static void main(String[] args) &#123; System.out.print("101--200中的素数有："); for(int i = 101; i &lt;= 200; i++)&#123; if(isPrime(i)) System.out.print(" " + i); &#125; &#125; //isPrime方法用来判断一个数是否是素数 private static boolean isPrime(int i) &#123; // TODO Auto-generated method stub for(int j = 2; j &lt;= Math.sqrt(i); j++)&#123; if(i % j == 0) return false; &#125; return true; &#125;&#125; 【程序3】打印”水仙花数”所谓”水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如: 153是一个”水仙花数”，因为153=1的三次方+5的三次方+3的三次方。1234567891011121314151617181920212223public class class_name &#123; public static void main(String[] args) &#123; System.out.print("水仙花数有："); for(int num = 100; num &lt; 1000; num++)&#123; if(isNarcissisticNum(num)) System.out.println(" " + num); &#125; &#125; //一个判断正整数是否为水仙花数的方法 private static boolean isNarcissisticNum(int num) &#123; // TODO Auto-generated method stub int a = num / 100; //分离出百位 a int b = (num / 10) % 10; //分离出十位 b int c = num % 10; //分离出个位 c int sum = a * a * a + b * b * b + c * c * c; if(sum == num) return true; else return false; &#125;&#125; 【程序4】正整数分解质因数将一个正整数分解质因数。例如: 输入90，打印出90=2*3*3*5。(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。(2)如果n&gt;k，但n能被k整除，则打印出k的值，并用n除以k的商，作为新的正整数n，重复执行第一步。(3)如果n不能被k整除，则用k+1作为k的值，重复执行第一步。123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println("请输入一个大于 3 的正整数"); int num = input.nextInt(); System.out.print(num + "的素因数:"); factor(num); &#125; private static void factor(int num) &#123; // TODO Auto-generated method stub for(int i = 2; i &lt;= Math.sqrt(num); i++)&#123; if(num % i == 0)&#123; System.out.print(i + " * "); if(isPrime(num / i))&#123; System.out.println(num / i); &#125; else factor(num / i); break; &#125; &#125; &#125; private static boolean isPrime(int i) &#123; // TODO Auto-generated method stub for(int j = 2; j &lt;= Math.sqrt(i); j++)&#123; if(i % j == 0) return false; &#125; return true; &#125;&#125; 【程序5】条件运算符的嵌套利用条件运算符的嵌套来完成此题: 学习成绩&gt;=90分的同学用A表示，60-89分之间用B表示，60分以下的用C表示。1234567891011121314151617181920import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入你的分数"); int score = in.nextInt(); if(score &gt;= 90)&#123; System.out.println("A 恭喜"); &#125; else if(score &gt;= 60)&#123; System.out.println("B 不错"); &#125; else&#123; System.out.println("C 加油"); &#125; &#125;&#125; 【程序6】最大公约数和最小公倍数输入两个正整数m和n，求其最大公约数和最小公倍数。1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入第一个数"); int a = in.nextInt(); System.out.println("请输入第二个数"); int b = in.nextInt(); System.out.println("这两个数的最大公约数是 " + MaxCommonDivisor(a, b)); System.out.println("这两个数的最小公倍数是 " + MinCommonMultiple(a, b)); &#125; private static int MaxCommonDivisor(int a, int b) &#123; // TODO Auto-generated method stub if(a &lt; b)&#123; int temp = a; a = b; b = temp; &#125; while(a % b != 0)&#123; int temp = a % b; a = b; b = temp; &#125; return b; &#125; private static int MinCommonMultiple(int a, int b) &#123; // TODO Auto-generated method stub return a * b / MaxCommonDivisor(a, b); &#125;&#125; 【程序7】统计英文字母、空格、数字和其它字符个数输入一行字符，分别统计出其中英文字母、空格、数字和其它字符个数。1234567891011121314151617181920212223242526272829import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("Input one sentance."); String s = in.nextLine(); int letter = 0, symbol = 0, space = 0, number = 0; char[] strArray = s.toCharArray(); for (int i = 0; i &lt; strArray.length; i++) &#123; char c = strArray[i]; if(('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z')) letter++; else if(48 &lt;= c &amp;&amp; c &lt;= 57) //注意！数字0-9的ASCII码是48-57 number++; else if(c == ' ') space++; else symbol++; &#125; System.out.println("This sentance have " + letter + " letters, "); System.out.println("have "+ number + " numbers, "); System.out.println("have " + space + " spaces, " + "and " + symbol + " symbols."); &#125;&#125; 【程序8】求s=a+aa+aaa+aaaa+…的值求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222(此时共有4个数相加)，几个数相加有键盘控制。1234567891011121314151617181920import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println("请输入相加的基数"); int n = input.nextInt(); System.out.println("请输入要相加的个数"); int i = input.nextInt(); long total = 0L; long temp = n; for(int j = 0; j &lt; i; j++)&#123; total += temp; temp = temp * 10 + n; &#125; System.out.println("和为" + total); &#125;&#125; 【程序9】完数一个数如果恰好等于它的因子之和，这个数就称为”完数”。例如: 6=1+2+3。编程: 找出1000以内的所有完数。12345678910111213141516public class class_name &#123; public static void main(String[] args) &#123; System.out.println("1000以内的完数有："); for(int i = 1; i &lt; 1000; i++)&#123; int sum= 0; for(int j= 1; j&lt; i; j++) &#123; if (i% j== 0) &#123; sum+= j; &#125; &#125; if (sum== i) &#123; System.out.println(i); &#125; &#125; &#125;&#125; 【程序10】球落地一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第10次落地时，共经过多少米？第10次反弹多高？1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入原始高度。"); double s = in.nextDouble(); System.out.println("要求第几次落地后的距离。"); int n = in.nextInt(); double total = s; System.out.printf("第%d次落地后共走的距离是：" , n); if(n == 1) &#123; System.out.println(total); System.out.printf("第%d次反弹的距离是%f。", n, s / 2); &#125; else &#123; for(int i = 1; i &lt; n; i++) &#123; s = s / 2; total += 2 * s; //一上一下共两倍的弹跳距离 &#125; System.out.print(total); System.out.println(); System.out.printf("第%d次反弹的距离是%f。", n, s / 2); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse安装JBoss Tools]]></title>
    <url>%2F2018%2F03%2F04%2Feclipse%E5%AE%89%E8%A3%85JBoss-Tools%2F</url>
    <content type="text"><![CDATA[进入JBoss Tools插件下载页面，点击Download。style的eclipse版本是4.7.2，选择相对应版本的插件下载。点击Update Site，复制对应的更新地址。打开eclipse，点击Help–&gt;Install New Software。进入插件安装界面，点击Add。输入name和url。确定后选择Select All，点击Next。]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP自动提示]]></title>
    <url>%2F2018%2F02%2F26%2FJSP%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[1、Window–&gt;Preferences–&gt;Java–&gt;Editor–&gt;Content Assist修改Auto activation triggers for Java的值为:1.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 2、JavaScript–&gt;Editor–&gt;Content Assist修改Auto activation triggers for JavaScript的值为:1.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3、Web–&gt;Html Files–&gt;Editor–&gt;Content Assist修改Prompt when these characters are inserted的值为:1&lt;=.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp编码]]></title>
    <url>%2F2018%2F02%2F25%2Fjsp%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在eclipse中修改jsp页面的默认编码。1、Window–&gt;Preferences。2、点击Web，选择JSP Files，将右边的Encoding选为UTF-8。3、新建一个jsp页面，页面编码就是修改后的。]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse Java EE配置Tomcat]]></title>
    <url>%2F2018%2F02%2F25%2Feclipse%E9%85%8D%E7%BD%AETomcat%2F</url>
    <content type="text"><![CDATA[配置Tomcat1、打开eclipse，单击Window菜单，选择下方的Preferences。2、单击Server选项，选择下方的Runtime Environments。3、点击Add，添加 Tomcat。4、点击Next， 选中自己安装的Tomcat路径。5、点击Finish完成。 建立一个Web应用1、File–&gt;New–&gt;Dynamic Web Project。2、创建一个Dynamic Web Project。3、连续点击两下Next。4、点击Finish完成。 让Tomcat服务器显示在控制台上，将Web应用部署到Tomcat1、Window–&gt;Show View–&gt;Servers2、右键Server面板中的Add and Remove。3、添加项目到Configured，选中项目并点击Add或者双击都可以添加到右边。4、点击Finish完成。返回下方的Servers面板，右键单击该面板中的Tomcat v9.0 Server at localhost节点，在弹出的快捷菜单中单击Start即可启动指定的Web服务器。如果此时直接访问http://localhost:8080/test_first ,会发现报404的错误。这是因为我们没有添加主页，下面添加主页(index.jsp)的内容。5、右键WebContent–&gt;New–&gt;JSP File。1注意: Web资源一定要在WebContent目录下添加。 此时，再一次来访问http://localhost:8080/test_first ，效果如下:]]></content>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Tomcat]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%AE%89%E8%A3%85Tomcat%2F</url>
    <content type="text"><![CDATA[Tomcat是Apache软件基金会的Jakarta项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成，成为目前比较流行的Web应用服务器。一、下载登录http://tomcat.apache.org 站点，下载合适的Tomcat版本。单击左边的Download下的Tomcat 9 超链接，在打开的新页面中，下载Tomcat的最新版9.0.5版的所有安装包。选择合适的版本下载即可。style选择下载的是64位的Windows下的64-bit Windows zip(pgp, md5, sha1, sha512)安装包。把下载得到的apache-tomcat-9.0.5-windows-x64.zip文件解压到合适的位置。可以看到如图的文件结构。style将其解压到了F:\apache-tomcat-9.0.5目录。各个文件目录的说明如下所示。1234567/bin: 存放Windows或Linux平台上启动和关闭Tomcat的脚本文件。/conf: 存放Tomcat服务器的各种全局配置文件，其中，最重要的是server.xml和web.xml。/lib: 存放Tomcat服务器所需的各种JAR文件。/logs: 存放Tomcat执行时的日志文件。/temp: 存放Web运行过程中生成的临时文件。/webapps: Tomcat的主要Web发布目录，默认情况下把Web应用文件放于此目录。/work: 存放JSP编译后产生的class文件。 二、Tomcat的配置要想运行Tomcat，还需要配置环境变量以及配置管理员。(1) 添加环境变量，如图所示，在”环境变量”里新建系统变量，变量名为CATALINA_HOME，变量值为F:\apache-tomcat-9.0.5(Tomcat解压到的目录)。(2) 如图所示，在系统变量Path的最后面添加:%CATALINA_HOME%\lib;%CATALINA_HOME%\lib\servlet-api.jar;%CATALINA_HOME%\lib\jsp-api.jar。注意不同系统变量之间的分号一定是英文的分号。(3) 如图所示，为Tomcat 9.0的管理员的配置，进入F:\apache-tomcat-9.0.5下的conf目录，编辑tomcat-users.xml,找到最后的1234567&lt;!-- &lt;role rolename="tomcat"/&gt; &lt;role rolename="role1"/&gt; &lt;user username="tomcat" password="&lt;must-be-changed&gt;" roles="tomcat"/&gt; &lt;user username="both" password="&lt;must-be-changed&gt;" roles="tomcat,role1"/&gt; &lt;user username="role1" password="&lt;must-be-changed&gt;" roles="role1"/&gt;--&gt; 在上面这段后面添加上1234&lt;role rolename="manager-gui"/&gt;&lt;role rolename="admin-gui"/&gt;&lt;user username="admin" password="123" roles="admin-gui"/&gt;&lt;user username="admin" password="123" roles="manager-gui"/&gt; 保存并关闭tomcat-users.xml。(4) 进入Tomcat目录下的bin目录，双击startup.bat启动Tomcat，在命令行窗口会显示出英文提示，如图所示。(5) 在浏览器中输入http://localhost:8080/ 出现Tomcat的欢迎页面就说明配置成功了，如图所示。(6) 单机右上角的Manager App按钮，输入上面配置的用户名和密码，就可以进入管理页面，如图所示。(7) 至此，Tomcat安装配置完成。]]></content>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py之计算器]]></title>
    <url>%2F2018%2F01%2F23%2Fpy%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[某大佬的作品，在此学习一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#!usr/bin/python# -*- coding: UTF-8 -*-import re,os,sys'''计算这表达式的值：1 - 2 * ((60-30 +(-40.0/5) * (9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 )) - (-4*3)/ (16-3*2)))'''def format_mark(express): ''' 表达式替换过程中可能出现一些组合符号， 机器无法辨别，此函数负责处理这些组合符号 ''' express = express.replace('+-', '-') express = express.replace('-+', '-') express = express.replace('++', '+') express = express.replace('--', '+') express = express.replace('*+', '*') express = express.replace('+*', '*') express = express.replace('+/', '/') express = express.replace('/+', '/') return expressdef com_jiajian(express): ''' :param express: :return: ''' expr = express sub_expr = re.search(r"\-?\d+\.?\d*[\+\-]\d+\.?\d*", expr) #print (sub_expr) #re.search()函数将对整个字符串进行搜索，并返回第一个匹配的字符串的match对象。 if not sub_expr: return expr else: sub_expr2 = sub_expr.group() #group()用来提出分组截获的字符串，（）用来分组 # print('sub_expr1',sub_expr1,'19行结果express:',div_express) if len(sub_expr2.split('+')) &gt; 1: #通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 n1, n2 = sub_expr2.split('+') result = float(n1)+float(n2) else: n1, n2 = sub_expr2.split('-') result = float(n1) - float(n2) re_sub_expr = re.sub(r"\-?\d+\.?\d*[\+\-]\d+\.?\d*", str(result), expr, count=1) # 反复调用除法 print('加减运算：',re_sub_expr) bb = com_jiajian(str(re_sub_expr)) return bbdef com_chengchu(expr_div): ''' :param expr_div: :return: ''' expr=expr_div sub_expr = re.search(r"\d+\.?\d*[\/\*]\-?\d+\.?\d*",expr) if not sub_expr: return expr else: sub_expr2 = sub_expr.group() if len(sub_expr2.split('/')) &gt; 1: n1, n2 = sub_expr2.split('/') result = float(n1)/float(n2) if len(sub_expr2.split('*')) &gt; 1: n1, n2 = sub_expr2.split('*') result = float(n1)*float(n2) else: #只计算乘除，加减直接pass，放入加减函数执行 pass re_sub_expr=re.sub(r"\d+\.?\d*[\/\*]\-?\d+\.?\d*",str(result),expr,count=1) #反复调用除法 print('乘除运算：',re_sub_expr) bb=com_chengchu(format_mark(re_sub_expr)) return bbdef compute(express): express = com_chengchu(format_mark(express)) express = com_jiajian(format_mark(express)) return expressdef delkuohao(express): #检测表达式是否存在括号，如果存在就去括号，否则直接执行 res=re.compile(r'[()]') #将一个字符串编译为字节代码。 sub_expr1 = re.search('(\([\+\-\*\/\.0-9]+\))', express) if not sub_expr1: return express else: sub_expr1=sub_expr1.group() #delkuohao(express) #匹配括号，将计算结果替换到表达式 sub_expr2=sub_expr1[1:len(sub_expr1)-1] sub_expr3=compute(sub_expr2) sub_expr3 = re.sub('(\([\+\-\*\/\.0-9]+\))', str(sub_expr3),express,count=1) print('括号运算：',sub_expr3) delkuohao_expr=delkuohao(format_mark(sub_expr3)) return delkuohao_exprif __name__=="__main__": #while True: #express=input("请输入要计算的表达式：") print('\n================================') print('\033[33m 混合运算计算器\033[0m') print('================================') #express ='1-2*((60-30+(-40.0/5)*(9-2*5/3+7/3*99/4*2998+10*568/14))-(-4*3)/(16-3*2))' while True: express = input('\033[32m请输入表达式,规范点哦 | (退出:q)\033[0m') express = re.sub('\s*', '', express) if len(express) == 0: continue elif express == 'q': sys.exit('退出程序') elif re.search('[^0-9\.\-\+\*\/\(\)]',express): print('\033[31m 不是有效的算数表达式哦，请重新输入!!!\033[0m') else: express = express.replace(' ', '') print('您输入的表达式：',express) '''调用删除括号的函数''' express2 = delkuohao(express) #删除括号 express2 = compute(format_mark(express2)) #删除括号后再调用一次计算函数 print('\033[31m表达式:%s'%express,'=', str(express2),'\033[0m')]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py基础四之异常处理]]></title>
    <url>%2F2018%2F01%2F20%2Fpy%E5%9F%BA%E7%A1%80%E5%9B%9B%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[python基础语法之异常处理12345678910111213141516171819202122232425262728293031#!/usr/bin/python# -*- coding: UTF-8 -*-try: 1 / 0except Exception as e: '''异常的父类，可以捕获所有的异常''' print "0不能被除"else: '''保护不抛出异常的代码''' print "没有异常"finally: print "最后总是要执行我"'''try： code #需要判断是否会抛出异常的代码，如果没有异常处理，python会直接停止执行程序except: #这里会捕捉到上面代码中的异常，并根据异常抛出异常处理信息#except ExceptionName，args： #同时也可以接受异常名称和参数，针对不同形式的异常做处理 code #这里执行异常处理的相关代码，打印输出等else： #如果没有异常则执行else code #try部分被正常执行后执行的代码finally： code #退出try语句块总会执行的程序''']]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py基础三]]></title>
    <url>%2F2018%2F01%2F20%2Fpy%E5%9F%BA%E7%A1%80%E4%B8%89%2F</url>
    <content type="text"><![CDATA[python基础语法(三)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!usr/bin/python# -*- coding: UTF-8 -*-#打开一个文件fo= open("4.txt", "r+")#fo.write( "www.runoob.com!\nVery good site!\n");str= fo.read(10)print "文件名: ", fo.nameprint "是否已关闭: ", fo.closedprint "访问模式: ", fo. modeprint "末尾是否强制加空格: ", fo.softspaceprint "读取的字符串是: ", strposition= fo.tell()print "当前文件位置: ", positionposition= fo.seek(0, 0)str= fo.read(10)print "重新读取字符串: ", strfo.close()#重命名文件import osos.rename("4.txt", "1.txt")#删除文件os.remove("1.txt")#创建目录os.mkdir("test")#改变目录#将当前目录改为"/home/newdir"os.chdir("/home/newdir")#显示当前目录os.getcwd()#删除目录os.rmdir("/tmp/test")#在 write 内容后，直接 read 文件输出会为空，是因为指针已经在内容末尾。#两种解决方式: 其一，先 close 文件，open 后再读取，其二，可以设置指针回到文件最初后再 readdocument = open("testfile.txt", "w+");print "文件名: ", document.name;document.write("这是我创建的第一个测试文件！\nwelcome!");print document.tell();#输出当前指针位置document.seek(os.SEEK_SET);#设置指针回到文件最初context = document.read();print context;document.close();]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py基础二]]></title>
    <url>%2F2018%2F01%2F18%2Fpy%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[python基础语法(二)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#!usr/bin/python# -*- coding: UTF-8 -*-import timelocaltime = time.localtime(time.time())print "本地时间为 :", localtime#获取格式化的时间localtime = time.asctime( time.localtime(time.time()) )print "本地时间为 :", localtime# 格式化成2016-03-20 11:45:39形式print time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 格式化成Sat Mar 28 22:24:24 2016形式print time.strftime("%a %b %d %H:%M:%S %Y", time.localtime()) # 将格式字符串转换为时间戳a = "Sat Mar 28 22:24:24 2016"print time.mktime(time.strptime(a,"%a %b %d %H:%M:%S %Y"))#获取某月日历import calendarcals = calendar.month(2018, 1)print "以下输出2018年1月份的日历:"print cals;import datetimei = datetime.datetime.now()print ("当前的日期和时间是 %s" % i)print ("ISO格式的日期和时间是 %s" % i.isoformat() )print ("当前的年份是 %s" %i.year)print ("当前的月份是 %s" %i.month)print ("当前的日期是 %s" %i.day)print ("dd/mm/yyyy 格式是 %s/%s/%s" % (i.day, i.month, i.year) )print ("当前小时是 %s" %i.hour)print ("当前分钟是 %s" %i.minute)print ("当前秒是 %s" %i.second)#函数#缺省参数#可写函数说明def printinfo( name, age = 35 ): "打印任何传入的字符串" print "Name: ", name; print "Age ", age; return; #调用printinfo函数printinfo( age=50, name="miki" );printinfo( name="miki" );#不定长参数#加了星号（*）的变量名会存放所有未命名的变量参数。# 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print "输出: " print arg1, '我是arg1' for var in vartuple: print var return; # 调用printinfo 函数printinfo( 10 );printinfo(70, 60, 50, 66);#全局变量想作用于函数内，需加globalglobvar = 0def set_globvar_to_one(): global globvar # 使用 global 声明全局变量 globvar = 1def print_globvar(): print(globvar) # 没有使用 globalset_globvar_to_one()print globvar # 输出 1print_globvar() # 输出 1，函数内的 globvar 已经是全局变量#列表反转函数def reverse(li): for i in range(0, len(li)/2): temp = li[i] li[i] = li[-i-1] li[-i-1] = templ = [1, 2, 3, 4, 5]reverse(l)print(l)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ie11降级]]></title>
    <url>%2F2018%2F01%2F17%2Fie11%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[中小学教师资格证考试有点坑…上图说是使用IE6-IE10系列浏览器或“搜狗浏览器(兼容模式)”！对于我这种不太使用IE系列浏览器的人来说，确实有点…下面说下解决方法：打开你的IE按照流程进入到报名系统处发现系统提示使用IE6-IE10系列浏览器或“搜狗浏览器(兼容模式)”！检查了下发现自家的IE是11，降级就行。在此网页下，点右上角的齿轮，选择F12开发人员工具将文档模式和用户代理字符串改为11以下的就行，比如10然后将上方网址的/memapp/ieNote删除再回车，就可以登录了。]]></content>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行管理系统修改一]]></title>
    <url>%2F2018%2F01%2F17%2F%E9%93%B6%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[之前写过一个银行管理系统，现在对它进行了一些完善。增加了主界面的背景图片。增加了管理员功能管理员登陆成功管理员界面点击查询按钮可以将数据库中的账户信息显示在上方表中。选中一行，可以对一些信息进行修改，比如删除或修改。完善了账户退出功能用户登陆账户，点第一次退出会退出当前账户，再次点击退出会退出程序。源码下载]]></content>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础一]]></title>
    <url>%2F2018%2F01%2F16%2Fpython%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[python的基本语法(一)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#!usr/bin/python# -*- coding: UTF-8 -*-print range(1, 5) #代表从1到5（不包括5）print range(1, 5, 2) #代表从1到5，间隔2（不包括5）print range(5) #代表从0到5（不包括5）print ord('b') #convert char to intprint chr(100) #convert int to charprint unichr(100) #return a unicode byte#abs()和 fabs()区别#abs()是一个内置函数， 而fabs()是在math模块中定义的。#fabs()函数只适用于float和 integer类型，而abs()也适用于复数print abs(-10)import mathprint math.fabs(-10)print type(abs(-10))print type(math.fabs(-10))#多行语句total= 'item_one '+ \'item_two '+ \'item_three'print total#字符串str = 'Hello World!' print str # 输出完整字符串print str[0] # 输出字符串中的第一个字符print str[2:5] # 输出字符串中第三个至第五个之间的字符串print str[2:] # 输出从第三个字符开始的字符串print str * 2 # 输出字符串两次print str + "TEST" # 输出连接的字符串print str[:2] # 输出从开始到第二个字符的字符串print "更新字符串: ", str[:3]+ 'sanstyle' #更新字符串print "My name is %s and age is %d!" % ('style', 21)# %s格式化字符串 %d格式化整数# %c格式化字符及其ASCII码#列表list1 = ['physics', 'chemistry', 1997, 2000];print list1print len(list1) #返回列表元素个数print list1[-2] #读取列表中倒数第二个元素print list1[-2:] #从倒数第二个元素开始读取print list1[:-2] #读到倒数第二个前(不包括倒数第二个)del list1[2] #删除第三个print list1list1.append('3e3e') #在列表末尾添加新的对象print list1.count('3e3e') #统计出现的次数print list1.index('3e3e') #从列表重找出第一个匹配项的索引位置list1.remove('3e3e') #移除列表中这个值的第一个匹配项list1.reverse() #反向列表中元素print list1list2=[123,["das","aaa"],234]print 'aaa' in list2 #in只能判断一个层次的元素 print 'aaa' in list2[1] #选中列表中的二层列表进行判断#元组(元素不能修改)#元组中只包含一个元素时，需要在元素后面添加逗号tup= (50, )print tuptup1= (12, 34, 56)tup2= ('abc', 'xyz')#以下修改元组元素的操作是非法的#tup1[0]= 100#任意无符号的对象，以逗号隔开，默认为元组print 'abc', -4.24e93, 18+6.6j, 'xyz';x, y = 1, 2;print "Value of x , y : ", x,y;#字典(可存储任意类型对象)dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; print "dict['Name']: ", dict['Name'];print "dict['Age']: ", dict['Age'];dict['Age'] = 8; # update existing entrydict['School'] = "DPS School"; # Add new entryprint "dict['Age']: ", dict['Age'];print "dict['School']: ", dict['School'];print dictdel dict['Name']; # 删除键是'Name'的条目print dict#dict.clear(); # 清空词典所有条目#print dict#del dict ; # 删除词典print dict.keys() #以列表返回一个字典所有的键print dict.values() #以列表返回一个字典所有的值#字典值可以是任意数值类型dict1= &#123;"a":[1,2]&#125; # 值为列表print dict1['a'][1]dict2= &#123;"a":&#123;"c":"d"&#125;&#125; # 值为字典 print dict2['a']['c']]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditPlus运行py编码问题]]></title>
    <url>%2F2018%2F01%2F15%2FEditPlus%E8%BF%90%E8%A1%8Cpy%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[文本编辑器是EditPlus，运行python时候报出如下错误: SyntaxError: (unicode error) &#39;utf-8&#39; codec can&#39;t decode byte 0xc4 in position 0: invalid continuation byte。非常普通的Hello World，编码格式是utf-8解决方法：用notepad++打开python1_1.py发现存储格式是ANSI。保存的时候默认是保存成ANSI格式。发现问题就好解决啦，保存文件的时候将文件格式换成UTF-8就好了。成功输出！]]></content>
      <tags>
        <tag>python</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javax/xml/bind/DatatypeConverter]]></title>
    <url>%2F2018%2F01%2F15%2Fjavax-xml-bind-DatatypeConverter%2F</url>
    <content type="text"><![CDATA[话不多说，上图。重装系统后，想调试下实训的代码，发现一样的代码竟然运行不了。后来发现，重装后安装的jdk版本是9.0，并不是完全兼容。看错误提示是java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter。这是因为Java虚拟机在编译时候能找到这个类，而在运行时没能找到这个类。按照错误提示，下载这个类的jar包就行。jar包下载地址]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.length和.length()的区别]]></title>
    <url>%2F2017%2F12%2F31%2Flength%E5%92%8C-length-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[java中的length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了length这个属性。java中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到length()这个方法。如何获取一个数组的长度？以及，如何获取一个字符串的长度？ 12345int[] arr = new int[3];System.out.println(arr.length);//使用length获取数组的程度 String str = "abc";System.out.println(str.length());//使用length()获取字符串的长度 为什么数组有length属性？ 数组是一个容器对象，其中包含固定数量的同一类型的值。一旦数组被创建，他的长度就是固定的了。数组的长度可以作为final实例变量的长度。因此，长度可以被视为一个数组的属性。 为什么String有length()方法？ String背后的数据结构是一个char数组,所以没有必要来定义一个不必要的属性（因为该属性在char数值中已经提供了）。和C不同的是，Java中char的数组并不等于字符串，虽然String的内部机制是char数组实现的。 注: 要想把char[]转成字符串有以下方式：1234char []s = &#123;'a','b','c'&#125;;String string1 = s.toString();String string2 = new String(s);String string3 = String.valueOf(s);]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识点一]]></title>
    <url>%2F2017%2F12%2F31%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1、面向对象的特征有哪些方面 1、抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。2、继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 3、封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 4、多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 2、什么是接口？写出接口与抽象类的区别。 接口是你在写程序时所有方法的一个声明，只设计，无实现。区别：1、都没有方法体2、通过接口可以支持多重继承，抽象类不支持3、抽象类可以包含已经实现的方法而接口不可以 3、写出String和StringBuffer的区别，int和Integer有什么区别。 String类创建的对象不可修改，StringBuffer创建的的对象是内存空间可以改变的大小的，可以调用append方法追加到字符串序列;Int是java的原始数据类型，Integer是java为int提供的封装类,引用数据类型。 4、sleep() 和 wait() 有什么区别?sleep()不释放同步锁,wait()释放同步锁。 sleep方法是Thread类的静态方法,线程在占用CPU资源期间，通过调用Sleep方法来使自己放CPU资源，休眠一段时间。wait是object类的方法，可以中断方法的执行，使本线程等待，暂时让出cpu的使用权，并允许其他线程使用这个同步方法。 5、简述线程的生命周期 新建、运行、中断、死亡 6、举例说明如何获取当前的年月日，时分秒以及从1970年到现在的毫秒数。1234567Date nowtime=new Date();System.out.println(nowtime);SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date currentTime=new Date(); Date beginTime=sdf.parse("1970-01-01 12:53:30"); long interval=(currentTime.getTime()-beginTime.getTime());]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[窗口程序]]></title>
    <url>%2F2017%2F12%2F31%2F%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[编写一个程序，生成一个窗口。标题为记事本，有一个文件菜单，正中显示一个TextArea,默认值为“我是TextArea！”。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.awt.*;import java.awt.event.*;import java.io.*;class WindowJiShiBen extends Frameimplements ActionListener&#123; MenuBar menubar; Menu menu; MenuItem itemExit; MenuItem itemSave; TextArea text1; FileWriter tofile; BufferedWriter out; FileDialog filedialog_save; WindowJiShiBen(String s) &#123; super(s); text1 =new TextArea("我是TextArea"); menubar =new MenuBar(); menu =new Menu("文件"); itemExit =new MenuItem("退出"); itemExit.setShortcut(new MenuShortcut(KeyEvent.VK_E)); itemSave=new MenuItem("保存"); itemSave.setShortcut(new MenuShortcut(KeyEvent.VK_S)); filedialog_save=new FileDialog(this,"保存文件话框",FileDialog.SAVE); menu.add(itemExit); menubar.add(menu); menu.add(itemSave); setMenuBar(menubar); add(text1); itemExit.addActionListener(this); itemSave.addActionListener(this); setBounds(100,100,150,150); setVisible(true); validate(); filedialog_save.addWindowListener(new WindowAdapter() &#123;public void windowClosing(WindowEvent e) &#123; filedialog_save.setVisible(false); &#125; &#125;); &#125; public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==itemExit) &#123;System.exit(0);&#125; else if(e.getSource()==itemSave) &#123;filedialog_save.setVisible(true); if(filedialog_save.getFile()!=null) &#123; try &#123; File file=new File(filedialog_save.getDirectory(),filedialog_save.getFile()); tofile=new FileWriter(file); out=new BufferedWriter(tofile); out.write(text1.getText(),0,(text1.getText()).length()); out.close(); tofile.close(); &#125; catch(IOException e2)&#123;&#125; &#125; &#125; &#125;&#125;public class jishiben&#123; public static void main(String args[]) &#123; WindowJiShiBen win=new WindowJiShiBen("记事本"); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见问题一]]></title>
    <url>%2F2017%2F12%2F29%2FJava%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[错误: 找不到或无法加载主类 Test8.Main解决方法：右键你的项目，选最后一个properties，把properties属性里的java compiler–&gt;building–&gt;abort build when build path errors occur前的勾去掉就好了。好像还有其他的解决方法。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行管理系统]]></title>
    <url>%2F2017%2F12%2F29%2F%E9%93%B6%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[此次的项目是银行管理系统，要求连接数据库，在此记录下。 总界面在此界面除了开户和退出两个功能能实现外，其它功能都需要登录后才能使用。 开户界面此界面需要用户输入个人信息来进行开户操作，用户输入的信息将会保存到数据库中。开户成功后系统会反馈一个开户账号。这个账号是使用的System.currentTimeMillis()产生一个当前的毫秒，这个毫秒其实就是自1970年1月1日0时起的毫秒数。 登录界面此界面需要用户输入开户的账号和密码，系统会从数据库中读取信息与之比对，无误则成功登录。 存款界面此界面需要用户输入存款金额，完成后系统会显示当前账号的余额。此操作记录将会存到数据库中。 取款界面此界面需要用户输入取款金额，完成后系统会显示当前账号的余额。此操作记录将会保存到数据库中。 转账界面此界面需要用户输入对方的账号和转账金额，完成后系统会显示当前账号的余额。此操作记录将会保存到数据库中。 销户界面进入此界面，系统会判断账户余额是否为零，如果不是，不能销户。用户将余额取出，销户完成。 修改密码界面用户需要输入两次相同的六位数字或字母密码，此操作记录将会保存到数据库中。 查看个人信息界面此界面将会显示查询到的当前账户的信息包括账号，姓名，性别，身份证号，联系电话以及开户时间。源码可在这里下载。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Four_or_six]]></title>
    <url>%2F2017%2F12%2F13%2FFour-or-six%2F</url>
    <content type="text"><![CDATA[嗯…没错，就是四六级！]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS填空题]]></title>
    <url>%2F2017%2F12%2F12%2FOS%E5%A1%AB%E7%A9%BA%E9%A2%98%2F</url>
    <content type="text"><![CDATA[操作系统填空题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869影响文件安全的主要因素: `人为因素`, `系统因素`, `自然因素`。程序执行时呈现出局部性规律: `时间局限性`, `空间局限性`。操作系统的主要功能有: `处理机管理`, `存储器管理`, `设备管理`, `文件管理`, `用户接口`。解决通道“瓶颈”问题最有效的方法是增加设备到主机间的: `通路`。进程三种基本状态: `就绪状态`, `执行状态`, `阻塞状态`。目录管理的主要功能: `实现按名存取`, `提高检索速度`, `文件共享`, `允许文件重名`。在操作系统中，实现进程同步的机制有: `信号量机制`, `管程机制`。进程同步机制应遵循的准则: `空闲让进`, `忙则等待`, `有限等待`, `让权等待`。抢占式进程调度方式基于的主要原则有: `优先权原则`, `短进程优先原则`, `时间片原则`。请求分页系统的主要硬件支持有: `请求分页页表机制`, `缺页中断机构`, `地址变换机构`。进程死锁原因: `竞争资源`, `进程间推进顺序非法`。通常采用解除死锁的两种方法是: `剥夺资源`, `撤消进程`。设备分配中的主要数据结构(英文缩写): `DCT`, `COCT`, `CHCT`, `SDT`。进程、文件、线程在系统中是否存在的唯一标志(英文缩写): `PCB`, `FCB`, `TCB`。产生进程死锁的必要条件: `互斥条件`, `请求和保持条件`, `不剥夺条件`, `环路等待条件`。目前比较流行的操作系统(实例): `Windows`, `UNIX`, `Linux`。OS(操作系统)的基本特征: `并发性`, `共享性`, `虚拟性`, `异步性`。OS(操作系统)的基本类型: `批处理系统`, `分时系统`, `实时系统`。外存分配条件: `连续分配`, `链接分配`, `索引分配`。文件物理结构: `顺序文件`, `链接文件`, `索引文件`。设备的独立性: `LUT`。按设备的固有属性分类，将I/O设备分为: `独占设备`, `共享设备`, `虚拟设备`。虚拟存储理论: `局部性原理`。虚拟设备技术: `SPOOLing`。将一台物理I/O设备虚拟为多台逻辑I/O设备的技术: `SPOOLing`。UNIX本质特征: `OSI`。UNIX内核结构: `进程控制子系统`, `文件子系统`。OS(操作系统)设计目标: `方便性`, `有效性`, `可扩充性`, `开放性`。OS(操作系统)用户接口: `命令接口`, `程序接口`, `图形用户接口`。`方便性`和`有效性`是操作系统设计中最重要的两个目标1990年后，`开放性`已成为新系统或软件能否被广泛应用的至关重要的因素。`并发性`和`共享性`是多用户、多任务操作系统两个最基本的特征。`并发性`是多用户、多任务操作系统最重要的特征。在OS基本特征中，`异步性`是指进程是以人们不可预知的速度向前推进的。在操作系统基本类型中，`可靠性`是实时系统最重要的特征。在操作系统接口中，`程序接口`亦称为`系统调用`。进程所请求的一次I/O完成后，将使进程状态从`阻塞状态`变为`就绪状态`。操作系统中处于执行状态的进程时间片用完后，进程状态将转变为`就绪状态`。操作系统中处于执行状态的进程提出I/O后请求后，进程状态将转变为`阻塞状态`。进程三种基本状态中，`就绪状态`是指进程已分配到除CPU以外的所有必要资源。同步机制准则中，`让权等待`是指当进程不能进入自己的临界区时，应立即释放处理机。在文件系统中，文件属性信息存储在`数据结构(英文缩写)FCB`中。操作系统利用`数据结构(英文缩写)PCB`描述进程的基本情况和活动过程。系统将被中断进程的CPU现场信息保存在该进程的`数据结构(英文缩写)PCB`中。1965年，荷兰学者Dijkstra提出的`信号量机制`是一种卓有成效的进程同步工具。在死锁的条件中，`不剥夺条件`是指进程已获得的资源只能在使用完时由自己释放。在死锁的条件中，`互斥条件`是指在一段时间内，某资源只能被一个进程占用。`资源的按序分配法`是摒弃死锁条件中的`环路等待条件`来预防死锁的发生。现代操作系统产生死锁的条件中，`互斥条件`是不能被摒弃来预防死锁的发生。在局部性原理中，产生`时间局限性`的典型原因是在程序中存在着大量的循环操作。在局部性原理中，产生`空间局限性`的典型情况是程序的顺序执行。在请求分页系统的硬件支持中，当所要访问的页面不在内存时，由`缺页中断机构`实现。在请求分页系统的硬件支持中，页面置换算法需要应用`请求页表机制`实现。为了实现设备的独立性，系统必须设置(英文缩写): `LUT`。在设备分配中，用于记录每一个设备情况的数据结构(英文缩写): `DCT`。在设备分配中，用于记录全部设备情况的数据结构(英文缩写): `SDT`。在设备分配中，用于记录每一个控制器情况的数据结构(英文缩写): `COCT`。在设备的固有属性分类中，`独占设备`属于临界资源，即进程临界区访问的资源。在设备的固有属性分类中，典型的独占设备有`打印机`、`磁带机`等。在设备的固有属性分类中，典型的共享设备有`磁盘`、`光盘`。在假脱机打印机系统中，在设备的固有属性分类，是将`独占设备`改造为`共享设备`。在假脱机打印机系统中，在设备的固有属性分类，实现了`虚拟设备`功能。`SPOOLing`技术是对脱机I/O系统的模拟，或称为`假脱机技术`。在索引节点中设置链接引用(links)计数的目的是为了实现目录管理的`文件共享功能`。实现`按名存取`是文件系统目录管理中最基本的功能。实现`按名存取`是文件系统向用户提供的最基本的服务。通过`建立后备系统`，防止由`自然因素`所造成的文件系统的不安全性。通过`存取控制机制`，防止由`人为因素`所造成的文件系统的不安全性。通过`采取容错技术`，防止由`系统因素`所造成的文件系统的不安全性。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐写之图片隐藏]]></title>
    <url>%2F2017%2F12%2F08%2F%E9%9A%90%E5%86%99%E4%B9%8B%E5%9B%BE%E7%89%87%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[在图片中插入其他的文件，例如一段音乐，一段视频，或是某个文件。1、准备一张图片和要隐藏的资料信息比如这里，style准备了一张壁纸和一个txt文件。现在需要将一个文件隐藏在这张图片里。2、选择需要隐藏的文件，右键压缩成一个rar文件，文件名字可以随便起，在这里style将其压缩成1.rar。3、新建一个文本文档，名字随便起，style这里将其命名为2.txt,，在里面输入以下代码copy /b 1.jpg+1.rar 222.jpg4、接着另存为这个文本文档，重要的是文件类型得是bat类型，也就是批处理命令。style这里命名为2.bat。5、双击这个bat命令，得到一个最终的文件222.jpg。6、这个图片打开看的话和正常的图片一样，但是大小与封面图片相比是不一样的，其实这里面包含了刚刚隐藏的那些重要信息。将得到的新的图片的后缀改为rar，然后解压就可得到我们刚刚隐藏的文件。也可以用二进制编辑器查看，发现在后面有个zip的文件头，可以将这个压缩包提取出来，再解压。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[情报搜集技术]]></title>
    <url>%2F2017%2F12%2F07%2F%E6%83%85%E6%8A%A5%E6%90%9C%E9%9B%86%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[#外围信息搜集网站的IP地址查询kali中使用nslookup工具对testfire.net这个网站进行查询root@bt:~# nslookup回车后输入set type=A回车后输入testfire.net就可以了。 IP2Location地理位置查询查询IP地址，可以在http://www.maxmind.com 网站上使用该服务。如果是国内的IP地址，推荐使用“QQ纯真数据库”。 IP2Domain反查域名一台物理服务器上面可能运行多个虚拟主机，这些虚拟主机具有不同的域名，但通常公用一个IP地址。如果你要知道有哪些网站公用这台服务器，就有可能通过此台服务器上其他网站的漏洞获取服务器控制权，进而迂回获取渗透目标的权限，这种攻击技术也称为旁注。可以使用http://www.ip-adress.com/reverse_ip/ 提供的服务查询有哪些域名指向同一个IP地址。国内也有一些类似的网站可用于IP反查，如http://www.7c.com/ ,该网站针对国内的IP查询结果更为准确。 探索网站的目录结构如果管理员允许，Web服务器会将没有默认页面的目录以文件列表的方式显示出来，而这些开放了浏览功能的网站目录往往会透露一些网站可供浏览的页面之外的信息，甚至能够再这些目录中发现网站源代码甚至后端数据库的连接口令。可以再Google中输入parent directory site:testfire.net来查找testfire.net上的此类目录。打开第一个链接，网站的bank目录中的文件内容一览无余。在浏览网站目录时，应当对以下几种文件特别留意: 1、扩展名为inc的文件:可能会包含网站的配置信息，如数据库用户名/口令等。2、扩展名为bak的文件：通常是一些文本编辑器在编辑源代码后留下的备份文件，可以让你知道与其对应的程序脚本文件中的大致内容。3、扩展名为txt或sql的文件：一般包含网站运行的SQL脚本，可能会透露类似数据库结构等信息。 检索特定类型的文件在Google中输入site:testfire.net filetype:xls，可以查询testfire.net这个网站中xls类型文件。 搜索网站中的E-mail地址使用Metasploit中一个非常棒的辅助模块search_email_collector，进行有针对性的右键地址搜集。search_email_collector模块要求提供一个邮箱后缀（域名），它并不是通过直接遍历网站页面获取邮件地址，而是通过多个搜索引擎的查询结果分析使用此后缀的邮件地址，使用它就能够很方便地获取某个机构地大量邮件地址。msf&gt; use auxiliary/gather/search_email_collectormsf auxiliary(search_email_collector)&gt; set DOMAIN altoromutual.com回车后输入runtestfire网站模拟了一个名为altoromutual地电子银行站点，用它来做测试。 搜索易存在SQL注入点地页面使用Google可以筛选出网站中容易出现SQL注入漏洞的页面，如网站登录页面。例如在google.com中输入site:testfire.net inurl:login关键字进行搜索，得到了其后台登录URL。 #主机探测与端口扫描Metasploit的主机发现模块Metasploit中提供了一些辅助模块可用于活跃主机的发现，这些模块位于Metasploit源码路径的modules/auxiliary/scanner/discovery/目录中。其中两个常用模块的主要功能为: 1、arp_sweep使用ARP请求枚举本地局域网络中的所有活跃主机。2、udp_sweep通过发送UDP数据包探查指定主机是否活跃，并发现主机上的UDP服务。 Metasploit的arp_sweep模块是一个ARP扫描器。如下演示使用方法。首先需要输入RHOSTS来对扫描目标进行设置，设置好后输入run命令启动扫描器。从代码中可以看到，arp_sweep模块很快发现了192.168.2.0/24网段上拥有3台活跃主机，其中前两个IP地址为宿主主机上模拟的虚拟网卡IP地址。arp_sweep模块只能探测同一子网中的活跃主机，对于远程网络，可以使用更为强大的Nmap扫描器进行探测。 使用Nmap进行主机探测通常一个Nmap命令格式如下所示:nmap &lt;扫描选项&gt; &lt;扫描目标&gt;如果仅是在一个内部网中发现存活主机，可以使用-sn，这个选项会使用ICMP的Ping扫描获取网络中的存活主机情况，而不会进一步探测主机的详细情况。如果是在Internet环境中，推荐使用-Pn选项，它会告诉Nmap不要使用Ping扫描，因为ICMP数据包通常无法穿透Internet上的网络边界(通常是被防火墙过滤掉了)。在Internet环境中，可以使用nmap-PU通过对开放的UDP端口进行探测以确定存活的主机，其功能类似Metasploit中的udp_sweep辅助模块。Nmap在进行UDP主机探测时，默认会列出开放的TCP端口，如果想加快扫描速度，可以使用-sn告诉Nmap仅探测存活主机，不对开放的TCP端口进行扫描。 操作系统辨识可以使用-O选项让Nmap对目标的操作系统进行识别。使用nmap -A命令可以获取更详细的服务和操作系统信息。 #端口扫描与服务类型探测Metasploit中的端口扫描器Metasploit的辅助模块中提供了几款实用的端口扫描器。可以输入search portscan命令找到相关的端口扫描器。 1、ack: 通过ACK扫描的方式对防火墙上未被屏蔽的端口进行探测。2、ftpbounce: 通过FTP bounce攻击的原理对TCP服务进行枚举，一些新的FTP服务器软件能够很好的防范FTP bounce攻击，但在一些旧的Solaris及FreeBSD系统的FTP服务中此类攻击方式仍能够被利用。3、syn: 通过一次完整的TCP连接来判断端口是否开放，这种扫描方式最精确，但扫描速度慢。4、xmas: 一种更为隐秘的扫描方式，通过发送FIN、PSH和URG标志，能够躲避一些高级的TCP标记监测器的过滤。 一般情况下，推荐使用syn端口扫描器，因为它的扫描速度较快、结果精确且不容易被对方察觉。 Nmap的端口扫描功能Nmap对端口的状态分为六个层次: open(开放)、cloase(关闭)、filtered(被过滤)、unfiltered(未过滤)、open|filtered(开放或被过滤)、closed|filtered(关闭或被过滤)。下面对这几种端口状态进行说明: 1、open: 一个应用程序正在此端口上进行监听，以接收来自TCP、UDP或SCTP协议的数据。这是在渗透测试中最关注的一类端口，开放端口往往能够为我们提供一条能够进入系统的攻击路径。2、closed: 关闭的端口指的是主机已响应，但没有应用程序监听的端口。这些信息并非毫无价值，扫描出关闭端口至少说明主机是活跃的。3、filtered: 指Nmap不能确认端口是否开放，但根据响应数据猜测该端口可能被防火墙等设备过滤。4、unfiltered: 仅在使用ACK扫描时，Nmap无法确定端口是否开放，会归为此类。可以使用其他类型的扫描(如WIndow扫描、SYN扫描、FIN扫描)进一步确认端口的信息。 常用的Nmap扫描类型参数主要有: 1、-sT: TCP connect扫描，类似Metasploit中的tcp扫描模块。2、-sS: TCP SYN扫描，类似Metasploit中的syn扫描模块。3、-sF/-sX/-sN: 这些扫描通过发送一些特殊的标志位以避开设备或软件的监测，4、-sP: 通过发送ICMP echo请求探测主机是否存活，原理同ping。5、-sU: 探测目标主机开放了哪些UDP端口。6、-sA: TCP ACK扫描，类似Metasploit中的ack扫描模块。 常用的Nmap扫描选项有: 1、-Pn: 在扫描之前，不发送ICMP echo请求测试目标是否活跃。2、-O: 启用对于TCP/IP协议栈的指纹特征扫描以获取远程主机的操作系统类型等信息。3、-F: 快速扫描模式，只扫描在nmap-services中列出的端口。4、-p&lt;端口范围&gt;: 可以使用这个参数指定希望扫描的端口，也可以使用一段端口范围(例如1~1023).在IP协议扫描中(使用-sO参数)，该参数的意义是指定想要扫描的协议号(0~255)。 使用Nmap对192.168.2.2进行一次端口扫描的结果，其中用到了-sS选项，该选项指定使用TCP SYN扫描，这种扫描方式不等待打开一个完全的TCP连接，所以执行速度会更快，而且这种扫描通常不会被IDS等设备记录。如果想同时列出UDP端口，可以加上-sU，但执行速度就会变得比较慢。 使用Nmap探测更详细的服务信息如果想获取更加详细的服务版本等信息，需要使用-sV选项。 #服务扫描与查点在Metasploit的Scanner辅助模块中，有很多用于服务扫描和查点的工具，这些工具常以[service_name]_version和[service_name]_login命令。 1、[service_name]_version可用于遍历网络中包含了某种服务的主机，并进一步确定服务的版本。2、[service_name]_login可对于某种服务进行口令探测攻击。 在MSF终端中，可以输入search name:_version命令查看所有可用的服务查点模块。 SSH服务扫描与telnet不同的是，ssh采用安全的加密信息传输方式。通常管理员会使用ssh对服务器进行远程管理，服务器会向ssh客户端返回一个远程的Shell连接。 Oracle数据库服务查点使用mssql_ping模块查找网络中的Microsoft SQL Server，使用tnslsnr_version模块查找网络中开放端口的Oracle监听器服务。 开放代理探测与利用避免被对方的入侵监测系统跟踪，需要隐藏自己的身份，最简单和最常见的是使用代理服务器。Metasploit提供了open_proxy模块，能够让你更加方便地获取免费地HTTP代理服务器地址。获取免费开放代理后，就可以在浏览器或者一些支持配置代理地渗透软件中配置代理，这可以在进行渗透测试时隐藏你的真实IP地址。比开放代理更保险地隐藏攻击源方法是利用开放的或自主架设VPN服务，可以自己架设OpenVPN。使用这些VPN可以采用加密方式转发路由你的渗透测试数据包，而无需担心你的攻击发起源被跟踪到。 #口令猜测与嗅探SSH服务口令猜测载入ssh_login模块后，首先需要设置RHOSTS参数指定口令攻击的对象，可以是一个IP地址，或一段IP地址，同样也可以使用CIDR表示的地址区段。然后使用USERNAME参数指定一个用户名(或者使用USER_FILE参数指定一个包含多个用户名的文本文件，每个用户名占一行)，并使用PASSWORD指定一个特定的口令字符串(或者使用PASS_FILE参数指定一个包含多个口令的字典文件，每个口令占一行)，也可以使用USER PASS_FILE指定一个用户名和口令的配对文件(用户名和口令之间用空格隔开，每对用户名和口令占一行)。默认情况下，ssh_login模块还会尝试空口令，以及与用户名相同的弱口令进行登录测试。 psnuffle口令嗅探psnuffle是目前Metasploit中唯一用于口令嗅探的工具，可以使用它截获常见协议的身份认证过程，并将用户名和口令信息记录下来。 #网络漏洞扫描OpenVAS漏洞扫描器可以用来识别远程主机、Web应用存在的各种漏洞，使用NVT脚本对多种远程系统的安全问题进行监测。在kali中安装openVAS，输入命令: apt-get install openvas，安装过程中可能会出现错误，输入openvas-check-setpu查看安装到哪步出错，以及缺少什么东西。配置OpenVAS的过程如下:1、输入以下命令生成OpenVAS运行所需的证书文件，生成证书过程中，系统会询问一些信息，可以按回车键使用其默认值: root@bt:~# openvas-mkcert -qroot@bt:~# openvas-mkcert-client -n om -i 2、升级NVT库: root@bt:~# openvas-nvt-sync 3、对OpenVAS的扫描引擎进行一些初始化的操作，依次输入如下命令: root@bt:~# openvassdroot@bt:~# openvasmd –migrateroot@bt:~# openvasmd –rebuild 4、使用openvasad命令添加一个管理员角色的OpenVAS登录用户: root@bt:~# openvasad -c ‘add_user’ -n admin -r ‘Admin’Enter password:admain:MESSAGE:2327:2017-12-07 03h37.44 EDT: No rules file provided, the new user will have no restrictions.admin:MESSAGE:2327:2017-12-07 03h37.44 EDT: User admin has been successfully created. 5、在终端输入如下命令启动OpenVAS Scanner: root@bt:~# openvassd –listen=127.0.0.1 –port=9391All plugins loaded 6、最后启动OpenVAS Manager，在终端中运行如下命令: root@bt:~# openvasmd –database=/usr/local/var/lib/openvas/mgr/tasks.db –slisten=127.0.0.1 –sport=9391 –listen=0.0.0.0 –port=9390 如果在启动OpenVAS各部件时报错，可以运行以下脚本确认OpenVAS已经安装配置无误，如果脚本运行检测出错误，请按照屏幕提示进行修正。 root@bt:~# /pentest/misc/openvas/openvas-check-setup Nmap扫描漏洞如果服务器开启了SMB服务，可以使用Nmap的SMB服务漏洞扫描模块对它进行探测。]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读写文件二]]></title>
    <url>%2F2017%2F12%2F05%2Fjava%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[使用Java的输入流、输出流将一个文本文件的内容按行读出，每读出一行就顺序添加行号，并写入到另一个文件中。1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class Test4 &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub BufferedReader br = null; BufferedWriter bw = null; try &#123; br = new BufferedReader(new FileReader("Input.txt")); bw = new BufferedWriter(new FileWriter("Output.txt")); String str = ""; int i = 1; while((str = br.readLine()) != null)&#123; bw.write(i+" "); bw.write(str); System.out.println(i+ " "+ str); bw.newLine(); //换行，换行后可以使用readline()来一行行读取数据 i++; &#125; bw.flush(); //清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再用数据写到文件中， //当数据读完时，如果调用close()方法关闭读写流，就可能造成数据丢失， //原因是一部分的数据可能留在缓存区 bw.close(); br.close(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block System.out.println("找不到指定文件！"); &#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读写文件一]]></title>
    <url>%2F2017%2F12%2F05%2Fjava%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E4%B8%80%2F</url>
    <content type="text"><![CDATA[写入文件后可逆序输出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.io.*;import java.util.Scanner;public class Test3 &#123; public static void main(String[] args) &#123; //创建文件对象 File file= new File("2.txt"); if (file.exists()) &#123; //文件存在 String name= file.getName(); long len= file.length(); //判断文件隐藏属性 boolean hidden= file.isHidden(); System.out.println("文件名称: "+ name+ "\n文件长度: "+ len+ "\n隐藏属性: "+ hidden); writefile(file); readfile(file); &#125;else &#123; //文件不存在，创建文件 try &#123; file.createNewFile(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; System.out.println("文件已创建"); &#125; &#125; &#125; private static void readfile(File file) &#123; // TODO Auto-generated method stub try &#123; FileInputStream fileInputStream= new FileInputStream(file); byte[] b= new byte[1024]; int len= fileInputStream.read(b); fileInputStream.close(); StringBuilder ab = new StringBuilder(new String(b, 0, len)); System.out.println("文件读出的内容是: \n"+ ab.reverse().toString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; private static void writefile(File file) &#123; // TODO Auto-generated method stub Scanner in= new Scanner(System.in); System.out.println("请输入要写入得内容"); String string= in.next(); //建立文件传输管道 try &#123; FileOutputStream fileOutputStream= new FileOutputStream(file); //写文件 fileOutputStream.write(string.getBytes()); //关闭管道 fileOutputStream.close(); System.out.println("文件写入完成"); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP简单大文件传送]]></title>
    <url>%2F2017%2F12%2F04%2FUDP%E7%AE%80%E5%8D%95%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%2F</url>
    <content type="text"><![CDATA[话不多说，直接上代码。运行的时候先运行You.java, 再运行My.javaMy.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.net.*;import java.util.concurrent.TimeoutException;import java.awt.event.*;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import javax.swing.*;public class My&#123; public static void main(String[] args) &#123; new MyFrame(); &#125;&#125;class MyFrame extends JFrame implements ActionListener &#123; JTextField out_message = new JTextField(16); JTextArea in_message = new JTextArea(); JButton cfile = new JButton("选择文件"); JFileChooser chooser = new JFileChooser(); public MyFrame() &#123; setTitle("My"); // setSize(600, 600); setVisible(true); setBounds(300, 200, 350, 300); cfile.addActionListener(this); // send.addActionListener(this); // out_message.addKeyListener(this); JPanel pSouth = new JPanel(); pSouth.add(out_message); pSouth.add(cfile); // pSouth.add(send); add(pSouth, "South"); add(new JScrollPane(in_message), "Center"); validate(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void actionPerformed(ActionEvent event) &#123; chooser.setFileSelectionMode(0); int status = chooser.showOpenDialog(null); if (status == 1) &#123; return; &#125; else &#123; File file = chooser.getSelectedFile(); out_message.setText(file.getAbsolutePath()); out_message.grabFocus(); long startTime = System.currentTimeMillis();// 获取当前时间 byte[] buf = new byte[UDPUtils.BUFFER_SIZE];// 发送文件的字节数组 byte[] receiveBuf = new byte[Math.max(UDPUtils.successData.length, UDPUtils.exitData.length)];// 传送验证信息的字节数组 RandomAccessFile accessFile = null; DatagramPacket dpk = null; DatagramSocket dsk = null; int readSize = -1; try &#123; accessFile = new RandomAccessFile(file.getAbsolutePath(), "r");// 创建一个只读的文件流 dpk = new DatagramPacket(buf, buf.length, new InetSocketAddress(InetAddress.getByName("192.168.199.143"), UDPUtils.PORT + 1));// 创建一个待发送数据包 dsk = new DatagramSocket(UDPUtils.PORT);// 接收.... dsk.setSoTimeout(1000);// 设置确认报文超时重传 int sendCount = 0;// 记录发送的数据包的数量 while ((readSize = accessFile.read(buf, 0, buf.length)) != -1) &#123;// 将文件的数据读满字节数组，返回读入数组的总字节数，如果到文件尾则等于-1 // 未读到文件尾 dpk.setData(buf, 0, readSize);// 设置包的缓冲区长度为读入的字节数 dsk.send(dpk);// 发送包 // 等待服务端回应 &#123; while (true) &#123; dpk.setData(receiveBuf, 0, receiveBuf.length);// UDPUtils.successData.length); try &#123; dsk.receive(dpk);// 接收数据包 if (!UDPUtils.isEqualsByteArray(UDPUtils.successData, receiveBuf, dpk.getLength())) &#123;// 返回的不是成功标志 throw new TimeoutException("数据没有收到！"); &#125; else &#123; break; &#125; &#125; catch (SocketTimeoutException | TimeoutException e) &#123;//没有收到数据包或返回的不是成功标志 // TODO 超时重传 System.out.println("resend ..."); dpk.setData(buf, 0, readSize); dsk.send(dpk); continue; &#125; &#125; &#125; System.out.println("send count of " + (++sendCount) + "!"); &#125; // 发送退出标志等待回应 System.out.println("客户端退出 ...."); dpk.setData(UDPUtils.exitData, 0, UDPUtils.exitData.length); dsk.send(dpk); while (true) &#123; dpk.setData(receiveBuf, 0, receiveBuf.length); // byte[] receiveData = dpk.getData(); try &#123; dsk.receive(dpk); if (!UDPUtils.isEqualsByteArray(UDPUtils.exitData, receiveBuf, dpk.getLength())) &#123; throw new TimeoutException("Msg not equal"); &#125; else &#123; break; &#125; &#125; catch (SocketTimeoutException | TimeoutException e) &#123; // TODO 超时重传 System.out.println("client Resend exit message ...."); dsk.send(dpk); continue; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (accessFile != null) accessFile.close(); if (dsk != null) dsk.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; long endTime = System.currentTimeMillis(); System.out.println("time:" + (endTime - startTime)); &#125; &#125;&#125; You.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.InetSocketAddress;public class You &#123; private static final String SAVE_FILE_PATH = "C:/Users/马冲/Desktop/flag.zip";//接收文件存储的路径 public static void main(String[] args) &#123; byte[] buf = new byte[UDPUtils.BUFFER_SIZE]; DatagramPacket dpk = null;//定义一个数据包 DatagramSocket dsk = null;//定义一个接收数据包 BufferedOutputStream bos = null;//定义一个缓冲的文件输出流 try &#123; dpk = new DatagramPacket(buf, buf.length, new InetSocketAddress(InetAddress.getByName("127.0.0.1"), UDPUtils.PORT)); dsk = new DatagramSocket(UDPUtils.PORT + 1);//创建一个数据包由于接收 bos = new BufferedOutputStream(new FileOutputStream(SAVE_FILE_PATH));//创建一个缓冲的文件输出流 System.out.println("等待客户端...."); dsk.receive(dpk);//等待客户端发送文件 int readSize = 0; int readCount = 0; int flushSize = 0; while ((readSize = dpk.getLength()) != 0) &#123; // 验证客户端发送退出标志 if (UDPUtils.isEqualsByteArray(UDPUtils.exitData, buf, readSize)) &#123; System.out.println("服务器退出 ..."); dpk.setData(UDPUtils.exitData, 0, UDPUtils.exitData.length);//设置包中数据为退出标志 dsk.send(dpk);//发送退出标志 break;//退出 &#125; bos.write(buf, 0, readSize);//将字节数组中的数据写入缓冲流 if (++flushSize % 1000 == 0) &#123; flushSize = 0; bos.flush(); &#125; dpk.setData(UDPUtils.successData, 0, UDPUtils.successData.length);//设置包中数据为接收成功标志 dsk.send(dpk);//返回一个接收成功标志 dpk.setData(buf, 0, buf.length);//重新设置包用于接收下一个数据包 System.out.println("receive count of " + (++readCount) + " !"); dsk.receive(dpk);//等待客户端发送文件 &#125; // last flush bos.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (bos != null) bos.close(); if (dsk != null) dsk.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; UDPUtils.java1234567891011121314151617181920212223242526272829303132333435363738394041424344public class UDPUtils &#123; private UDPUtils() &#123; &#125; /** transfer file byte buffer **/ public static final int BUFFER_SIZE = 50 * 1024; /** controller port **/ public static final int PORT = 50000; /** mark transfer success **/ public static final byte[] successData = "success data mark".getBytes(); /** mark transfer exit **/ public static final byte[] exitData = "exit data mark".getBytes(); /** * compare byteArray equest successData * * @param compareBuf * src * @param buf * target * @return */ public static boolean isEqualsByteArray(byte[] compareBuf, byte[] buf, int len) &#123; if (buf == null || buf.length == 0 || compareBuf.length &lt; len) return false; boolean flag = true; int innerMinLen = Math.min(compareBuf.length, len); // if(buf.length == compareBuf.length)&#123; for (int i = 0; i &lt; innerMinLen; i++) &#123; if (buf[i] != compareBuf[i]) &#123; flag = false; break; &#125; &#125; // &#125;else // return false; return flag; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP通信-AES和Base64加解密]]></title>
    <url>%2F2017%2F12%2F04%2FUDP%E9%80%9A%E4%BF%A1-AES%E5%92%8CBase64%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[基于UDP的通信和基于TCP的通信不同，基于UDP的信息传递更快，但不提供可靠性保证。也就是说，数据在传输时，用户无法知道能否正确地到达目的地主机，也不能确定数据到达目的地地顺序是否和发送地顺序相同。基于UDP通信地基本模式如下:(1)将数据打包，称为数据包，然后将数据包发往目的地。(2)接收别人发来地数据包，然后查看数据包中地内容。 发送数据包用DatagramPacket类将数据打包，即用DatagramPacket类创建一个对象，称为数据包。用DatagramPacket地以下两个构造方法创建待发送地数据包: DatagramPacket(byte data[], int length, InetAddtress address, int port);使用该构造方法创建地数据包对象具有下列两个性质：(1)含有data数组指定地数据(2)该数据包将发送到地址是adress、端口号是port的主机上。用DatagramSocket类的不带参数的构造方法DatagramSocket()创建一个对象，该对象负责发送数据包。例如: DatagramSocket mail_out= new DatagramSocket();mail_out.send(data_pack); 下面附上Mac.java, 其中使用了AES和Base64加解密。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import java.net.*;import java.text.SimpleDateFormat;import java.util.Date;import java.awt.event.*;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import javax.swing.*;import org.apache.commons.codec.binary.Base64;public class Mac&#123; public static void main(String[] args) &#123; MaCs maC= new MaCs(); &#125; &#125;class MaCs extends JFrame implements Runnable, ActionListener, KeyListener&#123; SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); JTextField out_message1= new JTextField(12); JTextArea in_message= new JTextArea(); JButton send= new JButton("发送"); String password = "ABCDEFGHIJKLMNOP"; MaCs()&#123; setTitle("SS"); setSize(400, 200); setBounds(700, 200, 350, 300); setVisible(true); send.addActionListener(this); out_message1.addKeyListener(this); JPanel pSouthJPanel= new JPanel(); pSouthJPanel.add(out_message1); pSouthJPanel.add(send); add(pSouthJPanel, "South"); add(new JScrollPane(in_message), "Center"); in_message.setEditable(false); validate(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Thread thread= new Thread(this); thread.start();//线程负责接收数据包 &#125; /** * 使用参数中的密钥加密 */ public static String Encrypt(String sSrc, String sKey) &#123; try&#123; if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); //SecretKeySpec类是KeySpec接口的实现类，用于构建秘密密钥规范 //构造一个用AES算法加密的密钥 Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//"算法/模式/补码方式，创建密码器" cipher.init(Cipher.ENCRYPT_MODE, skeySpec);//初始化为加密模式的密码器 //Cipher为加密解密提供密码功能 byte[] encrypted = cipher.doFinal(sSrc.getBytes("utf-8"));//加密 return new Base64().encodeToString(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用。 &#125;catch(Exception e)&#123; e.printStackTrace(); //在命令行打印异常信息在程序中出错的位置及原因 return null; &#125; &#125; /** * 使用参数中的密钥解密 */ public static String Decrypt(String sSrc, String sKey) &#123; try &#123; // 判断Key是否正确 if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, skeySpec); byte[] encrypted1 = new Base64().decode(sSrc);//先用base64解密 try &#123; byte[] original = cipher.doFinal(encrypted1); String originalString = new String(original,"utf-8"); return originalString; &#125; catch (Exception e) &#123; System.out.println(e.toString()); return null; &#125; &#125; catch (Exception ex) &#123; System.out.println(ex.toString()); return null; &#125; &#125; //回车发送 public void keyPressed(KeyEvent e) &#123; // TODO Auto-generated method stub if (e.getKeyCode()== 10) &#123; (this).actionPerformed(null); &#125; &#125; @Override public void actionPerformed(ActionEvent event) &#123; // TODO Auto-generated method stub String content1 = Encrypt(out_message1.getText(), password); byte buffer[]= content1.trim().getBytes(); try &#123; InetAddress address= InetAddress.getByName("192.168.199.143"); DatagramPacket datagramPacket= new DatagramPacket(buffer, buffer.length, address, 888); DatagramSocket mailDatagramSocket= new DatagramSocket(); mailDatagramSocket.send(datagramPacket); String content2 = Decrypt(content1, password); in_message.append("----------"+ df.format(new Date())+ "----------\nss: "+ content2+ "\n"); out_message1.setText(null); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; @Override public void run() &#123; // TODO Auto-generated method stub DatagramPacket packet= null; DatagramSocket mailDatagramSocket=null; byte data[]= new byte[8192];//定义数据包的大小 try&#123; packet= new DatagramPacket(data, data.length); mailDatagramSocket= new DatagramSocket(666); &#125; catch(Exception e)&#123; &#125; while(true)&#123; if (mailDatagramSocket== null) &#123; break; &#125; else &#123; try &#123; mailDatagramSocket.receive(packet);//可能会发生堵塞，直到收到数据包 String mesString= new String(packet.getData(), 0, packet.getLength()); String content3 = Decrypt(mesString, password); //System.out.println("123"); in_message.append("**********"+ df.format(new Date())+ "**********\n"); in_message.append("mc: "+ content3+ "\n"); &#125; catch (Exception e1) &#123; // TODO: handle exception &#125; &#125; &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; // TODO Auto-generated method stub &#125; @Override public void keyTyped(KeyEvent e) &#123; // TODO Auto-generated method stub &#125; &#125; 接收数据包用DatagramSocket的另一个构造方法DatagramSocket(int port)创建一个对象，其中的参数必须和待接收的数据包的端口号相同。例如，如果发送方发送的数据包的端口是5666，那么如下创建DatagramSocket对象:DatagramSocket mail_in= new DatagramSocket(5666);然后对象maill_in使用方法receive(DatagramPacket pack)接收数据包。该方法有一个数据包参数pack，方法receive把收到的数据包传递给该参数。因此，用户必须预备一个数据包，以便收取数据包。这时需使用DatagramPack类的另一个构造方法DatagramPacket(byte data[], int length)创建一个数据包，用于接收数据包，例如: byte data[]= new byte[100];int length= 90;DatagramPacket pack= new DatagramPacket(data, length);mail_in.receive(pack); 该数据包pack将接收长度是length字节的数据放入data。值得注意的是: receive方法可能会堵塞，直到收到数据包。下面附上Shens.java, 其中同样使用了AES、Base64加解密。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183import java.net.*;import java.text.SimpleDateFormat;import java.util.Date;import java.awt.event.*;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import javax.swing.*;import org.apache.commons.codec.binary.Base64;public class Shens&#123; public static void main(String[] args) &#123; ShenSs shenS= new ShenSs(); &#125;&#125;class ShenSs extends JFrame implements Runnable, ActionListener, KeyListener&#123; SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); JTextField out_message= new JTextField(12); JTextArea in_message= new JTextArea(); JButton send=new JButton("发送"); String password = "ABCDEFGHIJKLMNOP"; ShenSs()&#123; setTitle("MC"); //setSize(400, 200); setBounds(300, 200, 350, 300); setVisible(true); send.addActionListener(this); out_message.addKeyListener(this); JPanel panel= new JPanel();//创建一个面板，里面可以布局 panel.add(out_message); panel.add(send); add(panel, "South"); add(new JScrollPane(in_message), "Center"); in_message.setEditable(false); validate();//验证此容器及所有组件 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Thread thread= new Thread(this); thread.start();//线程负责接收数据包 &#125; /** * 使用参数中的密钥加密 */ public static String Encrypt(String sSrc, String sKey) &#123; try&#123; if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8");//字节型数组 SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); //SecretKeySpec类是KeySpec接口的实现类，用于构建秘密密钥规范 Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//"算法/模式/补码方式" cipher.init(Cipher.ENCRYPT_MODE, skeySpec); //Cipher为加密解密提供密码功能 byte[] encrypted = cipher.doFinal(sSrc.getBytes("utf-8")); return new Base64().encodeToString(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用。 &#125;catch(Exception e)&#123; e.printStackTrace(); //在命令行打印异常信息在程序中出错的位置及原因 return null; &#125; &#125; /** * 使用参数中的密钥解密 */ public static String Decrypt(String sSrc, String sKey) &#123; try &#123; // 判断Key是否正确 if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); //SecretKeySpec类是KeySpec接口的实现类，用于构建秘密密钥规范 Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//只实例化一次 //Cipher为加密解密提供密码功能 cipher.init(Cipher.DECRYPT_MODE, skeySpec); //初始化为解密模式的密码器 byte[] encrypted1 = new Base64().decode(sSrc);//先用base64解密 try &#123; byte[] original = cipher.doFinal(encrypted1);//解密 String originalString = new String(original,"utf-8"); return originalString;//明文 &#125; catch (Exception e) &#123; System.out.println(e.toString()); return null; &#125; &#125; catch (Exception ex) &#123; System.out.println(ex.toString()); return null; &#125; &#125; //回车发送 public void keyPressed(KeyEvent e) &#123; // TODO Auto-generated method stub if (e.getKeyCode()== 10) &#123; (this).actionPerformed(null); &#125; &#125; @Override public void actionPerformed(ActionEvent event) &#123;//单击按钮发送数据包 // TODO Auto-generated method stub String content1 = Encrypt(out_message.getText(), password); byte buffer[]= content1.trim().getBytes(); try &#123; InetAddress address= InetAddress.getByName("127.0.0.1"); DatagramPacket datagramPacket= new DatagramPacket(buffer, buffer.length, address, 666); //存放数据的数据报 DatagramSocket mailDatagramSocket= new DatagramSocket(); //接受或发送数据报的套接字 mailDatagramSocket.send(datagramPacket); String content2 = Decrypt(content1, password); in_message.append("**********"+ df.format(new Date())+ "**********\nmc: "+ content2+ "\n"); out_message.setText(null); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; @Override public void run() &#123; // TODO Auto-generated method stub DatagramPacket packet= null; DatagramSocket mailDatagramSocket=null; byte data[]= new byte[8192];//指定数据包的大小 try&#123; packet= new DatagramPacket(data, data.length); mailDatagramSocket= new DatagramSocket(888); &#125; catch(Exception e)&#123; &#125; while(true)&#123; if (mailDatagramSocket== null) &#123; break; &#125; else &#123; try &#123; mailDatagramSocket.receive(packet); String mesString= new String(packet.getData(), 0, packet.getLength()); String content3 = Decrypt(mesString, password); in_message.append("----------"+ df.format(new Date())+ "----------\n"); in_message.append("ss: "+ content3+ "\n"); &#125; catch (Exception e1) &#123; // TODO: handle exception &#125; &#125; &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; // TODO Auto-generated method stub &#125; @Override public void keyTyped(KeyEvent e) &#123; // TODO Auto-generated method stub &#125;&#125; 由于使用了Base64加解密，会出现Base64 cannot be resolved to a type这个错误。可以参考我的上一篇博文，那里有解决的方法。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java解决Base64包问题]]></title>
    <url>%2F2017%2F11%2F28%2FJava%E8%A7%A3%E5%86%B3Base64%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[java中使用AES对数据进行加解密算法模式：ECB 密钥 长度：128bits 16位长 偏移量： 默认 补码方式：PKCS5Padding 解密串编码方式：base64密钥为16位长度的字符串1234567891011121314151617181920212223242526272829/** * 使用参数中的密钥加密 * @param 明文 * @param 密钥 * @return 密文 */public static String Encrypt(String sSrc, String sKey) &#123; try&#123; if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//"算法/模式/补码方式" cipher.init(Cipher.ENCRYPT_MODE, skeySpec); byte[] encrypted = cipher.doFinal(sSrc.getBytes("utf-8")); return new Base64().encodeToString(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用。 &#125;catch(Exception e)&#123; e.printStackTrace(); return null; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/** * 使用参数中的密钥解密 * @param 密文 * @param 密钥 * @return 明文 */public static String Decrypt(String sSrc, String sKey) &#123; try &#123; // 判断Key是否正确 if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, skeySpec); byte[] encrypted1 = new Base64().decode(sSrc);//先用base64解密 try &#123; byte[] original = cipher.doFinal(encrypted1); String originalString = new String(original,"utf-8"); return originalString; &#125; catch (Exception e) &#123; System.out.println(e.toString()); return null; &#125; &#125; catch (Exception ex) &#123; System.out.println(ex.toString()); return null; &#125;&#125; 12345678测试方法String password = "ABCDEFGHIJKLMNOP";String content1 = "我的博客名是geekfly";System.out.println("加密前：" + content1); String content2 = Encrypt(content1, password);System.out.println("加密后：" + content2);String content3 = Decrypt(content2, password);System.out.println("解密后：" + content3); 在这个过程中出现个问题，base64 cannot be resolved to a type,问题显示: The import org.apache cannot be resolved.解决方法: 去 http://hc.apache.org/downloads.cgi 下载， HttpClient4.5.3.zip, 解压后得到\httpcomponents-client-4.5.3\lib, 里面有很多jar包加进来这样就好了！总结下：org.apache, 不是标准的java中的库。所以eclipse中，无法自动识别。org.apache下包括了一堆相关的库，此处用到的是org.apache.http, 所以：需要找到对应的org.apache.http相关的jar包，然后加到当前的项目中。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java获取本机外网IP]]></title>
    <url>%2F2017%2F11%2F28%2FJava%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E5%A4%96%E7%BD%91IP%2F</url>
    <content type="text"><![CDATA[一种可行的获取方法，是通过http请求从网站中取出ip字段。例如: http://ip.chinaz.com/通过这个网址，加上简单的正则表达式，即可得到123456789101112131415161718192021222324252627282930313233343536373839404142public static String getV4IP()&#123; String ip = ""; String chinaz = "http://ip.chinaz.com"; StringBuilder inputLine = new StringBuilder(); String read = ""; URL url = null; HttpURLConnection urlConnection = null; BufferedReader in = null; try &#123; url = new URL(chinaz); urlConnection = (HttpURLConnection) url.openConnection(); in = new BufferedReader( new InputStreamReader(urlConnection.getInputStream(),"UTF-8")); while((read=in.readLine())!=null)&#123; inputLine.append(read+"\r\n"); &#125; //System.out.println(inputLine.toString()); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(in!=null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; Pattern p = Pattern.compile("\\&lt;dd class\\=\"fz24\"&gt;(.*?)\\&lt;\\/dd&gt;"); Matcher m = p.matcher(inputLine.toString()); if(m.find())&#123; String ipstr = m.group(1); ip = ipstr; //System.out.println(ipstr); &#125; return ip;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CLOCK置换算法]]></title>
    <url>%2F2017%2F11%2F13%2FCLOCK%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在请求分页存储管理系统中，若为进程分配的物理块为4，开始执行时内存中没有装入任何页面，若进程依次访问的页面号为：7，1，6，4，6，2，3，0，3，1，0，7，6，0，1，3，6，3，0，7，2，0，5请用CLOCK算法完成作业(低物理地址优先)红色代表访问位为1，星号表示替换指针的位置 缺页次数: 14次缺页率: 14/23= 60.9%置换次数: 10次依次被置换的页号: 7 1 6 4 2 3 0 1 7 61234567891011121314151617181920217号页面：进程分配的物理块为4，开始执行的时候没有装入任何页面，当开始访问7号页面的时候，内存中没有该页面号，将页面直接调入内存，低物理地址优先，将页面放入第一个物理块，把访问位置为1.1、6、4号页面：访问1号页面的时候，内存中没有该页面号，且内存中还有空位，将1、6、4号页面放入内存，把访问位置为1，替换指针指向最高地址的物理块。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查4号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查4号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。7号页面：访问7号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查2号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查9号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查3号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。7号页面：访问7号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。5号页面：访问5号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟存储器]]></title>
    <url>%2F2017%2F11%2F12%2F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1、什么是虚拟存储器？（虚存）1解答：虚拟存储器是由硬件和操作系统自动实现存储信息调度和管理的，是在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理贮存容量大的多，可寻址的“主存储器”。 2、为什么要引入虚拟存储器？12解答：1&gt;能提高操作系统的内存利用率和系统吞吐量 2&gt;在计算机系统中，主存的容量有一定的限制，不可能大大满足各种用户的需要，而在技术上辅助存储器却可以做的相当大。为了给大作业提供方便，使它们不再承担对主存和辅存的具体分配和管理工作，而由操作系统把主存和辅存统一管理起来。 3、虚拟存储器的特征？12345解答：虚拟存储器具有虚拟性、离散性、多次性及强对换性等特征，其中最重要的特征是虚拟性。1&gt; 虚拟性。虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际的内存容量，这是虚拟存储器所表现出的最重要的特征，也是虚拟存储器最重要的目标。2&gt; 离散性。离散性是指内存分配时采用离散分配的方式，没有离散性就不可能实现虚拟存储器。采用连续分配方式，需要将作业装入到连续的内存区域，这样需要连续地一次性申请一部分内存空间，以便将整个作业先后多次装入内存。如果仍然采用连续装入的方式，则无法实现虚拟存储功能，只有采用离散分配方式，才能为它申请内存空间，以避免浪费内存空间。3&gt; 多次性。多次性是指一个作业被分成多次调入内存运行。作业在运行时，只将当前运行的那部分程序和数据装入内存，以后再陆续从外存将需要的部分调入内存。4&gt; 对换性。对换性是指允许在作业运行过程中换进换出。允许将暂时不用的程序和数据从内存调至外存的对换区，以后需要时再从外存调入到内存。 4、虚存可以建立在分区分配管理的基础上吗？为什么？1解答：不可以。在虚拟存储器中，允许将一个作业分多次调入内存。入宫采用连续分配方式时，应将作业装入一个连续的内存区域中。为此，需事先为它一次性地申请足够的内存空间，以便将整个作业先后分多次装入内存，这不仅会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟存储器的实现都是建立在离散分配存储管理方式的基础上。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生苦短]]></title>
    <url>%2F2017%2F11%2F10%2F%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%2F</url>
    <content type="text"><![CDATA[用Wireshark打开这个流量包点文件中的导出对象，选HTTP，发现其中有如下文件在010编辑器中打开，发现flagaa中有压缩包的头部，flagaf中有压缩包的尾部，猜测应该是压缩包分解成aa-af，拼凑一下，导出压缩包解压此压缩包，发现有密码先尝试用Ziperello爆破下没有加密文件，发现它是伪加密压缩包打开，得flag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RGB]]></title>
    <url>%2F2017%2F11%2F10%2FRGB%2F</url>
    <content type="text"><![CDATA[python脚本之RGB，将其转化为图片12345678910111213141516#!/usr/bin/env pythonfrom PIL import ImageMAX = 280pic = Image.new("RGB",(MAX, MAX))file = open("flag.txt",'r')m = file.read().split('\n')i=0for y in range (0,MAX): for x in range (0,MAX): if(m[i] == '(0, 0, 0)'): pic.putpixel([x,y],(0, 0, 0)) else: pic.putpixel([x,y],(255,255,255)) i = i+1pic.show()pic.save("flag.png")]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base混合解密]]></title>
    <url>%2F2017%2F11%2F10%2Fbase%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[Base64和Base32混合解密脚本12345678910111213import base64file = open('base.txt','r')st = file.read()while True: try: st = base64.b16decode(st) except: try: st = base64.b32decode(st) except: st = base64.b64decode(st) if(st.find('flag') == 0): print(st)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware Workstation 14黑屏问题及密钥]]></title>
    <url>%2F2017%2F11%2F08%2FVMware-Workstation-14%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98%E5%8F%8A%E5%AF%86%E9%92%A5%2F</url>
    <content type="text"><![CDATA[今儿个升级VM到14，完事后打开VM，想用下kali，却发现进入黑屏，如论如何都不能解决，没办法，拜访了下度娘。首先上VM的密钥：VMware Workstation Pro 14 许可证序列号：FF590-2DX83-M81LZ-XDM7E-MKUT4CG54H-D8D0H-H8DHY-C6X7X-N2KG6ZC3WK-AFXEK-488JP-A7MQX-XL8YFAC5XK-0ZD4H-088HP-9NQZV-ZG2R4ZC5XK-A6E0M-080XQ-04ZZG-YF08DZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8 黑屏问题解决:1以管理员身份进入cmd，输入`netsh winsock reset`, 重启，问题解决 网上也有其他的解决方法，不过没试过：123以管理员身份运行命令提示符（cmd.exe），输入命令 netsh winsock show catalog可以看到VMware注册了两个LSP：vSockets DGRAM、vSockets STREAM，路径是%windir%\system32\vsocklib.dll观察有没有其他模块也注册了vSockets DGRAM、vSockets STREAM，如果有，就卸载掉这个模块所属的软件。]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example5_10]]></title>
    <url>%2F2017%2F10%2F31%2FExample5-10%2F</url>
    <content type="text"><![CDATA[写一个类，该类有一个方法，public int ff(int a, int b), 该方法返回a 和b 的最大公约数。然后再编写一个该类的子类，要求子类重写方法ff，而且重写的方法将返回a 和b 的最小公约数；要求在重写的方法的方法体中首先调用被隐藏的方法返回a 和b 的最大公约数m ，然后将乘积(a* b)/ m返回；要求在应用的程序的主类中分别使用父类和子类创建对象，并分别调用方法f 计算两个正整数的最大公约数和最小公约数。123456789101112131415161718192021222324252627282930313233class AAb&#123; public int f(int a, int b)&#123; if(b&lt; a)&#123; int temp= 0; temp= a; a= b; b= temp; &#125; int r= b% a; while(r!= 0)&#123; b= a; a= r; r= b% a; &#125; return a; &#125;&#125;class BBb extends AAb&#123; public int f(int a, int b)&#123; int division= super.f(a, b); return (a* b)/ division; &#125;&#125;public class Example5_10 &#123; public static void main(String[] args) &#123; AAb aAb= new AAb(); BBb bBb= new BBb(); System.out.println("最大公约数: "+ aAb.f(36, 24)); System.out.println("最小公倍数: "+ bBb.f(36, 24)); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example5_9]]></title>
    <url>%2F2017%2F10%2F31%2FExample5-9%2F</url>
    <content type="text"><![CDATA[写一个类Aa， 该类创建的对象可以调用方法k输出英文字母表，然后再编写一个该类的子类Bb，要求子类Bb必须继承Aa类的方法k(不允许重写)，子类创建的对象不仅可以调用方法k输出英文字母表，而且可以调用子类新增的方法g输出希腊字母表。1234567891011121314151617181920212223242526class Ab&#123; public final void k()&#123; char cStart= 'a', cEnd= 'z'; for(char c= cStart; c&lt;= cEnd; c++)&#123; System.out.print(" "+ c); &#125; &#125;&#125;class Ba extends Ab&#123; public void g()&#123; char cStart= 'α', cEnd= 'ω'; for(char c= cStart; c&lt;= cEnd; c++)&#123; System.out.print(" "+ c); &#125; &#125;&#125;public class Example5_9 &#123; public static void main(String[] args) &#123; Ba ba=new Ba(); ba.k(); System.out.println(""); ba.g(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java连接MySQL数据库]]></title>
    <url>%2F2017%2F10%2F29%2FJava%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[工具：eclipseMySQL5.5MySQL连接驱动：mysql-connector-java-5.1.44-bin.jar Java编译器是eclipse，下载mysql-connector-java-5.1.44-bin.jar，我下的是最新版。加载驱动：1、在工程目录中创建lib文件夹，将下载好的JDBC放到该文件夹下，如图所示：2、右键工程名，点击Properties 选择Java Build Path中的Libraries，点击Add JARs…, 选择刚才添加的JDBC，如下图:3、配置好MySQL，添加一个用户，用户名是style,密码是1234, 创建一个数据库, 数据库名是student。创建表： create table students( -&gt; sno int(10) not null, -&gt; sname varchar(8) not null, -&gt; sex char(2) not null, -&gt; bdate date not null, -&gt; height dec(5,2) default 000.00, -&gt; primary key(sno)); 然后插入一条数据： insert into students(sno,sname,sex,bdate,height) values(‘1’,’gfa’,’男’,’2017-10-29’,’fwef’); 创建好数据库后, 编写Java文件来访问MySQL数据库。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package sqldemo;import java.sql.*;public class mains &#123; public static void main(String[] args) &#123; //声明Connection对象 Connection con; //驱动程序名 String driver = "com.mysql.jdbc.Driver"; //URL指向要访问的数据库名student String url = "jdbc:mysql://localhost:3306/student"; //MySQL配置时的用户名 String user = "style"; //MySQL配置时的密码 String password = "1234"; //遍历查询结果集 try &#123; //加载驱动程序 Class.forName(driver); //1.getConnection()方法，连接MySQL数据库！！ con = DriverManager.getConnection(url,user,password); if(!con.isClosed()) System.out.println("Succeeded connecting to the Database!"); //2.创建statement类对象，用来执行SQL语句！！ Statement statement = con.createStatement(); //要执行的SQL语句 String sql = "select * from students"; //3.ResultSet类，用来存放获取的结果集！！ ResultSet rs = statement.executeQuery(sql); System.out.println("-----------------"); System.out.println("执行结果如下所示:"); System.out.println("-----------------"); System.out.println("姓名" + "\t" + "性别"); System.out.println("-----------------"); String job = null; String id = null; while(rs.next())&#123; //获取stuname这列数据 job = rs.getString("sname"); //获取stuid这列数据 id = rs.getString("sex"); //输出结果 System.out.println(job + "\t" + id); &#125; rs.close(); con.close(); &#125; catch(ClassNotFoundException e) &#123; //数据库驱动类异常处理 System.out.println("Sorry,can`t find the Driver!"); e.printStackTrace(); &#125; catch(SQLException e) &#123; //数据库连接失败异常处理 e.printStackTrace(); &#125;catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally&#123; System.out.println("数据库数据获取成功！"); &#125; &#125;&#125; 运行结果如图所示：]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[txt文件导入MySQL]]></title>
    <url>%2F2017%2F10%2F28%2Ftxt%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5MySQL%2F</url>
    <content type="text"><![CDATA[创建数据表 CRETE TABLE tes(NAME VARCHAR(20) NULL,SEX VARCHAR(5) NULL,STUDENTID INT(20) NULL);txt文件中的内容如下你好 男 123世界 女 456啦啦啦 男 485 中间空格部分是TAB键, 保存为UTF-8编码.导入txt文件 load data local infile ‘C:/文件名.txt’ into table 数据表名; 如果第一行开头出现特殊符号，我的解决方法是在第一行中增加一行可以删去的信息，等导入数据库后，DELETE FROM 数据库表 WHERE 字段=&#39;字段对应的唯一信息&#39;;删除第一行就行。但这只是治标不治本，希望大家能提出宝贵的建议，共同学习。 导入数据库到MySQL mysql -u root -p &lt; 数据库文件名 回车后输入数据库密码，即可导入成功。 导出数据库 mysqldump -u root -p 数据库名 &gt; 要保存的数据库文件名 回车后输入数据库密码，导出的数据库在当前目录。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地连接腾讯云MySQL]]></title>
    <url>%2F2017%2F10%2F28%2F%E6%9C%AC%E5%9C%B0%E8%BF%9E%E6%8E%A5%E8%85%BE%E8%AE%AF%E4%BA%91MySQL%2F</url>
    <content type="text"><![CDATA[在腾讯云的MySQL中先新建一个用户，用于远程登录账号。环境是centos7登录MySQL mysql -u root -p 回车后输入密码 创建用户 允许本地IP访问localhost create user ‘style’@’localhost’ identified by ‘123456’; 用户名是style，密码是123456; 允许外网IP访问 create user ‘style’@’%’ identified by ‘123456’; 刷新授权 flush privileges; 为用户创建数据库 数据库名是student create database student DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 为新用户分配权限 授予用户通过外网IP对于该数据库的全部权限 grant all privileges on student.* to ‘style’@’%’ identified by ‘1234’; 授予用户在本地服务器对该数据库的全部权限 grant all privileges on student.* to ‘style’@’localhost’ identified by ‘1234’; 刷新权限 flush privileges; 退出root重新登录 exit 用新账号style重新登录，由于使用的是 % 任意IP连接， 所以需要指定外部访问IP mysql -h 腾讯云的公网IP -u用户名 -p密码 登录成功！ 查询用户权限 show grants for style 赋予权限 grant all privileges on . to ‘style’@’%’ identified by ‘1234’; 授予style用户在所有数据库上的所有权限 如果此时发现刚刚给的权限太大了，如果我们只想授予它在某个数据库上的权限，那么需要切换到root用户撤销刚才的权限，重新授权 revoke all privileges on . from ‘style’@’%’;grant all privileges on student.* to ‘style`@’%’ identified by ‘1234’; 甚至还可以指定该用户只能执行select和update命令 grant select, update on student.* to ‘style’@’%’ identified by ‘1234’; 这样一来，再次以style用户登录MySQL，只有student数据库是对其可见的，并且如果你只授权它select权限，那么它就不能执行delete语句 每当调整权限后，通常需要执行以下语句来刷新权限 flush privileges; 删除创建的用户 drop user style@’%’; 可用如下命令查看相应用户及对应的host select host, user from user; MarkSown语法用的不是很好，有些符号没有显示，以下图为准]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改MySQL密码]]></title>
    <url>%2F2017%2F10%2F27%2F%E4%BF%AE%E6%94%B9MySQL%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在DOS下执行：mysql -u root -p然后输入旧的密码，如果是第一次进入，则直接回车mysql&gt;show databases;mysql&gt;use mysql;注意一定先执行use mysql;再执行下面命令设置密码，如新密码123456mysql&gt;UPDATE user SET password=PASSWORD(&#39;123456&#39;) WHERE user=&#39;root&#39;;mysql&gt;FLUSH PRIVILEGES;mysql&gt;exit; 附上常用mysql命令(win8.1以管理员身份执行win+x+a):安装mysql服务：mysqld -install卸载mysql服务：mysqld -remove启动mysql服务：net start mysql停止mysql服务：net stop mysql 如果启动mysql服务出现1067错误码尝试清理datadir目录下的以下文件：auto.cnf、Cryhelyxx-pc.err、Cryhelyxx-pc.pid、ib_logfile0、ib_logfile1、ibdata1、ibtmp1注意：在清理之前请备份好数据库，否则后果自负，并再次启动mysql服务：net start mysql。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 安装问题]]></title>
    <url>%2F2017%2F10%2F10%2FAndroid-Studio-%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装android studio的时候，出现几个错误，在此记录下。第一个是出现这个解决方法：在自己的android studio安装目录下找到这个文件idea.properties,在最后面添加一行disable.android.first.run=true 第二个是出现这个(图是百度的==当时没保存下来)解决方法：SDK的目录名称不能有汉字，换个路径 第三个是出现这个解决方法：点击右下角的Configure点击project Defaults,点击Project Structure,填入SDK的地址 第四个是出现这个解决方法：SDK的目录不能有空格，换路径]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[super关键字]]></title>
    <url>%2F2017%2F09%2F28%2Fsuper%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[使用super调用父类的构造方法子类不继承父类的构造方法，因此，子类如果想使用父类的构造方法，必须在子类的构造方法中使用，必须使用关键字super来表示，而且super必须是子类构造方法中的头一条语句Student5_6.java1234567891011121314151617public class Student5_6 &#123; int number; String name; Student5_6()&#123; &#125; Student5_6(int number, String name)&#123; this.number= number; this.name= name; &#125; public int getNumber()&#123; return number; &#125; public String getName() &#123; return name; &#125;&#125; UniverStudent.java123456789public class UniverStudent extends Student5_6 &#123; boolean isNarriage;//子类新增的结婚属性 UniverStudent(int number, String name, boolean v)&#123; super(number, name);//调用父类的构造方法 &#125; public boolean getIsNarriage()&#123; return isNarriage; &#125;&#125; Example5_6.java123456789101112131415public class Example5_6 &#123; public static void main(String[] args) &#123; UniverStudent zhangStudent= new UniverStudent(20111, "张三", false); int number= zhangStudent.getNumber(); String name= zhangStudent.getName(); boolean marriage= zhangStudent.getIsNarriage(); System.out.println(name+ "的学号是: "+ number); if(marriage== true)&#123; System.out.println(name+ "已婚"); &#125; else &#123; System.out.println(name+ "未婚"); &#125; &#125;&#125; 使用super操作被隐藏的成员变量和方法如果在子类中想使用被子类隐藏的成员变量或方法，可以使用关键字super，super.x、super.play()，就是访问和调用被子类隐藏的成员变量x和方法play()Sum.java12345678910public class Sum &#123; int n; public double f()&#123; double sum= 0; for(int i= 1; i&lt;= n;i++)&#123; sum= sum+ i; &#125; return sum; &#125;&#125; Average.java1234567891011121314public class Average extends Sum &#123; double nm; public double fq()&#123; double c; super.n= (int)nm; c= super.f(); return c+ nm; &#125; public double g()&#123; double c; c= super.f(); return c- nm; &#125;&#125; Example5_7.java12345678910public class Example5_7 &#123; public static void main(String[] args) &#123; Average average= new Average(); average.nm= 100.5678; double result1= average.fq(); double result2= average.g(); System.out.println("result1= "+ result1); System.out.println("result2= "+ result2); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法内部类]]></title>
    <url>%2F2017%2F09%2F26%2F%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。1234567891011121314151617181920212223242526//外部类public class HelloWorld &#123; private String name = "爱慕课"; // 外部类中的show方法 public void show() &#123; // 定义方法内部类 class MInner &#123; int score = 83; public int getScore() &#123; return score + 10; &#125; &#125; // 创建方法内部类的对象 MInner mi= new MInner(); // 调用内部类的方法 int newScore= mi.getScore(); System.out.println("姓名：" + name + "\n加分后的成绩：" + newScore); &#125; // 测试方法内部类 public static void main(String[] args) &#123; // 创建外部类的对象 HelloWorld mo= new HelloWorld(); // 调用外部类的方法 mo.show(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成员内部类与静态内部类]]></title>
    <url>%2F2017%2F09%2F26%2F%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类中最常见的就是成员内部类，也称为普通内部类123456789101112131415161718192021222324252627//外部类HelloWorldpublic class HelloWorld&#123; //外部类的私有属性name private String name = "imooc"; //外部类的成员属性 int age = 20; //成员内部类Inner public class Inner &#123; String name = "爱慕课"; //内部类中的方法 public void show() &#123; System.out.println("外部类中的name：" + HelloWorld.this.name); System.out.println("内部类中的name：" + name); System.out.println("外部类中的age：" + age); &#125; &#125; //测试成员内部类 public static void main(String[] args) &#123; //创建外部类的对象 HelloWorld o = new HelloWorld (); //创建内部类的对象 Inner inn = o.new Inner(); //调用内部类对象的show方法 inn.show(); //外部类不能直接使用内部类的成员何方法，如show(); &#125;&#125; 静态内部类是static修饰的内部类，这种内部类的特点是:静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员； 如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();123456789101112131415161718192021//外部类public class HelloWorld &#123; // 外部类中的静态变量score private static int score = 84; // 创建静态内部类 public static class SInner &#123; // 内部类中的变量score int score = 91; public void show() &#123; System.out.println("访问外部类中的score：" + HelloWorld.score); System.out.println("访问内部类中的score：" + score); &#125; &#125; // 测试静态内部类 public static void main(String[] args) &#123; // 直接创建内部类的对象 SInner si= new SInner(); // 调用show方法 si.show(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2017%2F09%2F26%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类内部类的方法可以直接访问外部类的所有数据，包括私有的数据内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便内部类分为：成员内部类、静态内部类、方法内部类、匿名内部类1234567891011121314151617public class neibulei &#123; //内部类Inner，类Inner在类neibulei的内部 public class Inner&#123; //内部类的方法 public void show()&#123; System.out.println("Hello World!"); &#125; &#125; public static void main(String[] args)&#123; //创建外部类对象 neibulei neibulei= new neibulei(); //创建内部类对象 Inner inner= neibulei.new Inner(); //调用内部类对象的方法 inner.show(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可变参数]]></title>
    <url>%2F2017%2F09%2F26%2F%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[x是可变参数的代表，代表若干哥int型参数x.length是x代表的参数的个数x[i]是x代表的第i个参数(类似数组)123456789101112public class Example4_11 &#123; public static void main(String[] args) &#123; f(1,2); f(-1, -2, -3, -4); f(9, 7, 6); &#125; public static void f(int ... x)&#123; for(int i=0; i&lt; x.length; i++)&#123; System.out.println(x[i]); &#125; &#125;&#125; 上面的方法输出的是一个数字一行，觉得不好看，改版如下print输出不换行，println输出换行12345678910111213public class Example4_11 &#123; public static void main(String[] args) &#123; f(1,2); f(-1, -2, -3, -4); f(9, 7, 6); &#125; public static void f(int ... x)&#123; for(int i=0; i&lt; x.length-1; i++)&#123; System.out.print(x[i]); &#125; System.out.println(x[x.length-1]); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static]]></title>
    <url>%2F2017%2F09%2F26%2Fstatic%2F</url>
    <content type="text"><![CDATA[static存在的时候，调用b2.setN(5)，sum=6，去掉static，sum从0开始123456789101112131415161718192021222324252627class B&#123; int n; static int sum= 0; void setN(int n)&#123; this.n= n; System.out.println("this.n= "+ this.n); &#125; int getSum()&#123; for(int i= 1;i&lt;= n; i++)&#123; sum= sum+ i; &#125; System.out.println(sum); return sum; &#125; &#125;public class Example4_9 &#123; public static void main(String[] args) &#123; B b1=new B(), b2= new B(); b1.setN(3); b2.setN(5); int a1= b1.getSum(); int a2= b2.getSum(); System.out.println(a1+ a2); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[enum问题]]></title>
    <url>%2F2017%2F09%2F23%2Fenum%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天有个想法，是输出每个月的天数，正好最近学了enum，就想用这个来做。 &lt;!--more--&gt; 说干就干，啪啪啪啪...咦~有个错误，我改我改我改！ 然而改了多次，还是没成功，最后根据错误提示问了下度娘，说是格式有误。 我就想，是不是不能重复内容，我改我改，改到enum里面的内容只有两位31，30，还真是！ 但还是有相同的错误，又想了想，前面加上月份呢？ 啪！问题解决123456789101112enum Tian&#123; 一月31天, 二月28天, 三月31天, 四月30天, 五月31天, 六月30天, 七月31天, 八月31天, 九月30天, 十月31天, 十一月30天, 十二月31天&#125;public class Java &#123; public static void main(String[] args) &#123; for(Tian a: Tian.values())&#123; System.out.println(a); &#125; &#125;&#125; 总结: enum中的内容不能重复，enum中的内容不能只是数字,不然会出现Syntax error on token(s), misplaced constructs(s)这个错误]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse快捷键]]></title>
    <url>%2F2017%2F09%2F23%2Feclipse%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[eclipse常用快捷键12345678910Syso+alt+/ 快速输出代码Ctrl+shift+f 快速调整代码格式Ctrl+D 快速删除光标所在的行shift+回车 当输入代码较长的时候换行ctrl+F11 运行Alt+上下箭头 快速移动光标所在的行代码Ctrl+alt+上下箭头 快速复制光标所在行代码Alt+/ 快速补全代码Ctrl+/ 快速添加单行注释Ctrl+shift+/ 添加多行注释 小常识 打开eclipse，在上方的菜单栏中找到Window选中Preferences，点击Java–&gt;Editor–&gt;Content在红框中输入下面一行字符串，点击OK，退出。1.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 输入这一串，敲代码的时候可以智能提示 包的命名规则123456**.**(对应项目的名字).**（项目功能）com 公司 org 组织model 模型util 工具edu 教育]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小型通讯录]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%B0%8F%E5%9E%8B%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[定义Friend类，编写它具有的属性：姓名(name)、电话(phone)、邮箱(email)和公司(comp)以及它的方法showInfo()。编写测试类AddFriend，实现添加联系人的功能(从键盘输入)1234567891011121314151617181920212223242526272829303132//AddFriend.javaimport java.util.Scanner;public class AddFried &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Friend friend= new Friend(); Scanner inputScanner= new Scanner(System.in); System.out.println("请输入联系人姓名: "); friend.setName(inputScanner.next()); System.out.println("请输入联系人电话: "); friend.setPhone(inputScanner.next()); System.out.println("请输入联系人电子邮箱: "); friend.setEmail(inputScanner.next()); System.out.println("请输入联系人公司: "); friend.setComp(inputScanner.next()); friend.showInfo(); // friend.name= "花千骨";// friend.showInfo(); /* * 没有封装，将String name等四个变量封装为private就行 * 封装：把不想或不该告诉别人的事情隐藏起来 * 具体做法：将属性私有化，提供公有化的方法来访问属性 * */ inputScanner.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940//Friend.javapublic class Friend &#123; String name;// 默认private String phone; String email; String comp; public void setName(String name) &#123; this.name= name;// 访问本类中的属性和方法 &#125; public String getName()&#123; return name; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getComp() &#123; return comp; &#125; public void setComp(String comp) &#123; this.comp = comp; &#125; public void showInfo()&#123; System.out.println("新朋友的联系信息为: "); System.out.println("姓名: "+ this.getName()); System.out.println("电话: "+ this.getPhone()); System.out.println("电子邮箱: "+ this.getEmail()); System.out.println("公司: "+ this.hashCode()); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[竞猜商品]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%AB%9E%E7%8C%9C%E5%95%86%E5%93%81%2F</url>
    <content type="text"><![CDATA[电视商品价格竞猜活动， 活动规则是：随机出现一个商品名，用户猜测它的价格，连续猜测5次，如果猜对便可获得此商品提示：(1)定义GuessMachine，编写它的initial方法，预定义商品信息根据产生的随机数字，选定一款竞猜商品(2)编写GuessMachine的guess方法，如果猜测正确，返回“猜对了，恭喜中奖！”，价格偏高，提示高了，偏低，提示低了。(3)编写测试类模拟竞猜，产生随机数 Math.radom();只产生0.0~1.0之间的数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//GuessMachineimport java.util.Scanner;public class GuessMachine &#123; String mach= null; int price= 0; public void initial()&#123; int data= (int)(Math.random()* 4); switch(data)&#123; case 0: mach= "电视机"; price= 3359; break; case 1: mach= "电冰箱"; price= 1243; break; case 2: mach= "油烟机"; price= 4654; break; case 3: mach= "ipthone"; price= 2324; break; case 4: mach= "洗衣机"; price= 5643; break; default: break; &#125;// System.out.println(data);// System.out.println("请输出"+ mach+ "的价格: "); &#125; public void guess() &#123; Scanner inpScanner= new Scanner(System.in); int guess= 0;//用户输入的价格 int i= 0;//用户猜价格的次数 while(i&lt; 5)&#123; System.out.println("请输入您竞猜的价格: "); guess= inpScanner.nextInt(); if(price== guess)&#123; System.out.println("猜对了，恭喜中奖！"); &#125;else if(price&gt; guess) &#123; System.out.println("低了，请高一点。"); &#125;else if (price&lt; guess) &#123; System.out.println("高了， 请低一点。"); &#125; i++; &#125; if(i&gt;= 5)&#123; System.out.println("您已经猜奖5次，欢迎下次光临！"); &#125; inpScanner.close(); &#125; &#125; 123456789101112//Test.javapackage com.cnstrong.com;public class Test &#123; public static void main(String[] args)&#123; GuessMachine gMachine= new GuessMachine(); gMachine.initial();//初始化 gMachine.guess(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base32解密]]></title>
    <url>%2F2017%2F09%2F23%2Fbase32%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[运行环境python2.712import base64print base64.b32decode("NNSXS63JONRWGY3GOJTGO5DBMVTGCZ3SNB2H2===")]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列置换]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%88%97%E7%BD%AE%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[运行环境python2.7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#!usr/bin/env python#-*- coding:utf-8 -*-from itertools import *from optparse import *def start(): opt = OptionParser() opt.add_option('-c',dest='content',help='Input your content') opt.add_option('-o',dest='output',help='File to save the result') get,args = opt.parse_args() if get.content is None or get.output is None: print 'Use \'help\' to get help' exit(0) return get.content,get.outputdef Exp(content,output): for i in range(2,len(content)): if len(content)%i == 0: filename = open(output,'a+') getList = Code(i) getCo = SplitStr(i,content) for num in getList: get = '' for s in getCo: for one in num: get = get + s[int(one):int(one)+1] filename.write(get+'\n') filename.close() print 'The result is saved as ' + outputdef SplitStr(num,content): result = [] for i in range(len(content)/num): result.append(content[i*num:(i+1)*num]) return resultdef Code(num): number = '' result = [] for i in range(num): number = number + str(i) for i in permutations(number,num): result.append(i) return resultdef main(): content,output = start() Exp(content,output)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大小写转换]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[运行环境python31234567891011121314151617181920def UCaseChar(ch): if ord(ch) in range(97, 122): return chr(ord(ch) - 32) else: return ch def LCaseChar(ch): if ord(ch) in range(65, 91): return chr(ord(ch) + 32) else: return ch def UCase(str): return ''.join(map(UCaseChar, str)) def LCase(str): return ''.join(map(LCaseChar, str)) print (LCase('ABC我abc')) print (UCase('ABC我abc'))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移位]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%A7%BB%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[运行环境python2.7123456789key='CRL'.upper()for i in range(0,26): flag='' for j in key: if j.isalpha(): flag+=chr(((ord(j)-ord('A')+i)%26)+ord('A')) else: flag+=j print str(i).zfill(2),flag]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串转莫尔斯]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E8%8E%AB%E5%B0%94%E6%96%AF%2F</url>
    <content type="text"><![CDATA[运行环境python3123456789101112131415161718192021222324252627CODE = &#123;'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' &#125;def main(): msg = input('MESSAGE: ') for char in msg: if char == ' ': print else: print (CODE[char.upper()] + ' ',)if __name__ == "__main__": main()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转换字符串为莫尔斯]]></title>
    <url>%2F2017%2F09%2F23%2F%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BA%E8%8E%AB%E5%B0%94%E6%96%AF%2F</url>
    <content type="text"><![CDATA[请在python3环境下运行12345678chars = ",.0123456789?abcdefghijklmnopqrstuvwxyz"codes = """--..-- .-.-.- ----- .---- ..--- ...-- ....- ..... -.... --... ---.. ----. ..--.. .- -... -.-. -... . ..-. --. .... .. .--- -.- .-.. -- -. --- .--. --.- .-. ... - ..- ...- .-- -..- -.-- --.."""keys = dict(zip(chars, codes.split()))def char2morse(char): return keys.get(char.lower(), char)print (' '.join(char2morse(c) for c in 'SOS'))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[维吉尼亚]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%2F</url>
    <content type="text"><![CDATA[运行环境python312345678910111213141516171819key='helloworld'plaintext='whereisthekey'#key='relations'#plaintext='tobeornottobeth' ascii='abcdefghijklmnopqrstuvwxyz'keylen=len(key)ptlen=len(plaintext)ciphertext = ''i = 0while i &lt; ptlen: j = i % keylen k = ascii.index(key[j]) m = ascii.index(plaintext[i]) ciphertext += ascii[(m+k)%26] i += 1 print (ciphertext)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n次base64解密]]></title>
    <url>%2F2017%2F09%2F23%2Fn%E6%AC%A1base64%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[运行环境python31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import base64str = '''Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSWFJteFZVMjA1VjAxV2JETlhhMk0xVmpKS1NHVkVRbUZXVmxsM1ZtcEJlRll5U2tWVWJHaG9UVlZ3VlZacVFtRlRNbEpJVm10a1dHSkdjSEJXYTFwaFpWWmFkRTFVVWxSTmF6RTFWa2QwYzJGc1NuUmhSemxWVmpOT00xcFZXbUZrUjA1R1drWlNUbUpGY0VwV2JURXdZVEZrU0ZOclpHcFNWR3hoV1d4U1IyUnNXbGRYYlhSWFRWaENSbFpYZUhkV01ERkZVbFJDVjAxdVVuWldha3BIVmpGT2RWVnNXbWhsYlhob1ZtMXdUMkl5UmtkalJtUllZbGhTV0ZSV2FFTlNiRnBZWlVoa1YwMUVSa1pWYkZKRFZqSkdjbUV6YUZaaGExcG9WakJhVDJOdFJrZFhiV2hzWWxob2IxWnRNWGRVTVZWNVVtdGtWMWRIYUZsWmJGWmhZMVphZEdONlJteFNiSEJaV2xWb2ExWXdNVVZTYTFwV1lrWktSRlpxU2tabFZsSlpZVVprVTFKV2NIbFdWRUpoVkRKT2MyTkZhR3BTYkVwVVZteG9RMWRzV25KWGJHUmFWakZHTkZaSGRHdFdiVXBIVjJ4U1dtSkhhRlJXTUZwVFZqRmtkRkp0ZUZkaVZrbzFWbXBLTkZReFdsaFRiRnBxVWxkU1lWUlZXbmRsYkZweFVtMUdUMkpGV2xwWlZWcHJWVEZLVjJOSWJGZFdSVXBvVmtSS1QyUkdTbkphUm1ocFZqTm9WVmRXVWs5Uk1XUkhWMjVTVGxaRlNsaFVWbVEwVjBaYVdHUkhkRmhTTUhCSlZsZDRjMWR0U2toaFJsSlhUVVp3VkZacVNrZFNiRkp6Vlcxc1UwMHhSalpXYWtvd1ZURlZlRmR1U2s1WFJYQnhWVzB4YjFZeFVsaE9WemxzWWtad2VGVnRNVWRVTWtwR1YyeHdXbFpXY0hKV1ZFWkxWMVpHY21KR1pHbFhSVXBKVm10U1MxVXhXWGhXYmxaV1lsaENWRmxyVm5kV1ZscDBaVWM1VWsxWFVucFdNV2h2VjBkS1JrNVdVbFZXTTJoSVZHdGFjMk5zWkhSa1IyaHBVbGhCZDFkV1ZtOVVNVnAwVTJ4V1YyRXhTbUZhVjNSaFYwWndSbFpZYUZkTlZrcDVWR3hhVDJGV1NuUlBWRTVYVFc1b1dGbHFTa1psUm1SWldrVTFWMVpzY0ZWWFZsSkhaREZrUjJKSVRtaFNlbXhQVkZaYWQyVkdWblJsU0dScFVqQndWMVl5ZEhkV01ERnhVbXRvVjFaRldreFdNVnBIWTIxS1IxcEdaRTVOUlhCS1ZtMTBVMU14VlhoWFdHaGhVMFphVmxscldrdGpSbHB4VkcwNWEySkhVbnBYYTFKVFYyeFpkMkpFVWxkTmFsWlVWa2Q0WVZKc1RuTmhSbkJZVTBWS1NWWnFRbUZXYlZaWVZXdG9hMUp0YUZSWmJGcExVMnhrVjFadFJtcE5WMUl3Vld4b2MyRkdTbGRUYlVaaFZqTlNhRmxWV25OT2JFcHpXa2R3YVZORlNrbFdiR040WXpGVmQwMUliR2hTYlhoWVdXeG9RMVJHVW5KYVJWcHNVbTFTZWxsVldsTmhSVEZ6VTI1b1YxWjZSVEJhUkVaclVqSktTVlJ0YUZObGJYaFFWa1phWVdReVZrZFdibEpPVmxkU1YxUlhkSGRXTVd4eVZXMUdXRkl3VmpSWk1HaExWMnhhV0ZWclpHRldWMUpRVldwS1MxSXlSa2hoUlRWWFltdEtNbFp0TVRCVk1VMTRWVzVTVjJKSFVsVlpiWFIzWWpGV2NWTnRPVmRTYlhoYVdUQmFhMkV3TVZkalJteGhWbGROTVZaWGMzaGpNVTUxWTBaa1RtRnNXbFZXYTJRMFV6RktjMXBJVmxSaVJscFlXV3RhZG1Wc1drZFdiVVphVmpGS1IxUnNXbUZWUmxsNVlVaENWbUpIYUVSVWJYaHJWbFpHZEZKdGNFNVdNVWwzVmxkNGIyTXlSa2RUYkdSVVlsVmFWbFp1Y0Zka2JGcHlWMjFHYWxacmNEQmFSV1F3VlRKRmVsRllaRmhpUmxwb1dWUktSMVl4VG5OYVIyaE9UV3hLV1ZkWGVHOVJNVTE0WTBaYVdHRXpRbk5WYlRGVFpXeHNWbGRzVG1oV2EzQXhWVmMxYjFZeFdYcGhTRXBYVmtWYWVsWnFSbGRqTVdSellVZG9UazFWY0RKV2JHTjRUa2RSZVZaclpGZGlSMUp2Vlc1d2MySXhVbGRYYm1Sc1ZteHNOVlJzYUd0V01rcEhZa1JhV2xaV1NsQldNakZHWlZaV2NscEhSbGRXTVVwUlZsUkNWazVXV1hsU2EyaG9VbFJXV0ZsdGRFdE5iRnAwVFZSQ1ZrMVZNVFJXVnpWVFZqSktTRlZzV2xwaVdGSXpXV3BHVjJOV1RuUlBWbVJUWWxob1lWZFVRbUZoTVZwelUyNU9hbEp0ZUZaV2JGcExVMFphV0dNemFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRmxVUms5U01WcDFWR3hvYVZKc2NGbFhWM1JoWkRGa1YxZHJhR3hTTUZwaFZtcEdTMUl4VW5OWGJVWldVbXhzTlZsVldsTldNa1Y0VjJ0MFZWWnNjSEpaZWtaaFpFVTVWMVpyTlZkaWEwWXpWbXhqZDAxV1RYaFZXR2hZWW1zMVZWbHNWbUZXYkZwMFpVaGtUazFXY0hsV01qRkhZV3hhY21ORVJsaGhNWEJRVmtkNFlXTnRUa1ZYYkdST1lteEtlVmRZY0VkV2JWWlhWRzVXVkdKRk5XOVpXSEJYVjFaa1YxVnJaR3ROYTFwSVdXdGFiMkZ0Vm5KWGJHaFZWbTFTVkZZeWVHdGpiRnBWVW14b1UyRXpRbUZXVm1NeFlqRlplRmRxV2xKWFIyaFhWbXRXWVdWc1duRlNiWFJyVm14S01GVnRlRTloUjFaelYyeGtWMkpIVGpSVWEyUlNaVlphY2xwR1pGaFNNMmg1Vmxkd1ExbFhUa2RXYmxKc1UwZFNjMWxyV2xkT1ZsSnpXWHBXVjAxRVJsaFphMUpoVjJ4YVYyTklXbGROYm1ob1ZtcEdZV05XVm5OYVJUVlhZbXRLU2xZeGFIZFNNVmw1VkZoc1UyRXlhSEJWYlhNeFkwWnNWVkZ1WkU1aVJuQXdXbFZqTldFd01WWk5WRkpYWWtkb2RsWXdXbXRUUjBaSFlVWndhVmRIYUc5V2JURTBZekpPYzFwSVZtRlNNMEpVV1d0YWQwNUdXbGhOVkVKT1VteHNORll5TlZOV2JVcElaVWRvVm1KSFVsUlZNRnBoWTFaT2NscEZPV2xTV0VJMlZtdGtORmxXVlhsVGExcFlWMGhDV0Zac1duZFNNVkY0VjJ0T1ZtSkZTbFpVVlZGM1VGRTlQUT09'''for i in range(1,16): str = base64.b64decode(str)print (str)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相册]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[老规矩，先贴上index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;精品相册1&lt;/title&gt; &lt;link rel="stylesheet" href="css/img_style.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="picList"&gt; &lt;!--&lt;div id="Left"&gt;&lt;/div&gt;--&gt; &lt;span&gt;&lt;img src="img/main/1.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/2.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/3.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/4.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/5.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/6.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/7.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/8.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/9.jpg"/&gt;&lt;/span&gt; &lt;!--&lt;div id="Right"&gt;&lt;/div&gt;--&gt; &lt;/div&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：添加挡板 --&gt; &lt;div id="pan"&gt;&lt;/div&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：显示特效图片的位置 包含图片以及按钮 --&gt; &lt;div id="show"&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：中间显示图片容器的位置 --&gt; &lt;div id="showimage"&gt; &lt;span&gt;&lt;img src="img/show/0/1.jpg" title="1"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/2.jpg" title="2"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/3.jpg" title="3"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/4.jpg" title="4"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/5.jpg" title="5"/&gt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：切换图片的按钮 --&gt; &lt;span id="pre"&gt; &lt;p&gt;&lt;&lt;/p&gt;&lt;/span&gt; &lt;span id="next"&gt;&lt;p&gt;&gt;&lt;/p&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：导入js文件 --&gt; &lt;script type="text/javascript" src="js/jquery-1.11.3.js" &gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; //点击每一张图片容器的时候 $("#picList span").click(function()&#123; //获取showimage中的所有img标签 var $img = $("#showimage img"); //获取点击的那一个图片 //$(this).index();返回指定元素在相对应的集合中下标的位置 var index = $(this).index();//0 for(var i=0;i&lt;5;i++)&#123; //获取图片路径 //img/show/0/1.jpg var url="img/show/"+index+"/"+(i+1)+".jpg"; //更换图片 $img.eq(i).attr("src",url); &#125; //让特效显示 //淡入效果、600毫秒的执行时间 $("#pan").fadeIn(600); $("#show").fadeIn(600).show(); &#125;); //点击挡板的事件，让特效消失 $("#pan").click(function()&#123; //淡出的效果 $("#pan").fadeOut(600); $("#show").fadeOut(600); &#125;); //点击下一张按钮 $("#next").click(function()&#123; //索引到最后 一张图片 $("#showimage span:last-child").animate( &#123;left:"680px"&#125;,500,function()&#123; $(this).animate(&#123;left:"0px"&#125;,500); //更换位置 //将指定的元素，插入到当前集合中的开头位置 $("#showimage").prepend(this); &#125;); &#125;); //点击上一张按钮 $("#pre").click(function()&#123; //索引到第一张图片 $("#showimage span:first-child").animate( &#123;left:"-680px"&#125;,500,function()&#123; $(this).animate(&#123;left:"0px"&#125;,500); //更换位置 //将指定的元素，插入到当前集合中的结尾位置 $("#showimage").append(this); &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/html&gt; /img目录下的图片放在ghthub /js目录下的jquery-1.11.3.js /css目录下的img_style.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109*&#123; margin: 0; padding: 0; &#125;/*添加背景*/body&#123; background: url(../img/bg.jpg); /*隐藏滚动栏*/ overflow: hidden;&#125;#picList&#123; width: 750px; height: 600px; /*margin:第一个上下距离 第二个左右距离 auto 自适应*/ margin: 100px auto;&#125;img&#123; width: 230px; height: 160px; padding: 5px; margin: auto auto;&#125;/*行内元素不支持宽高的设置*/span&#123; background-color: #FFFFFF; width: 240px; height: 170px; /*把行内元素改变成块元素，支持宽高的设置*/ display: block; float: left; margin: 5px; /*加入外阴影*/ box-shadow: 0px 0px 20px #FFFFFF;&#125;/*遮光挡板*/#pan&#123; position: absolute; left: 0px; top: 0px; width: 100%; height: 100%; /*前三个参数：设置颜色编码 第四个参数：设置透明度*/ background: rgba(0,0,0,0.8); /*设置默认隐藏*/ display: none;&#125;#showimage&#123; /*设置中间容器的显示位置*/ position: absolute; top: 150px; left: 50%; margin-left: -330px; /*设置层级显示关系*/ z-index: 10;&#125;/*设置每一张大图的容器边框*//*派生选择器控制绝对路径的属性*/#showimage span&#123; width: 650px; height: 440px; background: #FFFFFF; box-shadow: 0px 0px 0px #FFFFFF; position: absolute; &#125;#showimage img&#123; width: 640px; height: 430px;&#125;#show p&#123; color: white; font-size: 60px; text-align: center; margin-top: -5px; /*设置粗体*/ font-weight: bold;&#125;/*上一张图片的按钮*/#pre&#123; position: absolute; width: 50px; height: 80px; top: 320px; left: 10%; background: rgba(0,0,0,0.5); /*设置圆角*/ border-radius: 10px; z-index: 20px;&#125;#next&#123; position: absolute; width: 50px; height: 80px; top: 320px; right: 10%; background: rgba(0,0,0,0.5); /*设置圆角*/ border-radius: 10px; z-index: 20px;&#125;/*让这个显示特效的区域隐藏*/#show&#123; display: none;&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打砖块]]></title>
    <url>%2F2017%2F09%2F22%2F%E6%89%93%E7%A0%96%E5%9D%97%2F</url>
    <content type="text"><![CDATA[style在北京实训的时候，跟着培训老师做的一个小游戏，有不足之处请指教！先放上index.html 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;打砖块游戏&lt;/title&gt; &lt;link rel="stylesheet" href="css/new_file.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-07-12 描述：创建一个画布 --&gt; &lt;canvas id="gameCanvas" width="1024px" height="768px"&gt;&lt;/canvas&gt; &lt;audio id="bgmp3" src="img/happy.mp3" autoplay="autoplay"&gt;&lt;/audio&gt; &lt;audio id="breakermp3" src="img/bucket1.mp3"&gt;&lt;/audio&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-07-13 描述：得分 --&gt; &lt;span id="kuangjia"&gt;&lt;p id="p_number"&gt;得分:0&lt;/p&gt;&lt;/span&gt; &lt;img id="start_game" src="img/image/4.png" onclick="Start_game()" /&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-07-12 描述：导入js文件 --&gt; &lt;script type="text/javascript" src="js/game_style.js" &gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; /img目录下的的图片和音频在github /js目录下的game_style.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243window.onload = init;//小括号写不写都行//window.onload = init();window.onmousemove = mouseMoveHandler;//获取鼠标移动的属性//画板设置成全局变量var canvas;//画笔设置成全局变量var context;var gamebg;//背景var board;//挡板var ball;//小球//挡板的坐标var boardY = 650;var boardX = 0;var it = 0;//定义画布的宽高var cW = 1024;var cH = 768;//设置小球的初始化坐标var ballX = 400;var ballY = 500;//定义小球XY轴的速度var vx = 8;var vy = -8;//定义一个数组用于存储砖块var Breaders;var breakermp3;//得分var score = 0;var p;var Tick;//游戏入口function init()&#123; //方法的调用 log("进入游戏中..."); //找到画布 canvas = document.getElementById("gameCanvas"); //找到声音控件 breakermp3 = document.getElementById("breakermp3"); //找到得分文字 p = document.getElementById("p_number"); //相当于画笔 context = canvas.getContext("2d");// gamebg = new Image();//创建一个image对象，用于加载图片// gamebg.src="img/image/bg.png";// //三个参数：第一个绘制的对象；第二个第三个绘制的起始坐标；// context.drawImage(gamebg,0,0); gamebg = AddImg("img/image/bg.png"); board = AddImg("img/image/board.png"); ball = AddImg("img/image/ball.png"); createrBreaders();//创建砖块 //删除数组中的参数 //Breaders.splice(0,1); //调用刷新机制 Tick = setInterval(gameTick,1000/60);//一秒刷新60次,1000毫秒等于1秒&#125;//创建一个刷新界面的方法function gameTick()&#123; log("刷新次数:"+(it++)); //清空当前屏幕 cleanScreen();//调用清空屏幕的方法 //绘制背景 context.drawImage(gamebg,0,0); //绘制的挡板 context.drawImage(board,boardX,boardY); //刷新砖块 updateBreaker(); //调用刷新小球位置 updateBall(); //调用检查碰撞 TextBallandBoread(); //调用检查小球与砖块碰撞 TextBallandBreaker();&#125;//检查小球跟砖块的碰撞function TextBallandBreaker()&#123; for(var i = Breaders.length-1;i&gt;=0 ;i--)&#123; var item = Breaders[i];//先提取最后一个 var hit = hitTextpoint(item.x,item.y,200,66,(ballX+ball.width/2),ballY); if(hit)&#123; breakermp3.play(); Breaders.splice(i,1); vy *= -1; p.innerText = "得分:"+(++score); if(score&gt;=25)&#123; RestartandClean(); &#125; &#125; &#125;&#125;//重新开始游戏的方法function Start_game()&#123; window.location.reload();//让界面重新刷新&#125;//游戏结束，清空屏幕function RestartandClean()&#123; clearInterval(Tick); cleanScreen(); context.drawImage(gamebg,0,0); var gamestart = document.getElementById("start_game"); gamestart.style.display = "block";//游戏结束，出现砖块&#125;//检查小球跟挡板的碰撞function TextBallandBoread()&#123; var hit = hitTextpoint(boardX-ball.width,boardY-ball.height,board.width+ball.width,board.height+ball.height,ballX,ballY); if(hit)&#123; ballY = boardY-ball.height; vy *= -1;//取反 &#125;else&#123; &#125;&#125;//碰撞满足的条件//x1、y1障碍物的坐标//w1、h1障碍物的宽高//x2、y2小球的坐标function hitTextpoint(x1,y1,w1,h1,x2,y2)&#123; if(x2&gt;=x1&amp;&amp;x2&lt;=x1+w1&amp;&amp;y2&gt;y1&amp;&amp;y2&lt;=y1+h1)&#123; return true; &#125;else&#123; return false; &#125;&#125;//刷新砖块function updateBreaker()&#123; //循环提取数组中的砖块 for(var i = 0; i&lt; Breaders.length; i++)&#123; var items = Breaders[i]; context.drawImage(items.bimg,items.x,items.y); &#125;&#125;//创建砖块function createrBreaders()&#123; Breaders = new Array(); for(var j=0; j&lt;5; j++)&#123; for(var i = 0; i &lt; 5; i++)&#123; var item = AddImg("img/image/"+(4+j)+".png"); //item.x = 20+200*i; //item.y = 100+70*j; Breaders.push(&#123; bimg:item, x: 20 + 200 * i, y: 100 + 72 * j &#125;); &#125; &#125; &#125;//小球位置刷新的方法function updateBall()&#123; ballX += vx; ballY += vy; log("小球的坐标为:X"+ballX+",Y轴坐标:"+ballY); //上边 if(ballY&lt;=80)&#123; ballY = 80; vy *= -1; &#125; //下方 if(ballY&gt;=cH)&#123;// ballY = cH - ball.height;// vy *= -1; log("游戏结束。。。"); RestartandClean(); &#125; //右边 if(ballX&gt;=cW - ball.width)&#123; ballX = cW -ball.width; vx *= -1; &#125; //左边 if(ballX&lt;=0)&#123; ballX = 0; vx *= -1; &#125; //绘制小球 context.drawImage(ball,ballX,ballY);&#125;//鼠标滑动触发的事件function mouseMoveHandler(e)&#123; //获取鼠标的X轴的数值 //将中心点设置为挡板的中心 boardX = e.x - board.width/2; //判断挡板不超出左边屏幕 if(e.x&lt;=0+board.width/2)&#123; boardX = 0; &#125; //判断挡板不超出右边屏幕 if(e.x&gt;cW - board.width/2)&#123; boardX = cW - board.width; &#125;&#125;//创建一个清空屏幕的方法function cleanScreen()&#123; /* * 第一个参数：X 坐标 * 第二个参数：Y 坐标 * 第三个参数：画板的宽度 * 第四个参数：画板的高度 * */ context.clearRect(0,0,cW,cH);&#125;//加载图片的方法 url 图片的路径function AddImg(url)&#123; var img = new Image();//创建一个Image对象 img.src = url; return img;&#125;//后台控制面板游戏进度数据输出function log(msg)&#123; //打印到控制台 console.log(msg);&#125; /css目录下的new_file.css 123456789101112131415161718192021222324#p_number&#123; /*设置绝对定位*/ position: absolute; left: 10px; top: -15px; font-size: 20px; padding: 5px; border-radius:5px;&#125;#kuangjia&#123; position: absolute; left: 100px; top: 20px; background: orange; width: 100px; height: 50px; border-radius:5px;&#125;#start_game&#123; position: absolute; top: 400px; left:300px; display: none;&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this用法(二)]]></title>
    <url>%2F2017%2F09%2F22%2FJava%E4%B8%ADthis%E7%94%A8%E6%B3%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[/* 关键字this： 1，在普通方法中，关键字this代表方法的调用者，即本次调用了该方法的对象 2，在构造方法中，关键字this代表了该方法本次运行所创建的那个新对象 */12345678910111213141516171819202122232425262728class A&#123; private int i; public A(int i) &#123; this.i = i; //将形参 i 赋给该构造方法本次运行所创建的那个新对象的i数据成员 &#125; public void show()&#123; System.out.println("i = " + this.i); //this表示当前时刻正在调用show方法的对象 //this可以省略 &#125; public void show1()&#123; System.out.println("i = " + i); //this表示当前时刻正在调用show方法的对象 //this可以省略 &#125;&#125;public class TestThis &#123; public static void main(String[] args)&#123; A aa1 = new A(100); aa1.show(); A aa2 = new A(300); aa2.show1(); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this用法(一)]]></title>
    <url>%2F2017%2F09%2F22%2FJava%E4%B8%ADthis%E7%94%A8%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[/* 作为参数传递 需要在某些完全分离的类中调用一个方法，并将当前对象的一个引用作为参数传递时 */12345678910111213141516171819202122232425262728public class Demo &#123; public static void main(String[] args) &#123; B b = new B(new AB()); System.out.println(b); &#125;&#125;class AB&#123; public AB()&#123; new B(this).print(); // 匿名对象 /*匿名对象就是没有名字的对象。 * 如果对象只使用一次，就可以作为匿名对象，代码中 new B(this).print(); * 等价于 ( new B(this) ).print();， * 先通过 new B(this) 创建一个没有名字的对象，再调用它的方法。*/ &#125; public void print()&#123; System.out.println("Hello from A!"); &#125;&#125;class B&#123; AB a; public B(AB a)&#123; this.a = a; &#125; public void print() &#123; a.print(); System.out.println("Hello from B!"); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断输入的字符串是否为数字]]></title>
    <url>%2F2017%2F09%2F21%2F%E5%88%A4%E6%96%AD%E8%BE%93%E5%85%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[传入的str1包含中文、负数,位数很长的数字的字符串也能正常匹配12345678910111213141516171819202122232425262728293031import java.math.BigDecimal;import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern;public class jisuanqiceshi &#123; public static void main(String[] args) &#123; Scanner str1= new Scanner(System.in); System.out.println("请输入您要判断的字符串: "); String str2 = str1.next(); System.out.println(isNumeric(str2)); str1.close(); &#125; //用正则表达式判断字符串是否为数字（含负数） public static boolean isNumeric(String str) &#123; String regEx = "-?[0-9]+\\.?[0-9]*"; Pattern pat = Pattern.compile(regEx); try&#123; regEx= new BigDecimal(str).toString(); &#125; catch (Exception e)&#123; return false;//异常 说明包含非数字 &#125; Matcher mat = pat.matcher(str); if (mat.find()) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 多组输入试过，没成功，希望大家多多指教！]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_9]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-9%2F</url>
    <content type="text"><![CDATA[求满足1+ 2!+ 3!+ ... +n!&lt;= 9999的最大整数N12345678910111213141516public class Example3_9 &#123; public static void main(String[] args) &#123; int n= 1; long sum= 0, t= 1; t= n* t; while(true)&#123; sum= sum+ t; if(sum&gt; 9999)&#123; break; &#125; n++; t= n* t; &#125; System.out.println("满足条件的最大整数："+ (n- 1)); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_8]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-8%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，计算两个非零正整数的最大公约数和最小公约数，要求两个非零正整数从键盘输入1234567891011121314151617181920212223public class Example3_8 &#123; public static void main(String[] args) &#123; System.out.println("请输入两个非零正整数，每输入一个数回车确认"); Scanner reader= new Scanner(System.in); int m= 0, n= 0, t= 0, gy= 0, gb= 0; m= reader.nextInt(); n= reader.nextInt(); if(m&gt; n)&#123; t= m; m= n; n= t; &#125; for(int i= 1; i&lt;= m; i++)&#123; if(m% i== 0 &amp;&amp; n% i== 0)&#123; gy= i; &#125; &#125; gb= m* n/ gy; System.out.println(m+ "和"+ n+ "的最大公约数为: "+ gy); System.out.println(m+ "和"+ n+ "的最小公倍数为: "+ gb); reader.close(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_7]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-7%2F</url>
    <content type="text"><![CDATA[一个数如果恰好等于它的因子之和，这个数就称为“完数”，编写一个应用程序，求1000之内的所有完整完数123456789101112131415public class Example3_7 &#123; public static void main(String[] args) &#123; int sum= 0, i, j; for(i= 1; i&lt;=1000; i++)&#123; for(j= 1, sum= 0; j&lt; i; j++)&#123; if(i% j== 0)&#123; sum+= j; &#125; &#125; if(sum== i)&#123; System.out.println("完数: "+ i); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_6]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-6%2F</url>
    <content type="text"><![CDATA[分别用while和for循环计算1+ 1/2!+ 1/3!+ 1/4!+ ... 的前20项之和1234567891011121314151617public class Example3_6 &#123; public static void main(String[] args) &#123; double sum= 0, a= 1, i= 1; while(i&lt;= 20)&#123; a= (1.0/i)* a; i++; sum= sum+ a; &#125; System.out.println("使用while循环计算的sum= "+ sum); for(sum= 0, i= 1, a= 1; i&lt;= 20; i++)&#123; a= a*(1.0/ i); sum= sum+ a; &#125; System.out.println("使用for循环计算的sum= "+ sum); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_5]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-5%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，求100以内的全部素数法一:123456789101112131415public class Example3_5 &#123; public static void main(String[] args) &#123; int i, j; for(j= 2; j&lt;= 100; j++)&#123; for(i= 2; i&lt;= j/2; i++)&#123; if(j%i== 0)&#123; break; &#125; &#125; if(i&gt; j/ 2)&#123; System.out.print(" "+ j); &#125; &#125; &#125;&#125; 法二:1234567891011121314public class demos &#123; public static void main(String[] args) &#123; int i, n; for(n= 2; n&lt;= 100; n++)&#123; for(i= 2; i&lt;= n- 1; i++)&#123; if (n% i== 0) &#123; break; &#125; &#125;if (i== n) &#123; System.out.print(n+ " "); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_4]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-4%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，求1!+ 2!+ ... + 20!123456789101112public class Example3_4 &#123; public static void main(String[] args) &#123; double sum= 0, a= 1; int i= 1; while (i&lt;= 20)&#123; sum= sum+ a; i++; a= a*i; &#125; System.out.println("sum= "+ sum); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_3]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-3%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，用for循环输出俄文的字母表1234567891011121314151617public class Example3_3&#123; public static void main (String args[]) &#123; int startPosition=0,endPosition=0; char cStart='А',cEnd='Я'; startPosition=(int)cStart;//cStart做int型转换运算，并将结果赋值给startPosition endPosition=(int)cEnd;//cEnd做int型转换运算，并将结果赋值给endPosition System.out.println("俄文字母共有:"+(endPosition-startPosition+1)+"个"); for(int i=startPosition;i&lt;=endPosition;i++) &#123; char c='\0'; c=(char)i;//i做char型转换运算，并将结果赋值给c System.out.print(" "+c); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays类中binarySearch()的问题]]></title>
    <url>%2F2017%2F09%2F10%2FArrays%E7%B1%BB%E4%B8%ADbinarySearch-%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近新上手了Java，学习的过程中发现在binarySearch()方法中有点地方不明，so~google了一下。binarySearch()方法的返回值有两种情况：1、如果找到关键字，则返回值为关键字在数组中的位置索引，且索引从0开始； 2、如果没有找到关键字，返回值为负的插入点值，插入点值就是第一个比关键字大的元素在数组中的位置索引，而且这个位置索引从1开始。 注：调用binarySearch()方法前要先调用sort方法对数组进行排序，否则得出的返回值不定，这是二分搜索算法决定的。 如下一个小例1234567891011121314151617181920212223242526272829303132import java.util.Arrays;public class Example2_7 &#123; public static void main(String[] args) &#123; int[] a= new int[] &#123;12, 34, 9, 23, 45, 6, 45, 90, 123, 19, 34&#125;; int[] b= &#123;12, 34, 9, 23, 45, 6, 45, 90, 123, 19, 34&#125;; //两种定义方法都可 Arrays.sort(b); System.out.println(Arrays.toString(b)); Arrays.sort(a); System.out.println(Arrays.toString(a)); int number= 45; int index= Arrays.binarySearch(a, number); System.out.println(index); if( index&gt;= 0)&#123; System.out.println(number+ "和数组中索引为"+ index+ "的元素值相同"); &#125; else &#123; System.out.println(number+ "不与数组中的任何元素值相同"); &#125; int numberd= 89; //此时没有找到关键字，返回值为-10，第一个比89大的数是90，位置是第十个，此时位置索引从1开始 int indexd= Arrays.binarySearch(a, numberd); System.out.println(indexd); if( indexd&gt;= 0)&#123; System.out.println(numberd+ "和数组中索引为"+ indexd+ "的元素值相同"); &#125; else &#123; System.out.println(numberd+ "不与数组中的任何元素值相同"); &#125; &#125;&#125; 运行结果为123456[6, 9, 12, 19, 23, 34, 34, 45, 45, 90, 123][6, 9, 12, 19, 23, 34, 34, 45, 45, 90, 123]845和数组中索引为8的元素值相同-1089不与数组中的任何元素值相同]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FengCms上传Webshell]]></title>
    <url>%2F2017%2F08%2F31%2FFengCms%E4%B8%8A%E4%BC%A0Webshell%2F</url>
    <content type="text"><![CDATA[今天拿一个演示站做测试 首页很平常，有一个输入框，可能有注入漏洞。查看源代码后，在最底下有一行注释，提示一些信息，有门！ 上网搜查下FengCms，发现FengCms是由地方网络工作室完全知识产权打造的一套适用于个人、企业建站的内容管理系统。在这个网页上有相关的漏洞https://www.seebug.org/appdir/FengCMS这次使用的是任意文件下载漏洞 通过扫描发现这段PHP代码有明显的漏洞。 通过找到这个文件名，base64编码后获取文件内容，将其下载到本地。 演示站证明: http://guf521656.h163.92hezu.org/?controller=down&amp;file=Y29uZmlnLnBocA 打开后发现MySQL的用户名和密码 用nmap扫描到演示站开着3306端口 利用所得的账号密码，进入数据库根据phpinfo.php中，找到的绝对路径/var/www/htmldocument_root的值，得到网站的绝对路径利用MySQL上传一句话木马 就会发现/upload/下多出1.php文件，上传成功随后可用中国菜刀链接到网站，提取里面的信息~]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP提数据]]></title>
    <url>%2F2017%2F08%2F30%2FSQLMAP%E6%8F%90%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[查询数据库中信息的sqlmap语句SQLMAP读取数据： -u 漏洞url-data “vul” POST内容 –dbs 罗列所有数据库 -D 指定数据库 –tables列表 -D 指定数据库 -T 指定表 –columns 列所有字段 -D 指定数据库 -T 指定表 -C 指定字段 –dump 获取数据 –random-agent 随机ua头 –level -risk 设置扫描等级 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ - -dbs查询数据库 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ - -current-db查询当前使用的数据库 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ -D security - -tables查询所有的表 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ -D security -T users - -columns查询表中所有字段 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ -D security -T users -C username,password - -dump指定查询的列 两条-之间没有空格，style在编辑的时候，两条-之间没加空格，它们会连在一起，不容易看出，额，markdown用的不是很熟~]]></content>
      <tags>
        <tag>SQLMAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos + Hexo + Github]]></title>
    <url>%2F2017%2F08%2F30%2FCentos-Hexo-Github%2F</url>
    <content type="text"><![CDATA[本文只介绍style安装的过程，其他版本请另行借鉴！(万变不离其宗)必需品： 注册有腾讯有以及域名 腾讯云中安装Centos 7 注册有Github ###Centos 7 中 下载并安装LNMP 我安装的是稳定版 wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp 安装成功后， 下一步 ###Centos 7 中 安装Hexo这个茬可真不好弄==，style第一次安装的时候出了许多的错误，无奈之下只能一点一点解决。安装过程中借鉴了许多资料，另行总结才搭配好，总觉得网上的教程不是很全面。在root下安装 ####首先安装Node.js找到最新的下载地址，用 wget 命令下载到本地 wget https://nodejs.org/dist/v4.4.4/node-v4.4.4-linux-x64.tar.xz 下载完后解压，因为是xz文件， 所以如下 xz -d node-v4.4.4-linux-x64.tar.gz tar -xvf node-v4.4.4-linux-x64.tar 文件被解压到当前文件夹下 mv node-v4.4.4-linux-x64 node-v4.4.4 mv node-v4.4.4 /usr/local/node ####配置环境变量 #编辑 /etc/profile (使用 vim) vim /etc/profile #在底部添加PATH变量 export PATH=$PATH:/usr/local/node/bin*#保存退出， 先按Esc键， 再按Shift + : 输入wq即可保存退出 最后保存并使其生效即可 source /etc/profile ###安装Hexo 创建目录 mkdir hexo 切换目录 cd hexo 安装Git(已安装， 跳过) yum install git-core 安装Hexo npm install -g hexo-cli 初始化Hexo hexo init 这里可能有个问题，就是在安装Hexo的时候， 输入安装Hexo的安装指令npm install -g hexo-cli，可能会出现错误，如果出错，可将官方源替换成淘宝源 npm install -g hexo –registry=https://registry.npm.taobao.org ####安装插件 npm install hexo-generator-index –save npm install hexo-generator-archive –save npm install hexo-generator-category –save npm install hexo-generator-tag –save npm install hexo-server –save npm install hexo-deployer-git –save npm install hexo-deployer-heroku –save npm install hexo-deployer-rsync –save npm install hexo-deployer-openshift –save npm install hexo-renderer-marked –save npm install hexo-renderer-stylus –save npm install hexo-generator-feed –save npm install hexo-generator-sitemap –save 安装结束后，进行下一步修改Hexo配置文件(站点文件，即hexo/config._yml,, hexo/themes/next/_config.yml是主题文件)注： key值没有对应的value值的时候，冒号后面一定要有空格！否则会报错，例如：timezone:会报错，，timezone: 不会 ###部署到Github这个简单 ####配置本机全局git变量(如果已经配置过请忽略)在VPS(你的服务器)上设置你的Git git config –global user.email “你的github注册时的邮箱” git config –global user.name “你的名字” ####生成ssh和密钥输入下面一段指令 less ~/.ssh/id_rsa.pub 如果出现一堆密码，则证明你已经生成ssh，可跳过下面一步，如果报错，请进行下一步。 ssh-keygen -t rsa -C example@126.com注： -C后面跟你在github注册的用户名邮箱，这样公钥才会被github认可回车后，不用输入文件夹路径和名字，自动选择默认的路径，存储新的ssh密钥连续回车，结束查看公钥内容，稍后加入github账户的sshkey中 less ~/.ssh/id_rsa.pub ###创建博客工程 创建一个新的仓库，仓库名为用户名.github.io，比如我的github用户名是sunstady，则创建的项目名为sunstady.github.io ###将ssh密钥添加到github中生成后，需要将密钥放到github上去，登录你的github账号，进入密钥设置面板：https://github.com/settings/ssh在执行less ~/.ssh/id_rsa.pub后，会有一堆长的密码，把这一堆密码全部复制到github上 ####配置Hexo， 编译与部署在站点文件_config.yml里第一段 #Site 站点信息设置title: Sanstyle #站名subtitle: 世界， 你好 #这是副标题description: #站描述autor: MC #作者language: zh-CN #语言timezone: 在站点文件_config.yml里最后一段 deploy:type: git repo:git@github.com:sunstady/sunstady.github.io.git branch: master message: &apos;站点更新:{{now("YYYY-MM-DD HH/mm/ss")}}&apos; 这里， 就是你创建的博客工程最后一步，编译， 上传静态代码 编译 hexo generate 在主机的hexo目录下，执行以下命令将自动更新到github hexo d ###修改主题和配置文件 ####安装主题NEXT切换到目录hexo下 git clone https://github.com/iissnan/hexo-theme-next themes/next在站点文件_config.yml中 找到 theme: 修改后面的参数，默认是 landscape theme: next ####验证主题首先启动Hexo站点， 并开启调试模式，整个命令是hexo s --debug。在启动服务的过程中，注意观察命令行输出是否有任何异常信息，当命令行提示：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问http://localhost:4000，检查站点是否正确运行。 ###主题设定 ####选择SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认Scheme， 这是NexT最初的版本，黑白主调，大量留白 Mist - Muse的紧凑版本， 整洁有序的单栏外观 Pisces - 双栏Scheme， 小家碧玉似的清新 Scheme的切换通过更改主题文件，搜索scheme关键字(用 vim 打开后，输入/scheme就可搜索)你会看到三行scheme的配置，将你启用的scheme前面注释#去掉即可。 scheme: Pisces ####设置菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑主题文件， 修改如下： menu:home: / archives: /archives about: /about categories: /categories tags: /tags commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的/去掉 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 menu_icons: enable: true home: home about: about categories: th tags: tags archives: archive commonweal: heartbeat ####设置头像编辑主题文件，修改字段avatar, 值设置成头像的链接地址 avatar: http://xxxx.com/xxxxx.jpg ###访问：现在可以通过用户名.github.io访问博客]]></content>
      <tags>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
