<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux笔记一]]></title>
    <url>%2F2018%2F07%2F19%2FLinux%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[鸟哥私房菜学习一。 计量单位&nbsp;&nbsp;&nbsp;&nbsp;电脑对数据的判断主要依据有没有通电来记录信息，所以理论上对于每一个记录单位而言，它只认识0与1而已。0/1这个二进制的单位我们成为bit。但bit太小，所以在储存数据时每份简单的数据都会使用到8个bit的大小来记录，因此定义出Byte这个单位，关系为1 Byte = 8 bits。 进位制 Kilo Mega Giga Tera Peta Exa Zetta 二进制 1024 1024K 1024M 1024G 1024T 1024P 1024E 十进制 1000 1000K 1000M 1000G 1000T 1000P 1000E 例题: 假设有500GB硬盘一个，但是格式化完毕后却只剩下460GB左右的容量，这是什么原因？ 答: 因为一般硬盘制造商会使用十进制的单位，所以500GByte代表为500*1000*1000*1000Byte之意。转成文件的容量单位时使用二进制(1024为底)，所以就成为460GB左右的容量了。 电脑架构与设备元件&nbsp;&nbsp;&nbsp;&nbsp;早期的芯片组通常分为两个桥接器来控制各元件的沟通，分别是：(1) 北桥：负责连接速度较快的CPU、内存与显卡接口等元件；(2) 南桥：负责连接速度较慢的设备接口，包括硬盘、USB、网卡等。目前的主流架构中，大多将北桥内存控制器整合到CPU封装当中了。 主板设备I/O位址与IRQ中断信道不能有两个设备使用同一个I/O位址，否则系统就会不晓得该如何运行这两个设备了。IRQ中断信道。 CMOS和BIOSCMOS：主要的功能为记录主板上面的重要参数，包括系统时间、CPU电压与频率、各项设备的I/O位址与IRQ等，由于这些数据的记录要花费电力，因此主板上面才有电池。BIOS：为写入到主板上某一块flash或EEPROM的程序，他可以在开机的时候执行，以载入CMOS当中的参数，并尝试调用储存设备中的开机程序，进一步进入操作系统当中。BIOS也可以修改CMOS中的数据。 回顾12345678910计算机的定义为: 接受使用者输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生储存成有用的信息。`电脑的五大单元包括`：输入单元、输出单元、控制单元、算术逻辑单元、存储单元五大部分。其中CPU占有控制、算术逻辑单元，存储单元又包含内存与辅助内存。数据会流进/流出内存是CPU所发布的控制命令，而CPU实际要处理的数据则完全来自于内存。`CPU设计理念主要分为`：精简指令集(RISC)与复杂指令集(CISC)系统。`关于CPU的频率部分`：外频指的是CPU与外部元件进行数据传输时的速度，倍频则是CPU内部用来加速工作性能的一个倍数，两者相乘才是CPU的频率速度。新的CPU设计中，已经将北桥的内存控制芯片整合到CPU中，而CPU与内存、显卡沟通的总线通常称为系统总线。南桥就是所谓的输入输出(I/O)总线，主要在联系硬盘、USB、网卡等周边设备。CPU每次能够处理的数据量称为字组大小，字组大小依据CPU的设计而有32位与64位。我们现在所称的电脑是32或64位主要是依据这个CPU解析的字组大小而来的。个人电脑的内存主要元件为动态随机存取内存，至于CPU内部的第二层高速缓存则使用静态随机存取内存。BIOS是一套程序，这套程序是写死到主板上面的一个内存芯片中，这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器(ROM)。操作系统(OS)其实也是一组程序，这组程序的重点在于管理电脑的所有活动以及驱动系统中的所有硬件。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断本网段有多少可用的IP地址]]></title>
    <url>%2F2018%2F07%2F18%2F%E5%88%A4%E6%96%AD%E6%9C%AC%E7%BD%91%E6%AE%B5%E6%9C%89%E5%A4%9A%E5%B0%91%E5%8F%AF%E7%94%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[首先获取本机IP地址和网段。再使用Java执行ping命令，判断这些IP地址是否能用，把能用的打印出来。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.InetAddress;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger; public class TestSocket &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; InetAddress host = InetAddress.getLocalHost(); String ip = host.getHostAddress(); String ipRange = ip.substring(0, ip.lastIndexOf('.')); System.out.println("本机ip地址：" + ip); System.out.println("网段是: " + ipRange); List&lt;String&gt; ips = Collections.synchronizedList(new ArrayList&lt;&gt;()); ThreadPoolExecutor threadPool = new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); AtomicInteger number = new AtomicInteger(); for (int i = 0; i &lt; 255; i++) &#123; String testIP = ipRange + "." + (i + 1); threadPool.execute(new Runnable() &#123; @Override public void run() &#123; boolean reachable = isReachable(testIP); if (reachable) // System.out.println("找到可连接的ip地址：" + testIP); ips.add(testIP); synchronized (number) &#123; System.out.println("已经完成:" + number.incrementAndGet() + " 个 ip 测试"); &#125; &#125; &#125;); &#125; // 等待所有线程结束的时候，就关闭线程池 threadPool.shutdown(); //等待线程池关闭，但是最多等待1个小时 if (threadPool.awaitTermination(1, TimeUnit.HOURS)) &#123; System.out.println("如下ip地址可以连接"); for (String theip : ips) &#123; System.out.println(theip); &#125; System.out.println("总共有:" + ips.size() + " 个地址"); &#125; &#125; private static boolean isReachable(String ip) &#123; try &#123; boolean reachable = false; Process p = Runtime.getRuntime().exec("ping -n 1 " + ip); BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream())); String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) &#123; if (line.length() != 0) sb.append(line + "\r\n"); &#125; //当有TTL出现的时候，就表示连通了 reachable = sb.toString().contains("TTL"); br.close(); return reachable; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return false; &#125; &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件夹复制进度条]]></title>
    <url>%2F2018%2F07%2F18%2F%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%8D%E5%88%B6%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[使用Java写出的简陋GUI，显示文件夹复制的进度条。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163import java.awt.Dimension;import java.awt.FlowLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException; import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JOptionPane;import javax.swing.JProgressBar;import javax.swing.JTextField; public class TestGUI &#123; static long allFileSize = 0; // 所有需要复制的文件大小 static long currentFileSizeCopied = 0;// 已复制的文件总大小 /** * 遍历文件夹获取文件夹内容总大小 * * @param file */ public static void calclateAllFilesize(File file) &#123; if (file.isFile()) &#123; allFileSize += file.length(); &#125; if (file.isDirectory()) &#123; File[] fs = file.listFiles(); for (File f : fs) &#123; calclateAllFilesize(f); &#125; &#125; &#125; public static void main(String[] args) &#123; JFrame f = new JFrame("带进度条的文件夹复制"); f.setSize(450, 140); f.setLocation(200, 200); f.setLayout(new FlowLayout()); // 文件地址 JLabel lStr = new JLabel("源文件地址："); JTextField strTf = new JTextField(""); strTf.setText("e:/JDK"); strTf.setPreferredSize(new Dimension(100, 30)); JLabel lDest = new JLabel("复制到："); JTextField destTf = new JTextField(""); destTf.setText("e:/JDK2"); destTf.setPreferredSize(new Dimension(100, 30)); f.add(lStr); f.add(strTf); f.add(lDest); f.add(destTf); JButton bStartCopy = new JButton("开始复制"); bStartCopy.setPreferredSize(new Dimension(100, 30)); JLabel l = new JLabel("文件复制进度："); JProgressBar pb = new JProgressBar(); pb.setMaximum(100); pb.setStringPainted(true); f.add(bStartCopy); f.add(l); f.add(pb); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); // 计算需要复制的文件的总大小 String srcPath = strTf.getText(); File folder = new File(srcPath); calclateAllFilesize(folder); // 点击开始复制 bStartCopy.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; currentFileSizeCopied = 0; String srcPath = strTf.getText(); String destPath = destTf.getText(); new Thread(() -&gt; copyFolder(srcPath, destPath)).start(); bStartCopy.setEnabled(false); &#125; public void copyFile(String srcPath, String destPath) &#123; File srcFile = new File(srcPath); File destFile = new File(destPath); // 缓存区，一次性读取1024字节 byte[] buffer = new byte[1024]; try (FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(destFile);) &#123; while (true) &#123; // 实际读取的长度是 actuallyReaded,有可能小于1024 int actuallyReaded = fis.read(buffer); // -1表示没有可读的内容了 if (-1 == actuallyReaded) break; fos.write(buffer, 0, actuallyReaded); fos.flush(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void copyFolder(String srcPath, String destPath) &#123; File srcFolder = new File(srcPath); File destFolder = new File(destPath); if (!srcFolder.exists()) return; if (!srcFolder.isDirectory()) return; if (destFolder.isFile()) return; if (!destFolder.exists()) destFolder.mkdirs(); File[] files = srcFolder.listFiles(); for (File srcFile : files) &#123; if (!(srcFile.isDirectory())) &#123; File newDestFile = new File(destFolder, srcFile.getName()); copyFile(srcFile.getAbsolutePath(), newDestFile.getAbsolutePath()); currentFileSizeCopied += srcFile.length(); double current = (double) currentFileSizeCopied / (double) allFileSize; int progress = (int) (current * 100); pb.setValue(progress); if (progress == 100) &#123; JOptionPane.showMessageDialog(f, "复制完毕"); bStartCopy.setEnabled(true); &#125; &#125; if (srcFile.isDirectory()) &#123; File newDestFolder = new File(destFolder, srcFile.getName()); copyFolder(srcFile.getAbsolutePath(), newDestFolder.getAbsolutePath()); &#125; &#125; &#125; &#125;); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2018%2F07%2F13%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[每一个线程的启动和结束都是比较消耗时间和占用资源的。如果在系统中用到了很多的线程，大量的启动和结束动作会导致系统的性能变卡，响应变慢。为了解决这个问题，引入线程池这种设计思想。线程池的模式很像生产者消费者模式，消费的对象是一个一个的能够运行的任务。 线程池设计思路线程池的思路和生产者消费者模型是很接近的。1、准备一个任务容器2、一次性启动10个消费者线程3、刚开始任务容器时是空的，所以线程都wait在上面。4、直到一个外部线程往这个任务容器中扔了一个”任务”，就会有一个消费者线程被唤醒notify。5、这个消费者线程取出”任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来。6、如果短时间内，有较多的任务加入，那么就会有多个线程别唤醒，去执行这些任务。 开发一个自定义的线程池这是一个自定义的线程池，虽然不够完善和健壮，但是已经足以说明线程池的工作原理。缓慢的给这个线程池添加任务，会看到有多条线程来执行这些任务。线程7执行完毕任务后，又回到池子里，下一次任务来的时候，线程7又来执行新的任务。ThreadPool.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.LinkedList; public class ThreadPool &#123; // 线程池大小 int threadPoolSize; // 任务容器 LinkedList&lt;Runnable&gt; tasks = new LinkedList&lt;Runnable&gt;(); // 试图消费任务的线程 public ThreadPool() &#123; threadPoolSize = 10; // 启动10个任务消费者线程 synchronized (tasks) &#123; for (int i = 0; i &lt; threadPoolSize; i++) &#123; new TaskConsumeThread("任务消费者线程 " + i).start(); &#125; &#125; &#125; public void add(Runnable r) &#123; synchronized (tasks) &#123; tasks.add(r); // 唤醒等待的任务消费者线程 tasks.notifyAll(); &#125; &#125; class TaskConsumeThread extends Thread &#123; public TaskConsumeThread(String name) &#123; super(name); &#125; Runnable task; public void run() &#123; System.out.println("启动： " + this.getName()); while (true) &#123; synchronized (tasks) &#123; while (tasks.isEmpty()) &#123; try &#123; tasks.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; task = tasks.removeLast(); // 允许添加任务的线程可以继续添加任务 tasks.notifyAll(); &#125; System.out.println(this.getName() + " 获取到任务，并执行"); task.run(); &#125; &#125; &#125;&#125; TestThread.java123456789101112131415161718192021222324252627public class TestThread &#123; public static void main(String[] args) &#123; ThreadPool pool = new ThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; Runnable task = new Runnable() &#123; @Override public void run() &#123; //System.out.println("执行任务"); //任务可能是打印一句话 //可能是访问文件 //可能是做排序 &#125; &#125;; pool.add(task); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 测试线程池创造一个情景，每个任务执行的时间都是1秒。刚开始是间隔1秒钟向线程池中添加任务，然后间隔时间越来越短，执行任务的线程还没有来得及结束，新的任务又来了。就会观察到线程池里的其他线程被唤醒来执行这些任务。TestThread.java1234567891011121314151617181920212223242526272829public class TestThread &#123; public static void main(String[] args) &#123; ThreadPool pool= new ThreadPool(); int sleep=1000; while(true)&#123; pool.add(new Runnable()&#123; @Override public void run() &#123; //System.out.println("执行任务"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); try &#123; Thread.sleep(sleep); sleep = sleep&gt;100?sleep-100:sleep; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 使用Java自带的线程池Java提供自带的线程池，而不需要自己去开发一个自定义线程池。线程池类ThreadPoolExecutor在包java.util.concurrent下1ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); 第一个参数10表示这个线程池初始化了10个线程在里面工作。第二个参数15表示如果10个线程不够用了，就会自动增加到最多15个线程。第三个参数60结合第四个参数TimeUnit.SECONDS，表示经过60秒,多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个。第四个参数TimeUnit.SECONDS如上。第五个参数new LinkedBlockingQueue()用来放任务的集合。execute方法用于添加新的任务。1234567891011121314151617181920import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit; public class TestThread &#123; public static void main(String[] args) throws InterruptedException &#123; ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); threadPool.execute(new Runnable()&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println("任务1"); &#125; &#125;); &#125;&#125; 借助线程池同步查找文件内容初始化一个大小是10的线程池遍历所有文件，当遍历到文件是.java的时候，创建一个查找文件的任务，把这个任务扔进线程池去执行，继续遍历下一个文件。SearchFileTask.java123456789101112131415161718192021222324252627282930313233import java.io.File;import java.io.FileReader;import java.io.IOException; public class SearchFileTask implements Runnable&#123; private File file; private String search; public SearchFileTask(File file,String search) &#123; this.file = file; this.search= search; &#125; public void run()&#123; String fileContent = readFileConent(file); if(fileContent.contains(search))&#123; System.out.printf( "线程: %s 找到子目标字符串%s,在文件:%s%n",Thread.currentThread().getName(), search,file); &#125; &#125; public String readFileConent(File file)&#123; try (FileReader fr = new FileReader(file)) &#123; char[] all = new char[(int) file.length()]; fr.read(all); return new String(all); &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125; &#125; ThreadPool.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.LinkedList; public class ThreadPool &#123; // 线程池大小 int threadPoolSize; // 任务容器 LinkedList&lt;Runnable&gt; tasks = new LinkedList&lt;Runnable&gt;(); // 试图消费任务的线程 public ThreadPool() &#123; threadPoolSize = 10; // 启动10个任务消费者线程 synchronized (tasks) &#123; for (int i = 0; i &lt; threadPoolSize; i++) &#123; new TaskConsumeThread("任务消费者线程 " + i).start(); &#125; &#125; &#125; public void add(Runnable r) &#123; synchronized (tasks) &#123; tasks.add(r); // 唤醒等待的任务消费者线程 tasks.notifyAll(); &#125; &#125; class TaskConsumeThread extends Thread &#123; public TaskConsumeThread(String name) &#123; super(name); &#125; Runnable task; public void run() &#123; while (true) &#123; synchronized (tasks) &#123; while (tasks.isEmpty()) &#123; try &#123; tasks.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; task = tasks.removeLast(); // 允许添加任务的线程可以继续添加任务 tasks.notifyAll(); &#125; task.run(); &#125; &#125; &#125; &#125; TestThread.java1234567891011121314151617181920212223242526import java.io.File; public class TestThread &#123; static ThreadPool pool= new ThreadPool(); public static void search(File file, String search) &#123; if (file.isFile()) &#123; if(file.getName().toLowerCase().endsWith(".java"))&#123; SearchFileTask task = new SearchFileTask(file, search); pool.add(task); &#125; &#125; if (file.isDirectory()) &#123; File[] fs = file.listFiles(); for (File f : fs) &#123; search(f, search); &#125; &#125; &#125; public static void main(String[] args) &#123; File folder =new File("e:\\project"); search(folder,"Magic"); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全的类]]></title>
    <url>%2F2018%2F07%2F13%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[常见的线程安全相关的面试题。 HashMap和Hashtable的区别HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式。区别1： HashMap可以存放null Hashtable不能存放null区别2： HashMap不是线程安全的类 Hashtable是线程安全的类 StringBuffer和StringBuilder的区别StringBuffer是线程安全的StringBuilder是非线程安全的所以当进行大量字符串拼接操作的时候，如果是单线程就用StringBuffer会更快些，如果是多线程，就需要用StringBuffer保证数据的安全性。 非线程安全的为什么会比线程安全的快？因为不需要同步，省略了时间。 ArrayList和Vector的区别通过在eclipse中查看源代码可以得知：ArrayList类的声明：12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable Vector类的声明：12public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 一模一样的~他们的区别也在于，Vector是线程安全的类，而ArrayList是非线程安全的。 把非线程安全的集合转换为线程安全ArrayList是非线程安全的，换句话说，多个线程可以同时进入一个ArrayList对象的add方法借助Collections.synchronizedList，可以把ArrayList转换为线程安全的List。与此类似的，还有HashSet, LinkedList, HashMap等等非线程安全的类，都通过工具类Collections转换为线程安全的。1234567891011121314package multiplethread; import java.util.ArrayList;import java.util.Collections;import java.util.List; public class TestThread &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list2 = Collections.synchronizedList(list1); &#125; &#125; 线程安全的MyStack把LinkedList通过Collections.synchronizedList转换成了一个线程安全的List。1List&lt;Hero&gt; heros = (List&lt;Hero&gt;) Collections.synchronizedList(new LinkedList&lt;Hero&gt;()); 不需要在push上加synchronized修饰符虽然多个线程可以同时进入push方法，但是调用heros.add方法的时候，同一时间，只有一个线程可以进入。123public void push(Hero h) &#123; heros.add(h);&#125; 12345678910111213141516171819202122232425262728package collection; import java.util.Collections;import java.util.LinkedList;import java.util.List; import charactor.Hero; public class MyStack implements Stack&#123; //把LinkedList通过 Collections.synchronizedList转换成了一个线程安全的List List&lt;Hero&gt; heros = (List&lt;Hero&gt;) Collections.synchronizedList(new LinkedList&lt;Hero&gt;()); //不需要在push上加synchronized修饰符 //虽然多个线程可以同时进入push方法，但是调用heros.add方法的时候 //同一时间，只有一个线程可以进入 public void push(Hero h) &#123; heros.add(h); &#125; public Hero pull() &#123; return heros.remove(heros.size()-1); &#125; public Hero peek() &#123; return heros.get(heros.size()-1); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑白棋子]]></title>
    <url>%2F2018%2F07%2F12%2F%E9%BB%91%E7%99%BD%E6%A3%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[黑白棋子Java版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313import java.awt.Color;import java.awt.Dimension;import java.awt.Graphics;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import javax.swing.JFrame;import javax.swing.JMenu;import javax.swing.JMenuBar;import javax.swing.JMenuItem;import javax.swing.JOptionPane;import javax.swing.JPanel;public class mc_07116 &#123; /** * 控件属性 */ private JFrame frame; // 五子棋游戏的窗口框架 private GameMap map; // 五子棋游戏的窗口容器 private JMenuBar bar; // 菜单 private JMenu game; // 菜单项 private JMenuItem[] items; // 菜单下拉项 /** * 静态数据属性 */ private static final int BOARD_SIZE = 15; // 棋盘大小(15 * 15) private static final int ROW_WIDTH = 36; // 间距 private static final int SPACE = ROW_WIDTH / 2; // 上下边间距 /** * 数据属性 */ private boolean player; // true黑,false白 private char[][] board; // 后台虚拟棋盘 public mc_07116() &#123; player = true; // 游戏先黑子下 board = new char[BOARD_SIZE][BOARD_SIZE]; // 建立后台虚拟棋盘 clearMap(); createGUI(); &#125; /** * 对GUI控件的创建 */ private void createGUI() &#123; frame = new JFrame("五子棋"); // 实现五子棋游戏窗口框架 bar = new JMenuBar(); // 建立菜单栏 game = new JMenu("游戏"); // 建立名为“游戏”的菜单 items = new JMenuItem[2]; // game菜单下创建2个子菜单项 game.add(items[0] = new JMenuItem("重新开始"));// 第一个子菜单为“重新开始” game.add(items[1] = new JMenuItem("退出")); // 第二个子菜单为“退出” bar.add(game);// 菜单项加入菜单栏 map = new GameMap(); // 实现五子棋游戏窗口容器 map.setPreferredSize( new Dimension(ROW_WIDTH * (BOARD_SIZE - 1) + SPACE * 2, ROW_WIDTH * (BOARD_SIZE - 1) + SPACE * 2));// 设置容器大小 frame.setJMenuBar(bar); frame.add(map); frame.pack(); frame.setLocation(450, 100); frame.setResizable(false); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE); &#125; /** * 清空棋子 */ protected void clearMap() &#123; for (int i = 0; i &lt; BOARD_SIZE; i++) &#123; for (int j = 0; j &lt; BOARD_SIZE; j++) &#123; board[i][j] = '+'; &#125; &#125; &#125; /** * 运行游戏 */ public void start() &#123; map.addMouseListener(new MouseAdapter() &#123; // 鼠标点击事件 public void mouseClicked(MouseEvent e) &#123; // 将用户鼠标事件的座标转换成棋子数组的座标。 int xPos = (int) (e.getX() / ROW_WIDTH); int yPos = (int) (e.getY() / ROW_WIDTH); if (board[xPos][yPos] == '+') &#123;// 判断是否下过棋 board[xPos][yPos] = player ? 'b' : 'w'; // 给虚拟键盘赋值 map.repaint(); // 通过读取board数组进行贴图 if (isWin(xPos, yPos)) &#123;// 如果有满足胜利条件的玩家了 map.repaint(); // 刷新图像 String str = player ? "黑方胜利" : "白方胜利"; JOptionPane.showMessageDialog(null, str, "游戏结束", JOptionPane.PLAIN_MESSAGE); // 弹出消息框 clearMap(); // 清空棋盘 map.repaint(); // 刷新棋盘 player = true; // 新一局继续黑子先下 &#125; else &#123; player = player ? false : true; // 切换玩家 &#125; &#125; &#125; &#125;); // 点击重新开始事件 items[0].addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; String str = "是否要重新开始游戏?"; // 添加消息对话框 if (JOptionPane.showConfirmDialog(null, str, "重新开始", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) &#123; clearMap(); // 清空棋盘 map.repaint(); // 刷新棋盘 player = true; // 玩家为黑棋 &#125; &#125; &#125;); // 点击退出事件 items[1].addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; String str = "是否要退出游戏?"; // 添加消息对话框 if (JOptionPane.showConfirmDialog(null, str, "重新开始", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) &#123; System.exit(0); // 退出 &#125; &#125; &#125;); // 点关闭按钮事件 frame.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; String str = "是否要退出游戏?"; // 添加消息对话框 if (JOptionPane.showConfirmDialog(null, str, "退出游戏", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) &#123; System.exit(0); // 退出 &#125; &#125; &#125;); &#125; /** * 纵向找 */ protected boolean find(int x, int y) &#123; int i, num = 1; char temp = player ? 'b' : 'w'; for (i = x + 1; i &lt; 15; i++) &#123;// 向下找 if (board[i][y] == temp) &#123; num++; if (num == 5) &#123; return true; &#125; &#125; else &#123; break; &#125; &#125; for (i = x - 1; i &gt;= 0; i--) &#123;// 向上找 if (board[i][y] == temp) &#123; num++; if (num == 5) &#123; return true; &#125; &#125; else &#123; break; &#125; &#125; return false; &#125; /** * 横向找 */ protected boolean find2(int x, int y) &#123; int i, num = 1; char temp = player ? 'b' : 'w'; for (i = y + 1; i &lt; 15; i++) &#123; // 向右找 if (board[x][i] == temp) &#123; num++; if (num == 5) &#123; return true; &#125; &#125; else &#123; break; &#125; &#125; for (i = y - 1; i &gt;= 0; i--) &#123;// 向左找 if (board[x][i] == temp) &#123; num++; if (num == 5) &#123; return true; &#125; &#125; else &#123; break; &#125; &#125; return false; &#125; /** * 方向 */ protected boolean find3(int x, int y) &#123; int i, j, num = 1; char temp = player ? 'b' : 'w'; for (i = x + 1, j = y + 1; i &lt; 15 &amp;&amp; j &lt; 15; i++, j++) &#123;// 向下方 if (board[i][j] == temp) &#123; num++; if (num == 5) &#123; return true; &#125; &#125; else &#123; break; &#125; &#125; for (i = x - 1, j = y - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;// 向上方 if (board[i][j] == temp) &#123; num++; if (num == 5) &#123; return true; &#125; &#125; else &#123; break; &#125; &#125; return false; &#125; /** * /方向 */ protected boolean find4(int x, int y) &#123; int i, j, num = 1; char temp = player ? 'b' : 'w'; for (i = x + 1, j = y - 1; i &lt; 15 &amp;&amp; j &gt;= 0; i++, j--) &#123;// 向下 if (board[i][j] == temp) &#123; num++; if (num == 5) &#123; return true; &#125; &#125; else &#123; break; &#125; &#125; for (i = x - 1, j = y + 1; i &gt;= 0 &amp;&amp; j &lt; 15; i--, j++) &#123; // 向上 if (board[i][j] == temp) &#123; num++; if (num == 5) &#123; return true; &#125; &#125; else &#123; break; &#125; &#125; return false; &#125; /** * 判断胜负 */ protected boolean isWin(int x, int y) &#123; return (find(x, y) || find2(x, y) || find3(x, y) || find4(x, y)); &#125; /** * 内部容器类，用于实现图像处理 */ private class GameMap extends JPanel &#123; private static final long serialVersionUID = 16578987565248L; public void paintComponent(Graphics g) &#123; super.paintComponent(g); // 棋盘 g.setColor(new Color(200, 100, 50)); // 设为桔黄色 g.fillRect(0, 0, ROW_WIDTH * (BOARD_SIZE + 1), ROW_WIDTH * (BOARD_SIZE + 1)); // 填充棋盘 g.setColor(Color.black); // 设为黑色 for (int i = 0; i &lt; BOARD_SIZE; i++) &#123;// 画竖线 g.drawLine(SPACE + ROW_WIDTH * i, SPACE, SPACE + ROW_WIDTH * i, SPACE + ROW_WIDTH * (BOARD_SIZE - 1)); &#125; for (int i = 0; i &lt; BOARD_SIZE; i++) &#123;// 画横线 g.drawLine(SPACE, SPACE + ROW_WIDTH * i, SPACE + ROW_WIDTH * (BOARD_SIZE - 1), SPACE + ROW_WIDTH * i); &#125; // 画点 g.fillOval(SPACE + 3 * ROW_WIDTH - 3, SPACE + 3 * ROW_WIDTH - 3, 7, 7); g.fillOval(SPACE + 11 * ROW_WIDTH - 3, SPACE + 3 * ROW_WIDTH - 3, 7, 7); g.fillOval(SPACE + 3 * ROW_WIDTH - 3, SPACE + 11 * ROW_WIDTH - 3, 7, 7); g.fillOval(SPACE + 7 * ROW_WIDTH - 3, SPACE + 7 * ROW_WIDTH - 3, 7, 7); g.fillOval(SPACE + 11 * ROW_WIDTH - 3, SPACE + 11 * ROW_WIDTH - 3, 7, 7); // 棋子 // 遍历数组，绘制棋子。 for (int i = 0; i &lt; BOARD_SIZE; i++) &#123; for (int j = 0; j &lt; BOARD_SIZE; j++) &#123; if (board[i][j] == 'b') &#123;// 绘制黑棋 g.setColor(Color.black); g.fillOval(SPACE + i * ROW_WIDTH - ROW_WIDTH / 2, SPACE + j * ROW_WIDTH - ROW_WIDTH / 2, ROW_WIDTH, ROW_WIDTH); &#125; if (board[i][j] == 'w') &#123;// 绘制白棋 g.setColor(Color.white); g.fillOval(SPACE + i * ROW_WIDTH - ROW_WIDTH / 2, SPACE + j * ROW_WIDTH - ROW_WIDTH / 2, ROW_WIDTH, ROW_WIDTH); &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; mc_07116 game = new mc_07116(); game.start(); System.out.println("测试成功"); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章设置密码]]></title>
    <url>%2F2018%2F07%2F09%2FHexo%E6%96%87%E7%AB%A0%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Hexo文件是静态的，文章的所有信息都在页面中。加密需要用到js的阻塞机制，当页面中有调用alert();函数的时候，整个页面会停止运行，直到你点击确定之后，页面中的代码才会继续执行下去。找到此路径下的文件：themes--&gt;next--&gt;layout--&gt;_partials--&gt;head.swig 。将下方代码添加在&lt;meta&gt;标签之后。12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码','') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; page这个变量就是你在hexo new的时候生成文件中最顶部的东西。修改文章头部标签文件：hexo--&gt;scaffolds/post.md可以参照如下模式。1234title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: password: password 这样我们就好像使用静态页面完成了部分只有动态页面能完成的东西。]]></content>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比较冒泡法、选择法以及二叉树排序的性能区别]]></title>
    <url>%2F2018%2F07%2F09%2F%E6%AF%94%E8%BE%83%E5%86%92%E6%B3%A1%E6%B3%95%E3%80%81%E9%80%89%E6%8B%A9%E6%B3%95%E4%BB%A5%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[创建4万个随机数，然后分别用冒泡法、选择法、二叉树3种排序算法进行排序，比较哪种更快。mc_07093.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public static void main(String[] args) &#123; //初始化随机数 int total = 40000; System.out.println("初始化一个长度是"+total+"的随机数字的数组"); int[] originalNumbers = new int[total]; for (int i = 0; i &lt; originalNumbers.length; i++) &#123; originalNumbers[i] = (int)(Math.random()*total); &#125; System.out.println("初始化完毕"); System.out.println("接下来分别用3种算法进行排序"); //从初始化了的随机数组复制过来，以保证，每一种排序算法的目标数组，都是一样的 int[] use4sort; use4sort= Arrays.copyOf(originalNumbers, originalNumbers.length); int[] sortedNumbersBySelection= performance(new SelectionSort(use4sort),"选择法"); use4sort= Arrays.copyOf(originalNumbers, originalNumbers.length); int[] sortedNumbersByBubbling=performance(new BubblingSort(use4sort),"冒泡法"); use4sort= Arrays.copyOf(originalNumbers, originalNumbers.length); int[] sortedNumbersByTree=performance(new TreeSort(use4sort),"二叉树"); System.out.println("查看排序结果，是否是不同的数组对象"); System.out.println(sortedNumbersBySelection); System.out.println(sortedNumbersByBubbling); System.out.println(sortedNumbersByTree); System.out.println("查看排序结果，内容是否相同"); System.out.println("比较 选择法 和 冒泡法 排序结果："); System.out.println(Arrays.equals(sortedNumbersBySelection, sortedNumbersByBubbling)); System.out.println("比较 选择法 和 二叉树 排序结果："); System.out.println(Arrays.equals(sortedNumbersBySelection, sortedNumbersByTree)); &#125; interface Sort&#123; void sort(); int[] values();&#125; static class SelectionSort implements Sort&#123; int numbers[]; SelectionSort(int [] numbers)&#123; this.numbers = numbers; &#125; @Override public void sort() &#123; for (int j = 0; j &lt; numbers.length-1; j++) &#123; for (int i = j+1; i &lt; numbers.length; i++) &#123; if(numbers[i]&lt;numbers[j])&#123; int temp = numbers[j]; numbers[j] = numbers[i]; numbers[i] = temp; &#125; &#125; &#125; &#125; @Override public int[] values() &#123; // TODO Auto-generated method stub return numbers; &#125; &#125; static class BubblingSort implements Sort&#123; int numbers[]; BubblingSort(int [] numbers)&#123; this.numbers = numbers; &#125; @Override public void sort() &#123; for (int j = 0; j &lt; numbers.length; j++) &#123; for (int i = 0; i &lt; numbers.length-j-1; i++) &#123; if(numbers[i]&gt;numbers[i+1])&#123; int temp = numbers[i]; numbers[i] = numbers[i+1]; numbers[i+1] = temp; &#125; &#125; &#125; &#125; @Override public int[] values() &#123; // TODO Auto-generated method stub return numbers; &#125; &#125; static class TreeSort implements Sort&#123; int numbers[]; mc_07092 n; TreeSort(int [] numbers)&#123; n =new mc_07092(); this.numbers = numbers; &#125; @Override public void sort() &#123; for (int i : numbers) &#123; n.add(i); &#125; &#125; @Override public int[] values() &#123; List&lt;Object&gt; list = n.values(); int sortedNumbers[] = new int[list.size()]; for (int i = 0; i &lt; sortedNumbers.length; i++) &#123; sortedNumbers[i] = Integer.parseInt(list.get(i).toString()); &#125; return sortedNumbers; &#125;&#125;private static int[] performance(Sort algorithm, String type) &#123; long start = System.currentTimeMillis(); algorithm.sort(); int sortedNumbers[] = algorithm.values(); long end = System.currentTimeMillis(); System.out.printf("%s排序，一共耗时 %d 毫秒%n",type,end-start); return sortedNumbers;&#125; mc_07092.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 左子节点public mc_07092 leftNode;// 右子节点public mc_07092 rightNode;// 值public Object value;// 插入 数据public void add(Object v) &#123; // 如果当前节点没有值，就把数据放在当前节点上 if (null == value) value = v; // 如果当前节点有值，就进行判断，新增的值与当前值的大小关系 else &#123; // 新增的值，比当前值小或者相同 if ((Integer) v -((Integer)value) &lt;= 0) &#123; if (null == leftNode) leftNode = new mc_07092(); leftNode.add(v); &#125; // 新增的值，比当前值大 else &#123; if (null == rightNode) rightNode = new mc_07092(); rightNode.add(v); &#125; &#125;&#125;// 中序遍历所有的节点public List&lt;Object&gt; values() &#123; List&lt;Object&gt; values = new ArrayList&lt;&gt;(); // 左节点的遍历结果 if (null != leftNode) values.addAll(leftNode.values()); // 当前节点 values.add(value); // 右节点的遍历结果 if (null != rightNode) values.addAll(rightNode.values()); return values;&#125;public static void main(String[] args) &#123; int randoms[] = new int[] &#123; 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 &#125;; mc_07092 roots = new mc_07092(); for (int number : randoms) &#123; roots.add(number); &#125; System.out.println(roots.values());&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO流]]></title>
    <url>%2F2018%2F07%2F08%2FIO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[复制文件需要留意的是，read会返回实际的读取数量，有可能实际的读取数量小于缓冲的大小，那么把缓冲中的数据写出到目标文件的时候，就只应该写出部分数据。123456789101112131415161718192021222324252627282930313233343536373839/*** @param srcPath 源文件* @param destPath 目标文件*/public static void copyFile(String srcPath, String destPath)&#123; File srcFile = new File(srcPath); File destFile = new File(destPath); //缓存区，一次性读取1024字节 byte[] buffer = new byte[1024]; try ( FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(destFile); )&#123; while(true)&#123; //实际读取的长度是 actuallyReaded,有可能小于1024 int actuallyReaded = fis.read(buffer); //-1表示没有可读的内容了 if(-1==actuallyReaded) break; fos.write(buffer, 0, actuallyReaded); fos.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /*** @param srcPath 源文件夹* @param destPath 目标文件夹*/public static void copyFolder(String srcPath, String destPath)&#123;&#125;public static void main(String[] args) &#123; copyFile("C:\\Users\\12905\\Desktop\\xxx\\2.txt", "C:\\Users\\12905\\Desktop\\xxx\\3.txt");&#125; 复制文件夹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*** @param srcPath 源文件* @param destPath 目标文件*/public static void copyFile(String srcPath, String destPath)&#123; File srcFile = new File(srcPath); File destFile = new File(destPath); //缓存区，一次性读取1024字节 byte[] buffer = new byte[1024]; try ( FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(destFile); )&#123; while(true)&#123; //实际读取的长度是 actuallyReaded,有可能小于1024 int actuallyReaded = fis.read(buffer); //-1表示没有可读的内容了 if(-1==actuallyReaded) break; fos.write(buffer, 0, actuallyReaded); fos.flush(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; /*** @param srcPath 源文件夹* @param destPath 目标文件夹*/public static void copyFolder(String srcPath, String destPath)&#123; File srcFolder = new File(srcPath); File destFolder = new File(destPath); //源文件夹不存在 if(!srcFolder.exists()) return; //源文件夹不是一个文件夹 if(!srcFolder.isDirectory()) return; //目标文件夹是一个文件 if(destFolder.isFile()) return; //目标文件夹不存在 if(!destFolder.exists()) destFolder.mkdirs(); //遍历源文件夹 File[] files= srcFolder.listFiles(); for (File srcFile : files) &#123; //如果是文件，就复制 if(srcFile.isFile())&#123; File newDestFile = new File(destFolder,srcFile.getName()); copyFile(srcFile.getAbsolutePath(), newDestFile.getAbsolutePath()); &#125; //如果是文件夹，就递归 if(srcFile.isDirectory())&#123; File newDestFolder = new File(destFolder,srcFile.getName()); copyFolder(srcFile.getAbsolutePath(),newDestFolder.getAbsolutePath()); &#125; &#125;&#125;public static void main(String[] args) &#123; copyFolder("C:\\Users\\12905\\Desktop\\xxx", "C:\\Users\\12905\\Desktop\\yyy");&#125; 查找文件内容12345678910111213141516171819202122232425262728293031323334353637/** * @param file 查找的目录 * @param search 查找的字符串 */public static void search(File file, String search) &#123; if (file.isFile()) &#123; if(file.getName().toLowerCase().endsWith(".java"))&#123; String fileContent = readFileConent(file); if(fileContent.contains(search))&#123; System.out.printf("找到子目标字符串%s,在文件:%s%n",search,file); &#125; &#125; &#125; if (file.isDirectory()) &#123; File[] fs = file.listFiles(); for (File f : fs) &#123; search(f, search); &#125; &#125;&#125; public static String readFileConent(File file)&#123; try (FileReader fr = new FileReader(file)) &#123; char[] all = new char[(int) file.length()]; fr.read(all); return new String(all); &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125;&#125;public static void main(String[] args) &#123; File folder =new File("e:\\project"); search(folder,"Magic");&#125; 流关系图]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL非主键自增]]></title>
    <url>%2F2018%2F06%2F29%2FMySQL%E9%9D%9E%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%2F</url>
    <content type="text"><![CDATA[MySQL中，一张表只能有一个自增，但不一定是主键自增。首先创建一个测试表。12345create table test(id int(11) primary key,sid int(11) not null auto_increment,name varchar(30) not null,key(sid)); 接着插入一条语句。1insert into test(id, name) values(1, 'a'); 发现sid非主键自增。 原理:ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key意思大义是：只能有一个自动列，并且必须被定义为键(key)。翻译成白话文就是说，普通列是没办法创建自增长的。 结论: MySQL中的每张表只能设置一个字段为自增长，这个字段可以是非主键，但必须是一种键(key)。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[员工部门表综合查询]]></title>
    <url>%2F2018%2F06%2F16%2F%E5%91%98%E5%B7%A5%E9%83%A8%E9%97%A8%E8%A1%A8%E7%BB%BC%E5%90%88%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[员工部门表综合查询 创建员工部门表12345678910111213141516171819202122232425262728293031323334353637383940CREATE DATABASE oa;USE oa;CREATE TABLE dept(deptno INT PRIMARY KEY,dname VARCHAR(20),loc VARCHAR(20))DROP TABLE empCREATE TABLE emp(empno INT PRIMARY KEY,ename VARCHAR(20) NOT NULL,job VARCHAR(20) CHECK (job IN ('CLERK','SALESMAN','MANAGER','SALESMAN','ANALYST')),mgp INT ,hiredate DATETIME ,sal DECIMAL(10,2),comm DECIMAL(10,2),DEPTNO INT FOREIGN KEY REFERENCES dept(deptno))INSERT INTO dept VALUES (10,'ACCOUNTING','NEWTORK')INSERT INTO dept VALUES (20,'RESEARCH','DALLAS')INSERT INTO dept VALUES (30,'SALES','CHICAGO')INSERT INTO dept VALUES (40,'OPERATIONS','BOSTON')insert into emp values(7369,'SMITH','CLERK',7902,'1980-12-17',1640,NULL,20);insert into emp values(7499,'ALLEN','SALESMAN',7698,'1981-2-20',11400,300,30);insert into emp values(7521,'WARD','SALESMAN',7698,'1981-2-22',5200,500,30);insert into emp values(7566,'JOENS','MANAGER',7839,'1981-4-2',7015,NULL,20);insert into emp values(7654,'MARTIN','SALESMAN',7698,'1981-9-28',5200,1400,30);insert into emp values(7698,'BLAKE','MANAGER',7839,'1981-5-1',5900,NULL,30);insert into emp values(7782,'CLARK','MANAGER',7839,'1981-6-9',2470,NULL,10);insert into emp values(7788,'SCOTT','ANALYST',7566,'1987-4-19',3040,NULL,20);insert into emp values(7844,'TURNER','SALESMAN',7698,'1980-12-17',6200,0,30);insert into emp values(7876,'ADAMS','CLERK',7788,'1981-9-8',2240,NULL,20);insert into emp values(7900,'JAMES','CLERK',7698,'1987-5-23',4000,NULL,30);insert into emp values(7902,'FORD','ANALYST',7566,'1981-12-3',3040,NULL,20);insert into emp values(7934,'MILLER','CLERK',7782,'1982-12-3',2620,NULL,10); 查询20部门的所有员工信息。1select * from emp where deptno=20; 查询所有工种为CLERK的员工的员工号、员工名和部门号。1select empno,ename,deptno from emp where job='CLERK'; 查询奖金（COMM）高于工资（SAL）的员工信息。1select * from emp where isnull(comm,0)&gt;sal 查询奖金高于工资的20%的员工信息。1select * from emp where isnull(comm,0)&gt;sal*0.2 查询所有工种不是MANAGER和CLERK，且工资大于或等于2000的员工的详细信息。123select * from empwhere job not in('MANAGER','CLERK') and sal&gt;=2000 查询有奖金的员工的不同工种。12select distinct job from empwhere comm is not null 查询没有奖金或奖金低于100的员工信息。123select * from empwhere comm is null or comm&lt;100 查询各月倒数第3天(倒数第2天)入职的员工信息。123select *from empwhere DATENAME(day,hiredate+3)=1 查询工龄大于或等于25年的员工信息。123select ename 姓名,hiredate 雇用日期,datediff(year,hiredate,getdate()) 工资from empwhere datediff(year,hiredate,getdate())&gt;=25 查询员工信息，要求以首字母大写的方式显示所有员工的姓名。12select upper(SUBSTRING(ename,1,1))+lower(substring(ename,2,(len(ename)-1)))from emp 查询员工名正好为6个字符的员工的信息。1select ename from emp where len(ename)=6 查询员工名字中不包含字母“Ｓ”的员工。1select ename from emp where ename not like '%Ｓ%' 查询员工姓名的第二字母为“M”的员工信息。12select ename from empwhere ename like '_M%' 查询所有员工姓名的前三个字符。12select ename 员工姓名,substring(ename,1,3) 员工姓名的前三个字符from emp 查询员工的姓名和入职日期，并按入职日期从先到后进行排序。123select ename,hiredatefrom emporder by hiredate 显示所有员工的姓名、工种、工资和奖金，按工种降序排序，若工种相同则按工资升序排序。123select ename,job,sal,commfrom emporder by job desc 查询在2月份入职的所有员工信息。12select * from empwhere datename(mm,hiredate)=2 查询至少有一个员工的部门信息。12345select d.dname,count(empno) 部门人数from emp eright join dept d on d.deptno=e.deptnogroup by d.dname,e.deptnohaving count(empno)&gt;=1 查询至少有两个员工的部门信息。12345select d.dname,count(empno) 部门人数from emp eright join dept d on d.deptno=e.deptnogroup by d.dname,e.deptnohaving count(empno)&gt;1 查询工资比SMITH员工工资高的所有员工信息。12345select *from empwhere sal&gt;(select sal from emp where ename='SMITH') 查询所有员工的姓名及其直接上级的姓名。1234select ename 员工的姓名,(select ename from emp e2 where e2.empno=e1.mgp) 直接上级from emp e1 查询入职日期早于其直接上级领导的所有员工信息。123456789select ename 员工的姓名,hiredate 入职日期,(select ename from emp e2 where e2.empno=e1.mgp) 直接上级,(select hiredate from emp e2 where e2.empno=e1.mgp) 直接上级入职日期from emp e1where e1.hiredate&lt;(select hiredate from emp e2 where e2.empno=e1.mgp) 查询所有部门及其员工信息，包括那些没有员工的部门。123select dept.dname,emp.ename from deptleft outer join emp on emp.deptno=dept.deptno 查询所有员工及其部门信息，包括那些还不属于任何部门的员工。123select dept.dname,emp.ename from empleft outer join dept on emp.deptno=dept.deptno 查询所有工种为CLERK的员工的姓名及其部门名称。1234select dept.dname,emp.ename,emp.job from empleft outer join dept on emp.deptno=dept.deptnowhere job='CLERK' 查询最低工资大于2500的各种工作。123select job,sal from empwhere sal&gt;2500 查询平均工资低于2000的部门及其员工信息。123456select *from dept left outer join emp on dept.deptno=emp.deptnowhere dept.deptno in (select deptno from empgroup by deptnohaving avg(sal)&lt;2000) 查询在SALES部门工作的员工的姓名信息。123456789表连接select *from dept left outer join emp on dept.deptno=emp.deptnowhere dept.dname='SALES'子查询select * from emp where emp.deptno=(select deptno from dept where dname='SALES') 查询工资高于公司平均工资的所有员工信息。1234select * from empwhere sal&gt;(select avg(sal)from emp) 查询出与SMITH员工从事相同工作的所有员工信息。1234select * from emp where job = (select job from emp where ename='SMITH') 列出工资等于30部门中某个员工的工资的所有员工的姓名和工资。123456select *from empwhere sal in (select salfrom empwhere deptno=30) and deptno!=30 查询工资高于30部门工作的所有员工的工资的员工姓名和工资。123456select *from empwhere sal &gt; all(select salfrom empwhere deptno=30) 查询每个部门中的员工数量、平均工资和平均工作年限。12345select dname 部门,count(ename) 员工数量,isnull(avg(sal),0) 平均工资,isnull(avg(datediff(yy,hiredate,getdate())),0) 平均工作年限from dept d left outer join emp e on d.deptno=e.deptnogroup by d.dname 查询从事同一种工作但不属于同一部门的员工信息。1234567select *from emp e1where e1.job in (select distinct e2.jobfrom emp e2where e2.deptno != e1.deptno ) 查询各个部门的详细信息以及部门人数、部门平均工资。1234select d.dname 部门名称,d.deptno 部门编号,count(e.empno) 人数,avg(e.sal) 平均工资 from dept d left outer join emp e on d.deptno=e.deptnogroup by d.deptno,d.dname 查询各种工作的最低工资。123select job 工种,min(sal) 最低工资from empgroup by job 查询各个部门中不同工种的最高工资。123select dname 部门名称,job 工种,max(isnull(sal,0)) 最高工资from dept d left join emp e on d.deptno=e.deptnogroup by job,dname 查询10号部门员工及其领导的信息。123select deptno 部门,ename 姓名 ,(select e2.ename from emp e2 where e2.mgp=e1.empno) 上级领导from emp e1where deptno=10 查询各个部门的人数及平均工资。123select dname 部门名称,count(ename) 部门人数,avg(isnull(sal,0)) 平均工资from dept d left outer join emp e on d.deptno=e.deptnogroup by d.dname 查询工资为某个部门平均工资的员工的信息。12345select * from empwhere sal in(select avg(sal)from emp group by deptno) 查询工资高于本部门平均工资的员工的信息。1234567select *from emp e1where sal&gt;(select avg(sal)from emp e2where e2.deptno=e1.deptno) 查询工资高于本部门平均工资的员工的信息及其部门的平均工资。12345select *,(select avg(sal) from emp e2 where e2.deptno=e1.deptno) 部门平均工资from emp e1where sal&gt;(select avg(sal) from emp e2 where e2.deptno=e1.deptno) 查询工资高于20号部门某个员工工资的员工的信息。12345select *from emp e1where sal&gt; any(select sal from emp e where deptno=20) 统计各个工种的员工人数与平均工资。123select job 工种,count(empno) 员工人数,avg(sal) 平均工资from empgroup by job 统计每个部门中各工种的人数与平均工资。123select dname 部门,job 工种,count(empno) 人数,avg(isnull(sal,0)) 平均工资from dept d left outer join emp e on d.deptno=e.deptnogroup by job,dname 查询其他部门中工资、奖金与30号部门某员工工资、奖金都相同的员工的信息。没有查询结果1234567select *from emp ewhere isnull(sal,0)+isnull(comm,0) in (select isnull(sal,0)+isnull(comm,0)from emp e1where e1.deptno=30 and e.sal=e1.sal and e.comm=e1.comm and e.deptno!=30) 查询部门人数大于5的部门的员工信息。123456select * from emp where deptno in(select deptnofrom empgroup by deptnohaving count(empno)&gt;5) 查询所有员工工资都大于1000的部门的信息。1234567select *from dept dwhere deptno in (select deptno from emp egroup by deptnohaving min(sal)&gt;1000) 查询所有员工工资都大于1000的部门的信息及其员工信息。1234567select *from dept d left outer join emp e on d.deptno=e.deptnowhere e.deptno in (select deptno from emp e1group by deptnohaving min(sal)&gt;1000) 查询所有员工工资都在900～3000之间的部门的信息。123456select * from deptwhere deptno in(select deptno from emp group by deptno having min(sal)&gt;900 and max(sal)&lt;3000) 查询有工资在900～3000之间的员工所在部门的员工信息。123456select * from empwhere deptno in(select deptno from emp group by deptno having min(sal)&gt;900 and max(sal)&lt;3000) 查询每个员工的领导所在部门的信息。12345678select ename 员工,(select e1.ename from emp e1 where emp.mgp=e1.empno) 领导,(select d.dnamefrom emp e left outer join dept d on e.deptno=d.deptnowhere emp.mgp=e.empno ) 领导所在部门from emp 查询人数最多的部门信息。123456select * from deptwhere deptno =(select top 1 deptnofrom empgroup by deptnoorder by -count(empno)) 查询30号部门中工资排序前3名的员工信息。1234select top 3 *from emp where deptno=30 order by -sal 查询所有员工中工资排序在5到10名之间的员工信息。123456select top 5 *from (select top 10 *from emp order by -sal) eorder by sal 查询指定年份之间入职的员工信息。(1980-1985)123select *from empwhere datename(year,hiredate) between 1980 and 1985]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL选择题]]></title>
    <url>%2F2018%2F06%2F06%2FMySQL%E9%80%89%E6%8B%A9%E9%A2%98%2F</url>
    <content type="text"><![CDATA[向数据表中插入一条记录用以下哪一项(B)A、CREATEB、INSERTC、SAVED、UPDATE 如果只需要返回匹配的列，则应当使用哪种连接(A)A、内连接B、交叉连接C、左连接D、全连接 下聚合函数求数据总和的是(B)A、MAXB、SUMC、COUNTD、AVG SQL语句中的条件用以下哪一项来表达(C)A、THENB、WHILEC、WHERED、IF 修改数据库表结构用以下哪一项(D)A、UPDATEB、CREATEC、UPDATEDD、ALTER SELECT语句的完整语法较复杂，但至少包括的部分是(B)A、仅SELECTB、SELECT， FROMC、SELECT， GROUPD、SELECT，INTO 以下语句错误的是(C)A、select sal+1 from emp;B、select sal10, saldeptno from emp;C、不能使用运算符号D、select sal10, deptno10 from emp; 若想限定某列在表中不允许出现重复的数据且不能为空值，应当使用(B)约束完成。A、CHECKB、PRIMARY KEYC、FOREIGN KEYD、UNIQUE 查找条件为: 姓名不是null的记录(C)A、WHERE NAME ! NULLB、WHERE NAME NOT NULLC、WHERE NAME IS NOT NULLD、WHERE NAME!=NULL 使用SQL语句进行分组检索时，为了去掉不满足条件的分组，应当(B)A、使用WHERE子句B、在GROUP BY后面使用HAVING子句C、先使用WHERE子句，再使用HAVING子句D、先使用HAVING子句，再使用WHERE子句 假设有scores表的设计如下:ID (编号，主键)StudentID (学生编号)CourseID (课程编号)Score (分数)现在要查询参加过至少两门课程考试的学生各门课程的平均成绩。以下SQL语句正确的是(A)A、select StudentID,avg(score) from scores group by StudentID having count(studentID)&gt;1B、select StudentID,avg(score) from scores group by StudentID where count(studentID)&gt;1C、select StudentID,avg(score) from scores group by StudentID where count(studentID)&gt;1 group by StudentIDD、select StudentID,avg(score) from scores having count(studentID)&gt;1 下列哪种操作能够实现实体完整性(D)A、设置非空约束B、设置外键C、减少数据冗余D、设置主键 为了去除结果集中重复的行，可在SELECT语句中使用下列哪个关键字(B)A、ALLB、DISTINCTC、UPDATED、MERGE 下列(C)不属于连接种类A、左外连接B、内连接C、中间连接D、交叉连接 SQL语言中允许使用通配符进行字符串匹配的操作，其中’%’可以表示(D)A、零个字符B、1个字符C、多个字符D、以上都是 若要查询成绩score为60-80分之间(包括60分，不包括80分)的学生信息，成绩字段查询准则应该设置为(B)A、score&gt;= 60 and &lt; 80B、score&gt;= 60 and score&lt; 80C、score between 60 and 80D、score IN(60, 80) GROUP BY 子句的作用是什么(A)A、查询结果的分组条件B、组的筛选条件C、限定返回的行的判断条件D、对结果集进行排序 唯一约束与主键约束的一个区别是(D)A、唯一约束的列的值不可以有重复值B、唯一约束的列的值可以不是唯一的C、唯一约束的列不可以为空值D、唯一约束的列可以为空值 在SQL语句中，子查询是(D)A、选区单表中字段子集的查询语句B、选取多表中字段子集的查询语句C、返回单表中数据子集的查询语言D、嵌入到另一个查询语句之中的查询语句 查询员工工资信息时，结果按工资降序排列，正确的是(B)A、ORDER BY 工资B、ORDER BY 工资 descC、ORDER BY 工资 ascD、ORDER BY 工资 dictinct]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML试题]]></title>
    <url>%2F2018%2F06%2F02%2FUML%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、UML的全称是(B)A、Unify Modeling LanguageB、Unified Modeling LanguageC、Unified Modem LanguageD、Unified Making Language2、执行者(Actor)与用例之间的关系是(C)A、包含关系B、泛化关系C、关联关系D、扩展关系 3、在类图中，”#”表示的可见性是(B)A、PublicB、ProtectedC、PrivateD、Package 4、生命线是UML视图中哪个图形的组成部分(D)A、类图B、状态图C、活动图D、顺序图(序列图/时序图) 5、在类图中，哪种关系表达总体与局部的关系(D)A、泛化B、实现C、依赖D、聚合 6、哪个UML视图是描述一个对象的声明周期的(B)A、类图B、状态图C、协作图D、顺序图 7、下面哪个视图属于UML语言的交互图(D)A、行为图B、状态图C、实现图D、顺序图(序列图/时序图) 8、在UML协作图中，有多少种关联角色的构造型(C)A、1B、3C、5D、7 9、下面哪些图形可以清楚地表达并发行为(CD)A、类图B、状态体C、活动图D、顺序图 10、下面哪些元素构成了组件图形(ACD)A、组件B、转换C、关系D、接口 11、部署图中的节点具有以下哪些方面的内容(ABC)A、计算能力B、基本内存C、位置D、接口 12、顺序图的用途包括(ABCD)A、显示并发进程和激活B、当不同的类之间存在多个简短的方法时，描述控制流的整体序列C、显示在协作图中难于描述的事件序列D、显示涉及类交互而与对象无关的一般形式 13、常见的UML工具有哪些?(ABCD)A、Rational RoseB、Power DesignerC、VisioD、Visual UML 14、UML提供了一系列的图支持面向对象的分析与设计，其中类图给出系统的静态设计视图；用例图对系统的行为进行组织和建模是非常重要的；序列图和协作图都是描述系统动态视图的交互图，其中序列图描述了以时间顺序组织的对象之间的交互活动，协作图强调收发消息的对象的组织结构。 15、UML提供了4种结构图用于对系统的静态方面进行可视化、详述、构造和文档化。其中类图是面向对象系统规模中最常用的图，用于说明系统的静态设计视图；当需要说明系统的静态实现视图时，应该选择组件图；当需要说明体系结构的静态实施视图时，应该选择部署图。 16、UML语言包含几大类图形(B)A、3B、5C、7D、9 17、OMT方法是由下面哪位科学家提出的(B)A、BoochB、RumbaughC、CoadD、Jacobson 18、什么概念被认为是第二代面向对象技术的标志(A)A、用例B、UML语言C、活动图D、组件图 19、在UML的顺序图中，通常由左向右分层排列各个对象，正确的排列方法是(A)A、执行者角色、控制类、用户接口、业务层、后台数据库B、执行者角色、用户接口、控制类、业务层、后台数据库C、执行者角色、控制类、用户接口、后台数据库、业务层D、执行者角色、用户接口、业务层、控制类、后台数据库 20、多对象是UML哪个视图中的概念(C)A、类图B、状态图C、协作图D、组件图 21、在UML中，接口有几种表达方式(A)A、2B、4C、6D、8 22、顺序图由类角色，生命线，激活期和(B)组成。A、关系B、消息C、用例D、实体 23、UML中关联的多重度是指(B)A、一个类有多个方法被另一个类调用B、一个类的实类能够与另一个类的多个实类相关联C、一个类的某个方法被另一个类调用的次数D、两个类所具有的相同的方法和属性 24、具有多重属性值的UML图形包括(AE)A、类图B、对象图C、状态图D、活动图E、部署图 25、在UML的状态图中，转换通常由以下哪些部分构成(ABCDE)A、动作B、触发事件C、源状态D、目标状态E、监护条件 26、软件工程的三要素是(ABD)A、方法B、工具C、模型D、过程E、语言 27、可能具有状态机的对象包括(ABCDE)A、类B、子系统C、用例D、接口E、协议 28、UML中，类的主要版型有(CDE)A、角色类B、业务类C、边界类D、控制类E、实体类 29、UML的类图包含哪些抽象的层次(ABC)A、概念层B、说明层C、实现层D、业务层E、控制层 30、下面哪一项不是包图中的关系(D)A、《use》B、《access》C、《trace》D、《stub》 31、RUP中有(C)个核心过程工作流。A、1B、3C、6D、9 32、部署图的组成不包括(C)A、处理器B、设备C、构件D、连接 33、顺序图由对象，生命线，控制焦点和(B)组成。A、关系B、消息C、用例D、实体 34、组成UML有三种基本的建筑块是: (A)、事物和图。A、关系B、类C、用例D、实体 35、UML体系包括三个部分：UML基本构造块、(A)和UML公共机制。A、UML规则B、UML命名C、UML模型D、UML约束 36、(A)模型的缺点是缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题。A、瀑布模型B、原型模型C、增量模型D、螺旋模型 37、下面哪个不是UML中的静态视图(A)A、状态图B、用例图C、对象图D、类图 38、对反应型对象建模一般使用(A)图。A、状态图B、顺序图C、活动图D、类图 39、类图应该画在Rose的哪种(B)视图中。A、Use CaseViewB、Logic ViewC、ComponentViewD、Deployment View 40、(D)是可复用的，提供明确接口完成特定功能的程序代码块。A、模块B、函数C、用例D、软件构件 41、(A)是用于把元素组织成组的通用机制。A、包B、类C、接口D、组件 42、(B)是被节点执行的事物体。A、包B、组件C、接口D、节点]]></content>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmall_ssm后台]]></title>
    <url>%2F2018%2F05%2F30%2Ftmall-ssm%E5%90%8E%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[查询Category.javaCategoryMapper.javaCategoryService.javaCategoryServiceImpl.javaCategoryController.javaCategoryMapper.xmllog4j.propertiesjdbc.propertiesapplicationContext.xmlspringMVC.xmlweb.xmllistCategory.jsp 分页Page.javaCategoryMapper.xmlCategoryMapper.javaCategoryService.javaCategoryServiceImpl.javaCategoryController.javalistCategory.jspadminPage.jsp 增加adminHeader.jspCategoryMapper.xmlCategoryMapper.javaCategoryService.javaCategoryServiceImpl.javaUploadedImageFile.javaImageUtil.javaCategoryController.javaweb.xml 中文问题 删除adminHeader.jsp 确认删除CategoryMapper.xmlCategoryMapper.javaCategoryService.javaCategoryServiceImpl.javaCategoryController.java 编辑listCategory.jspCategoryMapper.xmlCategoryMapper.javaCategoryService.javaCategoryServiceImpl.javaCategoryController.javaeditCategory.jsp 修改editCategory.jspCategoryMapper.xmlCategoryMapper.javaCategoryService.javaCategoryServiceImpl.javaCategoryController.java 重构CategoryController.java 分页插件, list获取分页数据,total获总数applicationContext.xml 插件部分 OverlsMergeablePlugin.javageneratorConfig.xmlMybatisGenerator.java 属性管理Property.java 新增CategoryPropertyService.java CRUD 在业务上需要查询某个分类下的属性，list带对应分类id。PropertyServiceImpl.java 实现对应方法PropertyController.javalistProperty.jspeditProperty.jsp 产品管理Product.java 新增CategoryProductService.java CRUDProductServiceImpl.javaProductController.javalistProduct.jspeditProduct.jsp 产品图片管理ProductImage.javaProductImageService.java CRUDProductImageServiceImpl.javaProductImageController.javalistProductImage.jsp以下调整为了在产品管理显示图片Product.java 新增firstProductImageProductService.java 新增setFirstProductImage(Product p)ProductServiceImpl.java 新增setFirstProductImage(Product p)和setFirstProductImage(List ps)listProduct.jsp 产品属性值设置PropertyValue.jsp 新增Property, getter, setterPropertyValueService.javaPropertyValueServiceImpl.javaPropertyValueController.javaeditPropertyValue.jsp 用户管理User.javaUserService.java CRUDUserServiceImpl.javaUserController.javalistUser.jsp 订单管理OrderItem.java 新增product, 要在订单管理页面需要看到订单下面的订单项里的产品图片Order.java 新增orderItems, user, total, totalNumberOrderItemService.java CRUDOrderItemServiceImpl.java 新增fill(Order order)和fill(List orders)进行二次开发OrderService.java 提供CRUD, 订单状态常量值OrderServiceImpl.java 实现CRUDOrderController.java list和delievery(发货)listOrder.jsp 数据库数据表tmall_ssm之数据库 表关系 一 多 Category-分类 Product-产品 Category-分类 Property-属性 Property-属性 PropertyValue-属性值 Product-产品 PropertyValue-属性值 Product-产品 ProductImage-产品图片 Product-产品 Review-评价 User-用户 Order-订单 Product-产品 OrderItem-订单项 User-用户 OrderItem-订单项 Order-订单 OrderItem-订单项 User-用户 Review-评价 Spring控制反转(IOC)控制反转也叫依赖注入，利用工厂模式将对象交给容器管理，只需在spring配置文件中配置相应的bean,以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。 面向切面(AOP)AOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。在面向切面的思想里面，把功能分为核心业务功能和周边功能。所谓的核心业务，比如登陆，增加数据，删除数据都是核心业务。所谓的周边业务，比如性能统计，日志，事务管理等。 Spring MVC分离了控制器、模型对象、分派器以及处理程序对象的角色。 Mybatis使用简单的XML或注解用于配置和原始映射，将接口和Java的普通对象映射成数据库中的记录。使用Mybatis后，只需要自己提供SQL语句，其他工作，诸如建立连接，Statement，JDBC相关异常处理等等都交给Mybatis，我们只需关注在增删改查等操作层面上，而把技术细节都封装在了我们看不见的地方。 CategoryMapper.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.how2java.tmall.mapper.CategoryMapper"&gt; &lt;select id="list" resultType="Category"&gt; select * from category order by id desc &lt;if test="start!=null and count!=null"&gt; limit #&#123;start&#125;,#&#123;count&#125; &lt;/if&gt; &lt;/select&gt; &lt;select id="total" resultType="int"&gt; select count(*) from category &lt;/select&gt; &lt;insert id="add" keyProperty="id" useGeneratedKeys="true" parameterType="Category" &gt; insert into category ( name ) values (#&#123;name&#125;) &lt;/insert&gt; &lt;delete id="delete"&gt; delete from category where id= #&#123;id&#125; &lt;/delete&gt; &lt;select id="get" resultType="Category"&gt; select * from category where id= #&#123;id&#125; &lt;/select&gt; &lt;update id="update" parameterType="Category" &gt; update category set name=#&#123;name&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt;]]></content>
      <tags>
        <tag>tmall_ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmall_ssm项目结构]]></title>
    <url>%2F2018%2F05%2F30%2Ftmall-ssm%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[项目结构项目名称tmall_ssm java源代码包结构pojo 实体类mapper Mapper类interceptor 拦截器controller 控制层service Service层test 测试类util 工具类comparator 比较类 web目录css css文件img 图片资源js js文件admin 后台管理用到的jsp文件fore 前台展示用到的jsp文件include 被包含的jsp文件 典型场景购物车立即购买购买流程点击购买，会在OrderItem表中插入一条数据，这条数据会表示:1、pid 购买的商品id2、oid 这个订单项还没有生成对应的订单，即还在购物车中3、uid 用户uid4、number 购买了几件产品 如果未登录，点击购买之前会弹出模态登录窗口。登录之后，点击立即购买，会访问tmall_ssm/forebuyone?pid=&amp;num=，并带上了产品id和购买数量。 为OrderItemService新增方法listByUser。为OrderItemServiceImpl新增方法listByUser的实现。通过上个步骤访问地址forebuyone，调用ForeController.buyone()。获取参数pid、num，根据pid获取产品对象p，从session中获取用户对象user。接下来就是新增订单项OrderItem，新增订单项要考虑两个情况。1、如果已经存在这个产品对应的OrderItem,并且还没有生成订单，即还在购物车中。那么就应该在对应的OrderItem基础上，调整数量。 1) 基于用户对象user，查询没有生成订单的订单项集合。2) 遍历这个集合。3) 如果产品是一样的话，就进行数量追加4）获取这个订单项的id 2、如果不存在对应的OrderItem，那么就新增一个订单项OrderItem 1) 生成新的订单项2）设置数量，用户和产品3）插入到数据库4）获取这个订单项的id 最后，基于这个订单项id，客户端跳转到结算页面/forebuy。 模态登录窗口立即购买和加入购物车这两个按钮的监听是放在imgAngInfo.jsp页面中。这两个按钮都会通过JQuery的.get方法，用异步Ajax的方式访问forecheckLogin，获取当前是否登录状态，如果返回的不是success即表明是未登录状态，那么就会打开登录的模态窗口: $(&quot;#loginModal&quot;).modal(&#39;show&#39;); 在上一步的Ajax访问路径/forecheckLogin会导致ForeController.checkLogin()方法被调用。获取session中的user对象，如果不为空，即表示已经登录，返回字符串success；如果为空，即表示未登录，返回字符串fail。 modal.jsp页面被footer.jsp所包含，所以每个页面都是加载了的。通过imgAndInfo.jsp页面中的购买按钮或者加入购物车按钮显示出来。点击登录按钮时，使用imgAndInfo.jsp页面中的Ajax代码进行登录验证。 在上一步modal.jsp中，点击了登录按钮之后，访问路径/foreloginAjax，导致ForeController.loginAjax()方法被调用。获取账号密码，通过账号密码获取User对象，如果User对象为空，那么就返回fail字符串，如果User对象不为空，那么就把User对象放在session中，并返回success字符串。 结算页面结算流程在购买页面中，客户端跳转到路径/forebuy?oiid=，导致ForeController.buy方法被调用。1、通过字符串数组获取参数oiid。为社么为什么这里要用字符串数组试图获取多个oiid，而不是int类型仅仅获取一个oiid? 因为根据购物流程环节与表关系，结算页面还需要显示在购物车中选中的多条OrderItem数据，所以为了兼容从购物车页面跳转过来的需求，要用字符串数组获取多个oiid。2、准备一个泛型是OrderItem的集合ois3、根据前面步骤获取的oiids，从数据库中取出OrderItem对象，并放入ois集合中4、累计这些ois的价格总数，赋值在total上5、把订单项集合放在session的属性 “ois” 上6、把总价格放在 model的属性 “total” 上7、服务端跳转到buy.jsp 在buyPage.jsp中，遍历出订单项集合ois中的订单项数据，显示总金额。 加入购物车加入购物车流程在产品页面点击加入购物车时，在OrderItem表中插入一条数据，把界面上的加入购物车按钮变成灰色并且不可点击。 如果未登录，那么点击加入购物车会弹出模态登陆窗口，登录之后，点击加入购物车，会使用Ajax一步访问地址/foreaddCart?pid=&amp;num=，并带上了产品id和购买数量num。 上一步访问地址/foreaddCart调用ForeController.addCart()。addCart()方法和立即购买中的ForeController.buyone()步骤做的事情是一样的，区别在于返回不一样。1、获取参数pid,num。2、根据pid获取产品对象p3、从session中获取用户对象user 接下来就是新增订单项OrderItem, 新增订单项要考虑两个情况:1、如果已经存在这个产品对应的OrderItem,并且还没有生成订单，即还在购物车中。那么就应该在对应的OrderItem基础上，调整数量。 1) 基于用户对象user，查询没有生成订单的订单项集合。2) 遍历这个集合。3) 如果产品是一样的话，就进行数量追加4）获取这个订单项的id 2、如果不存在对应的OrderItem，那么就新增一个订单项OrderItem 1) 生成新的订单项2）设置数量，用户和产品3）插入到数据库4）获取这个订单项的id 与ForeController.buyone()客户端跳转到结算页面不同的是，最后返回字符串”success”, 表示添加成功。 查看购物车页面访问地址/forecart调用ForeController.cart()方法。1、通过session获取当前用户， 所以一定要登录才能访问，否则拿不到用户对象，会报错。2、获取为这个用户关联的订单集合ois3、把ois放在model中4、服务端跳转到cart.jsp 与register.jsp相仿， cart.jsp也包含了header.jsp, top.jsp, simpleSearch.jsp, footer.jsp等公共页面。中间是产品业务页面cartPage.jsp 在cartPage.jsp中遍历订单项集合ois，即可。 购物车页面操作购物车页面和服务端的交互主要是三个1、增加、减少某种产品的数量2、删除某种产品3、选中产品后，提交到结算页面 调整订单数量点击增加或者减少按钮后，根据cartPage.jsp 中的js代码，会通过Ajax访问/forechangeOrderItem路径，导致ForeController.changeOrderItem()方法被调用1、判断用户是否登录2、获取pid和number3、遍历出用户当前所有的未生成订单的OrderItem4、根据pid找到匹配的OrderItem，并修改数量后更新到数据库5、返回字符串”success” 删除订单项点击删除按钮后，根据 cartPage.jsp 中的js代码，会通过Ajax访问/foredeleteOrderItem路径，导致ForeController.deleteOrderItem方法被调用1、判断用户是否登录2、获取oiid3、删除oiid对应的OrderItem数据4、返回字符串”success” 提交到结算页面在选中了购物车中的任意商品之后，结算按钮呈现可点击状态。点击之后，提交到结算页面，并带上(多个)被选中的OrderItem对象的id/forebuy?oiid=&amp;oiid=之后的流程就进入了前面的结算页面。 订单状态流转生成订单通过立即购买或者购物车的提交到结算页面进入结算页面，然后点击提交订单。提交订单后，在数据库中生成一条Order记录。不仅如此，订单项的oid字段也会被设置为这条Order记录的id。 在applicationContext.xml最后增加事务管理配置。因为增加订单行为需要同时修改两个表1、为Order表新增数据2、修改OrderItem表所以需要进行事务管理，否则当新增了Order表的数据，还没来得及修改OrderItem的时候出问题，比如突然断电，那么OrderItem的数据就会是脏数据了。 在OrderService中新增方法add(Order c, List ois)在OrderServiceImpl中实现add(Order o, List ois)方法，该方法通过注解进行事务管理。@Transactional(propagation= Propagation.REQUIRED,rollbackForClassName=&quot;Exception&quot;) 提交订单访问路径/forecreateOrder, 在ForeController中调用createOrder1、从session中获取user对象2、通过参数Order接受地址，邮编，收货人，用户留言等信息3、根据当前时间加上一个4位随机数生成订单号4、根据上述参数，创建订单对象5、把订单状态设置为等待支付6、从session中获取订单项集合 ( 在结算功能的ForeController.buy() 13行，订单项集合被放到了session中 )7、把订单加入到数据库，并且遍历订单项集合，设置每个订单项的order，更新到数据库8、统计本次订单的总金额9、客户端跳转到确认支付页forealipay，并带上订单id和总金额 确认支付1、在上一步客户端跳转到路径/forealipay方法，导致PageController.alipay()方法被调用。 alipay()没做什么事情，就是服务端跳转到了alipay.jsp页面。2、alipay.jsp :与 register.jsp 相仿，alipay.jsp也包含了header.jsp, top.jsp， footer.jsp 等公共页面。中间是确认支付业务页面 alipayPage.jsp3、alipayPage.jsp:显示总金额，并且让确认支付按钮跳转到页面 /forepayed页面，并带上oid和金额 支付成功页1、在上一步确认访问按钮提交数据到/forepayed,导致ForeController.payed方法被调用1.1 获取参数oid1.2 根据oid获取到订单对象order1.3 修改订单对象的状态和支付时间1.4 更新这个订单对象到数据库1.5 把这个订单对象放在model的属性”o”上1.6 服务端跳转到payed.jsp2、payed.jsp与 register.jsp 相仿，payed.jsp也包含了header.jsp, top.jsp, simpleSearch.jsp， footer.jsp 等公共页面。中间是支付成功业务页面 payedPage.jsp3、payedPage.jsp显示订单中的地址，邮编，收货人，手机号码等等 后台发货当订单状态是waitDelivery的时候，就会出现发货按钮1、发货按钮链接跳转到admin_order_delivery2、OrderController.delivery()方法被调用2.1 注入订单对象2.2 修改发货时间，设置发货状态2.3 更新到数据库2.4 客户端跳转到admin_order_list页面 确认收货1、点击确认收货后，访问地址/foreconfirmPay2、ForeController.confirmPay()方法被调用2.1 获取参数oid2.2 通过oid获取订单对象o2.3 为订单对象填充订单项2.4 把订单对象放在request的属性”o”上2.5 服务端跳转到 confirmPay.jsp 3、confirmPay.jsp与 register.jsp 相仿，confirmPay.jsp也包含了header.jsp, top.jsp, simpleSearch.jsp，footer.jsp 等公共页面。中间是订单确认业务页面 confirmPayPage.jsp4、confirmPayPage.jsp显示订单的创建时间，付款时间和发货时间，以及订单号，收款人信息等遍历订单项集合，显示其中的产品图片，产品标题，价格，数量，小计，总结信息最后提供确认支付按钮，提交到/foreorderconfirmed路径 确认收货成功通过上一步最后的确认支付按钮，提交到路径/foreorderConfirmed，导致ForeController.orderConfirmed()方法被调用1、ForeController.orderConfirmed() 方法1.1 获取参数oid1.2 根据参数oid获取Order对象o1.3 修改对象o的状态为等待评价，修改其确认支付时间1.4 更新到数据库1.5 服务端跳转到orderConfirmed.jsp页面2、orderConfirmed.jsp与 register.jsp 相仿，orderConfirmed.jsp也包含了header.jsp, top.jsp, simpleSearch.jsp， footer.jsp 等公共页面。中间是确认收货成功业务页面 orderConfirmedPage.jsp3、orderConfirmedPage.jsp显示”交易已经成功，卖家将收到您的货款。” 评价评价产品页面通过点击评价按钮，来到路径/forereview，导致ForeController.review()方法被调用1、ForeController.review()1.1 获取参数oid1.2 根据oid获取订单对象o1.3 为订单对象填充订单项1.4 获取第一个订单项对应的产品,因为在评价页面需要显示一个产品图片，那么就使用这第一个产品的图片了1.5 获取这个产品的评价集合1.6 为产品设置评价数量和销量1.7 把产品，订单和评价集合放在request上1.8 服务端跳转到 review.jsp2、review.jsp与 register.jsp 相仿，review.jsp也包含了header.jsp, top.jsp, simpleSearch.jsp，footer.jsp 等公共页面。中间是产品业务页面 reviewPage.jsp3、reviewPage.jsp在reviewPage.jsp中显示产品图片，产品标题，价格，产品销量，产品评价数量，以及订单信息等。同时还显示出了该产品所有的评价，但是默认是隐藏的 提交评价在评价产品页面点击提交评价，就把数据提交到了/foredoreview路径，导致ForeController.doreview方法被调用1、ForeController.doreview()1.1 获取参数oid1.2 根据oid获取订单对象o1.3 修改订单对象状态1.4 更新订单对象到数据库1.5 获取参数pid1.6 根据pid获取产品对象1.7 获取参数content (评价信息)1.8 对评价信息进行转义，道理同注册ForeController.register()1.9 从session中获取当前用户1.10 创建评价对象review1.11 为评价对象review设置 评价信息，产品，时间，用户1.12 增加到数据库1.13.客户端跳转到/forereview： 评价产品页面，并带上参数showonly=true2、reviewPage.jsp在reviewPage.jsp中，当参数showonly==true，那么就显示当前产品的所有评价信息 CRUD增加(create)读取查询(Retrieve)1、首先浏览器上访问路径 /admin_category_list2、tomcat根据web.xml上的配置信息，拦截到了/admin_category_list，并将其交由DispatcherServlet处理。3、DispatcherServlet 根据springMVC的配置，将这次请求交由CategoryController类进行处理，所以需要进行这个类的实例化4、在实例化CategoryController的时候，注入CategoryServiceImpl5、在实例化CategoryServiceImpl的时候，又注入CategoryMapper6、根据ApplicationContext.xml中的配置信息，将CategoryMapper和CategoryMapper.xml关联起来了。7、这样就拿到了实例化好了的CategoryController,并调用list方法8、在list方法中，访问CategoryService,并获取数据，并把数据放在”cs”上，接着服务端跳转到listCategory.jsp去9、最后在listCategory.jsp 中显示数据 更新(update)删除(delete)分页新增Page这个类专门为分页提供必要信息属性：&nbsp;&nbsp;&nbsp;&nbsp;int start; 开始位置&nbsp;&nbsp;&nbsp;&nbsp;int count; 每页显示的数量&nbsp;&nbsp;&nbsp;&nbsp;int total; 总共有多少条数据&nbsp;&nbsp;&nbsp;&nbsp;String param; 参数方法:&nbsp;&nbsp;&nbsp;&nbsp;getTotalPage根据每页显示的数量count以及总共有多少条数据total，计算出总共有多少页&nbsp;&nbsp;&nbsp;&nbsp;getLast计算出最后一页的数值是多少&nbsp;&nbsp;&nbsp;&nbsp;isHasPreviouse判断是否有前一页&nbsp;&nbsp;&nbsp;&nbsp;isHasNext判断是否有后一页 CategoryMapper.xml中，提供带分页的查询语句和获取总数的sql语句CategoryMapper.java中提供一个支持分页的查询方法list(Page page)和获取总数的方法totalCategoryService.java中，提供一个支持分页的查询方法list(Page page)和获取总数的方法listCategoryService.java中，提供一个支持分页的查询方法list(Page page)和获取总数的方法totalCategoryController.java中，为方法list增加参数Page用于获取浏览器传递过来的分页信息1、categoryService.list(page); 获取当前页的分类集合2、通过categoryService.total(); 获取分类总数3、通过page.setTotal(total); 为分页对象设置总数4、把分类集合放在”cs”中5、把分页对象放在 “page“ 中6、跳转到listCategory.jsp页面 在listCategory.jsp中加入adminPage.jsp adminPage.jsp中，分页超链的效果，用的Bootstrap的分页效果来制作。对边界进行了处理，没有上一页或下一页的时候，对应超链处于不可点击状态。hasPreviouse会导致isHasPreviouse()方法被调用。 逆向工程MybatisGenerator插件是Mybatis官方提供的，这个插件存在一个BUG，即第一次生成了CategoryMapper.xml后，再次运行会导致CategoryMapper.xml生成重复内容，而影响正常的运行。在resouces下创建generatorConfig.xml文件，其目的就是为了正确使用本插件而提供必要的配置信息。1、使用OverlsMergeablePlugin插件&lt;plugin type=&quot;com.how2java.tmall.util.OverIsMergeablePlugin&quot; /&gt;2、在生成的代码中，不提供注释。如果提供注释，生成出来的代码，看上去乱。3、指定链接数据库的账号和密码，既然是逆向工程，肯定要先链接到数据库。&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost/tmall_ssm&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;4、指定生成的pojo, mapper, xml文件的存放位置。5、生成对应表及类名。 在generatorConfig.xml中，加入所有的table表，运行MybatisGenerator，需要把today变量修改为今天。和手动编写的区别在于id类型 从基本类型id变成了Integer。12id: 基本类型Integer: 引用类型 属性管理属性管理流程Property.java实体类已经和其他所有的实体类一起，在逆向工程这个环节就一起自动生成好了。不过仅仅有自动生成的实体类代码，还不足以支撑业务需要，所以在Property基础上增加了一个Category字段。 PropertyService.java中，提供CRUD一套。因为在业务上需要查询某个分类下的属性，所以list方法会带上对应分类的id。 新增PropertyService.xml实现PropertyService对应的方法。通过调用自动生成的PropertyMapper就可以实现大部分方法。值得注意的是查询的时候用到了辅助查询类: PropertyExample。这一行表示查询cid字段example.createCriteria().andCidEqualTo(cid); 控制器类PropertyController.java用于映射不同路径的访问。 查询页面listProperty.jsp编辑页面editProperty.jsp 查询功能查询地址admin_property_list映射的是PropertyController的list()方法。1、获取分类 cid,和分页对象page2、通过PageHelper设置分页参数3、基于cid，获取当前分类下的属性集合4、通过PageInfo获取属性总数5、把总数设置给分页page对象6、拼接字符串”&amp;cid=”+c.getId()，设置给page对象的Param值。 因为属性分页都是基于当前分类下的分页，所以分页的时候需要传递这个cid7、把属性集合设置到 request的 “ps” 属性上8、把分类对象设置到 request的 “c” 属性上。 ( 这个c有什么用呢？ 在后面步骤的 其他-面包屑导航 中会用于显示分类名称)9、把分页对象设置到 request的 “page” 对象上10、服务端跳转到admin/listProperty.jsp页面11、在listProperty.jsp页面上使用c:forEach 遍历ps集合，并显示 增加功能1、在listProperty.jsp页面提交数据的时候，除了提交属性名称，还会提交cid2、在PropertyController通过参数Property 接受注入3、通过propertyService保存到数据库4、客户端跳转到admin_property_list,并带上参数cid 编辑功能1、在PropertyController的edit方法中，根据id获取Property对象2、根据properoty对象的cid属性获取Category对象，并把其设置在Property对象的category属性上3、把Property对象放在request的 “p” 属性中3、服务端跳转到admin/editProperty.jsp4、在editProperty.jsp中显示属性名称5、在editProperty.jsp中隐式提供id和cid( cid 通过 p.category.id 获取) 修改功能1、在PropertyController的update方法中获取Property对象2、借助propertyService更新这个对象到数据库3、客户端跳转到admin_property_list，并带上参数cid 删除功能1、在PropertyController的delete方法中获取id2、根据id获取Property对象3、借助propertyService删除这个对象对应的数据4、客户端跳转到admin_property_list，并带上参数cid 面包屑导航在属性管理页面的页头，有一个面包屑导航第一个连接跳转到admin_category_list第二个连接跳转到admin_property_list?cid=样式用的是Bootstrap面包屑导航 分页这里的分页比分类管理中的分页多了一个参数cid。1、在PropertyController.list() 方法中，把&amp;cid= 参数设置到在page对象的param属性上page.setParam(&quot;&amp;cid=&quot;+c.getId());2、在adminPage.jsp页面中通过${page.param}取出这个参数 产品管理产品管理流程Product.java在自动生成的基础上增加category属性。新增ProductService，提供CRUD一套。新增ProductServiceImpl，提供CRUD一套。get和list方法都会把取出来的Product对象设置上对应的category。准备ProductController.java类。查询页面listProduct.jsp编辑页面editProduct.jsp 查询功能讲解查询地址admin_product_list映射的是ProductController的list()方法1、获取分类 cid,和分页对象page2、通过PageHelper设置分页参数3、基于cid，获取当前分类下的产品集合4、通过PageInfo获取产品总数5、把总数设置给分页page对象6、拼接字符串”&amp;cid=”+c.getId()，设置给page对象的Param值。 因为产品分页都是基于当前分类下的分页，所以分页的时候需要传递这个cid7、把产品集合设置到 request的 “ps” 产品上8、把分类对象设置到 request的 “c” 产品上。 ( 这个c有什么用呢？ 在 其他-面包屑导航 中会用于显示分类名称)9、把分页对象设置到 request的 “page” 对象上10、服务端跳转到admin/listProduct.jsp页面11、在listProduct.jsp页面上使用c:forEach 遍历ps集合，并显示 增加功能讲解1、在listProduct.jsp提交数据的时候，除了提交产品名称，小标题，原价格，优惠价格，库存外还会提交cid2、在ProductController中获取Product对象，并插入到数据库3、客户端跳转到admin_product_list,并带上参数cid 编辑功能讲解1、在ProductController的edit方法中，根据id获取product对象2、根据product对象的cid产品获取Category对象，并把其设置在product对象的category产品上3、把product对象放在request的 “p” 产品中3、服务端跳转到admin/editProduct.jsp4、在editProduct.jsp中显示产品名称5、在editProduct.jsp中隐式提供id和cid( cid 通过 p.category.id 获取) 修改功能讲解1、在ProductController的update方法中获取Product对象2、借助productService更新这个对象到数据库3、客户端跳转到admin_product_list，并带上参数cid 删除功能讲解1、在ProductController的delete方法中获取id2、根据id获取Product对象3、借助productService删除这个对象对应的数据4、客户端跳转到admin_product_list，并带上参数cid 产品图片管理图片管理流程ProductImage.java直接使用自动生成的，没有变化。 创建ProductImageService，提供CRUD。同时提供两个常量，分别表示单个图片和详情图片:12String type_single = "type_single";String type_detail = "type_detail"; 除此之外，还提供了根据产品id和图片类型查询的list方法。1List list(int pid, String type); 创建ProductImageServiceImpl，实现CRUD相关方法。关于list方法，使用了ProductImageExample类，这样的写法表示同时匹配pid和type。123example.createCriteria() .andPidEqualTo(pid) .andTypeEqualTo(type); ProductImageController提供了list, add和delete方法。edit和update没有提供相关业务，所以无。 新增listProductImage.jsp 查询功能通过产品页面的图片管理访问ProductImageController的list()方法1、获取参数pid2、根据pid获取Product对象3、根据pid对象获取单个图片的集合pisSingle4、根据pid对象获取详情图片的集合pisDetail5、把product 对象，pisSingle ，pisDetail放在model上6、服务端跳转到admin/listProductImage.jsp页面7、在listProductImage.jsp，使用c:forEach 遍历pisSingle8、在listProductImage.jsp，使用c:forEach 遍历pisDetail 增加功能增加产品图片分单个和详情两种，其区别在于增加所提交的type类型不一样。这里就对单个的进行讲解，详情图片的处理同理。首先， 在listProductImage.jsp准备一个form，提交到admin_productImage_add。&lt;form method=&quot;post&quot; class=&quot;addFormSingle&quot; action=&quot;admin_productImage_add&quot; enctype=&quot;multipart/form-data&quot;&gt;接着在ProductImageController的add()方法中进行处理1、通过pi对象接受type和pid的注入2、借助productImageService，向数据库中插入数据。3、根据session().getServletContext().getRealPath( “img/productSingle”)，定位到存放单个产品图片的目录除了productSingle，还有productSingle_middle和productSingle_small。 因为每上传一张图片，都会有对应的正常，中等和小的三种大小图片，并且放在3个不同的目录下4、文件命名以保存到数据库的产品图片对象的id+”.jpg”的格式命名5、通过uploadedImageFile保存文件6、借助ImageUtil.change2jpg()方法把格式真正转化为jpg，而不仅仅是后缀名为.jpg7、再借助ImageUtil.resizeImage把正常大小的图片，改变大小之后，分别复制到productSingle_middle和productSingle_small目录下。8、处理完毕之后，客户端条跳转到admin_productImage_list?pid=，并带上pid。 详情图片做的是一样的事情，区别在于复制到目录productDetail下，并且不需要改变大小。ImageUtil.resizeImage 使用了swing自带的修改图片大小的API，属于底层工作原理。 删除功能点击删除超链，进入ProductImageController的delete方法1、获取id2、根据id获取ProductImage 对象pi3、借助productImageService，删除数据4、如果是单个图片，那么删除3张正常，中等，小号图片5、如果是详情图片，那么删除一张图片6、客户端跳转到admin_productImage_list地址 调整回到产品管理，在产品列表页面，是没有图片的。因为当时还没有产品图片管理功能，现在支持了，所以需要对Product做一些调整。 在Product.java新增属性private ProductImage firstProductImage; 在ProductService.java新增方法void setFirstProductImage(Product p); 在ProductServiceImpl.java中新增方法setFirstProductImage(Product p): 根据pid和图片类型查询出所有的单个图片，然后把第一个取出来放在firstProductImage上。增加方法setFirstProductImage(List ps): 给多个产品设置图片。在get方法中调用setFirstProductImage(Product p): 为单个产品设置图片。在list方法中调用setFirstProductImage(List ps): 为多个产品设置图片。 在listProduct.jsp中增加如下来显示图片:123&lt;c:if test="$&#123;!empty p.firstProductImage&#125;"&gt; &lt;img width="40px" src="img/productSingle/$&#123;p.firstProductImage.id&#125;.jpg"&gt;&lt;/c:if&gt; 产品展示前台无需登录从前台模块之间的依赖性，以及开发顺序的合理性来考虑，把前台功能分为了无需登录即可使用的功能，和需要登录才能访问的功能。 前台需要登录接着是需要登录的前台功能。这部分功能基本上都是和购物相关的。 首页从首页展示需求分析上来看:1、在横向导航栏上提供4个分类连接2、在纵向导航栏上提供全部17个分类连接3、当鼠标移动到某一个纵向分类连接的时候，显示这个分类下的推荐产品列表4、按照每种分类显示5个商品的方式，显示所有17种分类 在Category.java中新增两个瞬间自动products和productsByRow12List&lt;Product&gt; products;List&lt;List&lt;Product&gt;&gt; productsByRow; products比较好理解，代表一个分类下有多个产品。productByRow这个属性的类型是List]]></content>
      <tags>
        <tag>tmall_ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL练习二]]></title>
    <url>%2F2018%2F05%2F18%2FMySQL%E7%BB%83%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[统计各个部门对应员工涨幅的次数总和，给出部门编码dept_no、部门名称dept_name以及次数sum12345678910111213141516CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: dept_no dept_name sum d001 Marketing 24 省略 省略 省略 d006 Quality Management 25 解答:1select c.dept_no, c.dept_name, count(salary) as sum from (salaries a, dept_emp b on a.emp_no= b.emp_no), departments c on c.dept_no= b.dept_no group by c.dept_no 对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列123456CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: emp_no salary rank 10005 94692 1 10009 94409 2 10010 94409 2 10001 88958 3 解答1234select a.emp_no, a.salary, count(distinct b.salary) as rank from salaries a, salaries b where a.salary&lt;= b.salary and a.to_date= "9999-01-01" and b.to_date= "9999-01-01" group by a.emp_no order by rank 获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ，当前表示to_date=’9999-01-01’1234567891011121314151617181920212223242526CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: dept_no emp_no salary d001 10001 88958 d004 10003 43311 d005 10007 88070 d006 10009 95409 解答123456select d.dept_no, e.emp_no, s.salary from dept_emp d, ( select emp_no from employees where emp_no not in ( select emp_no from dept_manager )) e, salaries s where d.emp_no= e.emp_no and d.emp_no= s.emp_no and d.to_date= "9999-01-01" and s.to_date= "9999-01-01" 获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date=’9999-01-01’结果第一列给出员工的emp_no，第二列给出其manager的manager_no，第三列给出该员工当前的薪水emp_salary,第四列给该员工对应的manager当前的薪水manager_salary123456789101112131415161718CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: emp_no manager_no emp_salary manager_salary 10001 10002 88958 72527 10009 10010 95409 94409 解答12345678910111213141516select t1.emp_no, t2.emp_no,t1.salary as s1,t2.salary as s2from( select salary,s.emp_no,dept_no from salaries as s join dept_emp de on s.emp_no=de.emp_no where s.to_date='9999-01-01' and de.to_date='9999-01-01' and s.emp_no not in (select emp_no from dept_manager dm)) as t1,( select salary,s.emp_no,dept_no from salaries as s join dept_manager dm on s.emp_no=dm.emp_no where s.to_date='9999-01-01' and dm.to_date='9999-01-01') as t2where s1&gt;s2and t1.dept_no = t2.dept_no 汇总各个部门当前员工的title类型的分配数目，结果给出部门编号dept_no、dept_name、其当前员工所有的title以及该类型title对应的数目count123456789101112131415CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE IF NOT EXISTS "titles" (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL); 输入描述: 无 输出描述: dept_no dept_name title count d001 Marketing Senior Engineer 1 d001 Marketing Staff 1 d002 Finance Senior Engineer 1 d003 Human Resources Senior Staff 1 d004 Production Senior Engineer 2 d005 Development Senior Staff 1 解答1234567891011121314151617181920212223法一：select e.dept_no,d.dept_name,t.title,count(t.title)from departments d,dept_emp e,titles twhere d.dept_no=e.dept_noand e.emp_no=t.emp_noand e.to_date='9999-01-01'and t.to_date='9999-01-01'group by e.dept_no,t.title法二：select dp.dept_no,dp.dept_name,t.title,count(*) as countfrom ( select ds.dept_no,ds.dept_name,de.emp_no from departments as ds inner join dept_emp as de on ds.dept_no = de.dept_no where de.to_date = '9999-01-01' ) as dp inner join titles as t on dp.emp_no = t.emp_no where t.to_date = '9999-01-01' group by dp.dept_no,t.title 解析: 法一、先按照emp_no分组，再按照每个emp_no里的title分组。法二、先将部门表和部门员工表进行关联获取到部门编号和部门名称以及员工编号，然后再关联titles表，最后使用dept_no和title进行分组即可。 给出每个员工每年薪水涨幅超过5000的员工编号emp_no、薪水变更开始日期from_date以及薪水涨幅值salary_growth，并按照salary_growth逆序排列。提示：在sqlite中获取datetime时间对应的年份函数为strftime(‘%Y’, to_date)123456CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: emp_no from_date salary_growth 10003 1995-12-03 24178 10008 1998-03-11 20843 10008 2000-03-10 5997 解答123456select s1.emp_no, s1.from_date, s1.salary- s2.salary as salary_growthfrom salaries s1, salaries s2 where (strftime('%Y', s1.to_date)- strftime('%Y', s2.to_date))= 1and s1.emp_no= s2.emp_noand salary_growth&gt; 5000order by salary_growth desc 查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量&gt;=5部 film film 字段 说明 file_id 电影id title 电影名称 description 电影描述信息 12345CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT '0',title varchar(255) NOT NULL,description text,PRIMARY KEY (film_id)); category category 字段 说明 category_id 电影分类id name 电影分类名称 last_update 电影分类最后更新时间 1234CREATE TABLE category (category_id tinyint(3) NOT NULL ,name varchar(25) NOT NULL, `last_update` timestamp,PRIMARY KEY ( category_id )); film_category film_category 字段 说明 film_id 电影id category_id 电影分类id last_update 电影id和分类id对应关系的最后更新时间 123CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, `last_update` timestamp); 输入描述: 无 输出描述: 无 解答1234567891011121314select c.name,count(fc.film_id)from ( select category_id,count(film_id) as amount from film_category group by category_id having amount&gt;=5 ) as cc, category as c, film as f, film_category as fcwhere f.film_id = fc.film_id and fc.category_id = c.category_id and cc.category_id = c.category_id and f.description like '%robot%' 解析: 本题考查的是多表关联，本身有三个表关联，但是由于有条件说分类下的电影总数&gt;=5，所以可以先查询出film_category表内满足条件的category_id，然后与其他三表进行关联即可。 使用join查询方式找出没有分类的电影id以及名称输入描述: 无 输出描述: 无 解答:1select cc.film_id, cc.title from (select * from film as f left join film_category as fc on f.film_id= fc.film_id) as cc where cc.category_id is null]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL练习一]]></title>
    <url>%2F2018%2F05%2F12%2FMySQL%E7%BB%83%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[查找最晚入职员工的所有信息12345678CREATE TABLE employees ( emp_no int(11) NOT NULL, birth_date date NOT NULL, first_name varchar(14) NOT NULL, last_name varchar(16) NOT NULL, gender char(1) NOT NULL, hire_date date NOT NULL, PRIMARY KEY (emp_no)); 输入描述: 无 输出描述: emp_no birth_date first_name last_name gender hire_date 10008 1958-02-19 Saniya Kalloufi M 1994-09-15 解答:1select * from employees order by hire_date desc limit 1 查找入职员工时间排名倒数第三的员工所有信息12345678CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 输入描述: 无 输出描述: emp_no birth_date first_name last_name gender hire_date 10005 1955-01-21 Kyoichi Maliniak M 1989-09-12 解答:1select * from employees order by hire_date desc limit 2, 1 查找各个部门当前(to_date=’9999-01-01’)领导当前薪水详情以及其对应部门编号dept_no123456789101112CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: emp_no salary from_date to_date dept_no 10002 72527 2001-08-02 9999-01-01 d001 10004 74057 2001-11-27 9999-01-01 d004 10005 94692 2001-09-09 9999-01-01 d003 10006 43311 2001-08-02 9999-01-01 d002 10010 94409 2001-11-23 9999-01-01 d006 解答:1select a.*, b.dept_no from salaries a left join dept_manager b on a.emp_no= b.emp_no where a.to_date= '9999-01-01' and b.to_date= '9999-01-01' 注解:INNER JOIN 两边表同时有对应的数据，即任何一边缺失数据就不显示。LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。RIGHT JOIN 会读取右边数据表的全部数据，即便左边表无对应数据。 查找所有已经分配部门的员工的last_name和first_name1234567891011121314CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 输入描述: 无 输出描述: last_name first_name dept_no Facello Georgi d001 省略 省略 省略 Piveteau Duangkaew d006 解答:1select a.last_name, a.first_name, b.dept_no from employees a, dept_emp b where a.emp_no= b.emp_no 查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工1234567891011121314CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 输入描述: 无 输出描述: last_name first_name dept_no Facello Georgi d001 省略 省略 省略 Sluis Mary NULL(在sqlite中此处为空,MySQL为NULL) 解答:1select a.last_name, a.first_name, b.dept_no from employees a left join dept_emp b on a.emp_no= b.emp_no 注解数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。在使用left join时，on和where条件的区别如下:1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。2、where条件是在临时表生成后，再对临时表进行过滤的条件。这时已经没有left join的含义(必须返回左边表的记录)了，条件不为真的就全部过滤掉。 查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序1234567891011121314CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: emp_no salary 10011 25828 省略 省略 10001 60117 解答:1select a.emp_no, b.salary from employees a, salaries b where a.emp_no= b.emp_no and a.hire_date= b.from_date order by a.emp_no desc 查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t123456CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: emp_no t 10001 17 10004 16 10009 18 解答:1select emp_no, count(emp_no) as t from salaries group by emp_no having t&gt; 15 注解GROUP BY语法可以根据给定数据列的每个成员对查询结果进行分组统计，最终得到一个分组汇总表。SELECT子句中的列名必须为分组列或列函数，列函数对于GROUP BY子句定义的每个组返回一个结果。GROUP BY子句之后使用Having子句，可应用限定条件进行分组，以便系统仅对满足条件的组返回结果。因此，在GROUP BY子句后面包含了一个HAVING子句。HAVING类似于WHERE(唯一的差别是WHERE过滤行，HAVING过滤组), HAVING支持所有的WHERE操作符。 找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示123456CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: salary 94692 94409 88958 88070 74057 解答:1select distinct salary from salaries where to_date= '9999-01-01' order by salary desc 获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’123456789101112CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: dept_no emp_no salary d001 10002 72527 d004 10004 74057 d003 10005 94692 d002 10006 43311 解答:1select a.dept_no, a.emp_no, b.salary from salaries b inner join dept_manager a on a.emp_no= b.emp_no where a.to_date= '9999-01-01' and b.to_date='9999-01-01' 获取所有非manager的员工emp_no1234567891011121314CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 输入描述: 无 输出描述: emp_no 10001 10003 10007 解答:1select a.emp_no from employees a where a.emp_no not in (select b.emp_no from dept_manager b) 注解employees里的emp_no不在dept_manager出现非manager了，关键使用not in 获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=’9999-01-01’。结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。123456789101112CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`)); 输入描述: 无 输出描述: emp_no manager_no 10001 10002 10003 10004 10009 10010 解答:1select a.emp_no, b.emp_no as manager_no from dept_emp a, dept_manager b where a.to_date= '9999-01-01' and b.to_date='9999-01-01' and a.dept_no= b.dept_no and a.emp_no != b.emp_no 他们的职位不一样，部门却是一样的。 获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary123456789101112CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: dept_no emp_no salary d001 10001 88958 d002 10006 43311 d003 10005 94692 解答:123456select a.dept_no,a.emp_no,max(s.salary) as salaryfrom dept_emp a left join salaries s on a.emp_no= s.emp_nowhere a.to_date='9999-01-01' and s.to_date='9999-01-01'group by a.dept_no 从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。12345CREATE TABLE IF NOT EXISTS "titles" (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL); 输入描述: 无 输出描述: title t Assistant Engineer 2 Engineer 4 省略 省略 Staff 3 解答:1select title, count(title) as t from titles group by title having t&gt;= 2 having语句可以筛选出满足条件的聚合函数的结果。 从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的emp_no进行忽略。12345CREATE TABLE IF NOT EXISTS "titles" (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL); 输入描述: 无 输出描述: title t Assistant Engineer 2 Engineer 3 省略 省略 Staff 3 解答:1select title, count(distinct emp_no) as t from titles group by title having t&gt;= 2 查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列12345678CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 输入描述: 无 输出描述: emp_no birth_date first_name last_name gender hire_date 10011 1953-11-07 Mary Sluis F 1990-01-22 10005 1955-01-21 Kyoichi Maliniak M 1989-09-12 10007 1957-05-23 Tzvetan Zielinski F 1989-02-10 10003 1959-12-03 Parto Bamford M 1986-08-28 解答:1select * from employees where emp_no% 2!= 0 and last_name!= "Mary" order by hire_date desc 统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg。1234567891011CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));CREATE TABLE IF NOT EXISTS "titles" (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL); 输入描述: 无 输出描述: title avg Engineer Engineer 94409.0 Senior Engineer 69009.2 Senior Staff 91381.0 Staff 72527.0 解答:1select title, avg(salary) from titles left join salaries on titles.emp_no= salaries.emp_no where titles.to_date= "9999-01-01" and salaries.to_date= "9999-01-01" group by titles.title 获取当前（to_date=’9999-01-01’）薪水第二多的员工的emp_no以及其对应的薪水salary123456CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: emp_no salary 10009 94409 解答:1select emp_no, salary from salaries where to_date= "9999-01-01" order by salary desc limit 1, 1 查找当前薪水(to_date=’9999-01-01’)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by1234567891011121314CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: emp_no salary last_name first_name 10009 94409 Peac Sumant 解答:1234select a.emp_no, max(a.salary), b.last_name, b.first_name from salaries a, employees b where a.emp_no= b.emp_no and a.to_date= "9999-01-01" and a.salary not in (select max(salary) from salaries where to_date= "9999-01-01") 查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工123456789101112131415161718CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 输入描述: 无 输出描述: last_name first_name dept_name Facello Georgi Marketing 省略 省略 省略 Sluis Mary NULL 解答:1select a.last_name, a.first_name, c.dept_name from employees a left join dept_emp b on a.emp_no= b.emp_no left join departments c on b.dept_no= c.dept_no 查找员工编号emp_now为10001其自入职以来的薪水salary涨幅值growth123456CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: growth 28841 解答:1234select ( (select salary from salaries where emp_no= "10001" order by to_date desc limit 1)- (select salary from salaries where emp_no= "10001" order by to_date asc limit 1)) as growth 查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_noy以及其对应的薪水涨幅growth，并按照growth进行升序1234567891011121314CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输入描述: 无 输出描述: emp_no growth 10011 0 省略 省略 10010 54496 10004 34003 解答:1234select t1.emp_no, t1.salary- t2.salary as growth from( (select a.emp_no, b.salary from employees a, salaries b where a.emp_no= b.emp_no and b.to_date= "9999-01-01") as t1, (select a.emp_no, b.salary from employees a, salaries b where a.emp_no= b.emp_no and b.from_date= a.hire_date) as t2) where t1.emp_no= t2.emp_no order by growth]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[response用法]]></title>
    <url>%2F2018%2F05%2F11%2Fresponse%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[response是HttpServletResponse的实例，用于提供给浏览器的响应信息。 设置响应内容通过response设置响应已经用得比较多了，PrintWriter pw= response.getWriter(); 通过response.getWriter();获取一个PrintWriter对象。可以使用println()，append()，write()，format()等等方法设置返回给浏览器的html内容。123456789101112131415161718192021import java.io.IOException;import java.io.PrintWriter; import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class HelloServlet extends HttpServlet&#123; public void doGet(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; PrintWriter pw= response.getWriter(); pw.println("&lt;h1&gt;Hello Servlet&lt;/h1&gt;"); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 设置响应格式 response.setContentType(“text/html”); &quot;text/html&quot; 是即格式 ，在request获取头信息中对应的request.getHeader(&quot;accept&quot;)。&quot;text/html&quot; 是存在的，表示浏览器可以识别这种格式，如果换一个其他的格式， 比如 &quot;text/lol&quot; ，浏览器不能识别，那么打开此servlet就会弹出一个下载的对话框。这样的手段也就常常用于实现下载功能。12345678910111213141516171819202122import java.io.IOException;import java.io.PrintWriter; import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class HelloServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; try &#123; PrintWriter pw = response.getWriter(); pw.println("&lt;h1&gt;Hello Servlet&lt;/h1&gt;"); response.setContentType("text/lol"); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 设置响应编码设置响应编码有两种方式12response.setContentType("text/html; charset=UTF-8");response.setCharacterEncoding("UTF-8"); 这两种方式都需要在response.getWriter调用之前执行才能生效。他们的区别在于:1response.setContentType("text/html; charset=UTF-8"); 不仅发送到浏览器的内容会使用UTF-8编码，而且还通知浏览器使用UTF-8编码方式进行显示。所以总能正常显示中文。1response.setCharacterEncoding("UTF-8"); 仅仅是发送的浏览器的内容是UTF-8编码的，至于浏览器是用哪种编码方式显示不管。 所以当浏览器的显示编码方式不是UTF-8的时候，就会看到乱码，需要手动再进行一次设置。1234567891011121314151617181920212223import java.io.IOException;import java.io.PrintWriter; import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class HelloServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; try &#123; response.setContentType("text/html; charset=UTF-8");// response.setCharacterEncoding("UTF-8"); PrintWriter pw = response.getWriter(); pw.println("&lt;h1&gt;第一次 使用 Servlet&lt;/h1&gt;"); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 301或者302客户端跳转客户端有两种跳转：12345301表示永久性跳转response.setStatus(301);response.setHeader("Location", "fail.html");302表示临时跳转 response.sendRedirect("fail.html"); 用户感受不出这两种跳转的区别，但是可以借助火狐的调试工具看到响应的头信息是：301 Moved Permanently。301和302的区别主要在搜索引擎对页面排名的时候有影响。12345678910111213141516171819202122232425import java.io.IOException; import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter("name"); String password = request.getParameter("password"); if ("admin".equals(name) &amp;&amp; "123".equals(password)) &#123; request.getRequestDispatcher("success.html").forward(request, response); &#125; else &#123; response.setStatus(301); response.setHeader("Location", "fail.html"); &#125; &#125;&#125; 设置不使用缓存使用缓存可以加快页面的加载，降低服务端的负担。但是也可能看到过时的信息，可以通过如下手段通知浏览器不要使用缓存123response.setDateHeader("Expires",0 );response.setHeader("Cache-Control","no-cache");response.setHeader("pragma","no-cache"); 1234567891011121314151617181920212223import java.io.IOException;import java.util.Date; import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class HelloServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) &#123; try &#123; response.setDateHeader("Expires", 0); response.setHeader("Cache-Control", "no-cache"); response.setHeader("pragma", "no-cache"); response.getWriter().println("&lt;h1&gt;Hello Servlet!&lt;/h1&gt;"); response.getWriter().println(new Date().toLocaleString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[request常见方法]]></title>
    <url>%2F2018%2F05%2F11%2Frequest%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[request常见方法request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)” +request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名” +request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr(): 浏览器所处于的客户机的IP地址request.getRemoteHost(): 浏览器所处于的客户机的主机名request.getRemotePort(): 浏览器所处于的客户机使用的网络端口request.getLocalAddr(): 服务器的IP地址request.getLocalName(): 服务器的主机名request.getMethod(): 得到客户机请求方式一般是GET或者POST12345678910111213141516171819202122232425262728293031323334353637import java.io.IOException;import java.io.PrintWriter; import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class LoginServlet extends HttpServlet &#123; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter("name"); String password = request.getParameter("password"); System.out.println("浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有): " + request.getRequestURL()); System.out.println("浏览器发出请求的资源名部分，去掉了协议和主机名: " + request.getRequestURI()); System.out.println("请求行中的参数部分: " + request.getQueryString()); System.out.println("浏览器所处于的客户机的IP地址: " + request.getRemoteAddr()); System.out.println("浏览器所处于的客户机的主机名: " + request.getRemoteHost()); System.out.println("浏览器所处于的客户机使用的网络端口: " + request.getRemotePort()); System.out.println("服务器的IP地址: " + request.getLocalAddr()); System.out.println("服务器的主机名: " + request.getLocalName()); System.out.println("得到客户机请求方式: " + request.getMethod()); String html = null; if ("admin".equals(name) &amp;&amp; "123".equals(password)) html = "&lt;div style='color:green'&gt;登录成功&lt;/div&gt;"; else html = "&lt;div style='color:red'&gt;登录失败&lt;/div&gt;"; response.setContentType("text/html; charset=UTF-8"); PrintWriter pw = response.getWriter(); pw.println(html); &#125;&#125; 获取参数request.getParameter()：是常见的方法，用于获取单值的参数request.getParameterValues()：用于获取具有多值的参数，比如注册的时候提交的爱好，可以是多选的。request.getParameterMap()：用于遍历所有的参数，并返回Map类型。本例准备了一个注册的例子：包括一个注册页面register.html服务端的RegisterServlet分别演示了获取单值参数，多值参数以及遍历所有的参数。123456789101112register.html&lt;!DOCTYPE html&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;form action="register" method="get"&gt; 账号 ： &lt;input type="text" name="name"&gt; &lt;br&gt; 爱好 ： LOL&lt;input type="checkbox" name="hobits" value="lol"&gt; DOTA&lt;input type="checkbox" name="hobits" value="dota"&gt; &lt;br&gt; &lt;input type="submit" value="注册"&gt;&lt;/form&gt; 12345678910111213141516171819202122232425262728293031RegisterServlet.javaimport java.io.IOException;import java.util.Arrays;import java.util.Map;import java.util.Set; import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class RegisterServlet extends HttpServlet &#123; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("获取单值参数name:" + request.getParameter("name")); String[] hobits = request.getParameterValues("hobits"); System.out.println("获取具有多值的参数hobits: " + Arrays.asList(hobits)); System.out.println("通过 getParameterMap 遍历所有的参数： "); Map&lt;String, String[]&gt; parameters = request.getParameterMap(); Set&lt;String&gt; paramNames = parameters.keySet(); for (String param : paramNames) &#123; String[] value = parameters.get(param); System.out.println(param + ":" + Arrays.asList(value)); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435web.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;10&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;RegisterServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;RegisterServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;RegisterServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/register&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 获取头信息request.getHeader()获取浏览器传递过来的头信息。比如getHeader(“user-agent”)可以获取 浏览器的基本资料，这样就能判断是firefox、IE、chrome或者是safari浏览器 。request.getHeaderNames()获取 浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息。在本例，修改HelloServlet，使其获取头信息。访问HelloServlet获取如下头信息：host: 主机地址user-agent: 浏览器基本资料accept: 表示浏览器接受的数据类型accept-language: 表示浏览器接受的语言accept-encoding: 表示浏览器接受的压缩方式，是压缩方式，并非编码connection: 是否保持连接cache-control:缓存时限123456789101112131415161718192021222324252627282930313233import java.io.IOException;import java.util.Date;import java.util.Enumeration; import javax.servlet.ServletConfig;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class HelloServlet extends HttpServlet&#123; public void init(ServletConfig config)&#123; System.out.println("init of Hello Servlet"); &#125; public void doGet(HttpServletRequest request, HttpServletResponse response)&#123; Enumeration&lt;String&gt; headerNames= request.getHeaderNames(); while(headerNames.hasMoreElements())&#123; String header = headerNames.nextElement(); String value = request.getHeader(header); System.out.printf("%s\t%s%n",header,value); &#125; try &#123; response.getWriter().println("&lt;h1&gt;Hello Servlet!&lt;/h1&gt;"); response.getWriter().println(new Date().toLocaleString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 服务器传参setAttribute和getAttribute可以用来在进行服务端跳转的时候，在不同的Servlet之间进行数据共享。]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳转]]></title>
    <url>%2F2018%2F05%2F11%2F%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[准备工作在web目录下准备两个页面success.html，fail.html。分别用于显示登录成功或者登录失败。如果登录成功了，就服务端跳转到success.html；如果登录失败了，就客户端跳转到fail.html。12success.html&lt;div style="color:green"&gt;login success&lt;/div&gt; 12fail.html&lt;div style="color:red"&gt;login fail&lt;/div&gt; 123456789101112131415161718192021HelloServlet.javaimport java.io.IOException;import java.util.Date;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloServlet extends HttpServlet&#123; public void doGet(HttpServletRequest request, HttpServletResponse response)&#123; try &#123; response.getWriter().println("&lt;h1&gt;Hello Servlet!&lt;/h1&gt;"); response.getWriter().println(new Date().toLocaleString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 服务端跳转在Servlet中进行服务端跳转的方式:1request.getRequestDispatcher("success.html").forward(request, response); 1234567891011121314151617181920212223LoginServlet.javaimport java.io.IOException; import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter("name"); String password = request.getParameter("password"); if ("admin".equals(name) &amp;&amp; "123".equals(password)) &#123; request.getRequestDispatcher("success.html").forward(request, response); &#125; &#125;&#125; 客户端跳转在Servlet中进行 客户端跳转的方式：1response.sendRedirect("fail.html"); 1234567891011121314151617181920212223242526LoginServlet.javaimport java.io.IOException; import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter("name"); String password = request.getParameter("password"); if ("admin".equals(name) &amp;&amp; "123".equals(password)) &#123; request.getRequestDispatcher("success.html").forward(request, response); &#125; else&#123; response.sendRedirect("fail.html"); &#125; &#125;&#125; 服务端跳转和客户端跳转图示 客户端的跳转：跳转之后地址栏的信息是会变的，变为跳转之后的地址信息 。服务器端的跳转：跳转之后的地址栏的信息不会 发生任何的改变。(1) 在使用request属性范围时，只有服务器端跳转才能将request范围的属性保存到跳转页面；而如果是客户端的跳转，则无法进行request属性的传递(2) 另外，如果是服务器端的跳转，则执行跳转语句时立刻进行跳转；如果使用的是客户端跳转，则是整个页面执行完之后才执行跳转的。(3) 在Servlet中如果想要进行客户端的跳转，直接使用HttpServletResponse接口的SendRedirect()即可，但是需要注意的是，此跳转只能传递session以及application范围的属性，而无法传递request范围的属性。 响应代码123456200: 表示响应成功了，比如打开页面，就会看到200响应码。301: 表示客户端跳转，永久性的跳转。为了实现301跳转，在Servlet中应该使用如下代码: response.setStatus(301); response.setHeader("Location", "fail.html");302: 表示客户端跳转，临时性的跳转。在Servlet的代码 实现要比301简单点，直接使用: response.sendRedirect("/listHero");304: 表示资源未被修改。当不是第一次访问一个静态页面或者图片的时候，就会得到这么一个提示。这是服务端提示浏览器，这个资源没有发生变化，你直接使用上一次下载的就行了，不需要重新下载。这样就节约了带宽，并且浏览器的加载速度也更快。404: 表示访问的页面不存在。500: 表示服务端的错误。 更多代码预览:]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service()]]></title>
    <url>%2F2018%2F05%2F11%2FService%2F</url>
    <content type="text"><![CDATA[doGet当浏览器使用get方式提交数据的时候，servlet需要提供doGet()方法。哪些是get方式呢？ form默认的提交方式 如果通过一个超链访问某个地址 如果在地址栏直接输入某个地址 ajax指定使用get方式的时候 123456789101112131415import java.io.IOException; import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class LoginServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; &#125; doPost()当浏览器使用post方式提交数据的时候，servlet需要提供doPost()方法。哪些是post方式呢？ 在form上显示设置method=&quot;post&quot;的时候 ajax指定post方式的时候 123456789101112131415import java.io.IOException; import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class LoginServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; &#125; service()LoginServlet继承了HttpServlet，同时也继承了一个方法。 service(HttpServletRequest , HttpServletResponse ) 实际上，在执行doGet()或者doPost()之前，都会先执行service()。由service()方法进行判断，到底该调用doGet()还是doPost()可以发现，service(), doGet(), doPost()三种方式的参数列表都是一样的。所以，有时候也会直接重写service()方法，在其中提供相应的服务，就不用区分到底是get还是post了。比如把前面的登录的LoginServlet，改为提供service方法，也可以达到相同的效果。1234567891011121314151617181920212223242526272829303132原：import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class LoginServlet extends HttpServlet &#123; /*Tomcat定位到了LoginServlet后，发现并没有LoginServlet的实例存在， * 于是就调用LoginServlet的public无参构造方法LoginServlet()实例化一个LoginServlet对象以备后续使用*/ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter("name"); String password = request.getParameter("password"); String html = null; if ("admin".equals(name) &amp;&amp; "123".equals(password)) html = "&lt;div style='color:green'&gt;success&lt;/div&gt;"; else html = "&lt;div style='color:red'&gt;fail&lt;/div&gt;"; PrintWriter pw = response.getWriter(); /*获取 response的输出流，这个流是字符流用来向jsp界面输出字符串的*/ pw.println(html); /*在Servlet完成工作后，tomcat拿到被Servlet修改过的response，根据这个response生成html字符串， * 然后通过HTTP协议，这个html字符串，回发给浏览器，浏览器再根据HTTP协议获取这个html字符串， * 并渲染在界面上。这样在效果上，浏览器就可以看到Servlet中生成的字符串了*/ &#125;&#125; 123456789101112131415161718192021222324252627282930改：import java.io.IOException;import java.io.PrintWriter; import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; public class LoginServlet extends HttpServlet &#123; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter("name"); String password = request.getParameter("password"); String html = null; if ("admin".equals(name) &amp;&amp; "123".equals(password)) html = "&lt;div style='color:green'&gt;success&lt;/div&gt;"; else html = "&lt;div style='color:red'&gt;fail&lt;/div&gt;"; PrintWriter pw = response.getWriter(); pw.println(html); &#125; &#125;]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmall_ssm之数据库]]></title>
    <url>%2F2018%2F05%2F10%2Ftmall-ssm%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在需求分析结束之后，接下来要做的不是马上开发功能，而是进行表结构的设计。只有把表结构设计正确了，才能支撑软件后续的功能开发，这一步是非常重要的。 数据库的创建创建数据库tmall_ssm。并将数据库的编码格式设置为utf8，便于存放中文。12DROP DATABASE IF EXISTS tmall_ssm;CREATE DATABASE tmall_ssm DEFUALT CHARACTER SET utf8; 表关系图在这张表关系图上，列出了模仿天猫整站一共需要用到的9张表，以及表之间的关系。 表介绍 表名 中文含义 介绍 Category 分类表 存放分类信息，如女装，平板电视，沙发等 Property 属性表 存放属性信息，如颜色，重量，品牌，厂商，型号等 Product 产品表 存放产品信息，如LED40EC平板电视机，海尔EC6005热水器 PropertyValue 属性值表 存放属性值信息，如重量是900g,颜色是粉红色 ProductImage 产品图片表 存放产品图片信息，如产品页显示的5个图片 Review 评论表 存放评论信息，如买回来的蜡烛很好用，么么哒 User 用户表 存放用户信息，如斩手狗，千手小粉红 Order 订单表 存放订单信息，包括邮寄地址，电话号码等信息 OrderItem 订单项表 存放订单项信息，包括购买产品种类，数量等 建表在建表过程中，会设置外键约束，所以表和表之间有依赖关系。因此会先建立被外键指向的表，比如User，Category，然后再是其他表。 用户表123456CREATE TABLE user(id int(11) NOT NULL AUTO_INCREMENT,name varchar(255) DEFAULT NULL,password varchar(255) DEFAULT NULL,PRIMARY KEY (id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 分类表12345CREATE TABLE category(id int(11) NOT NULL AUTO_INCREMENT,name varchar(255) DEFAULT NULL,PRIMARY KEY (id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 属性表从这个表开始，就有外键约束了。本表的外cid，指向分类表的id字段。1234567CREATE TABLE property(id int(11) NOT NULL AUTO_INCREMENT,cid int(11) DEFAULT NULL,name varchar(255) DEFAULT NULL,PRIMARY KEY (id),CONSTRAINT fk_property_category FOREIGN KEY (cid) REFERENCES category (id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 产品表产品表字段稍多，介绍下。name: 产品名称subTitle: 小标题originalPrice: 原始价格promotePrice: 优惠价格stock: 库存createDate: 创建日期本表的外键cid，指向分类表的id字段。123456789101112CREATE TABLE product(id int(11) NOT NULL AUTO_INCREMENT,name varchar(255) DEFAULT NULL,subTitle varchar(255) DEFAULT NULL,originalPrice float DEFAULT NULL,promotePrice float DEFAULT NULL,stock int(11) DEFAULT NULL,cid int(11) DEFAULT NULL,createDate datetime DEFAULT NULL,PRIMARY KEY(id),CONSTRAINT fk_product_category FOREIGN KEY (cid) REFERENCES category(id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 属性值表本表有两个外键。外键ptid，指向属性表的id字段。外键pid，指向产品表的id字段。123456789CREATE TABLE propertyvalue(id int(11) NOT NULL AUTO_INCREMENT,pid int(11) DEFAULT NULL,ptid int(11) DEFAULT NULL,value varchar(255) DEFAULT NULL,PRIMARY KEY(id),CONSTRAINT fk_propertyvalue_property FOREIGN KEY(ptid) REFERENCES property(id),CONSTRAINT fk_propertyvalue_product FOREIGN KEY(pid) REFERENCES product(id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 产品图片表type表示类型，产品图片分单个图片和详情图片两种。本表的外键pid，指向产品表的id字段。1234567CREATE TABLE productimage(id int(11) NOT NULL AUTO_INCREMENT,pid int(11) DEFAULT NULL,type varchar(255) DEFAULT NULL,PRIMARY KEY(id),CONSTRATINT fk_productimage_product FOREIGN KEY(pid) REFERENCES product (id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 评价表外键pid，指向产品表的id字段。外键uid，指向用户表的id字段。12345678910CREATE TABLE review(id int(11) NOT NULL AUTO_INCREMENT,content varchar(4000) DEFAULT NULL,uid int(11) DEFAULT NULL,pid int(11) DEFAULT NULL,createDate datetime DEFAULT NULL,PRIMARY KEY(id),CONSTRAINT fk_review_product FOREIGN KEY(pid) REFERENCES product(id),CONSTRAINT fk_review_user FOREIGN KEY(uid) REFERENCES user(id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 订单表订单表的字段也比较多，说明一下。orderCode: 订单号address: 收货地址post: 邮编receiver: 收货人信息mobile: 手机号码userMessage: 用户备注信息createDate: 订单创建日期payDate: 支付日期deliveryDate: 发货日期confirmDate: 确认收货日期status: 订单状态外键uid，指向用户表id字段1234567891011121314151617CREATE TABLE order_(id int(11) NOT NULL AUTO_INCREMENT,orderCode varchar(255) DEFAULT NULL,address varchar(255) DEFAULT NULL,post varchar(255) DEFAULT NULL,receiver varchar(255) DEFAULT NULL,mobile varchar(255) DEFAULT NULL,userMessage varchar(255) DEFAULT NULL,createDate datetime DEFAULT NULL,payDate datetime DEFAULT NULL,deliveryDate datetime DEFAULT NULL,confirmDate datetime DEFAULT NULL,uid int(11) DEFAULT NULL,status varchar(255) DEFAULT NULL,PRIMARY KEY(id),CONSTRAINT fk_order_user FOREIGN KEY(uid) REFERENCES user(id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 订单项表这个表是外键最多的一个表。外键pid，指向产品表id字段。外键oid，指向订单表id字段。外键uid，指向用户表id字段。number字段表示购买数量。1234567891011CREATE TABLE orderitem(id int(11) NOT NULL AUTO_INCREMENT,pid int(11) DEFAULT NULL,oid int(11) DEFAULT NULL,uid int(11) DEFAULT NULL,number int(11) DEFAULT NULL,PRIMARY KEY(id),CONSTRAINT fk_orderitem_user FOREIGN KEY(uid) REFERENCES user(id),CONSTRAINT fk_orderitem_product FOREIGN KEY(pid) REFERENCES product(id),CONSTRAINT fk_orderitem_order FOREIGN KEY(oid) REFERENCES order_(id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 整理表一般来说，对于一个新项目，建表的时候，会把sql语句都准备好，一次性执行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596DROP DATABASE IF EXISTS tmall_ssm;CREATE DATABASE tmall_ssm DEFAULT CHARACTER SET utf8;USE tmall_ssm; CREATE TABLE user ( id int(11) NOT NULL AUTO_INCREMENT, name varchar(255) DEFAULT NULL, password varchar(255) DEFAULT NULL, PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE category ( id int(11) NOT NULL AUTO_INCREMENT, name varchar(255) DEFAULT NULL, PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE property ( id int(11) NOT NULL AUTO_INCREMENT, cid int(11) DEFAULT NULL, name varchar(255) DEFAULT NULL, PRIMARY KEY (id), CONSTRAINT fk_property_category FOREIGN KEY (cid) REFERENCES category (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE product ( id int(11) NOT NULL AUTO_INCREMENT, name varchar(255) DEFAULT NULL, subTitle varchar(255) DEFAULT NULL, originalPrice float DEFAULT NULL, promotePrice float DEFAULT NULL, stock int(11) DEFAULT NULL, cid int(11) DEFAULT NULL, createDate datetime DEFAULT NULL, PRIMARY KEY (id), CONSTRAINT fk_product_category FOREIGN KEY (cid) REFERENCES category (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE propertyvalue ( id int(11) NOT NULL AUTO_INCREMENT, pid int(11) DEFAULT NULL, ptid int(11) DEFAULT NULL, value varchar(255) DEFAULT NULL, PRIMARY KEY (id), CONSTRAINT fk_propertyvalue_property FOREIGN KEY (ptid) REFERENCES property (id), CONSTRAINT fk_propertyvalue_product FOREIGN KEY (pid) REFERENCES product (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE productimage ( id int(11) NOT NULL AUTO_INCREMENT, pid int(11) DEFAULT NULL, type varchar(255) DEFAULT NULL, PRIMARY KEY (id), CONSTRAINT fk_productimage_product FOREIGN KEY (pid) REFERENCES product (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE review ( id int(11) NOT NULL AUTO_INCREMENT, content varchar(4000) DEFAULT NULL, uid int(11) DEFAULT NULL, pid int(11) DEFAULT NULL, createDate datetime DEFAULT NULL, PRIMARY KEY (id), CONSTRAINT fk_review_product FOREIGN KEY (pid) REFERENCES product (id), CONSTRAINT fk_review_user FOREIGN KEY (uid) REFERENCES user (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE order_ ( id int(11) NOT NULL AUTO_INCREMENT, orderCode varchar(255) DEFAULT NULL, address varchar(255) DEFAULT NULL, post varchar(255) DEFAULT NULL, receiver varchar(255) DEFAULT NULL, mobile varchar(255) DEFAULT NULL, userMessage varchar(255) DEFAULT NULL, createDate datetime DEFAULT NULL, payDate datetime DEFAULT NULL, deliveryDate datetime DEFAULT NULL, confirmDate datetime DEFAULT NULL, uid int(11) DEFAULT NULL, status varchar(255) DEFAULT NULL, PRIMARY KEY (id), CONSTRAINT fk_order_user FOREIGN KEY (uid) REFERENCES user (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE orderitem ( id int(11) NOT NULL AUTO_INCREMENT, pid int(11) DEFAULT NULL, oid int(11) DEFAULT NULL, uid int(11) DEFAULT NULL, number int(11) DEFAULT NULL, PRIMARY KEY (id), CONSTRAINT fk_orderitem_user FOREIGN KEY (uid) REFERENCES user (id), CONSTRAINT fk_orderitem_product FOREIGN KEY (pid) REFERENCES product (id), CONSTRAINT fk_orderitem_order FOREIGN KEY (oid) REFERENCES order_ (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口的区别]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[区别一： 子类只能继承一个抽象类，不能继承多个 子类可以实现多个接口 区别二： 抽象类可以定义public、protected、package、private。静态、非静态final、非final属性 但是接口中声明的属性，只能是public、静态、final 抽象类和接口都可以有实体方法。接口中的实体方法，叫做默认方法。12345678910public interface AP &#123; public static final int resistPhysic = 100; //resistMagic即便没有显式的声明为 public static final //但依然默认为public static final int resistMagic = 0; public void magicAttack();&#125;]]></content>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将jdk9版本写的项目转换成jdk1.8]]></title>
    <url>%2F2018%2F05%2F05%2F%E5%B0%86jdk9%E7%89%88%E6%9C%AC%E5%86%99%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%BD%AC%E6%8D%A2%E6%88%90jdk1-8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;将jdk9版本写的项目转换成jdk1.8:右键项目名–&gt;Properties–&gt;Project Facets–&gt;Java选择右边的1.8就OK了。 &nbsp;&nbsp;&nbsp;&nbsp;将jdk1.8设为默认:Window–&gt;Preferences–&gt;Java–&gt;Installed JREs–&gt;add选择需要添加的jdk1.8版本位置]]></content>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拦截器]]></title>
    <url>%2F2018%2F05%2F05%2F%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;SpringMVC的所有请求都要通过Dispatherservlet来接收，然后通过Handlermapping来决定使用哪个控制器，再根据ViewResolver来决定返回哪个视图，从流程来看，Handlermapping就是我们可以实现拦截器的第一种方法，另外还有一种是实现WebRequestInterceptor接口，或者继承其子类。 实现HandlerInterceptor接口&nbsp;&nbsp;&nbsp;&nbsp;实现HandlerInterceptor接口或者继承HandlerInterceptor的子类，比如Spring已经提供的实现了HandlerInterceptor接口的抽象类HandlerInterceptorAdapter，下面讲实现其接口的写法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Date;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;public class IndexInterceptor extends HandlerInterceptorAdapter &#123; /** * preHandler方法是进行处理器拦截用的，在业务处理器处理请求之前被调用 * SpringMVC中的Interceptor拦截器是链式的，可以同时存在 * 如果返回false * 从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链 * 如果返回true * 执行下一个拦截器,直到所有的拦截器都执行完毕 * 再执行被拦截的Controller * 然后进入拦截器链, * 从最后一个拦截器往回执行所有的postHandle() * 接着再从最后一个拦截器往回执行所有的afterCompletion() */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("preHandle(), 在访问Controller之前被调用"); return true; &#125; /** 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。 * 在业务处理器处理请求执行完成后,生成视图之前执行的动作 * 它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操作。 * 这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用。 * 可在modelAndView中加入数据，比如当前时间 */ public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("postHandle(), 在访问Controller之后，访问视图之前被调用,这里可以注入一个时间到modelAndView中，用于后续视图显示"); modelAndView.addObject("date","由拦截器生成的时间:" + new Date()); &#125; /** 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。 * 该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行。 * 在DispatcherServlet完全处理完请求后被调用,可用于清理资源等 * 当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion() */ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("afterCompletion(), 在访问视图之后被调用"); &#125; &#125; 实现WebRequestInterceptor接口&nbsp;&nbsp;&nbsp;&nbsp;WebRequestInterceptor中定义了三个方法，我们也是通过这三个方法来实现拦截的。这三个方法都传递了同一个参数WebRequest，那么这个WebRequest是什么呢？这个WebRequest是Spring定义的一个接口，它里面的方法定义都基本跟HttpServletRequest一样，在WebRequestInterceptor中对WebRequest进行的所有操作都同步到HttpServletRequest中，然后在当前请求中一直传递。 方法preHandle: 方法将在请求处理之前进行调用，也就是说会在Controller方法调用之前被调用。这个方法跟HandlerInterceptor中的preHandle是不同的，主要区别在于该方法的返回值是void，也就是没有返回值，所以我们一般主要用它来进行资源的准备工作，比如我们在使用Hibernate的时候可以在这个方法中准备一个Hibernate的Session对象，然后利用WebRequest的setAttribute(name, value, scope)把它放到WebRequest的属性中。这里可以说说这个setAttribute方法的第三个参数scope，该参数是一个Integer类型的。在WebRequest的父层接口RequestAttributes中对它定义了三个常量:SCOPE_REQUEST: 它的值是0，代表只有在request中可以访问。SCOPE_SESSION: 它的值是1，如果环境允许的话它代表的是一个局部的隔离的session，否则就代表普通的session，并且在该session范围内可以访问。SCOPE_GLOBAL_SESSION: 它的值是2，如果环境允许的话，它代表的是一个全局共享的session，否则就代表普通的session，并且在该session`范围内可以访问。 方法postHandle: 该方法将在请求处理之后，也就是在Controller方法调用之后被调用，但是会在视图返回被渲染之前被调用，所以可以在这个方法里面通过改变数据模型ModelMap来改变数据的展示。该方法有两个参数，WebRequest对象是用于传递整个请求数据的，比如在preHandle中准备的数据都可以通过WebRequest来传递和访问；ModelMap就是Controller处理之后返回的Model对象，我们可以通过改变它的属性来改变返回的Model模型。 方法afterCompletion: 该方法会在整个请求处理完成，也就是在视图返回并被渲染之后执行。所以在该方法中可以进行资源的释放操作。而WebRequest参数就可以把我们在preHandle中准备的资源传递到这里进行释放。Exception参数表示的是当前请求的异常对象，如果在Controller中抛出的异常已经被Spring的异常处理器给处理了的话，那么这个异常对象就是是null。 1234567891011121314151617181920212223242526272829303132333435363738394041import org.springframework.ui.ModelMap;import org.springframework.web.context.request.WebRequest;import org.springframework.web.context.request.WebRequestInterceptor;public class AllInterceptor implements WebRequestInterceptor &#123; /** * 在请求处理之前执行，该方法主要是用于准备资源数据的，然后可以把它们当做请求属性放到WebRequest中 */ @Override public void preHandle(WebRequest request) throws Exception &#123; // TODO Auto-generated method stub System.out.println("AllInterceptor..............................."); request.setAttribute("request", "request", WebRequest.SCOPE_REQUEST);//这个是放到request范围内的，所以只能在当前请求中的request中获取到 request.setAttribute("session", "session", WebRequest.SCOPE_SESSION);//这个是放到session范围内的，如果环境允许的话它只能在局部的隔离的会话中访问，否则就是在普通的当前会话中可以访问 request.setAttribute("globalSession", "globalSession", WebRequest.SCOPE_GLOBAL_SESSION);//如果环境允许的话，它能在全局共享的会话中访问，否则就是在普通的当前会话中访问 &#125; /** * 该方法将在Controller执行之后，返回视图之前执行，ModelMap表示请求Controller处理之后返回的Model对象，所以可以在 * 这个方法中修改ModelMap的属性，从而达到改变返回的模型的效果。 */ @Override public void postHandle(WebRequest request, ModelMap map) throws Exception &#123; // TODO Auto-generated method stub for (String key:map.keySet()) System.out.println(key + "-------------------------");; map.put("name3", "value3"); map.put("name1", "name1"); &#125; /** * 该方法将在整个请求完成之后，也就是说在视图渲染之后进行调用，主要用于进行一些资源的释放 */ @Override public void afterCompletion(WebRequest request, Exception exception) throws Exception &#123; // TODO Auto-generated method stub System.out.println(exception + "-=-=--=--=-=-=-=-=-=-=-=-==-=--=-=-=-="); &#125;&#125; 拦截器的配置mvc:interceptors标签来声明需要加入到SpringMVC拦截器链中的拦截器123456789&lt;mvc:interceptors&gt; &lt;!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 --&gt; &lt;bean class="com.host.app.web.interceptor.AllInterceptor"/&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/test/number.do"/&gt; &lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt; &lt;bean class="com.host.app.web.interceptor.LoginInterceptor"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &nbsp;&nbsp;&nbsp;&nbsp;由上面的示例可以看出可以利用mvc:interceptors标签声明一系列的拦截器，然后它们就可以形成一个拦截器链，拦截器的执行顺序是按声明的先后顺序执行的，先声明的拦截器中的preHandle方法会先执行，然而它的postHandle方法和afterCompletion方法却会后执行。&nbsp;&nbsp;&nbsp;&nbsp;在mvc:interceptors标签下声明interceptor主要有两种方式：1) 直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。2) 使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。&nbsp;&nbsp;&nbsp;&nbsp;经过上述两步之后，定义的拦截器就会发生作用对特定的请求进行拦截了。]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j总结]]></title>
    <url>%2F2018%2F05%2F03%2Flog4j%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;Log4j是apache的一个开源项目，用来操作程序日志信息的框架。因便于管理，在工程中用来代替System.out打印语句。通过配置Log4j中的log4j.properties，可以指定日志信息的级别，输出地点，输出格式。 LOG4J组成&nbsp;&nbsp;&nbsp;&nbsp;Log4j有3大主要组件: Logger: 记录器，决定什么日志信息应该被输出、什么日志信息应该被忽略。 Appender: 存放器，指定日志信息应该输出到什么地方，可以是控制台、文件、网络设备。 Layout: 布局格式，指定日志信息的输出格式。 &nbsp;&nbsp;&nbsp;&nbsp;一个logger可以用多个appender，也就是说日志信息可以同时输出到多个设备上，每个appender对应一种layout。&nbsp;&nbsp;&nbsp;&nbsp;所以，记录器用来整合日志信息，一个日志信息调整好以后，交给记录器的所有存放器，每一个存放器根据自己的格式输出日志信息。 记录器组件Logger1、根记录器： rootLogger配置语法: log4j.rootLogger=[日志级别], 存放器名1, 存放器名2, … , 存放器名N。日志级别: 级别由高到低依次是: fatal、error、warn、info、debug。项目中的代码: log4j.rootLogger=INFO, stdout, logfile根记录器的日志级别是info，所以info, warn, error, fatal均会被执行。stdout, logfile是存放器。2、在配置文件中配置Logger组件可在Log4J配置文件中配置自己的Logger组件项目中代码:1234log4j.logger.Application=INFO,Applicationlog4j.logger.Service=DEBUG,Servicelog4j.logger.jdbc=INFO,jdbclog4j.logger.Action=INFO,Action 定义了application, service, jdbc, action四个自己的logger组件，并分别配置了级别和存放器。 存放器组件Appender配置语法:12log4j.appender.存放器名=存放类log4j.appender.存放器名.option1=value1 存放类:1234567org.apache.log4j.ConsoleAppender控制台输出org.apache.log4j.FileAppender 文件org.apache.log4j.DailyRollingFileAppender 每天产生一个日志文件org.apache.log4j.RollingFileAppender 文件大小到达指定尺寸的时候产生一个新的文件org.apache.log4j.WriterAppender 将日志信息以流格式发送到任意指定的地方 项目中代码:12345Application记录器: log4j.appender.Application=org.apache.log4j.RollingFileAppenderlog4j.appender.Application.encoding=UTF-8log4j.appender.Application.File=/imagesys/logs/ImageCreditServer/ApplicationLog.loglog4j.appender.Service.MaxFileSize=10240KB 12345Service记录器: log4j.appender.Service=org.apache.log4j.RollingFileAppenderlog4j.appender.Service.encoding=UTF-8log4j.appender.Service.File=/imagesys/logs/ImageCreditServer/ServiceLog.loglog4j.appender.Service.MaxFileSize=10240KB 12345jdbc记录器: log4j.appender.jdbc=org.apache.log4j.RollingFileAppenderlog4j.appender.jdbc.encoding=UTF-8log4j.appender.jdbc.File=/imagesys/logs/ImageCreditServer/jdbcLog.log log4j.appender.jdbc.MaxFileSize=1024KB 12345action记录器: log4j.appender.Action=org.apache.log4j.RollingFileAppenderlog4j.appender.Action.encoding=UTF-8log4j.appender.Action.File=/imagesys/logs/ImageCreditServer/ActionLog.loglog4j.appender.Action.MaxFileSize=10240KB 分别制定了输出文件的存放类、编码方式、文件路径、文件大小。 格式化组件Layout配置语法:1234log4j.appender.存放器名.layout = 格式类log4j.appender.存放器名.layout.option1 = value1… …log4j.appender.存放器名.layout.optionN = valueN 输出格式类型:1234. org.apache.log4j.HTMLLayout(以HTML表格形式布局);. org.apache.log4j.PatternLayout(可以灵活地指定布局模式);. org.apache.log4j.SimpleLayout(包含日志信息的级别和信息字符串);. org.apache.log4j.TTCCLayout(包含日志产生的时间、线程和类别等信息); 符号 描述 %r 自程序开始后消耗的毫秒数 %t 表示日志记录请求生成的线程 %p 表示日志语句的优先级 %r 与日志请求相关的类别名称 %c 日志信息所在的类名 %m%n 表示日志信息的内容 项目中代码:12log4j.appender.Application.layout=org.apache.log4j.PatternLayoutlog4j.appender.Application.layout.ConversionPattern=%d %p [%c] - %m%n 以自定义的格式输出日志信息。]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis配置文件基本结构]]></title>
    <url>%2F2018%2F04%2F25%2FMyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在使用mybatis框架时，首先导入其对应的jar包，并进行相应的配置，所以得对配置文件的每个参数都得了解。一个完全的mybatis配置文件结构如下:1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!-- xml的版本：1.0 和编码：utf8 --&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置文件的根元素 --&gt; &lt;properties&gt;&lt;/properties&gt; &lt;!-- 属性：定义配置外在化 --&gt; &lt;settings&gt; &lt;!-- 设置：定义mybatis的一些全局性设置 --&gt; &lt;setting name= "" value= "" /&gt; &lt;!-- 具体的参数名和参数值 --&gt; &lt;/settings&gt; &lt;typeAliases&gt;&lt;/typeAliases&gt; &lt;!-- 类型名称：为一些类定义别名 --&gt; &lt;typeHandlers&gt;&lt;/typeHandlers&gt; &lt;!-- 类型处理器：定义Java类型与数据库中的数据类型之间的转换关系 --&gt; &lt;objectFactory type=""&gt;&lt;/objectFactory&gt; &lt;!-- 对象工厂 --&gt; &lt;plugins&gt; &lt;!-- 插件，mybatis的插件，插件可以修改mybatis的内部运行规则 --&gt; &lt;plugin interceptor=""&gt;&lt;/plugin&gt; &lt;/plugins&gt; &lt;environments default=""&gt; &lt;!-- 环境变量：可以配置多个环境变量，比如使用多数据源时，就需要配置多个环境变量 --&gt;&lt;!-- default指现在默认使用什么环境，default的值必须是id对应的值 --&gt; &lt;environment id=""&gt; &lt;transactionManager type=""&gt;&lt;/transactionManager&gt; &lt;!-- 事务管理器 --&gt; &lt;dataSource type=""&gt;&lt;/dataSource&gt; &lt;!-- 数据源 --&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;databaseIdProvider type=""&gt;&lt;/databaseIdProvider&gt; &lt;!-- 数据库厂商标识 --&gt; &lt;mappers&gt;&lt;/mappers&gt; &lt;!-- 映射器: 指定映射文件或者映射类 --&gt;&lt;/configuration&gt;]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Edraw激活]]></title>
    <url>%2F2018%2F04%2F21%2FEdraw%E6%BF%80%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[请在断网的情况下激活，选择手动激活。 用户名:1GUANTAO2008 产品密钥:10711-8621-3000-8217-5433]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导包错误]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%AF%BC%E5%8C%85%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[1The package javax.servlet is accessible from more than one module: &lt;unnamed&gt;, jstl, servlet.api 今天导入包的时候出现这个错误，后来发现是导入位置错误。解决方法: 1、Remove the external jars from the node “modulepath”.2、Select the node “Classpath” then add the external jars.3、Review that all the jars are under the node “Classpath”.]]></content>
      <tags>
        <tag>失误锦集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FIRST、FOLLOW、SELECT]]></title>
    <url>%2F2018%2F04%2F18%2FFIRST%E3%80%81FOLLOW%E3%80%81SELECT%2F</url>
    <content type="text"><![CDATA[LL(1)文法 &nbsp;&nbsp;&nbsp;&nbsp;遍历所有表达式，取具有相同左部的表达式的select集合，将这些具有相同左部表达式的select集合取交集。&nbsp;&nbsp;&nbsp;&nbsp;只要有一组相同左部表达式交集不为空，则该文法非LL1文法。&nbsp;&nbsp;&nbsp;&nbsp;只有所有相同左部表达式交集都不为空，则为LL1文法。 FIRSTS-&gt;AB|bCA-&gt;ε|bB-&gt;ε|aDC-&gt;AD|bD-&gt;aS|c 12FIRST(S)= (FIRST(A)-&#123;ε&#125;)∪(FIRST(B)- &#123;ε&#125;)∪&#123;ε&#125;∪&#123;b&#125;=&#123;a,b,ε&#125;因为A的first有ε，B的first有ε，S-&gt;AB，所以是(FIRST(A)-&#123;ε&#125;)∪(FIRST(B)- &#123;ε&#125;)，然后S-&gt;bC，所以再加一个b，就是(FIRST(A)-&#123;ε&#125;)∪(FIRST(B)- &#123;ε&#125;)∪&#123;b&#125;。 12First(A)= &#123;b, ε&#125;没什么好解释的 12First(B)=&#123;a,ε&#125;ε不用解释，就是B-&gt;ε，所以有它，a就是因为B-&gt;aD，第一个非终结符是a所以有a，那要不要加上D的first呢，就是a和c，答案是不用，就只要aD里面的a就可以。 12First(C)=&#123;a,b,c&#125;C-&gt;AD这一句，AD都是非终结符，所以要找A和D的first集。D的是a，c。A的是b，ε。因为不是AD同时都能推出ε，所以C的first是A和D的first的并集减去ε，还要加上b，因为有C-&gt;b这一句。 1First(D)=&#123;a,c&#125; 12First(AB)=&#123;a,b,ε&#125;AB同时能够推出ε，所以First(AB)就是A和B的First的并集减去ε再并上ε。 两个非终结符的要看是不是他们两个同时能推出ε，能就有ε；要是有一个不能推出ε，那First集就没有ε。 FOLLOW从开始符号S开始推导，开始符号的follow里面一定要有#。所以开始符号的S的follow集要有#。follow是找-&gt;后面的。123比如找S的follow，就要看谁的-&gt;后面有S。D-&gt;aS里面有S，然后再看D-&gt;aS的S后面有没有别的符号，没有就加上D的follow集。如果有，就加上后面那个字母的first集里面除了ε以外的符号，再看这个字母能不能推出ε，如果能，就再加上-&gt;左边的那个字母的follow。Follow(S)-&gt;Follow(D)=&#123;#&#125; 12Follow(A)=&#123;a,c,#&#125;看A的follow，首先找所有-&gt;后面有A的，找到了S-&gt;AB，C-&gt;AD。先看S-&gt;AB，A后面有B，所以要加上B的first集里面除了ε的其他符号，再看B能不能在有限的步骤里推出ε，有B-&gt;ε这句，所以能，就要再加上-&gt;左边的S的follow集，所以目前的A的follow集里面有a,和follow(S)，再看C-&gt;AD这一句，A后面有D，所以要加上D的first集里面除了ε的其他的，再看D能不能在有限的步骤里推出ε，D不能，所以不用加-&gt;左边的C的follow，所以A的follow就是a,Follow(S),a,c，但是如果有重复的，就只要一个，所以最终就是a,c,follow(S)，这个follow(S)到后面还有算出来，不能就这么写。 12Follow(B)=&#123;#&#125;看B的follow，找所有-&gt;后面有B的，找到了S-&gt;AB，看B后面有字母吗？没有，就加上-&gt;左边的S的follow，所以Follow(B)=Follow(S) 12Follow(C)=&#123;#&#125;看C的follow，找所有-&gt;后面有C的，找到了S-&gt;bC，看C后面有字母吗？没有，就加上-&gt;左边的S的follow集，所以Follow(C)=Follow(S) 12Follow(D)=&#123;#&#125;看D的follow，找所有-&gt;后面有D的，找到了B-&gt;aD，C-&gt;AD，这两句D后面都没有字母，所以加上-&gt;左边的B和C的follow，所以Follow(D)=Follow(B)∪Flollow(C) 1Follow(S)=&#123;#&#125;∪Follow(D)，Follow(D)=Follow(B)+ Follow(C)，所以Follow(S)=&#123;#&#125;∪Follow(B)∪Follow(C)，Follow(B)= Follow(S)，Follow(C)= Follow(S)，所以Follow(S)=&#123;#&#125;，Follow(B)=&#123;#&#125;，Follow(C)=&#123;#&#125;，Follow(D)=&#123;#&#125;，Follow(A)=&#123;a,c,#&#125;。 SELECT1SELECT(S-&gt;AB)，AB都能推出ε，所以SELECT(S-&gt;AB)=First(AB)-ε+Follow(S)，所以SELECT(S-&gt;AB)=&#123;a,b,#&#125; 1SELECT(S-&gt;bC)，bC不能推出ε，所以是First(bC)，结果是&#123;b&#125; 1SELECT(A-&gt;ε)，A能推出ε所以是First(ε)-ε+Follow(A)，结果是&#123;a,c,#&#125; 1SELECT(A-&gt;b)，这里的A是推出ｂ，不是ε所以是first(b)，结果是&#123;b&#125; 1SELECT(B-&gt;ε)，B能推出ε，所以是First(ε)-ε+Follow(B)，结果是&#123;#&#125; 1SELECT(B-&gt;aD)，这里B不能推出ε，所以是First(aD)，结果是&#123;a&#125; 1SELECT(C-&gt;AD)，这里D不能推出ε，所以算AD不能推出ε，就是First(AD)，结果是&#123;a,b,c&#125; 1SELECT(C-&gt;b)，C推不出ε，所以是First(b)，结果是&#123;b&#125; 1SELECT(D-&gt;aS)，这里不能推出ε，所以是First(aS)，结果是&#123;a&#125; 1SELECT(D-&gt;c)，这里D不能推出ε，所以是First(c)，结果是&#123;c&#125;]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坦白说]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%9D%A6%E7%99%BD%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[来自Github上某大佬的作品，借鉴一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147from time import time, sleepfrom random import randomimport osimport reimport timeimport sysimport requestsimport subprocessfrom prettytable import PrettyTable'''QQ扫码登陆部分参考：1.fuck-login: https://github.com/xchaoinfo/fuck-login/blob/master/005%20webQQ/webQQ.py2.QQ-Groups-Spider:https://github.com/caspartse/QQ-Groups-Spider/blob/98b61bd0eb4e3fc70dd1cae1864018b9d5cf6bcf/app.pyQQ好友昵称获取：https://kylingit.com/blog/qq-%E7%A9%BA%E9%97%B4%E7%88%AC%E8%99%AB%E4%B9%8B%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/QQ号解密：QQ坦白说有什么bug吗？或者可以通过怎样方式去看见谁发的坦白说？ - 爱打伞的网瘾少女的回答 - 知乎https://www.zhihu.com/question/270498914/answer/355413819'''QRImgPath = os.path.split(os.path.realpath(__file__))[0] + os.sep + 'webQQqr.png'#os.path.realpath(__file__)获取当前执行脚本的绝对路径#split()拆分字符串，通过指定分隔符对字符串进行切片，并返回分割后的字符串列表#os.path.split()将文件名和路径分割开sess = requests.Session()sourceURL = 'https://ti.qq.com/cgi-node/honest-say/receive/mine'js_ver = '10226'def genqrtoken(qrsig): e = 0 for i in range(0, len(qrsig)): e += (e &lt;&lt; 5) + ord(qrsig[i]) qrtoken = (e &amp; 2147483647) return str(qrtoken)#ord()返回值是对应的十进制整数def genbkn(skey): b = 5381 for i in range(0, len(skey)): b += (b &lt;&lt; 5) + ord(skey[i]) bkn = (b &amp; 2147483647) return str(bkn)def genqq(qq): qq = qq.replace('4','a').replace('6','b').replace('5','d').replace('7i','l').replace('7z','l').replace('7z','l') en = ('oe','oK','ow','oi','7e','7K','7w','7i','Ne','NK', 'on','ov','oc','oz','7n','7v','7c','7z','Nn','Nv', 'n','b','-','o','v','a','C','S','c','E', 'z','d','A','i','P','k','s','l','F','q') for i in range(len(en)) : qq = qq.replace(en[i], str(i%10), 10) return qq#headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36' &#125;url = 'http://ui.ptlogin2.qq.com/cgi-bin/login'params = &#123; 'appid': '715030901', 'daid': '73', 'pt_no_auth': '1', &#125;loginresp = sess.get(url, params=params, timeout=1000)sess.headers.update(&#123;'Referer': url&#125;)url = 'http://ptlogin2.qq.com/ptqrshow'params = &#123; 'appid': '715030901', 'e': '2', 'l': 'M', 's': '3', 'd': '72', 'v': '4', 't': '%.17f' % (random()), 'daid': '73' &#125;qrresp = sess.get(url, params=params, timeout=1000)with open(QRImgPath, 'wb') as f : f.write(qrresp.content) f.close()if sys.platform.find('darwin') &gt;= 0: subprocess.call(['open', QRImgPath])elif sys.platform.find('linux') &gt;= 0: subprocess.call(['xdg-open', QRImgPath])else: os.startfile(QRImgPath)print('请使用手机 QQ 扫描二维码以登录')status = 0while True : #login_sig = sess.cookies['pt_login_sig'] qrsig = sess.cookies['qrsig'] errorMsg = '' url = 'http://ptlogin2.qq.com/ptqrlogin' params = &#123; 'u1': sourceURL, 'ptqrtoken': genqrtoken(qrsig), 'ptredirect': '1', 'h': '1', 't': '1', 'g': '1', 'from_ui': '1', 'ptlang': '2052', 'action': '0-0-%d' % (time.time() * 1000), 'js_ver': js_ver, 'js_type': '1', #'login_sig': login_sig, 'pt_uistyle': '40', 'aid': '715030901', 'daid': '73' &#125; resp = sess.get(url, params=params, timeout=1000,headers = headers) code = re.findall(r'(?&lt;=ptuiCB\(\').*?(?=\',)',resp.text)[0] if code == '67' and status == 0: print('扫码成功，请确认登录') status = 1 if code == '0' : print('确认登陆成功') break elif code == '65' : print('二维码失效, 请重新启动程序')os.remove(QRImgPath)qq = re.findall(r'(?&lt;=uin=).*?(?=&amp;service)',resp.text)[0]print(qq,'登陆成功')skey = sess.cookies['skey']print('正在获取坦白说...')tanbai_url = sourceURL + '?_client_version=0.0.79&amp;token=' + genbkn(skey)tanbai = sess.get(tanbai_url,headers = headers,timeout=1000)tanbai_EncodeUin = re.findall(r'(?&lt;=fromEncodeUin\":\").*?(?=\",\"fromFaceUrl)',tanbai.text)tanbai_topicName = re.findall(r'(?&lt;=topicName\":\").*?(?=\",\"timestamp)',tanbai.text)row = PrettyTable()row.field_names = ["QQ","备注","坦白说"]i = 0qzone_url = 'https://h5.qzone.qq.com/proxy/domain/r.qzone.qq.com/cgi-bin/user/cgi_personal_card?uin='while i&lt;len(tanbai_EncodeUin): friendrealqq = genqq(tanbai_EncodeUin[i].replace('*S1*','')) tanbai = tanbai_topicName[i] user_qzone = qzone_url + friendrealqq + '&amp;g_tk=' + genbkn(skey) resp = sess.get(user_qzone,headers = headers) nick = re.findall(r'(?&lt;=realname\":\").*?(?=\",)',resp.text)[0] row.add_row([friendrealqq,nick,tanbai]) i = i + 1print(row)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础题]]></title>
    <url>%2F2018%2F04%2F17%2FJava%E5%9F%BA%E7%A1%80%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、下面哪个是Java语言中正确的标识符（B）A、3com&nbsp;&nbsp;&nbsp;&nbsp;B、import&nbsp;&nbsp;&nbsp;&nbsp;C、that&nbsp;&nbsp;&nbsp;&nbsp;D、this 标识符是以字母开头的字母数字序列。字母通常指大小写英文字母，下划线_、美元符&amp;等，也可以是Unicode字符集中的字符，如汉字等；数字通常指0-9，可以是字母数字的任意组合但不能包含(如+，-)等，不能使用关键字但长度不受限制。 2、下面哪个语句(初始化数组)是不正确的（B）A、int x[]={1,2,3};&nbsp;&nbsp;&nbsp;&nbsp;B、int x[3]={1,2,3}C、int[] x={1,2,3};&nbsp;&nbsp;&nbsp;&nbsp;D、int x[]= new int[]{1,2,3}; int x[]={1,2,3};数组直接赋初值可以不标数组元素个数，会根据后面赋值个数自动分配空间。int[] x={1,2,3};这种方式等价于使用new来进行存储空间分配，即：int x[]= new int[]{1,2,3}; 3、下述概念中不属于面向对象方法的是（D）A、对象&nbsp;&nbsp;&nbsp;&nbsp;B、继承、多态&nbsp;&nbsp;&nbsp;&nbsp;C、类、封装&nbsp;&nbsp;&nbsp;&nbsp;D、过程调用 面向对象=对象+类+继承+通过消息的通信对象: 一组属性及其上的操作的封装体类: 一组有相同属性和操作的对象的集合继承: 一个类为另一个类上的扩充的方式，子类继承父类，主要目的是代码服用消息: 对象间通信的手段 4、下面的代码段中，执行之后，i和j的值是什么？（B）12int i= 1; int j;j= i++* 2+ 3* --i; A、1，2&nbsp;&nbsp;&nbsp;&nbsp;B、1，5&nbsp;&nbsp;&nbsp;&nbsp;C、2，1&nbsp;&nbsp;&nbsp;&nbsp;D、2，2 i++: 先运算再赋值，例如: a= i++，先运算a= i;再运算i= i+ 1;所以结果是a= 1；--i: 先赋值再运算，例如: a= –i;先运算i= i- 1;再运算a= i，所以结果是a= 2；本题中i++* 2+ 3* --i也可写为1* 2+ 3* 1。 5、java.lang包的（）方法比较两个对象是否相等，相等返回 true。（B）A、toString()&nbsp;&nbsp;&nbsp;&nbsp;B、equals()&nbsp;&nbsp;&nbsp;&nbsp;C、compare()&nbsp;&nbsp;&nbsp;&nbsp;D、全错 toString: 返回该对象的字符串表示。equals: 此方法一般用于比较的是对象的内容但是也有的情况下也会去比较两个对象的地址。compare(): 此方法可以用来比较 两个基本类型值的大小，同时也可以用来比较两个Boolean类型值。 6、使用 ___（）方法可以获得 Calendar类的实例（D）A、get()&nbsp;&nbsp;&nbsp;&nbsp;B、equals()&nbsp;&nbsp;&nbsp;&nbsp;C、getTime()&nbsp;&nbsp;&nbsp;&nbsp;D、getInstance() Calendar提供了一个类方法getInstance，以获得此类型的一个通用的对象，getInstance方法返回一个Calendar对象（该对象为Calendar的子类对象） 7、给出下面代码:123456public class Person&#123; static int arr[]= new int[10]; public static void main(String a[])&#123; System.out.println(arr[1]); &#125;&#125; 下面哪个语句是正确的？（B）A、编译时将产生错误;&nbsp;&nbsp;&nbsp;&nbsp;B、输出零;C、编译时正确，运行时将产生错误;&nbsp;&nbsp;&nbsp;&nbsp;D、输出空 arr[]为整型数组，分配地址后默认值为0，所以创建数组时也是对每个数组元素赋初值0。 8、下面关于java中类的说法哪个是不正确的 ?（C）A、类体中只能有变量定义和成员方法的定义，不能有其他语句。B、构造函数是类中的特殊方法。C、类一定要声明为 public 的，才可以执行。D、一个 java文件中可以有多个 class定义。 class前的修饰符是用来控制访问权限的，public表示在任何包里都可访问，protected表示同一包和子类可访问，package(缺省不写时就是这个）表示在同一包内可访问，private表示只有当前类可访问。 9、在 Java中如果要在字符串类型对象 s=“ JAVA”，中找出, V出现的位置可使用下面哪个方法：（C）A、mid(2, s);&nbsp;&nbsp;&nbsp;&nbsp;B、charAt(2); &nbsp;&nbsp;&nbsp;&nbsp; C、s.indexOf(“V”); &nbsp;&nbsp;&nbsp;&nbsp;D、indexOf(s, V); mid(): 从一个字符串中截取出指定数量的字符。charAt(): 返回指定索引位置的char值。检索范围是0~length()-1。indexOf(): 返回某个指定的字符串值在字符串中首次出现的位置。 10、A 派生出子类 B， B 派生出子类 C，并且在 Java源代码中有如下声明:1) A a0=new A();2) A a1=new B();3) A a2=new C();问以下哪个说法是正确的？（D）A、只有第 1 行能通过编译B、第 1、 2 行能通过编译，但第 3 行编译出错C、第 1、 2、 3 行能通过编译，但第 2、 3 行运行时出错D、第 1 行、第 2 行和第 3 行的声明都是正确的 子类继承父类的所有属性和方法，B为A的子类，用A可以去实例B；C为B的子类，用B去实例C，也可以；间接的，C也是A的子类，可以用A去实例C 11、下面说法正确的是（A）A、final可修饰类、属性、方法。B、abstract可修饰类、属性、方法C、定义抽象方法需有方法的返回类型、名称、参数列表和方法体。D、用final修饰的变量，在程序中可对这个变量的值进行更改。 final为最终的 可以修饰类、属性、方法。abstract为抽象的 可以修饰类、方法，但是不能修饰属性。定义抽象方法不能有方法体。既然final为最终的，就不能更改。 12、Java中main()函数的值是什么？（D）A、String&nbsp;&nbsp;&nbsp;&nbsp;B、int&nbsp;&nbsp;&nbsp;&nbsp;C、char&nbsp;&nbsp;&nbsp;&nbsp;D、void 13、已知表达式 int m[] = {0, 1, 2, 3, 4, 5, 6 }; 下面表达式的值与数组下标量总数相等。（B）A、m.length()&nbsp;&nbsp;&nbsp;&nbsp;B、m.length- 1&nbsp;&nbsp;&nbsp;&nbsp; C、m.length()+ 1&nbsp;&nbsp;&nbsp;&nbsp;D、m.length+ 1 数组的下标是从0开始的，所以数组下标最大为6。而m.length得值为7,所以m.length- 1。length用于求String字符串数组的长度；length()用于求String字符串对象的长度。 14、以下（C）方法用于定义线程的执行体。A、start()&nbsp;&nbsp;&nbsp;&nbsp;B、init()&nbsp;&nbsp;&nbsp;&nbsp;C、run()&nbsp;&nbsp;&nbsp;&nbsp;D、main() run()方法是用来定义这个线程在启动的时候需要做什么。但是，直接执行run()方法那就不是线程，必须使用start()启动，那样才是线程。 15、当浏览器返回到新URL的包含applet 的页面时调用以下哪个函数（B）A、init()&nbsp;&nbsp;&nbsp;&nbsp;B、start()&nbsp;&nbsp;&nbsp;&nbsp;C、stop()&nbsp;&nbsp;&nbsp;&nbsp;D、destory() 16、下列方法与Applet显示无关的是（D）A、paint&nbsp;&nbsp;&nbsp;&nbsp;B、update&nbsp;&nbsp;&nbsp;&nbsp;C、repaint()&nbsp;&nbsp;&nbsp;&nbsp;D、draw Applet显示相关的方法主要有3个。paint()方法，具体执行Applet的绘制，定义为: public void paint(Graphics g)。update()方法，定义为: public void update(Graphics g)，主要用于更新Applet的显示。repaint()方法，定义为: public void repaint()，主要用于Applet的重新显示，它调用update()方法实现对Applet的更新。而draw()方法与显示无关。 17、请问如下（D）方法可以将 MenuBar 加入 Frame 中。A、setMenu()&nbsp;&nbsp;&nbsp;&nbsp;B、setMenuBar()&nbsp;&nbsp;&nbsp;&nbsp;C、add()&nbsp;&nbsp;&nbsp;&nbsp;D、addMenuBar() 18、下面（B、E）不是Java中的容器。A、ScrollPane&nbsp;&nbsp;&nbsp;&nbsp;B、Canvas&nbsp;&nbsp;&nbsp;&nbsp;C、Dialog&nbsp;&nbsp;&nbsp;&nbsp;D、Applet&nbsp;&nbsp;&nbsp;&nbsp;E、Scrollbar Canvas只是画布，是游戏中所有UI组件的”容器”。Scrollbar是滚动条，它是一个构件。常用的容器由Frame(窗口容器)，Panel(画板容器)，Applet(Java小程序的容器)，Dialog(对话框容器)等。 19、下面的程序段创建了 BufferedReader 类的对象in，以便读取本机d盘my 文件夹下的文件1.txt。File构造函数中正确的路径和文件名的表示是 （C）。123File f=new File( 填代码处 );file=new FileReader(f);in=new BufferedReader(file); A、”1.txt”&nbsp;&nbsp;&nbsp;&nbsp;B、”d:\my\1”&nbsp;&nbsp;&nbsp;&nbsp; C、”d:\my\1.txt”&nbsp;&nbsp;&nbsp;&nbsp;D、”my\1.txt” 20、有整型数组：int[] x={12,35,8,7,2};, 则 调 用 方 法Arrays.sort(x) 后，数组 x 中的元素值依次是（A）A、2 7 8 12 35&nbsp;&nbsp;&nbsp;&nbsp;B、12 35 8 7 2C、35 12 8 7 2&nbsp;&nbsp;&nbsp;&nbsp;D、8 7 12 35 2 21、下面（A）赋值语句是不合法的。A 、float a= 2.0&nbsp;&nbsp;&nbsp;&nbsp;B、double b = 2.0C、int c = 2&nbsp;&nbsp;&nbsp;&nbsp;D、long d = 2L 22、下面（C）语句不是创建数组的正确语句。A、float f[][] = new float[6][6];B、float []f[] = new float[6][6];C、float f[][] = new float[][6];D、float [][]f = new float[6][6];E、float f[][] = new float[6][];F、float [][]f = new float[6][]; 行不能为空 23、Java中如下（A、B、C）约束符是正确的。A、private&nbsp;&nbsp;&nbsp;&nbsp;B、public&nbsp;&nbsp;&nbsp;&nbsp;C、protected&nbsp;&nbsp;&nbsp;&nbsp;D、protect&nbsp;&nbsp;&nbsp;&nbsp;E、final 24、下面（C、D）事件监听器在Java中没有事件适配器。A、MouseListenerB、KeyListenerC、ActionListenerD、ItemListenerE、WindowListener 这两个借口中都只有一个abstract方法。java中只要该接口中包含了两个或以上abstract方法的接口都有适配器。Java语言为一些Listener接口提供了适配器(Adapter)类。可以通过继承事件所对应的Adapter类，重写重要的方法，无关方法不用实现。java.awt,enent包中定义的事件适配器类包括以下几个:1、ComponentAdapter，构件适配器。2、ContainerAdapter，容器适配器。3、FocusAdapter，焦点适配器。4、KeyAdapter，键盘适配器。5、MouseMotionAdapter，鼠标运动适配器。6、MouseAdapter，鼠标适配器。7、WindowAdapter，窗口适配器。 25、已知如下的命令执行java MyTest a b c，（C、D）语句是正确的。A、 args[0] = “MyTest a b c”B、 args[0] = “MyTest”C、 args[0] = “a”D、 args[1]= ‘b’ 26、下列特点中，（A）是Java虚拟机执行的特点之一。A、字节代码&nbsp;&nbsp;&nbsp;&nbsp;B、多进程&nbsp;&nbsp;&nbsp;&nbsp;C、静态链接&nbsp;&nbsp;&nbsp;&nbsp;D、编译 Java语言的执行模式是半编译和半解释型。Java编写好的程序首先由编译器转换为标准字节代码，然后由Java虚拟机去解释执行。字节代码也是一种二进制文件，但不能直接在操作系统上运行，它可看作虚拟机的机器码。虚拟机把字节代码程序与各操作系统和硬件分开，使Java程序独立于平台。 27、对于catch字句的排列，下列（A）是正确的。A、父类在先，子类在后&nbsp;&nbsp;&nbsp;&nbsp;B、子类在先，父类在后C、有继承关系的异常不能在同一个try程序段内D、先有子类，其他如何排列都无关 在Java中提供了结构化的异常处理功能，其主要是通过try...catch语句来实现的。在Java中可以将可能产生异常的代码放入到try子句中，如果产生异常，将会执行catch子句。如果有多个异常，则应先处理父类异常，再处理子类异常，否则后面的异常处理，将得不到执行。 28、以下（B）表达式是不合法的。A、String x=”Hello”; int y=9; x+=y;B、String x=”Hello”; int y=9; if(x==y) { }C、String x=”Hello”; int y=9; x=x+y;D、String x=null; int y=(x!=null)&amp;&amp;(x.length()&gt;0) ? x.length() : 0 Java对”+”进行了扩展，不仅可以连接字符串，而且还能将字符串与其他类型数据进行连接，结果是字符串。若”+”的第一个操作数是字符串，Java会自动将后面的操作数类型转换成字符串类型。例如本题选项A中，x+= y即x= x+ y，则计算结果x的值为字符串Hello9；选项C与此类似，故此选项也是正确的；选项D主要考查的是条件运算符”?:”，即把表达式(x!=null)&amp;&amp;(x.length()&gt;0) ? x.length() : 0的值赋给整型变量y，运算结果y的值是0；而选项B是因为==两边的类型不匹配，无法比较，所以此表达式是错误的。 29、在程序读入字符文件时，能够以该文件作为直接参数的类是（A）。A、FileReader&nbsp;&nbsp;&nbsp;&nbsp;B、BufferedReaderC、FileInputStream&nbsp;&nbsp;&nbsp;&nbsp;D、ObjectInputStream FileReader、BufferedReader是字符类输入流。FileInputStream是字节输入流。对象串行化时，需要使用ObjectInputStream类中提供的方法从对象流中读取对象。所以，在程序读入字符文件时，要使用字符流FileReader或BufferedReader。但是FileReader的参数是读入的文件，而BufferedReader的参数是FileReader流的一个对象。 30、在Java中，线程是（B）。A、分时的&nbsp;&nbsp;&nbsp;&nbsp;B、抢占式的C、非抢占式的&nbsp;&nbsp;&nbsp;&nbsp;D、非分时的 Java的线程调度策略是一种基于优先级的抢占式调度。Java这种抢占式调度可以是分时的，即每个等待池中的线程轮流执行，也可以不是，即线程逐个运行。具体待用哪种方式，由具体JVM而定。线程一般通过使用sleep()等方法保证其他线程运行时间。 31、数据库设计中，用E-R图来描述信息结构但不涉及信息在计算机中的表示，它属于数据库设计的（C）。A．需求分析阶段B．逻辑设计阶段C．概念设计阶段D．物理设计阶段 E-R图是E-R模型的一种非常直观的图的形式表示，它描述信息结构但不涉及信息在计算机中的表示，它是数据库概念设计阶段的工具。 32、下列关于Java布尔类型的描述中，正确的是（A）。A．一种基本的数据类型，它的类型名称为booleanB．用int表示类型C．其值可以赋给int类型的变量D．有两个值，1代表真，0代表假 Java语言中boolean型数据只有两个值：true(真)和false(假)。它不对应任何数值，也不能与数字进行相互转换。 33、在文件类提供的方法中，用于创建目录的方法是（A）。A．mkdir()&nbsp;&nbsp;&nbsp;&nbsp;B．mkdirs()C．list()&nbsp;&nbsp;&nbsp;&nbsp;D．listRoots() mkdir()是为目录操作提供的方法，用来创建目录；mkdirs()也是为目录操作提供的方法，创建包含父目录的目录；list()是对文件名操作提供的方法，返回一个字符串数组，为该文件所在目录下的所有文件名列表；listRoots是为目录提供的方法，返回根目录结构。 34、下列能够正确创建线程的方法是（D）。Ⅰ．继承java．1ang．Thread类，并重写run()方法Ⅱ．继承java．1ang．Runnable类，并重写start()方法Ⅲ．实现java．1ang．Thread接口，并实现run()方法IV．实现java．1ang．Runable接口，并实现run()方法A、I，Ⅲ&nbsp;&nbsp;&nbsp;&nbsp;B、Ⅱ，IVC、Ⅱ，Ⅲ&nbsp;&nbsp;&nbsp;&nbsp;D、I，IV 用Thread类的构造方法Thread(Runnabletarget)创建线程对象时，构造方法中的参数必须是一个具体的对象，该对象称作线程的目标对象，创建目标对象的类必须要实现Runnable接口。 35、下列有关数组的叙述中，错误的是（A）。A、在同一个环境下，数组与内存变量可以同名，两者互不影响B、可以用一维数组的形式访问二维数组C、在可以使用简单内存变量的地方都可以使用数组元素D、一个数组中各元素的数据类型可以相同，也可以不同 整个数组的数据类型为A(Array)，而各个数组元素可以分别存放不同类型的数据。在使用数组和数组元素时，应注意如下问题：1) 在任何能使用简单内存变量的地方都可以使用数组元素；2) 在同一个环境下，数组名不能与简单变量名重复；3) 可以用一维数组的形式访问二维数组。 36、下列关于构造方法的叙述中，错误的是（C）。A、Java语言规定构造方法名与类名必须相同B、Java语言规定构造方法没有返回值，但不用void声明C、Java语言规定构造方法不可以重载D、Java语言规定构造方法只能通过new自动调用 构造方法是类中的一种特殊方法，是为对象初始化操作编写的方法，用它来定义对象的初始状态。构造方法名必须与类名相同，它没有返回值，用户不能直接调用它，只能通过new自动调用。构造方法具有下列特点：①因为构造方法与类名必须相同，所以方法首字母小写规则对它不适用。②构造方法是给对象赋初值，所以没有返回值，但不要void来声明。③构造方法不能被程序调用。④构造方法可由编程人员在类中定义，默认时由Java语言自动生成。⑤构造方法可以重载实现不同的初始化方法，调用时按参数决定调用哪个方法。 37、用来导入已定义好的类或包的语句是（B）。A、mainB、importC、public classD、ClaSS Java中使用import语句来导入已定义好的类或包，需要注意Java语言的java．1ang包是编译器自动导入的，编程时如果使用该包中的类，可省去import导入，如果要使用其他包中的类，必须用import导入。 38、Java程序的执行过程中用到一套JDK工具，其中java.exe是指（B）A、Java文档生成器B、Java解释器C、Java编译器D、Java类分解器 javac是编译器，Java是运行Java程序的，也就是启动虚拟机，把.class字节码文件解释成机器码，然后运行 39、Java编程所必须的默认引用包为（A）A、java.sys包B、java.lang包C、java.new包D、以上都不是 40、定义一个类名为“ MyClass.java ”的类，并且该类可被一 个 工 程 中 的 所 有 类 访 问 ， 那 么 该 类 的 正 确 声 明 应为（C）A、private class MyClass extends ObjectB、class MyClass extends ObjectC、public class MyClassD、private class MyClass extends Object 41、Java程序经常用到”递归”，”递归”的基本思想是（C）A、”让别人反复调用自己”B、”自己反复调用别人”C、”自己反复调用自己”D、以上说法都不对 42、Applet类的直接父类是（D）A、Component类B、Container类C、Frame类D、Panel类 43、Frame的默认的布局管理器是下列哪一个（B）A、FlowLayout&nbsp;&nbsp;&nbsp;&nbsp;B、BorderLayoutC、GridLayout&nbsp;&nbsp;&nbsp;&nbsp;D、CardLayout 44、下列说法不正确的是（C）A、IOException 必须被捕获或抛出B、java 语言会自动初始化变量的值C、java 语言不允许同时继承一个类并实现一个接口D、java 语言会自动回收内存中的垃圾 45、下面的说法正确的是（A、B、C、D）。A、Java 语言是面向对象的、解释执行的网络编程语言。B、Java 语言具有可移植性，是与平台无关的编程语言。C、Java 语言可对内存垃圾自动收集。D、Java 语言编写的程序虽然是“一次编译，到处运行” ，但必须要 java 的运行环境。 46、定义变量如下:1234char c= 'w';int i= 8; long l= 15;float f= 8.9f; 以下赋值语句不正确的是（B、C）A、i= c+ i;B、c= c+ i;C、l= f+ l;D、f= i+ l+ f; double&gt; float&gt; long&gt; int&gt; short&gt; char 47、下列哪一种叙述是正确的（D）A、abstract 修饰符可修饰字段、方法和类B、抽象方法的 body 部分必须用一对大括号{ }包住C、声明抽象方法，大括号可有可无D、声明抽象方法不可写出大括号 abstract不能修饰字段。既然是抽象方法，当然是没有实现的方法，根本就没有body部分。 48、下列说法正确的有 （C）A、class 中的 constructor 不可省略B、constructor 必须与 class 同名，但方法不能与 class同名C、constructor 在一个对象被 new 时执行D、一个 class 只能定义一个 constructor123456789101112见代码，很明显方法是可以和类名同名的，和构造方法唯一的区别就是，构造方法没有返回值。public long1_1() &#123; System.out.println("1");&#125;public void long1_1() &#123; System.out.println("2");&#125;public static void main(String a[])&#123; long1_1 aLong1_1= new long1_1(); System.out.println("3"); aLong1_1.long1_1();&#125; 输出结果为: 132 49、下列关于修饰符混用的说法，错误的是（D）A、abstract不能与 final 并列修饰同一个类B、abstract类中不可以有 private 的成员C、abstract方法必须在 abstract 类中D、static 方法中能处理非 static 的属性 50、（B）修饰符允许对类成员的访问不依赖于该类的任何对象A、 abstractB、 staticC、 returnD、 public 51、关于被私有访问控制符private修饰的成员变量，以下说法正确的是（C）A、可以被三种类所引用：该类自身、与它在同一个包中的其他类、在其他包中的该类的子类B、可以被两种类访问和引用：该类本身、该类的所有子类C、只能被该类自身所访问和修改D、只能被同一个包中的类访问 52、下面的集合中，（C）不可以存储重复元素。A、SetB、CollectionC、MapD、List 53、关于 Map 和 List，下面说法正确的是（D）。A、Map 继承 ListB、List 中可以保存 Map 或 ListC、Map 和 List 只能保存从数据库中取出的数据D、Map 的 value 可以是 List 或 Map 54、给定Java代码如下，编译运行后，结果是（B）1234567public class long1_1&#123; static String string; public static void main(String[] args) &#123; char c= string.charAt(0); System.out.println(c); &#125;&#125; A、编译错误B、运行期异常，异常类型为NullPointerExceptionC、运行期异常，异常类型为ArithmeticExceptionD、正确运行，但无输出内容 55、给定Java代码如下，关于super的用法，以下描述正确的是（C）12345class C extends B&#123; public C() &#123; super(); &#125; &#125; A、用来调用类B中定义的super()方法B、用来调用类C中定义的super()方法C、用来调用类B的无参构造方法D、用来调用类B中第一个出现的构造方法 56、给定Java代码如下，编译运行，结果是（A）123456public class long1_1&#123; public static void main(String[] args) &#123; int i; System.out.println("i= "+ i); &#125;&#125; A、编译错误B、运行时出现例外C、正常运行，输出i= -1;D、正常运行，输出i= 0; 编译一下会出现这个错误The local variable i may not have been initialized。意思是没有对该变量进行初始化。 57、下面的Java代码，当x= 2时，运行结果是（C）123456789switch (x) &#123; case 1: System.out.println(1); case 2: case 3: System.out.println(3); case 4: System.out.println(4); &#125; A、没有输出任何结果B、输出结果为3C、输出结果是3和4D、输出结果是1、3和4 58、分析如下Java代码片段，输出结果为（A）1234567891011int money= 0;int price= 10;int number= 0;for(int i= 0; i&lt; 2; i++) &#123; number++; //System.out.println(number); --price; //System.out.println(price); money+= number* price;&#125;System.out.println(money); A、25&nbsp;&nbsp;&nbsp;&nbsp;B、28C、31&nbsp;&nbsp;&nbsp;&nbsp;D、30 59、给定如下Java代码，编译运行时，结果是（C）1234public static void main(String[] args) &#123; String string= "123456789"; System.out.println(string.indexOf("5")); &#125; A、6&nbsp;&nbsp;&nbsp;&nbsp;B、5&nbsp;&nbsp;&nbsp;&nbsp;C、4&nbsp;&nbsp;&nbsp;&nbsp;D、-1 60、下列哪一个操作不能使线程从等待阻塞状态进入对象阻塞状态（D）A、等待阻塞状态下的线程被notify()唤醒B、等待阻塞状态下的纯种被interrput()中断C、等待时间到D、等待阻塞状态下的线程调用wait()方法 61、在Java中，下列（D）类不能派生出子类。A、public class MyClass{}B、class MyClass{}C、abstract class MyClass{}D、final class MyClass{} 62、在Java中，要判断D盘下是否存在文件abc.txt，应该使用以下（C）判断语句。A、if(new File(“d:abc.txt”).exists()== 1)B、if(File.exists(“d:abc.txt”)== 1)C、if(new File(“d:/abc.txt”).exists())D、if(File.exists(“d:/abc.txt”)) 63、在Java中，关于HashMap类的描述，以下说法错误的是（B）A、HashMap使用键/值的形式保存数据B、HashMap能够保证其中元素的顺序C、HashMap允许将null用作键D、HashMap允许将null用作值 64、在Java中，下面关于变量及其作用域的描述错误的是（A、B）A、实例变量是存放在方法区中B、实例变量用关键字static声明C、在方法中定义的局部变量在该方法被执行时创建D、局部变量在使用前必须被初始化 对象的所有数据成员都在堆中。实例变量在栈中，实例在堆中。定义该成员变量时没有使用static修饰，该成员变量又被称为非静态变量或实例变量；如果使用了static修饰，则该成员变量又可被称为静态变量或类变量。 65、给定Java代码，如下:123abstract class Shape&#123; abstract void draw();&#125; 要创建Shape类的子类Circle，以下代码正确的是（B、D）A、class Circle extends Shape{int draw(){}}B、abstract class Circle extends Shape{}C、class Circle extends Shape{void draw()}D、class Circle extends Shape{void draw(){}} 66、给定一个Java程序的方法结构如下，以下方法体实现语句正确的是（B、C）12public Integer change(int i)&#123;&#125; A、Integer int= new Integer(i); return int;B、Integer t= Integer.valueOf(i); return t;C、return new Integer(i);D、return i; 67、给定一段Java代码如下，要打印出list中存储的内容，以下语句正确的是（A、B）1234ArrayList list= new ArrayList(); list.add("a"); list.add("b"); Iterator iterator= list.iterator(); 1234A、while(iterator.hasNext()) &#123; System.out.println(iterator.next());&#125; 1234B、for(int i= 0; i&lt; list.size(); i++) &#123; System.out.println(list.get(i));&#125; 1234C、while(list.hasNext()) &#123; System.out.println(list.next());&#125; 1234D、for(int i= 0; i&lt; list.size(); i++) &#123; System.out.println(iterator(i));&#125; 68、在Java中，下面（C、D）是不合法的声明。A、short x[]B、short[] yC、short[5] x2D、short z2[5] 69、以下（B、C）不是Java的原始数据类型。A、shortB、BooleamC、unitD、float Java的原始数据类型一共就8个，分别是: byte、short、int、long、boolean、char、float、double。注意这些都是大小写敏感的，而Booleanm是boolean的封装类(Wrapper class)。 70、给定如下Java代码，编译运行时，以下（A、C）语句的值是true。1234String string= "Hello";String t= "Hello";String e= new String("Hello");char c[]= &#123;'H', 'e', 'l', 'l', 'o', "G"&#125;; A、string.equals(t);B、t.equals(c);C、t.equals(e);D、t== c; ==操作符所比较的是操作符两端的操作数是否是同一个对象，而String的`equals()方法所比较的是两个String对象的内容是否一样，其参数是一个String对象时才有可能返回true，其他对象都返回false。定义char时候，字符必须用单引号，字符串用双引号。例如，在char c= ‘a’中，’a’是字符常量，必须用单引号。”a”表示字符串，包含两个字符，一个是’a’，一个是’\0’。 71、在Java中，下面关于抽象类的描述正确的是（B、D）A、抽象类可以被实例化B、如果一个类中有一个方法被声明为抽象的，那么这个类必须是抽象类C、抽象类中的方法必须都是抽象的D、声明抽象类必须带有关键字abstract 72、以下代码运行输出的是（C）123456789101112class Person&#123; private String name= "Person"; int age= 0;&#125;public class long1_1 extends Person&#123; public String grade; public static void main(String[] args) &#123; Person person= new Person(); System.out.println(person.name); &#125;&#125; A、输出: PersonB、没有输出C、编译错误D、运行出错 73、在使用 super 和 this关键字时，以下描述正确的是（A）A、在子类构造方法中使用super()显示调用父类的构造方法，super()必须写在子类构造方法的第一行，否则编译不通过B、super()和this()不一定要放在构造方法内第一行C、this()和super()可以同时出现在一个构造函数中D、this()和super()可以在static环境中使用，包括static方法和static语句块 1、调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。2、super()和this()类似。区别是：super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。3、super()和this()均需放在构造方法内第一行。4、尽管可以用this()调用一个构造器，但却不能调用两个。5、this()和super()不能同时出现在一个构造函数里面，因为this()必然会调用其它的构造函数，其它的构造函数必然也会有super()语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。6、this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量，static方法，static语句块。7、从本质上讲，this()是一个指向本对象的指针,然而super()是一个Java关键字。 74、以下对封装的描述正确的是（D）A、只能对一个类中的方法进行封装，不能对属性进行封装B、如果子类继承了父类，对于父类中进行封装的方法，子类仍然可以直接调用C、封装的意义不大，因此在编码时尽量不要使用D、封装的主要作用在于对外隐藏内部实现细节，增强程序的安全性 75、以下对继承的描述错误的是（A）A、Java 中的继承允许一个子类继承多个父类B、父类更具有通用性，子类更具体C、Java 中的继承存在着传递性D、当实例化子类时会递归调用父类中的构造方法 76、Java提供哪几种运算符（A、B、C、D）A、算数运算符B、位运算符C、关系运算符D、逻辑运算符E、条件运算符 77、以下说法错误的是（D）A. super.方法()可以调用父类的所有非私有方法B. super()可以调用父类的所有非私有构造函数C. super.属性可以调用父类的所有非私有属性D. this和super关键字可以出现在同一个构造函数中 78、访问修饰符作用范围由大到小是（D）A、private-default-protected-publicB、public-default-protected-privateC、private-protected-default-publicD、public-protected-default-private 79、多态的表现形式有（A）A、重写B、抽象C、继承D、封装 80、以下对重载描述错误的是（B） overload(重载 ) override(重写)A、方法重载多发生在一个类的内部B、构造方法不能重载C、重载要求方法名相同，参数列表不同D、方法的返回值类型不是区分方法重载的条件 81、以下对抽象类的描述正确的是（C）A、抽象类没有构造方法B、抽象类必须提供抽象方法C、有抽象方法的类一定是抽象类D、抽象类可以通过 new 关键字直接实例化 82、以下对接口描述错误的有（D）A、接口没有提供构造方法B、接口中的方法默认使用 public、 abstract 修饰C、接口中的属性默认使用 public、 static、 final 修饰D、接口不允许多继承 83、以下代码，描述正确的有（A）1234567891011interface IDemo&#123; public static final String name; //1 void print(); //2 public void getInfo(); //3&#125;abstract class long1_1 implements IDemo&#123; //4 public void print() &#123; &#125;&#125; A、第1行错误，没有给变量赋值B、第2行错误，方法没有修饰符C、第4行错误，没有实现接口的全部方法D、第3行错误，没有方法的实现 84、以下描述错误的有（C）A、abstract 可以修饰类、接口、方法B、abstract 修饰的类主要用于被继承C、abstract 可以修饰变量D、abstract 修饰的类，其子类也可以是 abstract修饰的 85、以下描述正确的有（B）A、方法的重写应用在一个类的内部B、方法的重载与返回值类型无关C、构造方法不能重载D、构造方法可以重写 86、以下对异常的描述不正确的有（C）A、异常分为 Error 和 ExceptionB、Throwable 是所有异常类的父类C、Exception 是所有异常类父类D、Exception 包括 RuntimeException 和 RuntimeException 之外的异常 87、下面代码的运行结果是（B）1234567891011121314151617public class long1_1&#123; public int add(int a, int b) &#123; try &#123; return a+ b; &#125;catch (Exception e) &#123; // TODO: handle exception System.out.println("catch语句块"); &#125;finally &#123; System.out.println("finally语句块"); &#125; return 0; &#125; public static void main(String[] args) &#123; long1_1 long1_1= new long1_1(); System.out.println("和是: "+ long1_1.add(9, 34)); &#125;&#125; A、编译异常B、finally语句块和是: 43C、和是: 43finally语句块D、catch语句块和是: 43 88、以下对自定义异常描述正确的是（C）A、自定义异常必须继承 ExceptionB、自定义异常可以继承自 ErrorC、自定义异常可以更加明确定位异常出错的位置和给出详细出错信息D、程序中已经提供了丰富的异常类，使用自定义异常没有意义 89、Java中的集合类包括 ArrayList 、 LinkedList 、 HashMap 等类，下列关于集合类描述错误的是（C）A、ArrayList 和 LinkedList 均实现了 List 接口B、ArrayList 的访问速度比 LinkedList 快C、添加和删除元素时， ArrayList 的表现更佳D、HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值 90、在Java中开发JDBC应用程序时，使用DriverManager类的getConnection（）方法建立与数据源的连接语句为：Connection con= DriverManager.getConnection( “ jdbc:odbc:news ” ); URL连接中的”news”表示的是（C）A、数据库中表的名称B、数据库服务器的机器名C、数据源的名称D、用户名 91、获取 ResutlSet对象 rst 的第一行数据，以下正确的是（B）A、rst.hashNext();B、rst.next();C、rst.first();D、rst.nextRow(); first()：移动到第一条记录，并未读取。 92、以下哪个方法用于定义线程的执行体？（C）A、start()B、init()C、run()D、synchronized() 创建线程有两种方法：实现java.lang.Runnable接口和继承Thread类并重写run()方法。无论通过哪种方式创建线程，都必须通过run()方法定义线程体，因为一个线程在开始执行时，就是通过从其run()方法开始执行的。Runnable接口中定义了抽象run()方法，而Thread类本身也实现了Runnable接口。 93、下面哪个流类属于面向字符的输入流（D）A、BufferedWriterB、FileInputStreamC、ObjectInputStreamD、InputStreamReader 字节输入流: InputStreamFileInputStream、ByteArrayInputStream、PipedInputStream、BufferedInputStream、ObjectInputStream、FilterInputStream、PushbackInputStream、DataInputStream字节输出流: OutputStreamFileOutputStream、ByteArrayOutputStream、PipedOutputStream、BufferedOutputStream、ObjectOutputStream、FilterOutputStream、PrintStream、DataOutputStream字符输入流: ReaderFileReader、CharArrayReader、PipedReader、StringReader、BufferedReader、InputStreamReader、FilterReader、PushbackReader字符输出流: WriterFileWriter、CharArrayWriter、PipedWriter、StringWriter、BufferedWriter、OutputStreamWriter、FilterWriter、PrintWriter 94、一个线程在任何时刻都处于某种线程状态（thread state）,例如创建状态、运行状态、阻塞状态、就绪状态等。一个线程可以由选项中的哪种线程状态直接到达运行状态？（D）A、死亡状态B、阻塞状态（对象 lock 池内）C、阻塞状态（对象 wait 池内）D、就绪状态 95、选项中哪一行代码可以替换题目中//add code here而不产生编译错误？（A）123456public abstract class long1_1&#123; public int constInt= 5; //add code here public void method() &#123; &#125;&#125; A、public abstract void method(int a);B、constInt= constInt+ 5;C、public int method();D、public abstract void anotherMethod() {} 96、下列哪种说法是正确的（D）A、实例方法可直接调用超类的实例方法B、实例方法可直接调用超类的类方法C、实例方法可直接调用其他类的实例方法D、实例方法可直接调用本类的类方法 类方法即用static修饰的方法，不能使用this，super关键字，不能调用非static的成员变量，非static的成员方法，只能访问static修饰的成员变量，成员方法类方法指的是用static关键字修饰的方法，而实例方法就是相对于类方法的其它方法。当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址，当该类创建对象后，类中的实例方法才分配入口地址，从而实例方法可以被类创建的任何对象调用执行。需要注意的是，当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址，也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。对于类中的类方法，在该类被加载到内存时，就分配了相应的入口地址。从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。类方法的入口地址直到程序退出才被取消。对于A,不可以调用父类的private实例方法。因为private修饰的方法只有本类对象才可以调用对于B,类方法只有本类才可以调用对于C,跟A相同，比A更离谱 97、用于调用存储过程的对象是（C）A、ResultSetB、DriverManagerC、CallableStatemetD、PreparedStatement 98、按照 MVC 设计模式， JSP 用于实现（B）A、ModelB、ViewC、ControllerD、容器 99、在什么时候Float对象会被垃圾回收（C）12345678public Object m() &#123; Object o = new Float(3.14F); Object[] oa = new Object[1]; oa[0] = o; o = null; oa[0] = null; return o;&#125; A、在“oa[0] = o;”之后B、在“o = null;”之后C、在“oa[0] = null;”之后D、在“return o;”之后 垃圾回收的判断条件是对象不可达，上面代码中与Float对象可达的有对象o和oa[0]，所以在这两个对象都为空之后就可以回收了 100、下面代码的输出结果是（B）123456789101112class Base &#123; Base() &#123; System.out.print("Base"); &#125;&#125;public class Alpha extends Base &#123; public static void main(String[] args) &#123; new Alpha(); new Base(); &#125;&#125; A、BaseB、BaseBaseC、代码运行但没有输出D、运行时抛出异常 子类如果没有构造方法，默认调用父类的无参的构造方法 101、在Servlet的生命周期中，容器只调用一次的方法是（C、D）A、serviceB、getServletConfigC、initD、destroy init() 和destroy() 即 初始化 和 销毁 只执行一次 102、在一个线程中Sleep（1000）方法，将使得该线程在多少时间后获得对CPU的控制（假设睡眠过程中不会有其他事件唤醒该线程）（C）Ａ、正好1000毫秒Ｂ、1000毫秒不到Ｃ、=&gt;1000毫秒Ｄ、不一定 因为在1000ms之后，只是让线程重新回到队列中，如果还有其它线程在执行，还会继续等待，不会立即取得CPU的控制 103、下面关于垃圾收集的说法正确的是（D）Ａ、一旦一个对象成为垃圾，就立刻被收集掉。Ｂ、对象空间被收集掉之后，会执行该对象的finalize方法Ｃ、finalize方法和C++的析构函数是完全一回事情Ｄ、一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此。 只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的；垃圾回收器准备释放内存的时候，会先调用finalize()；如果你为某个对象定义了finalize() 方法，JVM 可能不会调用它，因为垃圾回收器不曾释放过那些对象的内，调用System.gc() 也不会起作用，因为它仅仅是给 JVM 一个建议而不是命令。 104、下面的语句会产生什么样的输出？（A）1System.out.println(4&amp;7); A、4&nbsp;&nbsp;&nbsp;&nbsp;B、5C、6&nbsp;&nbsp;&nbsp;&nbsp;D、7 0100 &amp; 1111= 0100即为4 105、下列关于构造方法的叙述中，错误的（C）A、Java语言规定构造方法名与类名必须相同B、Java语言规定构造方法没有返回值，但不用void声明C、Java语言规定构造方法不可以重载D、Java语言规定构造方法只能通过new自动调用 当不声明构造函数时，默认有一个无参数的构造方法；构造函数不能有返回类型；构造函数可以是私有的，这样外部就无法由私有的构造函数创建对象，如单例模式 106、在接口中以下哪条定义是正确的?（A、B）A、void methoda();B、public double methoda();C、public final double methoda();D、static void methoda(double d1);E、protected void methoda(double d1); 接口only public, abstract, default, static and strictfp are permitted，而且只有default, static修饰的方法才能有方法体，而且必须有方法体，也就是方法后面得有大括号 107、如下代码123456789public class X &#123;public X aMethod() &#123; return this;&#125;&#125;public class Y extends X &#123;&#125; 哪两个方法能加到Y类的定义中（C、E）A、public void aMethod() {}B、private void aMethod() {}C、public void aMethod(String s) {}D、private Y aMethod() { return null; }E、public X aMethod() { return new Y(); } C属于重载，其实跟父类的同名方法没什么关系，E属于重写，覆盖父类的同名方法 108、写一个SIngleton（单例模式）出来1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 109、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？ 对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。 110、描述forward和redirect的区别 forward是服务器请求资源，服务器直接访问目标地址的URL，目标地址可以接收request 请求参数，然后把结果发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求哪个地址，浏览器会重新进行请求，此时不能用request传值，浏览器的地址栏会变成新的地址。 111、数据连接池的工作机制是什么？ J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其标记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 112、swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上? switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。long,string 都不能作用于swtich。 113、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？ JSP是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是”类servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。 114、jsp 指令中 isELIgnored=”boolean” 的意思是（C）A、决定是否实现 Servler 的单线程模式，B、决定改页面是否是一个错误处理页面，C、决定是否支持 EL表示，D、没有具体的含义 115、下面关于 Java 的引用，说法正确的是（B）A、应用实际上就是指针B、应用本身是 PrimitiveC、引用就是对象本身D、一个对象只能被一个引用所指引 116、用于调用存储过程的对象是（C）A、ResultSetB、DriverManagerC、CallableStatementD、PreparedStatement 117、对于 import java.util 包，以下那种说法是错误的（C）A、Vector 类属于 java.util 包B、Vector 类放在 … ／ java/util/ 目录下C、Vector 类放在 java.util 文件中D、Vector 类是 Sun 公司的产品 118、下面关于垃圾收集的说法正确的是（D）A、一旦一个对象成为垃圾，就立刻被收集掉。B、对象空间被收集掉之后，会执行该对象的 finalize 方法C、finalize 方法和 C++的析构函数是完全一回事情D、一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此。 119、下列标识符（名字）命名原则中，正确的是（D）A、类名的首字母小写B、变量和方法名的首写字母大写C、接口名的首写字母小写D、常量完全大写 120、类 Test1定义如下：1． public class Test1{2． public float aMethod （ float a， float b ） { return 0;}3．4． }将以下哪种方法插入行 3 是不合法的。（B）A、public float aMethod （ float a， float b ， float c） { return 0;}B、public float aMethod （ float c ， float d ） { return 0;}C、public intaMethod （ int a， int b） { return 0;}D、private float aMethod （ int a， int b ， int c） { return 0;}]]></content>
      <tags>
        <tag>Java基础题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium的使用]]></title>
    <url>%2F2018%2F04%2F12%2FSelenium%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;Selenium是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面的源代码，做到可见即可爬。对于一些JavaScript动态渲染的页面来说，此种抓取方式非常有效。 基本使用&nbsp;&nbsp;&nbsp;&nbsp;确保已经正确安装好了Chrome浏览器并配置好了ChromeDriver。另外，还需要正确安装好Python的Selenium库。&nbsp;&nbsp;&nbsp;&nbsp;准备工作做好之后，首先来大体看一下Selenium有一些怎样的功能。示例如下:12345678910111213141516171819from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWait browser = webdriver.Chrome()try: browser.get('https://www.baidu.com') input = browser.find_element_by_id('kw') input.send_keys('Python') input.send_keys(Keys.ENTER) wait = WebDriverWait(browser, 10) wait.until(EC.presence_of_element_located((By.ID, 'content_left'))) print(browser.current_url) print(browser.get_cookies()) print(browser.page_source)finally: browser.close() &nbsp;&nbsp;&nbsp;&nbsp;运行代码后发现，会自动弹出一个Chrome浏览器。浏览器首先会跳转到百度，然后在搜索框中输入Python，接着跳转到搜索结果页，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;搜索结果加载出来后，控制台分别会输出当前的URL、当前的Cookies和网页源代码:123https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=Python&amp;rsv_pq=c94d0df9000a72d0&amp;rsv_t=07099xvun1ZmC0bf6eQvygJ43IUTTUOl5FCJVPgwG2YREs70GplJjH2F%2BCQ&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=6&amp;rsv_sug2=0&amp;inputT=87&amp;rsv_sug4=87[&#123;'secure': False, 'value': 'B490B5EBF6F3CD402E515D22BCDA1598', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'BDORZ', 'expiry': 1491688071.707553&#125;, &#123;'secure': False, 'value': '22473_1441_21084_17001', 'domain': '.baidu.com', 'path': '/', 'httpOnly': False, 'name': 'H_PS_PSSID'&#125;, &#123;'secure': False, 'value': '12883875381399993259_00_0_I_R_2_0303_C02F_N_I_I_0', 'domain': '.www.baidu.com', 'path': '/', 'httpOnly': False, 'name': '__bsi', 'expiry': 1491601676.69722&#125;]&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;...&lt;/html&gt; &nbsp;&nbsp;&nbsp;&nbsp;源代码过长，在此省略。可以看到，我们得到的当前URL、Cookies和源代码都是浏览器中的真实内容。&nbsp;&nbsp;&nbsp;&nbsp;所以说，如果用Selenium来驱动浏览器加载网页的话，就可以直接拿到JavaScript渲染的结果了，不用担心使用的是什么加密系统。 声明浏览器对象&nbsp;&nbsp;&nbsp;&nbsp;Selenium支持非常多的浏览器，如Chrome、Firefox、Edge等，还有Android、BlackBerry等手机端的浏览器。另外，也支持无界面浏览器PhantomJS。&nbsp;&nbsp;&nbsp;&nbsp;此外，我们可以用如下方式初始化:1234567from selenium import webdriver browser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari() &nbsp;&nbsp;&nbsp;&nbsp;这样就完成了浏览器对象的初始化并将其赋值为browser对象。接下来，我们要做的就是调用`browser对象，让其执行各个动作以模拟浏览器操作。 访问页面&nbsp;&nbsp;&nbsp;&nbsp;我们可以用get()方法来请求网页，参数传入链接URL即可。比如，这里用get()方法访问淘宝，然后打印出源代码，代码如下:123456from selenium import webdriver browser = webdriver.Chrome()browser.get('https://www.taobao.com')print(browser.page_source)browser.close() &nbsp;&nbsp;&nbsp;&nbsp;运行后发现，弹出了Chrome浏览器并且自动访问了淘宝，然后控制台输出了淘宝页面的源代码，随后浏览器关闭。&nbsp;&nbsp;&nbsp;&nbsp;通过这几行简单的代码，我们可以实现浏览器的驱动并获取网页源码，非常便捷。 查找节点&nbsp;&nbsp;&nbsp;&nbsp;Selenium可以驱动浏览器完成各种操作，比如填充表单、模拟点击等。比如，我们想要完成向某个输入框输入文字的操作，总需要知道这个输入框在哪里吧？而Selenium提供了一系列查找节点的方法，我们可以用这些方法来获取想要的节点，以便下一步执行一些动作或者提取信息。 单个节点&nbsp;&nbsp;&nbsp;&nbsp;比如，想要从淘宝页面中提取搜索框这个节点，首先要观察它的源代码，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;可以发现，它的id是q，name也是q。此外，还有许多其他属性，此时我们就可以用多种方式获取它了。比如，find_element_by_name()是根据name值获取，find_element_by_id()是根据id获取。另外，还有根据XPath、CSS选择器等获取的方式。&nbsp;&nbsp;&nbsp;&nbsp;我们用代码实现以下:123456789from selenium import webdriver browser = webdriver.Chrome()browser.get('https://www.taobao.com')input_first = browser.find_element_by_id('q')input_second = browser.find_element_by_css_selector('#q')input_third = browser.find_element_by_xpath('//*[@id="q"]')print(input_first, input_second, input_third)browser.close() &nbsp;&nbsp;&nbsp;&nbsp;这里我们使用3种方式获取输入框，分别是根据ID、CSS选择器和XPath获取，它们返回的结果完全一致。运行结果如下:123&lt;selenium.webdriver.remote.webelement.WebElement (session="5e53d9e1c8646e44c14c1c2880d424af", element="0.5649563096161541-1")&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session="5e53d9e1c8646e44c14c1c2880d424af", element="0.5649563096161541-1")&gt; &lt;selenium.webdriver.remote.webelement.WebElement (session="5e53d9e1c8646e44c14c1c2880d424af", element="0.5649563096161541-1")&gt; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，这3个节点都是WebElement类型，是完全一致的。&nbsp;&nbsp;&nbsp;&nbsp;这里列出所有获取单个节点的方法:12345678find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector &nbsp;&nbsp;&nbsp;&nbsp;另外，Selenium还提供了通用方法find_element()，它需要传入两个参数：查找方式By和值。实际上，它就是find_element_by_id()这种方法的通用函数版本，比如find_element_by_id(id)就等价于find_element(By.ID, id)，二者得到的结果完全一致。我们用代码实现一下:12345678from selenium import webdriverfrom selenium.webdriver.common.by import By browser = webdriver.Chrome()browser.get('https://www.taobao.com')input_first = browser.find_element(By.ID, 'q')print(input_first)browser.close() &nbsp;&nbsp;&nbsp;&nbsp;实际上，这种查找方式的功能和上面列举的查找函数完全一致，不过参数更加灵活。 多个节点&nbsp;&nbsp;&nbsp;&nbsp;如果查找的目标在网页中只有一个，那么完全可以用find_element()方法。但如果有多个节点，再用find_element()方法查找，就只能得到第一个节点了。如果要查找所有满足条件的节点，需要用find_elements()这样的方法。注意，在这个方法的名称中，element多了一个s，注意区分。&nbsp;&nbsp;&nbsp;&nbsp;比如，要查找淘宝左侧导航条的所有条目，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;就可以这样来实现:1234567from selenium import webdriver browser = webdriver.Chrome()browser.get('https://www.taobao.com')lis = browser.find_elements_by_css_selector('.service-bd li')print(lis)browser.close() &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1[&lt;selenium.webdriver.remote.webelement.WebElement (session="c26290835d4457ebf7d96bfab3740d19", element="0.09221044033125603-1")&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session="c26290835d4457ebf7d96bfab3740d19", element="0.09221044033125603-2")&gt;, &lt;selenium.webdriver.remote.webelement.WebElement (session="c26290835d4457ebf7d96bfab3740d19", element="0.09221044033125603-3")&gt;...&lt;selenium.webdriver.remote.webelement.WebElement (session="c26290835d4457ebf7d96bfab3740d19", element="0.09221044033125603-16")&gt;] &nbsp;&nbsp;&nbsp;&nbsp;这里简化了输出结果，中间部分省略。&nbsp;&nbsp;&nbsp;&nbsp;可以看到，得到的内容变成了列表类型，列表中的每个节点都是WebElement类型。&nbsp;&nbsp;&nbsp;&nbsp;也就是说，如果我们用find_element()方法，只能获取匹配的第一个节点，结果是WebElement类型。如果用find_elements()方法，则结果是列表类型，列表中的每个节点是WebElement类型。&nbsp;&nbsp;&nbsp;&nbsp;这里列出所有获取多个节点的方法:12345678find_elements_by_idfind_elements_by_namefind_elements_by_xpathfind_elements_by_link_textfind_elements_by_partial_link_textfind_elements_by_tag_namefind_elements_by_class_namefind_elements_by_css_selector &nbsp;&nbsp;&nbsp;&nbsp;当然，我们也可以直接用find_elements()方法来选择，这时可以这样写:1lis = browser.find_elements(By.CSS_SELECTOR, '.service-bd li') &nbsp;&nbsp;&nbsp;&nbsp;结果是完全一致的。 节点交互&nbsp;&nbsp;&nbsp;&nbsp;Selenium可以驱动浏览器来执行一些操作，也就是说可以让浏览器模拟执行一些动作。比较常见的用法有：输入文字时用send_keys()方法，清空文字时用clear()方法，点击按钮时用click()方法。示例如下:123456789101112from selenium import webdriverimport time browser = webdriver.Chrome()browser.get('https://www.taobao.com')input = browser.find_element_by_id('q')input.send_keys('iPhone')time.sleep(1)input.clear()input.send_keys('iPad')button = browser.find_element_by_class_name('btn-search')button.click() &nbsp;&nbsp;&nbsp;&nbsp;这里首先驱动浏览器打开淘宝，然后用find_element_by_id()方法获取输入框，然后用send_keys()方法输入iPhone文字，等待一秒后用clear()方法清空输入框，再次调用send_keys()方法输入iPad文字，之后再用find_element_by_class_name()方法获取搜索按钮，最后调用click()方法完成搜索动作。 动作链&nbsp;&nbsp;&nbsp;&nbsp;在上面的实例中，一些交互动作都是针对某个节点执行的。比如，对于输入框，我们就调用它的输入文字和清空文字方法；对于按钮，就调用它的点击方法。其实，还有另外一些操作，它们没有特定的执行对象，比如鼠标拖曳、键盘按键等，这些动作用另一种方式来执行，那就是动作链。&nbsp;&nbsp;&nbsp;&nbsp;比如，现在实现一个节点的拖曳操作，将某个节点从一处拖曳到另外一处，可以这样实现:123456789101112from selenium import webdriverfrom selenium.webdriver import ActionChains browser = webdriver.Chrome()url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'browser.get(url)browser.switch_to.frame('iframeResult')source = browser.find_element_by_css_selector('#draggable')target = browser.find_element_by_css_selector('#droppable')actions = ActionChains(browser)actions.drag_and_drop(source, target)actions.perform() &nbsp;&nbsp;&nbsp;&nbsp;首先，打开网页中的一个拖曳实例，然后依次选中要拖曳的节点和拖曳到的目标节点，接着声明ActionChains对象并将其赋值为actions变量，然后通过调用actions变量的drag_and_drop()方法，再调用perform()方法执行动作，此时就完成了拖曳操作，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;拖拽后的页面。 执行JavaScript&nbsp;&nbsp;&nbsp;&nbsp;对于某些操作，Selenium API并没有提供。比如，下拉进度条，它可以直接模拟运行JavaScript，此时使用execute_script()方法即可实现，代码如下:123456from selenium import webdriver browser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')browser.execute_script('alert("To Bottom")') &nbsp;&nbsp;&nbsp;&nbsp;这里就利用execute_script()方法将进度条下拉到最底部，然后弹出alert提示框。&nbsp;&nbsp;&nbsp;&nbsp;所以说有了这个方法，基本上API没有提供的所有功能都可以用执行JavaScript的方式来实现了。 获取节点信息&nbsp;&nbsp;&nbsp;&nbsp;前面说过，通过page_source属性可以获取网页的源代码，接着就可以使用解析库（如正则表达式、Beautiful Soup、pyquery等）来提取信息了。&nbsp;&nbsp;&nbsp;&nbsp;不过，既然Selenium已经提供了选择节点的方法，返回的是WebElement类型，那么它也有相关的方法和属性来直接提取节点信息，如属性、文本等。这样的话，我们就可以不用通过解析源代码来提取信息了，非常方便。 获取属性&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用get_attribute()方法来获取节点的属性，但是其前提是先选中这个节点，示例如下:123456789from selenium import webdriverfrom selenium.webdriver import ActionChains browser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)logo = browser.find_element_by_id('zh-top-link-logo')print(logo)print(logo.get_attribute('class')) &nbsp;&nbsp;&nbsp;&nbsp;运行之后，程序便会驱动浏览器打开知乎页面，然后获取知乎的logo节点，最后打印出它的class。&nbsp;&nbsp;&nbsp;&nbsp;控制台的输出结果如下:12&lt;selenium.webdriver.remote.webelement.WebElement (session="e08c0f28d7f44d75ccd50df6bb676104", element="0.7236390660048155-1")&gt;zu-top-link-logo &nbsp;&nbsp;&nbsp;&nbsp;通过get_attribute()方法，然后传入想要获取的属性名，就可以得到它的值了。 获取文本值&nbsp;&nbsp;&nbsp;&nbsp;每个WebElement节点都有text属性，直接调用这个属性就可以得到节点内部的文本信息，这相当于Beautiful Soup的get_text()方法、pyquery的text()方法，示例如下:1234567from selenium import webdriver browser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input.text) &nbsp;&nbsp;&nbsp;&nbsp;这里依然先打开知乎页面，然后获取“提问”按钮这个节点，再将其文本值打印出来。&nbsp;&nbsp;&nbsp;&nbsp;控制台的输出结果如下:1提问 获取id、位置、标签名和大小&nbsp;&nbsp;&nbsp;&nbsp;另外，WebElement节点还有一些其他属性，比如id属性可以获取节点id，location属性可以获取该节点在页面中的相对位置，tag_name属性可以获取标签名称，size属性可以获取节点的大小，也就是宽高，这些属性有时候还是很有用的。示例如下:12345678910from selenium import webdriver browser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input.id)print(input.location)print(input.tag_name)print(input.size) &nbsp;&nbsp;&nbsp;&nbsp;这里首先获得“提问”按钮这个节点，然后调用其id、location、tag_name、size属性来获取对应的属性值。 切换Frame&nbsp;&nbsp;&nbsp;&nbsp;我们知道网页中有一种节点叫作iframe，也就是子Frame，相当于页面的子页面，它的结构和外部网页的结构完全一致。Selenium打开页面后，它默认是在父级Frame里面操作，而此时如果页面中还有子Frame，它是不能获取到子Frame里面的节点的。这时就需要使用switch_to.frame()方法来切换Frame。示例如下:12345678910111213141516import timefrom selenium import webdriverfrom selenium.common.exceptions import NoSuchElementException browser = webdriver.Chrome()url = 'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'browser.get(url)browser.switch_to.frame('iframeResult')try: logo = browser.find_element_by_class_name('logo')except NoSuchElementException: print('NO LOGO')browser.switch_to.parent_frame()logo = browser.find_element_by_class_name('logo')print(logo)print(logo.text) &nbsp;&nbsp;&nbsp;&nbsp;控制台的输出如下:123NO LOGO&lt;selenium.webdriver.remote.webelement.WebElement (session="4bb8ac03ced4ecbdefef03ffdc0e4ccd", element="0.13792611320464965-2")&gt;RUNOOB.COM &nbsp;&nbsp;&nbsp;&nbsp;这里还是以前面演示动作链操作的网页为实例，首先通过switch_to.frame()方法切换到子Frame里面，然后尝试获取父级Frame里的logo节点（这是不能找到的），如果找不到的话，就会抛出NoSuchElementException异常，异常被捕捉之后，就会输出NO LOGO。接下来，重新切换回父级Frame，然后再次重新获取节点，发现此时可以成功获取了。&nbsp;&nbsp;&nbsp;&nbsp;所以，当页面中包含子Frame时，如果想获取子Frame中的节点，需要先调用switch_to.frame()方法切换到对应的Frame，然后再进行操作。 延时等待&nbsp;&nbsp;&nbsp;&nbsp;在Selenium中，get()方法会在网页框架加载结束后结束执行，此时如果获取page_source，可能并不是浏览器完全加载完成的页面，如果某些页面有额外的Ajax请求，我们在网页源代码中也不一定能成功获取到。所以，这里需要延时等待一定时间，确保节点已经加载出来。&nbsp;&nbsp;&nbsp;&nbsp;这里等待的方式有两种：一种是隐式等待，一种是显式等待。 隐式等待&nbsp;&nbsp;&nbsp;&nbsp;当使用隐式等待执行测试的时候，如果Selenium没有在DOM中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常。换句话说，当查找节点而节点并没有立即出现的时候，隐式等待将等待一段时间再查找DOM，默认的时间是0。示例如下:1234567from selenium import webdriver browser = webdriver.Chrome()browser.implicitly_wait(10)browser.get('https://www.zhihu.com/explore')input = browser.find_element_by_class_name('zu-top-add-question')print(input) &nbsp;&nbsp;&nbsp;&nbsp;这里我们用implicitly_wait()方法实现了隐式等待。 显式等待&nbsp;&nbsp;&nbsp;&nbsp;隐式等待的效果其实并没有那么好，因为我们只规定了一个固定时间，而页面的加载时间会受到网络条件的影响。&nbsp;&nbsp;&nbsp;&nbsp;这里还有一种更合适的显式等待方法，它指定要查找的节点，然后指定一个最长等待时间。如果在规定时间内加载出来了这个节点，就返回查找的节点；如果到了规定时间依然没有加载出该节点，则抛出超时异常。示例如下:1234567891011from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC browser = webdriver.Chrome()browser.get('https://www.taobao.com/')wait = WebDriverWait(browser, 10)input = wait.until(EC.presence_of_element_located((By.ID, 'q')))button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, '.btn-search')))print(input, button) &nbsp;&nbsp;&nbsp;&nbsp;这里首先引入WebDriverWait这个对象，指定最长等待时间，然后调用它的until()方法，传入要等待条件expected_conditions。比如，这里传入了presence_of_element_located这个条件，代表节点出现的意思，其参数是节点的定位元组，也就是ID为q的节点搜索框。&nbsp;&nbsp;&nbsp;&nbsp;这样可以做到的效果就是，在10秒内如果ID为q的节点（即搜索框）成功加载出来，就返回该节点；如果超过10秒还没有加载出来，就抛出异常。&nbsp;&nbsp;&nbsp;&nbsp;对于按钮，可以更改一下等待条件，比如改为element_to_be_clickable，也就是可点击，所以查找按钮时查找CSS选择器为.btn-search的按钮，如果10秒内它是可点击的，也就是成功加载出来了，就返回这个按钮节点；如果超过10秒还不可点击，也就是没有加载出来，就抛出异常。&nbsp;&nbsp;&nbsp;&nbsp;运行代码，在网速较佳的情况下是可以成功加载出来的。&nbsp;&nbsp;&nbsp;&nbsp;控制台的输出如下:12&lt;selenium.webdriver.remote.webelement.WebElement (session="07dd2fbc2d5b1ce40e82b9754aba8fa8", element="0.5642646294074107-1")&gt;&lt;selenium.webdriver.remote.webelement.WebElement (session="07dd2fbc2d5b1ce40e82b9754aba8fa8", element="0.5642646294074107-2")&gt; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，控制台成功输出了两个节点，它们都是WebElement类型。&nbsp;&nbsp;&nbsp;&nbsp;如果网络有问题，10秒内没有成功加载，那就抛出TimeoutException异常，此时控制台的输出如下:12345TimeoutException Traceback (most recent call last)&lt;ipython-input-4-f3d73973b223&gt; in &lt;module&gt;() 7 browser.get('https://www.taobao.com/') 8 wait = WebDriverWait(browser, 10)----&gt; 9 input = wait.until(EC.presence_of_element_located((By.ID, 'q'))) 前进和后退&nbsp;&nbsp;&nbsp;&nbsp;平常使用浏览器时都有前进和后退功能，Selenium也可以完成这个操作，它使用back()方法后退，使用forward()方法前进。示例如下:1234567891011import timefrom selenium import webdriver browser = webdriver.Chrome()browser.get('https://www.baidu.com/')browser.get('https://www.taobao.com/')browser.get('https://www.python.org/')browser.back()time.sleep(1)browser.forward()browser.close() &nbsp;&nbsp;&nbsp;&nbsp;这里我们连续访问3个页面，然后调用back()方法回到第二个页面，接下来再调用forward()方法又可以前进到第三个页面。 Cookies&nbsp;&nbsp;&nbsp;&nbsp;使用Selenium，还可以方便地对Cookies进行操作，例如获取、添加、删除Cookies等。示例如下:123456789from selenium import webdriver browser = webdriver.Chrome()browser.get('https://www.zhihu.com/explore')print(browser.get_cookies())browser.add_cookie(&#123;'name': 'name', 'domain': 'www.zhihu.com', 'value': 'germey'&#125;)print(browser.get_cookies())browser.delete_all_cookies()print(browser.get_cookies()) &nbsp;&nbsp;&nbsp;&nbsp;首先，我们访问了知乎。加载完成后，浏览器实际上已经生成Cookies了。接着，调用get_cookies()方法获取所有的Cookies。然后，我们添加一个Cookie，这里传入一个字典，有name、domain和value等内容。接下来，再次获取所有的Cookies。可以发现，结果就多了这一项新加的Cookie。最后，调用delete_all_cookies()方法删除所有的Cookies。再重新获取，发现结果就为空了。&nbsp;&nbsp;&nbsp;&nbsp;控制台的输出如下:123[&#123;'secure': False, 'value': '"NGM0ZTM5NDAwMWEyNDQwNDk5ODlkZWY3OTkxY2I0NDY=|1491604091|236e34290a6f407bfbb517888849ea509ac366d0"', 'domain': '.zhihu.com', 'path': '/', 'httpOnly': False, 'name': 'l_cap_id', 'expiry': 1494196091.403418&#125;][&#123;'secure': False, 'value': 'germey', 'domain': '.www.zhihu.com', 'path': '/', 'httpOnly': False, 'name': 'name'&#125;, &#123;'secure': False, 'value': '"NGM0ZTM5NDAwMWEyNDQwNDk5ODlkZWY3OTkxY2I0NDY=|1491604091|236e34290a6f407bfbb517888849ea509ac366d0"', 'domain': '.zhihu.com', 'path': '/', 'httpOnly': False, 'name': 'l_cap_id', 'expiry': 1494196091.403418&#125;][] 选项卡管理&nbsp;&nbsp;&nbsp;&nbsp;在访问网页的时候，会开启一个个选项卡。在Selenium中，我们也可以对选项卡进行操作。示例如下:123456789101112import timefrom selenium import webdriver browser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.execute_script('window.open()')print(browser.window_handles)browser.switch_to_window(browser.window_handles[1])browser.get('https://www.taobao.com')time.sleep(1)browser.switch_to_window(browser.window_handles[0])browser.get('https://python.org') &nbsp;&nbsp;&nbsp;&nbsp;控制台的输出如下:1['CDwindow-4f58e3a7-7167-4587-bedf-9cd8c867f435', 'CDwindow-6e05f076-6d77-453a-a36c-32baacc447df'] &nbsp;&nbsp;&nbsp;&nbsp;首先访问了百度，然后调用了execute_script()方法，这里传入window.open()这个JavaScript语句新开启一个选项卡。接下来，我们想切换到该选项卡。这里调用window_handles属性获取当前开启的所有选项卡，返回的是选项卡的代号列表。要想切换选项卡，只需要调用switch_to_window()方法即可，其中参数是选项卡的代号。这里我们将第二个选项卡代号传入，即跳转到第二个选项卡，接下来在第二个选项卡下打开一个新页面，然后切换回第一个选项卡重新调用switch_to_window()方法，再执行其他操作即可。 异常处理&nbsp;&nbsp;&nbsp;&nbsp;在使用Selenium的过程中，难免会遇到一些异常，例如超时、节点未找到等错误，一旦出现此类错误，程序便不会继续运行了。这里我们可以使用try except语句来捕获各种异常。&nbsp;&nbsp;&nbsp;&nbsp;首先，演示一下节点未找到的异常，示例如下:12345from selenium import webdriver browser = webdriver.Chrome()browser.get('https://www.baidu.com')browser.find_element_by_id('hello') &nbsp;&nbsp;&nbsp;&nbsp;这里首先打开百度页面，然后尝试选择一个并不存在的节点，此时就会遇到异常。&nbsp;&nbsp;&nbsp;&nbsp;运行之后控制台的输出如下:12345NoSuchElementException Traceback (most recent call last)&lt;ipython-input-23-978945848a1b&gt; in &lt;module&gt;() 3 browser = webdriver.Chrome() 4 browser.get('https://www.baidu.com')----&gt; 5 browser.find_element_by_id('hello') &nbsp;&nbsp;&nbsp;&nbsp;可以看到，这里抛出了NoSuchElementException异常，这通常是节点未找到的异常。为了防止程序遇到异常而中断，我们需要捕获这些异常，示例如下:1234567891011121314from selenium import webdriverfrom selenium.common.exceptions import TimeoutException, NoSuchElementException browser = webdriver.Chrome()try: browser.get('https://www.baidu.com')except TimeoutException: print('Time Out')try: browser.find_element_by_id('hello')except NoSuchElementException: print('No Element')finally: browser.close() &nbsp;&nbsp;&nbsp;&nbsp;这里我们使用try except来捕获各类异常。比如，我们对find_element_by_id()查找节点的方法捕获NoSuchElementException异常，这样一旦出现这样的错误，就进行异常处理，程序也不会中断了。&nbsp;&nbsp;&nbsp;&nbsp;控制台的输出如下:1No Element]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Ajax爬取头条街拍美图]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%88%86%E6%9E%90Ajax%E7%88%AC%E5%8F%96%E5%A4%B4%E6%9D%A1%E8%A1%97%E6%8B%8D%E7%BE%8E%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[抓取分析&nbsp;&nbsp;&nbsp;&nbsp;在抓取之前，首先要分析抓取的逻辑。打开今日头条的首页。&nbsp;&nbsp;&nbsp;&nbsp;在右上角的搜索入口处输入”街拍”二字搜索一下。&nbsp;&nbsp;&nbsp;&nbsp;这时打开开发者工具，查看所有的网络请求。首先，打开第一个网络请求，这个请求的URL就是当前的街拍链接。打开Preview选项卡查看Response Body。如果页面中的内容是根据第一个请求得到的结果渲染出来的，那么第一个请求的源代码中必然会包含页面结果中的文字。为了验证，我们可以尝试搜索一下搜索结果的标题，比如”路人”二字，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;我们发现，网页源代码中并没有包含这两个字，搜索匹配结果数目为0。因此，可以初步判断这些内容是由Ajax加载，然后用Javascript渲染出来的。接下来，我们可以切换到XHR过滤选项卡，查看一下有没有Ajax请求。&nbsp;&nbsp;&nbsp;&nbsp;不出所料，此处出现了一个比较常规的Ajax请求，看看它的结果是否包含了页面中的相关数据。&nbsp;&nbsp;&nbsp;&nbsp;点击data字段展开，发现这里有许多条数据。点击第一条展开，可以发现有一个title字段，它的值正好就是页面中第一条数据的标题。再检查一下其他数据，也正好是一一对应的，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;这就确定了这些数据确实是由Ajax加载的。&nbsp;&nbsp;&nbsp;&nbsp;我们的目的是要抓取其中的美图，这里一组图就对应前面data字段中的一条数据。每条数据还有一个image_detail字段，它是列表形式，这其中就包含了组图的所有图片列表，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;因此，我们只需要将列表中的url字段提取出来并下载下来就好了。每一组图都建立一个文件夹，文件夹的名称就为组图的标题。&nbsp;&nbsp;&nbsp;&nbsp;接下来，就可以直接用Python来模拟这个Ajax请求，然后提取出相关美图链接并下载。但是在这之前，我们还需要分析一下URL的规律。&nbsp;&nbsp;&nbsp;&nbsp;切换回Headers选项卡，观察一下它的请求URL和Headers信息，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;可以看到，这是一个GET请求，请求URL的参数有offset、format、keyword、autoload、count和cur_tab。我们需要找出这些参数的规律，因为这样才可以方便地用程序构造出来。&nbsp;&nbsp;&nbsp;&nbsp;接下来，可以滑动页面，多加载一些新结果。在加载的同时可以发现，Network中又出现了许多Ajax请求，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;这里观察一下后续链接的参数，发现变化的参数只有offset，其他参数都没有变化，而且第二次请求的offset值为20，第三次为40，第四次为60，所以可以发现规律，这个offset值就是偏移量，进而可以推断出count参数就是一次性获取的数据条数。因此，我们可以用offset参数来控制数据分页。这样一来，我们就可以通过接口批量获取数据了，然后将数据解析，将图片下载下来即可。 实战演练&nbsp;&nbsp;&nbsp;&nbsp;首先，实现方法get_page()来加载单个Ajax请求的结果。其中唯一变化的参数就是offset，所以我们将它当作参数传递，实现如下:12345678910111213141516171819import requestsfrom urllib.parse import urlencode def get_page(offset): params = &#123; 'offset': offset, 'format': 'json', 'keyword': '街拍', 'autoload': 'true', 'count': '20', 'cur_tab': '1', &#125; url = 'http://www.toutiao.com/search_content/?' + urlencode(params) try: response = requests.get(url) if response.status_code == 200: return response.json() except requests.ConnectionError: return None &nbsp;&nbsp;&nbsp;&nbsp;这里我们用urlencode()方法构造请求的GET参数，然后用requests请求这个链接，如果返回状态码为200，则调用response的json()方法将结果转为JSON格式，然后返回。&nbsp;&nbsp;&nbsp;&nbsp;接下来，再实现一个解析方法：提取每条数据的image_detail字段中的每一张图片链接，将图片链接和图片所属的标题一并返回，此时可以构造一个生成器。实现代码如下:12345678910def get_images(json): if json.get('data'): for item in json.get('data'): title = item.get('title') images = item.get('image_detail') for image in images: yield &#123; 'image': image.get('url'), 'title': title &#125; &nbsp;&nbsp;&nbsp;&nbsp;接下来，实现一个保存图片的方法save_image()，其中item就是前面get_images()方法返回的一个字典。在该方法中，首先根据item的title来创建文件夹，然后请求这个图片链接，获取图片的二进制数据，以二进制的形式写入文件。图片的名称可以使用其内容的MD5值，这样可以去除重复。相关代码如下:1234567891011121314151617import osfrom hashlib import md5 def save_image(item): if not os.path.exists(item.get('title')): os.mkdir(item.get('title')) try: response = requests.get(item.get('image')) if response.status_code == 200: file_path = '&#123;0&#125;/&#123;1&#125;.&#123;2&#125;'.format(item.get('title'), md5(response.content).hexdigest(), 'jpg') if not os.path.exists(file_path): with open(file_path, 'wb') as f: f.write(response.content) else: print('Already Downloaded', file_path) except requests.ConnectionError: print('Failed to Save Image') &nbsp;&nbsp;&nbsp;&nbsp;最后，只需要构造一个offset数组，遍历offset，提取图片链接，并将其下载即可:123456789101112131415161718from multiprocessing.pool import Pool def main(offset): json = get_page(offset) for item in get_images(json): print(item) save_image(item) GROUP_START = 1GROUP_END = 20 if __name__ == '__main__': pool = Pool() groups = ([x * 20 for x in range(GROUP_START, GROUP_END + 1)]) pool.map(main, groups) pool.close() pool.join() &nbsp;&nbsp;&nbsp;&nbsp;这里定义了分页的起始页数和终止页数，分别为GROUP_START和GROUP_END，还利用了多线程的线程池，调用其map()方法实现多线程下载。&nbsp;&nbsp;&nbsp;&nbsp;这样整个程序就完成了，运行之后可以发现街拍美图都分文件夹保存下来了，如图所示。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储]]></title>
    <url>%2F2018%2F04%2F11%2FMySQL%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在Python 2中，连接MySQL的库大多是使用MySQLdb，但是此库的官方并不支持Python 3，所以这里使用的库是PyMySQL。 安装方法1pip install PyMySQL 连接数据库&nbsp;&nbsp;&nbsp;&nbsp;首先尝试连接一下数据库。假设当前的MySQL运行在本地，用户名为root，密码为123123，运行端口为3306。这里利用PyMySQL先连接MySQL，然后创建一个新的数据库，名字叫作spiders，代码如下:123456789import pymysql db = pymysql.connect(host='localhost',user='root', password='123123', port=3306)cursor = db.cursor()cursor.execute('SELECT VERSION()')data = cursor.fetchone()print('Database version:', data)cursor.execute("CREATE DATABASE spiders DEFAULT CHARACTER SET utf8")db.close() &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1Database version: ('5.5.53',) &nbsp;&nbsp;&nbsp;&nbsp;这里通过PyMySQL的connect()方法声明一个MySQL连接对象db，此时需要传入MySQL运行的host（即IP）。由于MySQL在本地运行，所以传入的是localhost。如果MySQL在远程运行，则传入其公网IP地址。后续的参数user即用户名，password即密码，port即端口（默认为3306）。&nbsp;&nbsp;&nbsp;&nbsp;连接成功后，需要再调用cursor()方法获得MySQL的操作游标，利用游标来执行SQL语句。这里我们执行了两句SQL，直接用execute()方法执行即可。第一句SQL用于获得MySQL的当前版本，然后调用fetchone()方法获得第一条数据，也就得到了版本号。第二句SQL执行创建数据库的操作，数据库名叫作spiders，默认编码为UTF-8。由于该语句不是查询语句，所以直接执行后就成功创建了数据库spiders。接着，再利用这个数据库进行后续的操作。 创建表&nbsp;&nbsp;&nbsp;&nbsp;一般来说，创建数据库的操作只需要执行一次就好了。当然，我们也可以手动创建数据库。以后，我们的操作都在spiders数据库上执行。&nbsp;&nbsp;&nbsp;&nbsp;创建数据库后，在连接时需要额外指定一个参数db。&nbsp;&nbsp;&nbsp;&nbsp;接下来，新创建一个数据表students，此时执行创建表的SQL语句即可。这里指定3个字段，结构如表所示。 字段名 含义 类型 id 学号 varchar name 姓名 varchar age 年龄 int &nbsp;&nbsp;&nbsp;&nbsp;创建该表的示例代码如下:1234567import pymysql db = pymysql.connect(host='localhost', user='root', password='123123', port=3306, db='spiders')cursor = db.cursor()sql = 'CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY (id))'cursor.execute(sql)db.close() &nbsp;&nbsp;&nbsp;&nbsp;运行之后，我们便创建了一个名为students的数据表。 插入数据&nbsp;&nbsp;&nbsp;&nbsp;下一步就是向数据库中插入数据了。例如，这里爬取了一个学生信息，学号为20120001，名字为Bob，年龄为20，那么如何将该条数据插入数据库呢？示例代码如下:123456789101112131415import pymysql id = '20120001'user = 'Bob'age = 20 db = pymysql.connect(host='localhost', user='root', password='123123', port=3306, db='spiders')cursor = db.cursor()sql = 'INSERT INTO students(id, name, age) values(%s, %s, %s)'try: cursor.execute(sql, (id, user, age)) db.commit()except: db.rollback()db.close() &nbsp;&nbsp;&nbsp;&nbsp;这里首先构造了一个SQL语句，其Value值没有用字符串拼接的方式来构造，如:1sql = 'INSERT INTO students(id, name, age) values(' + id + ', ' + name + ', ' + age + ')' &nbsp;&nbsp;&nbsp;&nbsp;这样的写法烦琐而且不直观，所以我们选择直接用格式化符%s来实现。有几个Value写几个%s，我们只需要在execute()方法的第一个参数传入该SQL语句，Value值用统一的元组传过来就好了。这样的写法既可以避免字符串拼接的麻烦，又可以避免引号冲突的问题。&nbsp;&nbsp;&nbsp;&nbsp;之后值得注意的是，需要执行db对象的commit()方法才可实现数据插入，这个方法才是真正将语句提交到数据库执行的方法。对于数据插入、更新、删除操作，都需要调用该方法才能生效。&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们加了一层异常处理。如果执行失败，则调用rollback()执行数据回滚，相当于什么都没有发生过。&nbsp;&nbsp;&nbsp;&nbsp;这里涉及事务的问题。事务机制可以确保数据的一致性，也就是这件事要么发生了，要么没有发生。比如插入一条数据，不会存在插入一半的情况，要么全部插入，要么都不插入，这就是事务的原子性。另外，事务还有3个属性——一致性、隔离性和持久性。这4个属性通常称为ACID特性，具体如表所示。事务详情可看此博文 属性 解释 原子性(atomicity) 事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做 一致性（consistency） 事务必须使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的 隔离性（isolation） 一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰 持久性（durability） 持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响 &nbsp;&nbsp;&nbsp;&nbsp;插入、更新和删除操作都是对数据库进行更改的操作，而更改操作都必须为一个事务，所以这些操作的标准写法就是:12345try: cursor.execute(sql) db.commit()except: db.rollback() &nbsp;&nbsp;&nbsp;&nbsp;这样便可以保证数据的一致性。这里的commit()和rollback()方法就为事务的实现提供了支持。&nbsp;&nbsp;&nbsp;&nbsp;上面数据插入的操作是通过构造SQL语句实现的，但是很明显，这有一个极其不方便的地方，比如突然增加了性别字段gender，此时SQL语句就需要改成:1INSERT INTO students(id, name, age, gender) values(%s, %s, %s, %s) &nbsp;&nbsp;&nbsp;&nbsp;相应的元组参数则需要改成:1(id, name, age, gender) &nbsp;&nbsp;&nbsp;&nbsp;这显然不是我们想要的。在很多情况下，我们要达到的效果是插入方法无需改动，做成一个通用方法，只需要传入一个动态变化的字典就好了。比如，构造这样一个字典:12345&#123; 'id': '20120001', 'name': 'Bob', 'age': 20&#125; &nbsp;&nbsp;&nbsp;&nbsp;然后SQL语句会根据字典动态构造，元组也动态构造，这样才能实现通用的插入方法。所以，这里我们需要改写一下插入方法:1234567891011121314151617data = &#123; 'id': '20120001', 'name': 'Bob', 'age': 20&#125;table = 'students'keys = ', '.join(data.keys())values = ', '.join(['%s'] * len(data))sql = 'INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES (&#123;values&#125;)'.format(table=table, keys=keys, values=values)try: if cursor.execute(sql, tuple(data.values())): print('Successful') db.commit()except: print('Failed') db.rollback()db.close() &nbsp;&nbsp;&nbsp;&nbsp;这里我们传入的数据是字典，并将其定义为data变量。表名也定义成变量table。接下来，就需要构造一个动态的SQL语句了。&nbsp;&nbsp;&nbsp;&nbsp;首先，需要构造插入的字段id、name和age。这里只需要将data的键名拿过来，然后用逗号分隔即可。所以&#39;, &#39;.join(data.keys())的结果就是id, name, age，然后需要构造多个%s当作占位符，有几个字段构造几个即可。比如，这里有三个字段，就需要构造%s, %s, %s。这里首先定义了长度为1的数组[&#39;%s&#39;]，然后用乘法将其扩充为[&#39;%s&#39;, &#39;%s&#39;, &#39;%s&#39;]，再调用join()方法，最终变成%s, %s, %s。最后，我们再利用字符串的format()方法将表名、字段名和占位符构造出来。最终的SQL语句就被动态构造成了:1INSERT INTO students(id, name, age) VALUES (%s, %s, %s) &nbsp;&nbsp;&nbsp;&nbsp;最后，为execute()方法的第一个参数传入sql变量，第二个参数传入data的键值构造的元组，就可以成功插入数据了。&nbsp;&nbsp;&nbsp;&nbsp;如此以来，我们便实现了传入一个字典来插入数据的方法，不需要再去修改SQL语句和插入操作了。 更新数据&nbsp;&nbsp;&nbsp;&nbsp;数据更新操作实际上也是执行SQL语句，最简单的方式就是构造一个SQL语句，然后执行:1234567sql = 'UPDATE students SET age = %s WHERE name = %s'try: cursor.execute(sql, (25, 'Bob')) db.commit()except: db.rollback()db.close() &nbsp;&nbsp;&nbsp;&nbsp;这里同样用占位符的方式构造SQL，然后执行execute()方法，传入元组形式的参数，同样执行commit()方法执行操作。如果要做简单的数据更新的话，完全可以使用此方法。&nbsp;&nbsp;&nbsp;&nbsp;但是在实际的数据抓取过程中，大部分情况下需要插入数据，但是我们关心的是会不会出现重复数据，如果出现了，我们希望更新数据而不是重复保存一次。另外，就像前面所说的动态构造SQL的问题，所以这里可以再实现一种去重的方法，如果数据存在，则更新数据；如果数据不存在，则插入数据。另外，这种做法支持灵活的字典传值。示例如下:123456789101112131415161718192021data = &#123; 'id': '20120001', 'name': 'Bob', 'age': 21&#125; table = 'students'keys = ', '.join(data.keys())values = ', '.join(['%s'] * len(data)) sql = 'INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES (&#123;values&#125;) ON DUPLICATE KEY UPDATE'.format(table=table, keys=keys, values=values)update = ','.join([" &#123;key&#125; = %s".format(key=key) for key in data])sql += updatetry: if cursor.execute(sql, tuple(data.values())*2): print('Successful') db.commit()except: print('Failed') db.rollback()db.close() &nbsp;&nbsp;&nbsp;&nbsp;这里构造的SQL语句其实是插入语句，但是我们在后面加了ON DUPLICATE KEY UPDATE。这行代码的意思是如果主键已经存在，就执行更新操作。比如，我们传入的数据id仍然为20120001，但是年龄有所变化，由20变成了21，此时这条数据不会被插入，而是直接更新id为20120001的数据。完整的SQL构造出来是这样的:1INSERT INTO students(id, name, age) VALUES (%s, %s, %s) ON DUPLICATE KEY UPDATE id = %s, name = %s, age = %s &nbsp;&nbsp;&nbsp;&nbsp;这里就变成了6个%s。所以在后面的execute()方法的第二个参数元组就需要乘以2变成原来的2倍。&nbsp;&nbsp;&nbsp;&nbsp;如此一来，我们就可以实现主键不存在便插入数据，存在则更新数据的功能了。 删除数据&nbsp;&nbsp;&nbsp;&nbsp;删除操作相对简单，直接使用DELETE语句即可，只是需要指定要删除的目标表名和删除条件，而且仍然需要使用db的commit()方法才能生效。示例如下:1234567891011table = 'students'condition = 'age &gt; 20' sql = 'DELETE FROM &#123;table&#125; WHERE &#123;condition&#125;'.format(table=table, condition=condition)try: cursor.execute(sql) db.commit()except: db.rollback() db.close() &nbsp;&nbsp;&nbsp;&nbsp;因为删除条件有多种多样，运算符有大于、小于、等于、LIKE等，条件连接符有AND、OR等，所以不再继续构造复杂的判断条件。这里直接将条件当作字符串来传递，以实现删除操作。 查询数据&nbsp;&nbsp;&nbsp;&nbsp;说完插入、修改和删除等操作，还剩下非常重要的一个操作，那就是查询。查询会用到SELECT语句，示例如下:1234567891011121314sql = 'SELECT * FROM students WHERE age &gt;= 20' try: cursor.execute(sql) print('Count:', cursor.rowcount) one = cursor.fetchone() print('One:', one) results = cursor.fetchall() print('Results:', results) print('Results Type:', type(results)) for row in results: print(row)except: print('Error') &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234567Count: 4One: ('20120001', 'Bob', 25)Results: (('20120011', 'Mary', 21), ('20120012', 'Mike', 20), ('20120013', 'James', 22))Results Type: &lt;class 'tuple'&gt;('20120011', 'Mary', 21)('20120012', 'Mike', 20)('20120013', 'James', 22) &nbsp;&nbsp;&nbsp;&nbsp;这里我们构造了一条SQL语句，将年龄20岁及以上的学生查询出来，然后将其传给execute()方法。注意，这里不再需要db的commit()方法。接着，调用cursor的rowcount属性获取查询结果的条数，当前示例中是4条。&nbsp;&nbsp;&nbsp;&nbsp;然后我们调用了fetchone()方法，这个方法可以获取结果的第一条数据，返回结果是元组形式，元组的元素顺序跟字段一一对应，即第一个元素就是第一个字段id，第二个元素就是第二个字段name，以此类推。随后，我们又调用了fetchall()方法，它可以得到结果的所有数据。然后将其结果和类型打印出来，它是二重元组，每个元素都是一条记录，我们将其遍历输出出来。&nbsp;&nbsp;&nbsp;&nbsp;但是这里需要注意一个问题，这里显示的是3条数据而不是4条，fetchall()方法不是获取所有数据吗？这是因为它的内部实现有一个偏移指针用来指向查询结果，最开始偏移指针指向第一条数据，取一次之后，指针偏移到下一条数据，这样再取的话，就会取到下一条数据了。我们最初调用了一次fetchone()方法，这样结果的偏移指针就指向下一条数据，fetchall()方法返回的是偏移指针指向的数据一直到结束的所有数据，所以该方法获取的结果就只剩3个了。&nbsp;&nbsp;&nbsp;&nbsp;此外，我们还可以用while循环加fetchone()方法来获取所有数据，而不是用fetchall()全部一起获取出来。fetchall()会将结果以元组形式全部返回，如果数据量很大，那么占用的开销会非常高。因此，推荐使用如下方法来逐条取数据:12345678910sql = 'SELECT * FROM students WHERE age &gt;= 20'try: cursor.execute(sql) print('Count:', cursor.rowcount) row = cursor.fetchone() while row: print('Row:', row) row = cursor.fetchone()except: print('Error') &nbsp;&nbsp;&nbsp;&nbsp;这样每循环一次，指针就会偏移一条数据，随用随取，简单高效。]]></content>
      <tags>
        <tag>存储</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSV文件存储]]></title>
    <url>%2F2018%2F04%2F11%2FCSV%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;CSV，全称为Comma-Separated Values，中文可以叫作逗号分隔值或字符分隔值，其文件以纯文本形式存储表格数据。该文件是一个字符序列，可以由任意数目的记录组成，记录间以某种换行符分隔。每条记录由字段组成，字段间的分隔符是其他字符或字符串，最常见的是逗号或制表符。不过所有记录都有完全相同的字段序列，相当于一个结构化表的纯文本形式。它比Excel文件更加简介，XLS文本是电子表格，它包含了文本、数值、公式和格式等内容，而CSV中不包含这些内容，就是特定字符分隔的纯文本，结构简单清晰。所以，有时候用CSV来保存数据是比较方便的。 写入&nbsp;&nbsp;&nbsp;&nbsp;这里先看一个最简单的例子:12345678import csv with open('data.csv', 'w') as csvfile: writer = csv.writer(csvfile) writer.writerow(['id', 'name', 'age']) writer.writerow(['10001', 'Mike', 20]) writer.writerow(['10002', 'Bob', 22]) writer.writerow(['10003', 'Jordan', 21]) &nbsp;&nbsp;&nbsp;&nbsp;首先，打开data.csv文件，然后指定打开的模式为w（即写入），获得文件句柄，随后调用csv库的writer()方法初始化写入对象，传入该句柄，然后调用writerow()方法传入每行的数据即可完成写入。&nbsp;&nbsp;&nbsp;&nbsp;运行结束后，会生成一个名为data.csv的文件，此时数据就成功写入了。直接以文本形式打开的话，其内容如下:1234id,name,age10001,Mike,2010002,Bob,2210003,Jordan,21 &nbsp;&nbsp;&nbsp;&nbsp;可以看到，写入的文本默认以逗号分隔，调用一次writerow()方法即可写入一行数据。用Excel打开的结果如图所示:&nbsp;&nbsp;&nbsp;&nbsp;如果想修改列与列之间的分隔符，可以传入delimiter参数，其代码如下:12345678import csv with open('data.csv', 'w') as csvfile: writer = csv.writer(csvfile, delimiter=' ') writer.writerow(['id', 'name', 'age']) writer.writerow(['10001', 'Mike', 20]) writer.writerow(['10002', 'Bob', 22]) writer.writerow(['10003', 'Jordan', 21]) &nbsp;&nbsp;&nbsp;&nbsp;另外，我们也可以调用writerows()方法同时写入多行，此时参数就需要为二维列表，例如:123456import csv with open('data.csv', 'w') as csvfile: writer = csv.writer(csvfile) writer.writerow(['id', 'name', 'age']) writer.writerows([['10001', 'Mike', 20], ['10002', 'Bob', 22], ['10003', 'Jordan', 21]]) &nbsp;&nbsp;&nbsp;&nbsp;输出效果是相同的，内容如下:1234id,name,age10001,Mike,2010002,Bob,2210003,Jordan,21 &nbsp;&nbsp;&nbsp;&nbsp;但是一般情况下，爬虫爬取的都是结构化数据，我们一般会用字典来表示。在csv库中也提供了字典的写入方式，示例如下:123456789import csv with open('data.csv', 'w') as csvfile: fieldnames = ['id', 'name', 'age'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() writer.writerow(&#123;'id': '10001', 'name': 'Mike', 'age': 20&#125;) writer.writerow(&#123;'id': '10002', 'name': 'Bob', 'age': 22&#125;) writer.writerow(&#123;'id': '10003', 'name': 'Jordan', 'age': 21&#125;) &nbsp;&nbsp;&nbsp;&nbsp;这里先定义3个字段，用fieldnames表示，然后将其传给DictWriter来初始化一个字典写入对象，接着可以调用writeheader()方法先写入头信息，然后再调用writerow()方法传入相应字典即可。最终写入的结果是完全相同的，内容如下:1234id,name,age10001,Mike,2010002,Bob,2210003,Jordan,21 &nbsp;&nbsp;&nbsp;&nbsp;这样就可以完成字典到CSV文件的写入了。&nbsp;&nbsp;&nbsp;&nbsp;另外，如果想追加写入的话，可以修改文件的打开模式，即将open()函数的第二个参数改成a，代码如下:123456import csv with open('data.csv', 'a') as csvfile: fieldnames = ['id', 'name', 'age'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writerow(&#123;'id': '10004', 'name': 'Durant', 'age': 22&#125;) &nbsp;&nbsp;&nbsp;&nbsp;这样在上面的基础上再执行这段代码，文件内容便会变成:12345id,name,age10001,Mike,2010002,Bob,2210003,Jordan,2110004,Durant,22 &nbsp;&nbsp;&nbsp;&nbsp;可见，数据被追加写入到文件中。&nbsp;&nbsp;&nbsp;&nbsp;如果要写入中文内容的话，可能会遇到字符编码的问题，此时需要用codecs提供的open方法来指定打开的文件的语言编码，它会在读取的时候自动转换为内部unicode。比如，这里再写入一行包含中文的数据，代码需要改写如下:123456import csv, codecswith codecs.open('data.csv', 'a', encoding='gbk') as csvfile: fieldnames = ['id', 'name', 'age'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writerow(&#123;'id': '10005', 'name': '王伟', 'age': 22&#125;) &nbsp;&nbsp;&nbsp;&nbsp;这里需要给open()函数指定编码，否则可能发生编码错误。&nbsp;&nbsp;&nbsp;&nbsp;另外，如果接触过pandas等库的话，可以调用DataFrame对象的to_csv()方法来将数据写入CSV文件中。 读取&nbsp;&nbsp;&nbsp;&nbsp;我们同样可以使用csv库来读取CSV文件。例如，将刚才写入的文件内容读取出来，相关代码如下:123456import csv with open('data.csv', 'r', encoding='gbk') as csvfile: reader = csv.reader(csvfile) for row in reader: print(row) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456['id', 'name', 'age']['10001', 'Mike', '20']['10002', 'Bob', '22']['10003', 'Jordan', '21']['10004', 'Durant', '22']['10005', '王伟', '22'] &nbsp;&nbsp;&nbsp;&nbsp;这里我们构造的是Reader对象，通过遍历输出了每行的内容，每一行都是一个列表形式。注意，如果CSV文件中包含中文的话，还需要指定文件编码。&nbsp;&nbsp;&nbsp;&nbsp;另外，如果接触过pandas的话，可以利用read_csv()方法将数据从CSV中读取出来，例如:1234import pandas as pd df = pd.read_csv('data.csv', encoding='gbk')print(df) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456 id name age0 10001 Mike 201 10002 Bob 222 10003 Jordan 213 10004 Durant 224 10005 王伟 22 &nbsp;&nbsp;&nbsp;&nbsp;在做数据分析的时候，此种方法用得比较多，也是一种比较方便地读取CSV文件的方法。]]></content>
      <tags>
        <tag>python</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON文件存储]]></title>
    <url>%2F2018%2F04%2F11%2FJSON%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;JSON，全称为JavaScript Object Notation，也就是JavaScript对象标记，它通过对象和数组的组合来表示数据，构造简洁但是结构化程度非常高，是一种轻量级的数据交换格式。 对象和数组&nbsp;&nbsp;&nbsp;&nbsp;在JavaScript语言中，一切都是对象。因此，任何支持的类型都可以通过JSON来表示，例如字符串、数字、对象、数组等，但是对象和数组是比较特殊且常用的两种类型。 对象: 它在JavaScript中是使用花括号{}包裹起来的内容，数据结构为{key1：value1, key2：value2, ...}的键值对结构。在面向对象的语言中，key为对象的属性，value为对应的值。键名可以使用整数和字符串来表示。值得类型可以是任意类型。 数组: 数组在JavaScript中是方括号[]包裹起来的内容，数据结构为[&quot;java&quot;, &quot;javascript&quot;, &quot;vb&quot;, ...]的索引结构。在JavaScript中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引用得多。同样，值得类型可以是任意类型。 所以，一个JSON对象可以写为如下形式:123456789[&#123; "name": "Bob", "gender": "male", "birthday": "1992-10-18"&#125;, &#123; "name": "Selina", "gender": "female", "birthday": "1995-10-18"&#125;] &nbsp;&nbsp;&nbsp;&nbsp;由中括号包围的就相当于列表类型，列表中的每个元素可以是任意类型，这个示例中它是字典类型，由大括号包围。&nbsp;&nbsp;&nbsp;&nbsp;JSON可以由以上两种形式自由组合而成，可以无限次嵌套，结构清晰，是数据交换的极佳方式。 读取JSON&nbsp;&nbsp;&nbsp;&nbsp;Python为我们提供了简单易用的库来实现JSON文件的读写操作，我们可以调用库的loads()方法将JSON文本字符串转为JSON对象，可以通过dumps()方法将JSON对象转为文本字符串。&nbsp;&nbsp;&nbsp;&nbsp;例如，这里有一段JSON形式的字符串，它是str类型，我们用Python将其转换为可操作的数据结构，如列表或字典:1234567891011121314151617import json str = '''[&#123; "name": "Bob", "gender": "male", "birthday": "1992-10-18"&#125;, &#123; "name": "Selina", "gender": "female", "birthday": "1995-10-18"&#125;]'''print(type(str))data = json.loads(str)print(data)print(type(data)) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123&lt;class 'str'&gt;[&#123;'name': 'Bob', 'gender': 'male', 'birthday': '1992-10-18'&#125;, &#123;'name': 'Selina', 'gender': 'female', 'birthday': '1995-10-18'&#125;]&lt;class 'list'&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里使用loads()方法将字符串转为JSON对象。由于最外层是中括号，所以最终的类型是列表类型。&nbsp;&nbsp;&nbsp;&nbsp;这样一来，我们就可以用索引来获取对应的内容了。例如，如果想取第一个元素里的name属性，就可以使用如下方式:12data[0]['name']data[0].get('name') &nbsp;&nbsp;&nbsp;&nbsp;得到的结果都是:1Bob &nbsp;&nbsp;&nbsp;&nbsp;通过中括号加0索引，可以得到第一个字典元素，然后再调用其键名即可得到相应的键值。获取键值时有两种方式，一种是中括号加键名，另一种是通过get()方法传入键名。这里推荐使用get()方法，这样如果键名不存在，则不会报错，会返回None。另外，get()方法还可以传入第二个参数（即默认值），示例如下:12data[0].get('age')data[0].get('age', 25) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12None25 &nbsp;&nbsp;&nbsp;&nbsp;这里我们尝试获取年龄age，其实在原字典中该键名不存在，此时默认会返回None。如果传入第二个参数（即默认值），那么在不存在的情况下返回该默认值。&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，JSON的数据需要用双引号来包围，不能使用单引号。例如，若使用如下形式表示，则会出现错误:12345678910import json str = '''[&#123; 'name': 'Bob', 'gender': 'male', 'birthday': '1992-10-18'&#125;]'''data = json.loads(str) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 3 column 5 (char 8) &nbsp;&nbsp;&nbsp;&nbsp;这里会出现JSON解析错误的提示。这是因为这里数据用单引号来包围，请千万注意JSON字符串的表示需要用双引号，否则loads()方法会解析失败。&nbsp;&nbsp;&nbsp;&nbsp;如果从JSON文本中读取内容，例如这里有一个data.json文本文件，其内容是刚才定义的JSON字符串，我们可以先将文本文件内容读出，然后再利用loads()方法转化:123456import json with open('data.json', 'r') as file: str = file.read() data = json.loads(str) print(data) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1[&#123;'name': 'Bob', 'gender': 'male', 'birthday': '1992-10-18'&#125;, &#123;'name': 'Selina', 'gender': 'female', 'birthday': '1995-10-18'&#125;] 输出JSON&nbsp;&nbsp;&nbsp;&nbsp;另外，我们还可以调用dumps()方法将JSON对象转化为字符串。例如，将上例中的列表重新写入文本:123456789import json data = [&#123; 'name': 'Bob', 'gender': 'male', 'birthday': '1992-10-18'&#125;]with open('data.json', 'w') as file: file.write(json.dumps(data)) &nbsp;&nbsp;&nbsp;&nbsp;利用dumps()方法，我们可以将JSON对象转为字符串，然后再调用文件的write()方法写入文本，结果如图所示。&nbsp;&nbsp;&nbsp;&nbsp;另外，如果想保存JSON的格式，可以再加一个参数indent，代表缩进字符个数。示例如下:12with open('data.json', 'w') as file: file.write(json.dumps(data, indent=2)) &nbsp;&nbsp;&nbsp;&nbsp;此时写入结果如图所示。&nbsp;&nbsp;&nbsp;&nbsp;这样得到的内容会自动带缩进，格式会更加清晰。&nbsp;&nbsp;&nbsp;&nbsp;另外，如果JSON中包含中文字符，会怎么样呢？例如，我们将之前的JSON的部分值改为中文，再用之前的方法写入到文本:123456789import json data = [&#123; 'name': '王伟', 'gender': '男', 'birthday': '1992-10-18'&#125;]with open('data.json', 'w') as file: file.write(json.dumps(data, indent=2)) &nbsp;&nbsp;&nbsp;&nbsp;写入结果如图所示:&nbsp;&nbsp;&nbsp;&nbsp;可以看到，中文字符都变成了Unicode字符，这并不是我们想要的结果。&nbsp;&nbsp;&nbsp;&nbsp;为了输出中文，还需要指定参数ensure_ascii为False，另外还要规定文件输出的编码:12with open('data.json', 'w', encoding='utf-8') as file: file.write(json.dumps(data, indent=2, ensure_ascii=False)) &nbsp;&nbsp;&nbsp;&nbsp;写入结果如图所示:&nbsp;&nbsp;&nbsp;&nbsp;可以发现，这样就可以输出JSON为中文了。]]></content>
      <tags>
        <tag>python</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TXT存储]]></title>
    <url>%2F2018%2F04%2F09%2FTXT%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;将数据保存到TXT文本的操作非常简单，而且TXT文本几乎兼容任何平台，但是这有个缺点，那就是不利于检索。所以如果对检索和数据结构要求不高，追求方便第一的话，可以采用TXT文本存储。 基本实例&nbsp;&nbsp;&nbsp;&nbsp;首先，可以用requests将网页源代码获取下来，然后使用PyQuery解析库解析，接下来将提取的标题、回答者、回答保存到文本，代码如下:123456789101112131415161718import requestsfrom pyquery import PyQuery as pq url = 'https://www.zhihu.com/explore'headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'&#125;html = requests.get(url, headers=headers).textdoc = pq(html)items = doc('.explore-tab .feed-item').items()for item in items: question = item.find('h2').text() author = item.find('.author-link-line').text() answer = pq(item.find('.content').html()).text() file = open('explore.txt', 'a', encoding='utf-8') file.write('\n'.join([question, author, answer])) file.write('\n' + '=' * 50 + '\n') file.close() &nbsp;&nbsp;&nbsp;&nbsp;这里主要是为了演示文件保存的方式，因此requests异常处理部分在此省去。首先，用requests提取知乎的“发现”页面，然后将热门话题的问题、回答者、答案全文提取出来，然后利用Python提供的open()方法打开一个文本文件，获取一个文件操作对象，这里赋值为file，接着利用file对象的write()方法将提取的内容写入文件，最后调用close()方法将其关闭，这样抓取的内容即可成功写入文本中了。&nbsp;&nbsp;&nbsp;&nbsp;运行程序，可以发现在本地生成了一个explore.txt文件。&nbsp;&nbsp;&nbsp;&nbsp;这里open()方法的第一个参数即要保存的目标文件名称，第二个参数为a，代表以追加方式写入到文本。另外，我们还指定了文件的编码为utf-8。最后，写入完成后，还需要调用close()方法来关闭文件对象。 打开方式&nbsp;&nbsp;&nbsp;&nbsp;在刚才的实例中，open()方法的第二个参数设置成了a，这样在每次写入文本时不会清空源文件，而是在文件末尾写入新的内容，这是一种文件打开方式。关于文件的打开方式，其实还有其他几种，这里简要介绍一下。 r: 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb: 以二进制只读方式打开一个文件。文件指针将会放在文件的开头。 r+: 以读写方式打开一个文件。文件指针将会放在文件的开头。 rb+: 以二进制读写方式打开一个文件。文件指针将会放在文件的开头。 w: 以写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。 wb: 以二进制写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。 w+: 以读写方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。 以二进制读写格式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。 a: 以追加方式打开一个文件。如果该文件已存在，文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。 ab: 以追加方式打开一个文件。如果该文件已存在，文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。 a+: 以读写方式打开一个文件。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，则创建新文件来读写。 ab+: 以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。如果该文件不存在，则创建新文件用于读写。 简化写法&nbsp;&nbsp;&nbsp;&nbsp;另外，文件写入还有一种简写方法，那就是使用with as语法。在with控制块结束时，文件会自动关闭，所以就不需要再调用close()方法了。这种保存方式可以简写如下:123with open('explore.txt', 'a', encoding='utf-8') as file: file.write('\n'.join([question, author, answer])) file.write('\n' + '=' * 50 + '\n') 如果想保存时将原文清空，那么可以将第二个参数改写为w，代码如下:123with open('explore.txt', 'w', encoding='utf-8') as file: file.write('\n'.join([question, author, answer])) file.write('\n' + '=' * 50 + '\n')]]></content>
      <tags>
        <tag>python</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用pyquery]]></title>
    <url>%2F2018%2F04%2F09%2F%E4%BD%BF%E7%94%A8pyquery%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;PyQuery库也是一个非常强大又灵活的网页解析库，PyQuery 是 Python 仿照 jQuery 的严格实现。pyquery相当于jQuery的python实现，可以用于解析HTML网页等。语法与jQuery几乎完全相同。 初始化&nbsp;&nbsp;&nbsp;&nbsp;像Beautiful Soup一样，初始化pyquery的时候，也需要传入HTML文本来初始化一个PyQuery对象。它的初始化方式有多种，比如直接传入字符串，传入URL，传入文件名，等等。 字符串初始化&nbsp;&nbsp;&nbsp;&nbsp;首先，我们用一个实例来感受下:1234567891011121314html = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)print(doc('li')) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12345&lt;li class="item-0"&gt;first item&lt;/li&gt;&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里首先引入PyQuery这个对象，取别名为pq。然后声明了一个HTML字符串，并将其当作参数传递给PyQuery类，这样就成功完成了初始化。接下来，将初始化的对象传入CSS选择器。在这个实例中，我们传入li节点，这样就可以选择所有的li节点。 URL初始化&nbsp;&nbsp;&nbsp;&nbsp;初始化的参数不仅可以以字符串的形式传递，还可以传入网页的URL，此时只需要指定参数为url即可:123from pyquery import PyQuery as pqdoc = pq(url='https://sanstylemc.cn/')print(doc('title')) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1&lt;title&gt; Sanstyle - &lt;/title&gt; &nbsp;&nbsp;&nbsp;&nbsp;这样的话，PyQuery对象会首先请求这个URL，然后用得到的HTML内容完成初始化，这其实就相当于用网页的源代码以字符串的形式传递给PyQuery类来初始化。&nbsp;&nbsp;&nbsp;&nbsp;它与下面的功能是相同的:1234from pyquery import PyQuery as pqimport requestsdoc = pq(requests.get('http://cuiqingcai.com').text)print(doc('title')) 文件初始化&nbsp;&nbsp;&nbsp;&nbsp;当然，除了传递URL，还可以传递本地的文件名，此时将参数指定为filename即可:123from pyquery import PyQuery as pqdoc = pq(filename='demo.html')print(doc('li')) &nbsp;&nbsp;&nbsp;&nbsp;当然，这里需要有一个本地HTML文件demo.html，其内容是待解析的HTML字符串。这样它会首先读取本地的文件内容，然后用文件内容以字符串的形式传递给PyQuery类来初始化。 基本CSS选择器&nbsp;&nbsp;&nbsp;&nbsp;首先，用一个实例来感受PyQuery的CSS选择器的用法:123456789101112131415html = '''&lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)print(doc('#container .list li'))print(type(doc('#container .list li'))) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456&lt;li class="item-0"&gt;first item&lt;/li&gt;&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;&lt;class 'pyquery.pyquery.PyQuery'&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里我们初始化PyQuery对象之后，传入了一个CSS选择器#container .list li，它的意思是先选取id为container的节点，然后再选取其内部的class为list的节点内容的所有li节点。然后，打印输出。可以看到，我们成功获取到了符合条件的节点。&nbsp;&nbsp;&nbsp;&nbsp;最后，将它的类型打印输出。可以看到，它的类型依然是PyQuery类型。 查找节点&nbsp;&nbsp;&nbsp;&nbsp;下面我们介绍一些常用的查询函数，这些函数和jQuery中函数的用法完全相同。 子节点&nbsp;&nbsp;&nbsp;&nbsp;查找子节点时，需要用到find()方法，此时传入的参数是CSS选择器。这里还是以前面的HTML为例:12345678from pyquery import PyQuery as pqdoc = pq(html)items = doc('.list')print(type(items))print(items)lis = items.find('li')print(type(lis))print(lis) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234567891011121314&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class="item-0"&gt;first item&lt;/li&gt;&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;首先，我们选取class为list的节点，然后调用了find()方法，传入CSS选择器，选取其内部的li节点，最后打印输出。可以发现，find()方法会将符合条件的所有节点选择出来，结果的类型是PyQuery类型。&nbsp;&nbsp;&nbsp;&nbsp;其实find()的查找范围是节点的所有子孙节点，而如果我们只想查找子节点，那么可以用children()方法:123lis = items.children()print(type(lis))print(lis) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class="item-0"&gt;first item&lt;/li&gt;&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;如果要筛选所有子节点中符合条件的节点，比如想筛选出子节点中class为active的节点，可以向children()方法传入CSS选择器.active:12lis = items.children('.active')print(lis) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，输出结果已经做了筛选，留下了class为active的节点。 父节点&nbsp;&nbsp;&nbsp;&nbsp;我们可以用parent()方法来获取某个节点的父节点，示例如下:12345678910111213141516171819html = '''&lt;div class="wrap"&gt; &lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)items = doc('.list')container = items.parent()print(type(container))print(container) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12345678910&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里我们首先用.list选取class为list的节点，然后调用parent()方法得到其父节点，其类型依然是PyQuery类型。&nbsp;&nbsp;&nbsp;&nbsp;这里的父节点是该节点的直接父节点，也就是说，它不会再去查找父节点的父节点，即祖先节点。&nbsp;&nbsp;&nbsp;&nbsp;但是如果想获取某个祖先节点，该怎么办呢？这时可以用parents()方法:123456from pyquery import PyQuery as pqdoc = pq(html)items = doc('.list')parents = items.parents()print(type(parents))print(parents) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456789101112131415161718192021&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;div class="wrap"&gt; &lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，输出结果有两个：一个是class为wrap的节点，一个是id为container的节点。也就是说，parents()方法会返回所有的祖先节点。&nbsp;&nbsp;&nbsp;&nbsp;如果想要筛选某个祖先节点的话，可以向parents()方法传入CSS选择器，这样就会返回祖先节点中符合CSS选择器的节点:12parent = items.parents('.wrap')print(parent) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234567891011&lt;div class="wrap"&gt; &lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，输出结果少了一个节点，只保留了class为wrap的节点。 兄弟节点&nbsp;&nbsp;&nbsp;&nbsp;前面我们说明了子节点和父节点的用法，还有一种节点，那就是兄弟节点。如果要获取兄弟节点，可以使用siblings()方法。这里还是以上面的HTML代码为例:1234from pyquery import PyQuery as pqdoc = pq(html)li = doc('.list .item-0.active')print(li.siblings()) &nbsp;&nbsp;&nbsp;&nbsp;这里首先选择class为list的节点内部class为item-0和active的节点，也就是第三个li节点。那么，很明显，它的兄弟节点有4个，那就是第一、二、四、五个li节点。&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0"&gt;first item&lt;/li&gt;&lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，这正是我们刚才所说的4个兄弟节点。&nbsp;&nbsp;&nbsp;&nbsp;如果要筛选某个兄弟节点，我们依然可以向siblings方法传入CSS选择器，这样就会从所有兄弟节点中挑选出符合条件的节点了:1234from pyquery import PyQuery as pqdoc = pq(html)li = doc('.list .item-0.active')print(li.siblings('.active')) &nbsp;&nbsp;&nbsp;&nbsp;这里我们筛选了class为active的节点，通过刚才的结果可以观察到，class为active的兄弟节点只有第四个li节点，所以结果应该是一个。&nbsp;&nbsp;&nbsp;&nbsp;我们再看一下运行结果:1&lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; 遍历&nbsp;&nbsp;&nbsp;&nbsp;刚才可以观察到，pyquery的选择结果可能是多个节点，也可能是单个节点，类型都是PyQuery类型，并没有返回像Beautiful Soup那样的列表。&nbsp;&nbsp;&nbsp;&nbsp;对于单个节点来说，可以直接打印输出，也可以直接转成字符串:12345from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li)print(str(li)) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;对于多个节点的结果，我们就需要遍历来获取了。例如，这里把每一个li节点进行遍历，需要调用items()方法:123456from pyquery import PyQuery as pqdoc = pq(html)lis = doc('li').items()print(type(lis))for li in lis: print(li, type(li)) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234567891011&lt;class 'generator'&gt;&lt;li class="item-0"&gt;first item&lt;/li&gt;&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;class 'pyquery.pyquery.PyQuery'&gt;&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;&lt;class 'pyquery.pyquery.PyQuery'&gt; &nbsp;&nbsp;&nbsp;&nbsp;可以发现，调用items()方法后，会得到一个生成器，遍历一下，就可以逐个得到li节点对象了，它的类型也是PyQuery类型。每个li节点还可以调用前面所说的方法进行选择，比如继续查询子节点，寻找某个祖先节点等，非常灵活。 获取信息&nbsp;&nbsp;&nbsp;&nbsp;提取到节点之后，我们的最终目的当然是提取节点所包含的信息了。比较重要的信息有两类，一是获取属性，二是获取文本，下面分别进行说明。 获取属性&nbsp;&nbsp;&nbsp;&nbsp;提取到某个PyQuery类型的节点后，就可以调用attr()方法来获取属性:123456789101112131415161718html = '''&lt;div class="wrap"&gt; &lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)a = doc('.item-0.active a')print(a, type(a))print(a.attr('href')) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt; &lt;class 'pyquery.pyquery.PyQuery'&gt;link3.html &nbsp;&nbsp;&nbsp;&nbsp;这里首先选中class为item-0和active的li节点内的a节点，它的类型是PyQuery类型。&nbsp;&nbsp;&nbsp;&nbsp;然后调用attr()方法。在这个方法中传入属性的名称，就可以得到这个属性值了。&nbsp;&nbsp;&nbsp;&nbsp;此外，也可以通过调用attr属性来获取属性，用法如下:1print(a.attr.href) &nbsp;&nbsp;&nbsp;&nbsp;结果如下:1link3.html &nbsp;&nbsp;&nbsp;&nbsp;这两种方法的结果完全一样。&nbsp;&nbsp;&nbsp;&nbsp;如果选中的是多个元素，然后调用attr()方法，会出现怎样的结果呢？我们用实例来测试一下:1234a = doc('a')print(a, type(a))print(a.attr('href'))print(a.attr.href) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt; &lt;class 'pyquery.pyquery.PyQuery'&gt;link2.htmllink2.html &nbsp;&nbsp;&nbsp;&nbsp;照理来说，我们选中的a节点应该有4个，而且打印结果也应该是4个，但是当我们调用attr()方法时，返回结果却只是第一个。这是因为，当返回结果包含多个节点时，调用attr()方法，只会得到第一个节点的属性。&nbsp;&nbsp;&nbsp;&nbsp;那么，遇到这种情况时，如果想获取所有的a节点的属性，就要用到前面所说的遍历了:12345from pyquery import PyQuery as pqdoc = pq(html)a = doc('a')for item in a.items(): print(item.attr('href')) &nbsp;&nbsp;&nbsp;&nbsp;此时的运行结果如下:1234link2.htmllink3.htmllink4.htmllink5.html &nbsp;&nbsp;&nbsp;&nbsp;因此，在进行属性获取时，可以观察返回节点是一个还是多个，如果是多个，则需要遍历才能依次获取每个节点的属性。 获取文本&nbsp;&nbsp;&nbsp;&nbsp;获取节点之后的另一个主要操作就是获取其内部的文本了，此时可以调用text()方法来实现:123456789101112131415161718html = '''&lt;div class="wrap"&gt; &lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)a = doc('.item-0.active a')print(a)print(a.text()) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;third item &nbsp;&nbsp;&nbsp;&nbsp;这里首先选中一个a节点，然后调用text()方法，就可以获取其内部的文本信息。此时它会忽略掉节点内部包含的所有HTML，只返回纯文字内容。&nbsp;&nbsp;&nbsp;&nbsp;但如果想要获取这个节点内部的HTML文本，就要用html()方法了:12345from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li)print(li.html()) &nbsp;&nbsp;&nbsp;&nbsp;这里我们选中了第三个li节点，然后调用了html()方法，它返回的结果应该是li节点内的所有HTML文本。&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里同样有一个问题，如果我们选中的结果是多个节点，text()或html()会返回什么内容？我们用实例来看一下:123456789101112131415161718html = '''&lt;div class="wrap"&gt; &lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('li')print(li.html())print(li.text())print(type(li.text()) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123&lt;a href="link2.html"&gt;second item&lt;/a&gt;second item third item fourth item fifth item&lt;class 'str'&gt; &nbsp;&nbsp;&nbsp;&nbsp;结果可能比较出乎意料，html()方法返回的是第一个li节点的内部HTML文本，而text()则返回了所有的li节点内部的纯文本，中间用一个空格分割开，即返回结果是一个字符串。&nbsp;&nbsp;&nbsp;&nbsp;所以这个地方值得注意，如果得到的结果是多个节点，并且想要获取每个节点的内部HTML文本，则需要遍历每个节点。而text()方法不需要遍历就可以获取，它将所有节点取文本之后合并成一个字符串。 节点操作&nbsp;&nbsp;&nbsp;&nbsp;pyquery提供了一系列方法来对节点进行动态修改，比如为某个节点添加一个class，移除某个节点等，这些操作有时候会为提取信息带来极大的便利。&nbsp;&nbsp;&nbsp;&nbsp;由于节点操作的方法太多，下面举几个典型的例子来说明它的用法。 addClass和removeClass&nbsp;&nbsp;&nbsp;&nbsp;我们先用实例来感受一下:123456789101112131415161718192021html = '''&lt;div class="wrap"&gt; &lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li)li.removeClass('active')print(li)li.addClass('active')print(li) &nbsp;&nbsp;&nbsp;&nbsp;首先选中了第三个li节点，然后调用removeClass()方法，将li节点的active这个class移除，后来又调用addClass()方法，将class添加回来。每执行一次操作，就打印输出当前li节点的内容。&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，一共输出了3次。第二次输出时，li节点的active这个class被移除了，第三次class又添加回来了。&nbsp;&nbsp;&nbsp;&nbsp;所以说，addClass()和removeClass()这些方法可以动态改变节点的class属性。 attr、text和html&nbsp;&nbsp;&nbsp;&nbsp;当然，除了操作class这个属性外，也可以用attr()方法对属性进行操作。此外，还可以用text()和html()方法来改变节点内部的内容。示例如下:123456789101112131415html = '''&lt;ul class="list"&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('.item-0.active')print(li)li.attr('name', 'link')print(li)li.text('changed item')print(li)li.html('&lt;span&gt;changed item&lt;/span&gt;')print(li) &nbsp;&nbsp;&nbsp;&nbsp;这里我们首先选中li节点，然后调用attr()方法来修改属性，其中该方法的第一个参数为属性名，第二个参数为属性值。接着，调用text()和html()方法来改变节点内部的内容。三次操作后，分别打印输出当前的li节点。&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234&lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0 active" name="link"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0 active" name="link"&gt;changed item&lt;/li&gt;&lt;li class="item-0 active" name="link"&gt;&lt;span&gt;changed item&lt;/span&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;可以发现，调用attr()方法后，li节点多了一个原本不存在的属性name，其值为link。接着调用text()方法，传入文本之后，li节点内部的文本全被改为传入的字符串文本了。最后，调用html()方法传入HTML文本后，li节点内部又变为传入的HTML文本了。&nbsp;&nbsp;&nbsp;&nbsp;所以说，如果attr()方法只传入第一个参数的属性名，则是获取这个属性值；如果传入第二个参数，可以用来修改属性值。text()和html()方法如果不传参数，则是获取节点内纯文本和HTML文本；如果传入参数，则进行赋值。 remove()&nbsp;&nbsp;&nbsp;&nbsp;顾名思义，remove()方法就是移除，它有时会为信息的提取带来非常大的便利。下面有一段HTML文本:12345678910html = '''&lt;div class="wrap"&gt; Hello, World &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)wrap = doc('.wrap')print(wrap.text()) &nbsp;&nbsp;&nbsp;&nbsp;现在想提取Hello, World这个字符串，而不要p节点内部的字符串，需要怎样操作呢？&nbsp;&nbsp;&nbsp;&nbsp;这里直接先尝试提取class为wrap的节点的内容，看看是不是我们想要的。运行结果如下:1Hello, World This is a paragraph. &nbsp;&nbsp;&nbsp;&nbsp;这个结果还包含了内部的p节点的内容，也就是说text()把所有的纯文本全提取出来了。如果我们想去掉p节点内部的文本，可以选择再把p节点内的文本提取一遍，然后从整个结果中移除这个子串，但这个做法明显比较烦琐。&nbsp;&nbsp;&nbsp;&nbsp;这时remove()方法就可以派上用场了，我们可以接着这么做:12wrap.find('p').remove()print(wrap.text()) &nbsp;&nbsp;&nbsp;&nbsp;首先选中p节点，然后调用了remove()方法将其移除，然后这时wrap内部就只剩下Hello, World这句话了，然后再利用text()方法提取即可。 伪类选择器&nbsp;&nbsp;&nbsp;&nbsp;CSS选择器之所以强大，还有一个很重要的原因，那就是它支持多种多样的伪类选择器，例如选择第一个节点、最后一个节点、奇偶数节点、包含某一文本的节点等。示例如下:123456789101112131415161718192021222324252627html = '''&lt;div class="wrap"&gt; &lt;div id="container"&gt; &lt;ul class="list"&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;'''from pyquery import PyQuery as pqdoc = pq(html)li = doc('li:first-child')print(li)li = doc('li:last-child')print(li)li = doc('li:nth-child(2)')print(li)li = doc('li:gt(2)')print(li)li = doc('li:nth-child(2n)')print(li)li = doc('li:contains(second)')print(li) 运行结果如下:12345678910111213&lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里我们使用了CSS3的伪类选择器，依次选择了第一个li节点、最后一个li节点、第二个li节点、第三个li之后的li节点、偶数位置的li节点、包含second文本的li节点。]]></content>
      <tags>
        <tag>python</tag>
        <tag>解析库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Beautiful Soup]]></title>
    <url>%2F2018%2F04%2F08%2F%E4%BD%BF%E7%94%A8Beautiful-Soup%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;Beautiful Soup是强大的解析工具，它借助网页的结构和属性等特性来解析网页。有了它，我们不用再去写一些复杂的正则表达式，只需要简单的几条语句，就可以完成网页中某个元素的提取。 简介&nbsp;&nbsp;&nbsp;&nbsp;简单来说，Beautiful Soup就是Python的一个HTML或XML的解析库，可以用它来方便地从网页中提取数据。官方解释如下: &nbsp;&nbsp;&nbsp;&nbsp;Beautiful Soup提供一些简单的、Python式的函数来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。&nbsp;&nbsp;&nbsp;&nbsp;Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为UTF-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时你仅仅需要说明一下原始编码方式就可以了。&nbsp;&nbsp;&nbsp;&nbsp;Beautiful Soup已成为和lxml、html6lib一样出色的Python解释器，为用户灵活地提供不同的解析策略或强劲的速度。 解析器&nbsp;&nbsp;&nbsp;&nbsp;Beautiful Soup在解析时实际上依赖解析器，它除了支持Python标准库中的HTML解析器外，还支持一些第三方解析器(比如lxml).下表列出了Beautiful Soup支持的解析器。 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, &quot;html.parser&quot;) Python的内置标准库、执行速度适中、文档容错能力强 Python 2.7.3及Python 3.2.2之前的版本文档容错能力查 lxml HTML解析器 BeautifulSoup(markup, &quot;lxml&quot;) 速度快、文档容错能力强 需要安装C语言库 lxml XML解析器 BeautifulSoup(markup, &quot;xml&quot;) 速度快、唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, &quot;html5lib&quot;) 最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档 速度慢、不依赖外部扩展 &nbsp;&nbsp;&nbsp;&nbsp;通过以上对比可以看出，lxml解析器有解析HTML和XML的功能，而且速度快，容错能力强，所以推荐使用它。&nbsp;&nbsp;&nbsp;&nbsp;如果使用lxml，那么在初始化Beautiful Soup时，可以把第二个参数改为lxml即可:123from bs4 import BeautifulSoupsoup = BeautifulSoup('&lt;p&gt;Hello&lt;/p&gt;', 'lxml')print(soup.p.string) 基本用法&nbsp;&nbsp;&nbsp;&nbsp;下面首先用实例来看看Beautiful Soup的基本用法:123456789101112131415html = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.prettify())print(soup.title.string) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12345678910111213141516171819202122232425262728293031323334&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class="title" name="dromouse"&gt; &lt;b&gt; The Dormouse's story &lt;/b&gt; &lt;/p&gt; &lt;p class="story"&gt; Once upon a time there were three little sisters; and their names were &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt; &lt;!-- Elsie --&gt; &lt;/a&gt; , &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt; Lacie &lt;/a&gt; and &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt; Tillie &lt;/a&gt; ;and they lived at the bottom of a well. &lt;/p&gt; &lt;p class="story"&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;The Dormouse's story &nbsp;&nbsp;&nbsp;&nbsp;这里首先声明变量html，它是一个HTML字符串。但是需要注意的是，它并不是一个完整的HTML字符串，因为body和html节点都没有闭合。接着，我们将它当作第一个参数传给BeautifulSoup对象，该对象的第二个参数为解析器的类型（这里使用lxml），此时就完成了BeautifulSoup对象的初始化。然后，将这个对象赋值给soup变量。&nbsp;&nbsp;&nbsp;&nbsp;接下来，就可以调用soup的各个方法和属性解析这串HTML代码了。&nbsp;&nbsp;&nbsp;&nbsp;首先，调用prettify()方法。这个方法可以把要解析的字符串以标准的缩进格式输出。这里需要注意的是，输出结果里面包含body和html节点，也就是说对于不标准的HTML字符串BeautifulSoup，可以自动更正格式。这一步不是由prettify()方法做的，而是在初始化BeautifulSoup时就完成了。&nbsp;&nbsp;&nbsp;&nbsp;然后调用soup.title.string，这实际上是输出HTML中title节点的文本内容。所以，soup.title可以选出HTML中的title节点，再调用string属性就可以得到里面的文本了。 节点选择器&nbsp;&nbsp;&nbsp;&nbsp;直接调用节点的名称就可以选择节点元素，再调用string属性就可以得到节点内的文本了，这种选择方式速度非常快。如果单个节点结构层次非常清晰，可以选用这种方式来解析。 选择元素&nbsp;&nbsp;&nbsp;&nbsp;下面再用一个例子详细说明选择元素的方法:123456789101112131415161718html = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.title)print(type(soup.title))print(soup.title.string)print(soup.head)print(soup.p) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12345&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;class 'bs4.element.Tag'&gt;The Dormouse's story&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里依然选用刚才的HTML代码，首先打印输出title节点的选择结果，输出结果正是title节点加里面的文字内容。接下来，输出它的类型，是bs4.element.Tag类型，这是Beautiful Soup中一个重要的数据结构。经过选择器选择后，选择结果都是这种Tag类型。Tag具有一些属性，比如string属性，调用该属性，可以得到节点的文本内容，所以接下来的输出结果正是节点的文本内容。&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们又尝试选择了head节点，结果也是节点加其内部的所有内容。最后，选择了p节点。不过这次情况比较特殊，我们发现结果是第一个p节点的内容，后面的几个p节点并没有选到。也就是说，当有多个节点时，这种选择方式只会选择到第一个匹配的节点，其他的后面节点都会忽略。 提取信息&nbsp;&nbsp;&nbsp;&nbsp;上面演示了调用string属性来获取文本的值，那么如何获取节点属性的值呢？如何获取节点名呢？下面我们来统一梳理一下信息的提取方式。 获取名称&nbsp;&nbsp;&nbsp;&nbsp;可以利用name属性获取节点的名称。这里还是以上面的文本为例，选取title节点，然后调用name属性就可以得到节点名称:1print(soup.title.name) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1title 获取属性&nbsp;&nbsp;&nbsp;&nbsp;每个节点可能有多个属性，比如id和class等，选择这个节点元素后，可以调用attrs获取所有属性:12print(soup.p.attrs)print(soup.p.attrs['name']) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12&#123;'class': ['title'], 'name': 'dromouse'&#125;dromouse &nbsp;&nbsp;&nbsp;&nbsp;可以看到，attrs的返回结果是字典形式，它把选择的节点的所有属性和属性值组合成一个字典。接下来，如果要获取name属性，就相当于从字典中获取某个键值，只需要用中括号加属性名就可以了。比如，要获取name属性，就可以通过attrs[&#39;name&#39;]来得到。&nbsp;&nbsp;&nbsp;&nbsp;其实这样有点烦琐，还有一种更简单的获取方式：可以不用写attrs，直接在节点元素后面加中括号，传入属性名就可以获取属性值了。样例如下:12print(soup.p['name'])print(soup.p['class']) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12dromouse['title'] &nbsp;&nbsp;&nbsp;&nbsp;这里需要注意的是，有的返回结果是字符串，有的返回结果是字符串组成的列表。比如，name属性的值是唯一的，返回的结果就是单个字符串。而对于class，一个节点元素可能有多个class，所以返回的是列表。在实际处理过程中，我们要注意判断类型。 获取内容&nbsp;&nbsp;&nbsp;&nbsp;可以利用string属性获取节点元素包含的文本内容，比如要获取第一个p节点的文本:1print(soup.p.string) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1The Dormouse's story &nbsp;&nbsp;&nbsp;&nbsp;再次注意一下，这里选择到的p节点是第一个p节点，获取的文本也是第一个p节点里面的文本。 嵌套选择&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子中，我们知道每一个返回结果都是bs4.element.Tag类型，它同样可以继续调用节点进行下一步的选择。比如，我们获取了head节点元素，我们可以继续调用head来选取其内部的head节点元素:123456789html = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;"""from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.head.title)print(type(soup.head.title))print(soup.head.title.string) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;class 'bs4.element.Tag'&gt;The Dormouse's story &nbsp;&nbsp;&nbsp;&nbsp;第一行结果是调用head之后再次调用title而选择的title节点元素。然后打印输出了它的类型，可以看到，它仍然是bs4.element.Tag类型。也就是说，我们在Tag类型的基础上再次选择得到的依然还是Tag类型，每次返回的结果都相同，所以这样就可以做嵌套选择了。&nbsp;&nbsp;&nbsp;&nbsp;最后，输出它的string属性，也就是节点里的文本内容。 关联选择&nbsp;&nbsp;&nbsp;&nbsp;在做选择的时候，有时候不能做到一步就选到想要的节点元素，需要先选中某一个节点元素，然后以它为基准再选择它的子节点、父节点、兄弟节点等，这里就来介绍如何选择这些节点元素。 子节点和子孙节点&nbsp;&nbsp;&nbsp;&nbsp;选取节点元素之后，如果想要获取它的直接子节点，可以调用contents属性，示例如下:123456789101112131415161718html = """&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class="story"&gt; Once upon a time there were three little sisters; and their names were &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and &lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt; &lt;p class="story"&gt;...&lt;/p&gt;""" &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123['\n Once upon a time there were three little sisters; and their names were\n ', &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;, '\n', &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, ' \n and\n ', &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;, '\n and they lived at the bottom of a well.\n '] &nbsp;&nbsp;&nbsp;&nbsp;可以看到，返回结果是列表形式。p节点里既包含文本，又包含节点，最后会将它们以列表形式统一返回。&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，列表中的每个元素都是p节点的直接子节点。比如第一个a节点里面包含一层span节点，这相当于孙子节点了，但是返回结果并没有单独把span节点选出来。所以说，contents属性得到的结果是直接子节点的列表。&nbsp;&nbsp;&nbsp;&nbsp;同样，我们可以调用children属性得到相应的结果:12345from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.children)for i, child in enumerate(soup.p.children): print(i, child) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12345678910111213141516&lt;list_iterator object at 0x1064f7dd8&gt;0 Once upon a time there were three little sisters; and their names were 1 &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;4 and 5 &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;6 and they lived at the bottom of a well. &nbsp;&nbsp;&nbsp;&nbsp;还是同样的HTML文本，这里调用了children属性来选择，返回结果是生成器类型。接下来，我们用for循环输出相应的内容。&nbsp;&nbsp;&nbsp;&nbsp;如果要得到所有的子孙节点的话，可以调用descendants属性:12345from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.p.descendants)for i, child in enumerate(soup.p.descendants): print(i, child) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456789101112131415161718192021222324&lt;generator object descendants at 0x10650e678&gt;0 Once upon a time there were three little sisters; and their names were 1 &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;2 3 &lt;span&gt;Elsie&lt;/span&gt;4 Elsie5 6 7 &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;8 Lacie9 and 10 &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;11 Tillie12 and they lived at the bottom of a well. &nbsp;&nbsp;&nbsp;&nbsp;此时返回结果还是生成器。遍历输出一下可以看到，这次的输出结果就包含了span节点。descendants会递归查询所有子节点，得到所有的子孙节点。 父节点和祖先节点&nbsp;&nbsp;&nbsp;&nbsp;如果要获取某个节点元素的父节点，可以调用parent属性:1234567891011121314151617html = """&lt;html&gt; &lt;head&gt; &lt;title&gt;The Dormouse's story&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class="story"&gt; Once upon a time there were three little sisters; and their names were &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;/p&gt; &lt;p class="story"&gt;...&lt;/p&gt;"""from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.a.parent) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456&lt;p class="story"&gt; Once upon a time there were three little sisters; and their names were &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里我们选择的是第一个a节点的父节点元素。很明显，它的父节点是p节点，输出结果便是p节点及其内部的内容。&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，这里输出的仅仅是a节点的直接父节点，而没有再向外寻找父节点的祖先节点。如果想获取所有的祖先节点，可以调用parents属性:12345678910111213html = """&lt;html&gt; &lt;body&gt; &lt;p class="story"&gt; &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; &lt;/p&gt;"""from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(type(soup.a.parents))print(list(enumerate(soup.a.parents))) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234567891011121314151617181920212223242526&lt;class 'generator'&gt;[(0, &lt;p class="story"&gt;&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;), (1, &lt;body&gt;&lt;p class="story"&gt;&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;), (2, &lt;html&gt;&lt;body&gt;&lt;p class="story"&gt;&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;), (3, &lt;html&gt;&lt;body&gt;&lt;p class="story"&gt;&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;)] &nbsp;&nbsp;&nbsp;&nbsp;可以发现，返回结果是生成器类型。这里用列表输出了它的索引和内容，而列表中的元素就是a节点的祖先节点。 兄弟节点&nbsp;&nbsp;&nbsp;&nbsp;上面说明了子节点和父节点的获取方式，如果要获取同级的节点（也就是兄弟节点），应该怎么办呢？示例如下:123456789101112131415161718192021html = """&lt;html&gt; &lt;body&gt; &lt;p class="story"&gt; Once upon a time there were three little sisters; and their names were &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt; &lt;span&gt;Elsie&lt;/span&gt; &lt;/a&gt; Hello &lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and &lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt; and they lived at the bottom of a well. &lt;/p&gt;"""from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print('Next Sibling', soup.a.next_sibling)print('Prev Sibling', soup.a.previous_sibling)print('Next Siblings', list(enumerate(soup.a.next_siblings)))print('Prev Siblings', list(enumerate(soup.a.previous_siblings))) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12345678Next Sibling Hello Prev Sibling Once upon a time there were three little sisters; and their names were Next Siblings [(0, '\n Hello\n '), (1, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;), (2, ' \n and\n '), (3, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;), (4, '\n and they lived at the bottom of a well.\n ')]Prev Siblings [(0, '\n Once upon a time there were three little sisters; and their names were\n ')] &nbsp;&nbsp;&nbsp;&nbsp;可以看到，这里调用了4个属性，其中next_sibling和previous_sibling分别获取节点的下一个和上一个兄弟元素，next_siblings和previous_siblings则分别返回所有前面和后面的兄弟节点的生成器。 提取信息&nbsp;&nbsp;&nbsp;&nbsp;前面讲解了关联元素节点的选择方法，如果想要获取它们的一些信息，比如文本、属性等，也用同样的方法，示例如下:123456789101112131415161718html = """&lt;html&gt; &lt;body&gt; &lt;p class="story"&gt; Once upon a time there were three little sisters; and their names were &lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Bob&lt;/a&gt;&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; &lt;/p&gt;"""from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print('Next Sibling:')print(type(soup.a.next_sibling))print(soup.a.next_sibling)print(soup.a.next_sibling.string)print('Parent:')print(type(soup.a.parents))print(list(soup.a.parents)[0])print(list(soup.a.parents)[0].attrs['class']) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234567891011Next Sibling:&lt;class 'bs4.element.Tag'&gt;&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;LacieParent:&lt;class 'generator'&gt;&lt;p class="story"&gt; Once upon a time there were three little sisters; and their names were &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Bob&lt;/a&gt;&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;&lt;/p&gt;['story'] &nbsp;&nbsp;&nbsp;&nbsp;如果返回结果是单个节点，那么可以直接调用string、attrs等属性获得其文本和属性；如果返回结果是多个节点的生成器，则可以转为列表后取出某个元素，然后再调用string、attrs等属性获取其对应节点的文本和属性。 方法选择器&nbsp;&nbsp;&nbsp;&nbsp;前面所讲的选择方法都是通过属性来选择的，这种方法非常快，但是如果进行比较复杂的选择的话，它就比较烦琐，不够灵活了。幸好，Beautiful Soup还为我们提供了一些查询方法，比如find_all()和find()等，调用它们，然后传入相应的参数，就可以灵活查询了。 find_all()&nbsp;&nbsp;&nbsp;&nbsp;find_all，顾名思义，就是查询所有符合条件的元素。给它传入一些属性或文本，就可以得到符合条件的元素，它的功能十分强大。&nbsp;&nbsp;&nbsp;&nbsp;它的API如下:1find_all(name , attrs , recursive , text , **kwargs) name&nbsp;&nbsp;&nbsp;&nbsp;我们可以根据节点名来查询元素，示例如下:12345678910111213141516171819202122html='''&lt;div class="panel"&gt; &lt;div class="panel-heading"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;ul class="list" id="list-1"&gt; &lt;li class="element"&gt;Foo&lt;/li&gt; &lt;li class="element"&gt;Bar&lt;/li&gt; &lt;li class="element"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class="list list-small" id="list-2"&gt; &lt;li class="element"&gt;Foo&lt;/li&gt; &lt;li class="element"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(name='ul'))print(type(soup.find_all(name='ul')[0])) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456789[&lt;ul class="list" id="list-1"&gt;&lt;li class="element"&gt;Foo&lt;/li&gt;&lt;li class="element"&gt;Bar&lt;/li&gt;&lt;li class="element"&gt;Jay&lt;/li&gt;&lt;/ul&gt;, &lt;ul class="list list-small" id="list-2"&gt;&lt;li class="element"&gt;Foo&lt;/li&gt;&lt;li class="element"&gt;Bar&lt;/li&gt;&lt;/ul&gt;]&lt;class 'bs4.element.Tag'&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里我们调用了find_all()方法，传入name参数，其参数值为ul。也就是说，我们想要查询所有ul节点，返回结果是列表类型，长度为2，每个元素依然都是bs4.element.Tag类型。&nbsp;&nbsp;&nbsp;&nbsp;因为都是Tag类型，所以依然可以进行嵌套查询。还是同样的文本，这里查询出所有ul节点后，再继续查询其内部的li节点:12for ul in soup.find_all(name='ul'): print(ul.find_all(name='li')) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12[&lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;, &lt;li class="element"&gt;Jay&lt;/li&gt;][&lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;] &nbsp;&nbsp;&nbsp;&nbsp;返回结果是列表类型，列表中的每个元素依然还是Tag类型。&nbsp;&nbsp;&nbsp;&nbsp;接下来，就可以遍历每个li，获取它的文本了:1234for ul in soup.find_all(name='ul'): print(ul.find_all(name='li')) for li in ul.find_all(name='li'): print(li.string) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234567[&lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;, &lt;li class="element"&gt;Jay&lt;/li&gt;]FooBarJay[&lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;]FooBar attrs&nbsp;&nbsp;&nbsp;&nbsp;除了根据节点名查询，我们也可以传入一些属性来查询，示例如下:12345678910111213141516171819202122html='''&lt;div class="panel"&gt; &lt;div class="panel-heading"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;ul class="list" id="list-1" name="elements"&gt; &lt;li class="element"&gt;Foo&lt;/li&gt; &lt;li class="element"&gt;Bar&lt;/li&gt; &lt;li class="element"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class="list list-small" id="list-2"&gt; &lt;li class="element"&gt;Foo&lt;/li&gt; &lt;li class="element"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(attrs=&#123;'id': 'list-1'&#125;))print(soup.find_all(attrs=&#123;'name': 'elements'&#125;)) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12345678910[&lt;ul class="list" id="list-1" name="elements"&gt;&lt;li class="element"&gt;Foo&lt;/li&gt;&lt;li class="element"&gt;Bar&lt;/li&gt;&lt;li class="element"&gt;Jay&lt;/li&gt;&lt;/ul&gt;][&lt;ul class="list" id="list-1" name="elements"&gt;&lt;li class="element"&gt;Foo&lt;/li&gt;&lt;li class="element"&gt;Bar&lt;/li&gt;&lt;li class="element"&gt;Jay&lt;/li&gt;&lt;/ul&gt;] &nbsp;&nbsp;&nbsp;&nbsp;这里查询的时候传入的是attrs参数，参数的类型是字典类型。比如，要查询id为list-1的节点，可以传入attrs={&#39;id&#39;: &#39;list-1&#39;}的查询条件，得到的结果是列表形式，包含的内容就是符合id为list-1的所有节点。在上面的例子中，符合条件的元素个数是1，所以结果是长度为1的列表。&nbsp;&nbsp;&nbsp;&nbsp;对于一些常用的属性，比如id和class等，我们可以不用attrs来传递。比如，要查询id为list-1的节点，可以直接传入id这个参数。还是上面的文本，我们换一种方式来查询:1234from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(id='list-1'))print(soup.find_all(class_='element')) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456[&lt;ul class="list" id="list-1"&gt;&lt;li class="element"&gt;Foo&lt;/li&gt;&lt;li class="element"&gt;Bar&lt;/li&gt;&lt;li class="element"&gt;Jay&lt;/li&gt;&lt;/ul&gt;][&lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;, &lt;li class="element"&gt;Jay&lt;/li&gt;, &lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;] &nbsp;&nbsp;&nbsp;&nbsp;这里直接传入id=&#39;list-1&#39;，就可以查询id为list-1的节点元素了。而对于class来说，由于class在Python里是一个关键字，所以后面需要加一个下划线，即class_=&#39;element&#39;，返回的结果依然还是Tag组成的列表。 text&nbsp;&nbsp;&nbsp;&nbsp;text参数可用来匹配节点的文本，传入的形式可以是字符串，可以是正则表达式对象，示例如下:123456789101112import rehtml='''&lt;div class="panel"&gt; &lt;div class="panel-body"&gt; &lt;a&gt;Hello, this is a link&lt;/a&gt; &lt;a&gt;Hello, this is a link, too&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find_all(text=re.compile('link'))) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1['Hello, this is a link', 'Hello, this is a link, too'] &nbsp;&nbsp;&nbsp;&nbsp;这里有两个a节点，其内部包含文本信息。这里在find_all()方法中传入text参数，该参数为正则表达式对象，结果返回所有匹配正则表达式的节点文本组成的列表。 find()&nbsp;&nbsp;&nbsp;&nbsp;除了find_all()方法，还有find()方法，只不过后者返回的是单个元素，也就是第一个匹配的元素，而前者返回的是所有匹配的元素组成的列表。示例如下:1234567891011121314151617181920212223html='''&lt;div class="panel"&gt; &lt;div class="panel-heading"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;ul class="list" id="list-1"&gt; &lt;li class="element"&gt;Foo&lt;/li&gt; &lt;li class="element"&gt;Bar&lt;/li&gt; &lt;li class="element"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class="list list-small" id="list-2"&gt; &lt;li class="element"&gt;Foo&lt;/li&gt; &lt;li class="element"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.find(name='ul'))print(type(soup.find(name='ul')))print(soup.find(class_='list')) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234567891011&lt;ul class="list" id="list-1"&gt;&lt;li class="element"&gt;Foo&lt;/li&gt;&lt;li class="element"&gt;Bar&lt;/li&gt;&lt;li class="element"&gt;Jay&lt;/li&gt;&lt;/ul&gt;&lt;class 'bs4.element.Tag'&gt;&lt;ul class="list" id="list-1"&gt;&lt;li class="element"&gt;Foo&lt;/li&gt;&lt;li class="element"&gt;Bar&lt;/li&gt;&lt;li class="element"&gt;Jay&lt;/li&gt;&lt;/ul&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里的返回结果不再是列表形式，而是第一个匹配的节点元素，类型依然是Tag类型。&nbsp;&nbsp;&nbsp;&nbsp;另外，还有许多查询方法，其用法与前面介绍的find_all()、find()方法完全相同，只不过查询范围不同，这里简单说明一下。 find_parents()和find_parent()：前者返回所有祖先节点，后者返回直接父节点。 find_next_siblings()和find_next_sibling()：前者返回后面所有的兄弟节点，后者返回后面第一个兄弟节点。 find_previous_siblings()和find_previous_sibling()：前者返回前面所有的兄弟节点，后者返回前面第一个兄弟节点。 find_all_next()和find_next()：前者返回节点后所有符合条件的节点，后者返回第一个符合条件的节点。 find_all_previous()和find_previous()：前者返回节点后所有符合条件的节点，后者返回第一个符合条件的节点。 CSS选择器&nbsp;&nbsp;&nbsp;&nbsp;Beautiful Soup还提供了另外一种选择器，那就是CSS选择器。使用CSS选择器时，只需要调用select()方法，传入相应的CSS选择器即可，示例如下:123456789101112131415161718192021222324html='''&lt;div class="panel"&gt; &lt;div class="panel-heading"&gt; &lt;h4&gt;Hello&lt;/h4&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;ul class="list" id="list-1"&gt; &lt;li class="element"&gt;Foo&lt;/li&gt; &lt;li class="element"&gt;Bar&lt;/li&gt; &lt;li class="element"&gt;Jay&lt;/li&gt; &lt;/ul&gt; &lt;ul class="list list-small" id="list-2"&gt; &lt;li class="element"&gt;Foo&lt;/li&gt; &lt;li class="element"&gt;Bar&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;'''from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')print(soup.select('.panel .panel-heading'))print(soup.select('ul li'))print(soup.select('#list-2 .element'))print(type(soup.select('ul')[0])) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456[&lt;div class="panel-heading"&gt;&lt;h4&gt;Hello&lt;/h4&gt;&lt;/div&gt;][&lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;, &lt;li class="element"&gt;Jay&lt;/li&gt;, &lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;][&lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;]&lt;class 'bs4.element.Tag'&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里我们用了3次CSS选择器，返回的结果均是符合CSS选择器的节点组成的列表。例如，select(&#39;ul li&#39;)则是选择所有ul节点下面的所有li节点，结果便是所有的li节点组成的列表。&nbsp;&nbsp;&nbsp;&nbsp;最后一句打印输出了列表中元素的类型。可以看到，类型依然是Tag类型。 嵌套选择&nbsp;&nbsp;&nbsp;&nbsp;select()方法同样支持嵌套选择。例如，先选择所有ul节点，再遍历每个ul节点，选择其li节点，样例如下:1234from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.select('ul'): print(ul.select('li')) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12[&lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;, &lt;li class="element"&gt;Jay&lt;/li&gt;][&lt;li class="element"&gt;Foo&lt;/li&gt;, &lt;li class="element"&gt;Bar&lt;/li&gt;] &nbsp;&nbsp;&nbsp;&nbsp;可以看到，这里正常输出了所有ul节点下所有li节点组成的列表。 获取属性&nbsp;&nbsp;&nbsp;&nbsp;我们知道节点类型是Tag类型，所以获取属性还可以用原来的方法。仍然是上面的HTML文本，这里尝试获取每个ul节点的id属性:12345from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for ul in soup.select('ul'): print(ul['id']) print(ul.attrs['id']) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234list-1list-1list-2list-2 &nbsp;&nbsp;&nbsp;&nbsp;可以看到，直接传入中括号和属性名，以及通过attrs属性获取属性值，都可以成功。 获取文本&nbsp;&nbsp;&nbsp;&nbsp;要获取文本，当然也可以用前面所讲的string属性。此外，还有一个方法，那就是get_text()，示例如下:12345from bs4 import BeautifulSoupsoup = BeautifulSoup(html, 'lxml')for li in soup.select('li'): print('Get Text:', li.get_text()) print('String:', li.string) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12345678910Get Text: FooString: FooGet Text: BarString: BarGet Text: JayString: JayGet Text: FooString: FooGet Text: BarString: Bar &nbsp;&nbsp;&nbsp;&nbsp;可以看到，二者的效果完全一致。&nbsp;&nbsp;&nbsp;&nbsp;到此，Beautiful Soup的用法基本就介绍完了，最后做一下简单的总结。 推荐使用lxml解析库，必要时使用html.parser。 节点选择筛选功能弱但是速度快。 建议使用find()或者find_all()查询匹配单个结果或者多个结果。 如果对CSS选择器熟悉的话，可以使用select()方法选择。]]></content>
      <tags>
        <tag>python</tag>
        <tag>解析库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用XPath]]></title>
    <url>%2F2018%2F04%2F08%2F%E4%BD%BF%E7%94%A8XPath%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;XPath，全称XML Path Language，即XML路径语言，它是一门在XML文档中查找信息的语言。它最初是用来搜寻XML文档的，但是它同样适用于HTML文档的搜索。&nbsp;&nbsp;&nbsp;&nbsp;所以在做爬虫时，我们完全可以使用XPath来做相应的信息抽取。 XPath概览&nbsp;&nbsp;&nbsp;&nbsp;XPath的选择功能十分强大，它提供了非常简洁明了的路径选择表达式。另外，它还提供了超过100个内建函数，用于字符串、数值、时间的匹配以及节点、序列的处理等。几乎所有我们想要定位的节点，都可以用XPath来选择。&nbsp;&nbsp;&nbsp;&nbsp;XPath于1999年11月16日成为W3C标准，它被设计为供XSLT、XPointer以及其他XML解析软件使用，更多的文档可以访问其官方网站：https://www.w3.org/TR/xpath/ 。 XPath常用规则 表达式 描述 nodename 选取此节点的所有子节点 / 从当前节点选取直接子节点 // 从当前节点选取子孙节点 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 &nbsp;&nbsp;&nbsp;&nbsp;这里列出了XPath的常用匹配规则，示例如下:1//title[@lang='eng'] &nbsp;&nbsp;&nbsp;&nbsp;这就是一个XPath规则，它代表选择所有名称为title，同时属性lang的值为eng的节点。 实例引入&nbsp;&nbsp;&nbsp;&nbsp;现在通过实例来感受下使用XPath来对网页进行解析的过程，相关代码如下:123456789101112131415from lxml import etreetext = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt; &lt;/ul&gt; &lt;/div&gt;'''html = etree.HTML(text)result = etree.tostring(html)print(result.decode('utf-8')) &nbsp;&nbsp;&nbsp;&nbsp;这里首先导入lxml库的etree模块，然后声明了一段HTML文本，调用HTML类进行初始化，这样就成功构造了一个XPath解析对象。这里需要注意的是，HTML文本中的最后一个li节点是没有闭合的，但是etree模块可以自动修正HTML文本。&nbsp;&nbsp;&nbsp;&nbsp;这里我们调用tostring()方法即可输出修正后的HTML代码，但是结果是bytes类型。这里利用decode()方法将其转成str类型，结果如下:12345678910&lt;html&gt;&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，经过处理之后，li节点标签被补全，并且还自动添加了body、html节点。&nbsp;&nbsp;&nbsp;&nbsp;另外，也可以直接读取 文本文件进行解析，示例如下:12345from lxml import etree html = etree.parse('./test.html', etree.HTMLParser())result = etree.tostring(html)print(result.decode('utf-8')) &nbsp;&nbsp;&nbsp;&nbsp;其中test.html的内容就是上面例子中的HTML代码，内容如下:123456789&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt; &lt;/ul&gt; &lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;这次的输出结果略有不同，多了一个DOCTYPE的声明，不过对解析无任何影响，结果如下:12345678910&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"&gt;&lt;html&gt;&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 所有节点&nbsp;&nbsp;&nbsp;&nbsp;我们一般会用//开头的XPath规则来选取所有符合要求的节点。这里以前面的HTML文本为例，如果要选取所有节点，可以这样实现:1234rom lxml import etreehtml = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//*')print(result) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1[&lt;Element html at 0x10510d9c8&gt;, &lt;Element body at 0x10510da08&gt;, &lt;Element div at 0x10510da48&gt;, &lt;Element ul at 0x10510da88&gt;, &lt;Element li at 0x10510dac8&gt;, &lt;Element a at 0x10510db48&gt;, &lt;Element li at 0x10510db88&gt;, &lt;Element a at 0x10510dbc8&gt;, &lt;Element li at 0x10510dc08&gt;, &lt;Element a at 0x10510db08&gt;, &lt;Element li at 0x10510dc48&gt;, &lt;Element a at 0x10510dc88&gt;, &lt;Element li at 0x10510dcc8&gt;, &lt;Element a at 0x10510dd08&gt;] &nbsp;&nbsp;&nbsp;&nbsp;这里使用*代表匹配所有节点，也就是整个HTML文本中的所有节点都会被获取。可以看到，返回形式是一个列表，每个元素是Element类型，其后跟了节点的名称，如html、body、div、ul、li、a等，所有节点都包含在列表中了。&nbsp;&nbsp;&nbsp;&nbsp;当然，此处匹配也可以指定节点名称。如果想获取所有li节点，示例如下:12345from lxml import etreehtml = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//li')print(result)print(result[0]) &nbsp;&nbsp;&nbsp;&nbsp;这里要选取所有li节点，可以使用//，然后直接加上节点名称即可，调用时直接使用xpath()方法即可。&nbsp;&nbsp;&nbsp;&nbsp;运行结果:12[&lt;Element li at 0x105849208&gt;, &lt;Element li at 0x105849248&gt;, &lt;Element li at 0x105849288&gt;, &lt;Element li at 0x1058492c8&gt;, &lt;Element li at 0x105849308&gt;]&lt;Element li at 0x105849208&gt; &nbsp;&nbsp;&nbsp;&nbsp;这里可以看到提取结果是一个列表形式，其中每个元素都是一个 Element对象。如果要取出其中一个对象，可以直接用中括号加索引，如[0]。 子节点&nbsp;&nbsp;&nbsp;&nbsp;我们通过/或//即可查找元素的子节点或子孙节点。假如现在想选择li节点的所有直接a子节点，可以这样实现:12345from lxml import etree html = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//li/a')print(result) &nbsp;&nbsp;&nbsp;&nbsp;这里通过追加/a即选择了所有li节点的所有直接a子节点。因为//li用于选中所有li节点，/a用于选中li节点的所有直接子节点a，二者组合在一起即获取所有li节点的所有直接a子节点。&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1[&lt;Element a at 0x106ee8688&gt;, &lt;Element a at 0x106ee86c8&gt;, &lt;Element a at 0x106ee8708&gt;, &lt;Element a at 0x106ee8748&gt;, &lt;Element a at 0x106ee8788&gt;] &nbsp;&nbsp;&nbsp;&nbsp;此处的/用于选取直接子节点，如果要获取所有子孙节点，就可以使用//。例如，要获取ul节点下的所有子孙a节点，可以这样实现:12345from lxml import etree html = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//ul//a')print(result) &nbsp;&nbsp;&nbsp;&nbsp;运行结果是相同的。&nbsp;&nbsp;&nbsp;&nbsp;但是如果这里用//ul/a，就无法获取任何结果了。因为/用于获取直接子节点，而在ul节点下没有直接的a子节点，只有li节点，所以无法获取任何匹配结果，代码如下:12345from lxml import etree html = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//ul/a')print(result) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1[] &nbsp;&nbsp;&nbsp;&nbsp;因此，这里我们要注意/和//的区别，其中/用于获取直接子节点，//用于获取子孙节点。 父节点&nbsp;&nbsp;&nbsp;&nbsp;我们知道通过连续的/或//可以查找子节点或子孙节点，那么假如我们知道了子节点，怎样来查找父节点呢？这可以用..来实现。&nbsp;&nbsp;&nbsp;&nbsp;比如，现在首先选中href属性为link4.html的a节点，然后再获取其父节点，然后再获取其class属性，相关代码如下:12345from lxml import etree html = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//a[@href="link4.html"]/../@class')print(result) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1['item-1'] &nbsp;&nbsp;&nbsp;&nbsp;检查一下结果发现，这正是我们获取的目标li节点的class。&nbsp;&nbsp;&nbsp;&nbsp;同时，我们也可以通过parent::来获取父节点，代码如下:12345from lxml import etree html = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//a[@href="link4.html"]/parent::*/@class')print(result) 属性匹配&nbsp;&nbsp;&nbsp;&nbsp;在选取的时候，我们还可以用@符号进行属性过滤。比如，这里如果要选取class为item-1的li节点，可以这样实现:1234from lxml import etreehtml = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//li[@class="item-0"]')print(result) &nbsp;&nbsp;&nbsp;&nbsp;这里我们通过加入[@class=&quot;item-0&quot;]，限制了节点的class属性为item-0，而HTML文本中符合条件的li节点有两个，所以结果应该返回两个匹配到的元素。结果如下:1[&lt;Element li at 0x10a399288&gt;, &lt;Element li at 0x10a3992c8&gt;] &nbsp;&nbsp;&nbsp;&nbsp;可见，匹配结果正是两个。 文本获取&nbsp;&nbsp;&nbsp;&nbsp;我们用XPath中的text()方法获取节点中的文本，接下来尝试获取前面li节点中的文本，相关代码如下:12345from lxml import etree html = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//li[@class="item-0"]/text()')print(result) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1['\n '] &nbsp;&nbsp;&nbsp;&nbsp;奇怪的是，我们并没有获取到任何文本，只获取到了一个换行符，这是为什么呢？因为XPath中text()前面是/，而此处/的含义是选取直接子节点，很明显li的直接子节点都是a节点，文本都是在a节点内部的，所以这里匹配到的结果就是被修正的li节点内部的换行符，因为自动修正的li节点的尾标签换行了。&nbsp;&nbsp;&nbsp;&nbsp;即选中的是这两个节点:123&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &nbsp;&nbsp;&nbsp;&nbsp;其中一个节点因为自动修正，li节点的尾标签添加的时候换行了，所以提取文本得到的唯一结果就是li节点的尾标签和a节点的尾标签之间的换行符。&nbsp;&nbsp;&nbsp;&nbsp;因此，如果想获取li节点内部的文本，就有两种方式，一种是先选取a节点再获取文本，另一种就是使用//。接下来，我们来看下二者的区别。&nbsp;&nbsp;&nbsp;&nbsp;首先，选取到a节点再获取文本，代码如下:12345from lxml import etree html = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//li[@class="item-0"]/a/text()')print(result) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1['first item', 'fifth item'] &nbsp;&nbsp;&nbsp;&nbsp;可以看到，这里的返回值是两个，内容都是属性为item-0的li节点的文本，这也印证了前面属性匹配的结果是正确的。&nbsp;&nbsp;&nbsp;&nbsp;这里我们是逐层选取的，先选取了li节点，又利用/选取了其直接子节点a，然后再选取其文本，得到的结果恰好是符合我们预期的两个结果。&nbsp;&nbsp;&nbsp;&nbsp;再来看下用另一种方式（即使用//）选取的结果，代码如下:12345from lxml import etree html = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//li[@class="item-0"]//text()')print(result) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1['first item', 'fifth item', '\n '] &nbsp;&nbsp;&nbsp;&nbsp;不出所料，这里的返回结果是3个。可想而知，这里是选取所有子孙节点的文本，其中前两个就是li的子节点a节点内部的文本，另外一个就是最后一个li节点内部的文本，即换行符。&nbsp;&nbsp;&nbsp;&nbsp;所以说，如果要想获取子孙节点内部的所有文本，可以直接用//加text()的方式，这样可以保证获取到最全面的文本信息，但是可能会夹杂一些换行符等特殊字符。如果想获取某些特定子孙节点下的所有文本，可以先选取到特定的子孙节点，然后再调用text()方法获取其内部文本，这样可以保证获取的结果是整洁的。 属性获取&nbsp;&nbsp;&nbsp;&nbsp;我们知道用text()可以获取节点内部文本，那么节点属性该怎样获取呢？其实还是用@符号就可以。例如，我们想获取所有li节点下所有a节点的href属性，代码如下:12345from lxml import etree html = etree.parse('./test.html', etree.HTMLParser())result = html.xpath('//li/a/@href')print(result) &nbsp;&nbsp;&nbsp;&nbsp;这里我们通过@href即可获取节点的href属性。注意，此处和属性匹配的方法不同，属性匹配是中括号加属性名和值来限定某个属性，如[@href=&quot;link1.html&quot;]，而此处的@href指的是获取节点的某个属性，二者需要做好区分。&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1['link1.html', 'link2.html', 'link3.html', 'link4.html', 'link5.html'] &nbsp;&nbsp;&nbsp;&nbsp;可以看到，我们成功获取了所有li节点下a节点的href属性，它们以列表形式返回。 属性多值匹配&nbsp;&nbsp;&nbsp;&nbsp;有时候，某些节点的某个属性可能有多个值，例如:1234567from lxml import etreetext = '''&lt;li class="li li-first"&gt;&lt;a href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;'''html = etree.HTML(text)result = html.xpath('//li[@class="li"]/a/text()')print(result) &nbsp;&nbsp;&nbsp;&nbsp;这里HTML文本中li节点的class属性有两个值li和li-first，此时如果还想用之前的属性匹配获取，就无法匹配了，此时的运行结果如下:1[] &nbsp;&nbsp;&nbsp;&nbsp;这时就需要用contains()函数了，代码可以改写如下:1234567from lxml import etreetext = '''&lt;li class="li li-first"&gt;&lt;a href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;'''html = etree.HTML(text)result = html.xpath('//li[contains(@class, "li")]/a/text()')print(result) &nbsp;&nbsp;&nbsp;&nbsp;这样通过contains()方法，第一个参数传入属性名称，第二个参数传入属性值，只要此属性包含所传入的属性值，就可以完成匹配了。&nbsp;&nbsp;&nbsp;&nbsp;此时运行结果如下:1['first item'] &nbsp;&nbsp;&nbsp;&nbsp;此种方式在某个节点的某个属性有多个值时经常用到，如某个节点的class属性通常有多个。 多属性匹配&nbsp;&nbsp;&nbsp;&nbsp;另外，我们可能还遇到一种情况，那就是根据多个属性确定一个节点，这时就需要同时匹配多个属性。此时可以使用运算符and来连接，示例如下:1234567from lxml import etreetext = '''&lt;li class="li li-first" name="item"&gt;&lt;a href="link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;'''html = etree.HTML(text)result = html.xpath('//li[contains(@class, "li") and @name="item"]/a/text()')print(result) &nbsp;&nbsp;&nbsp;&nbsp;这里的li节点又增加了一个属性name。要确定这个节点，需要同时根据class和name属性来选择，一个条件是class属性里面包含li字符串，另一个条件是name属性为item字符串，二者需要同时满足，需要用and操作符相连，相连之后置于中括号内进行条件筛选。运行结果如下:1['first item'] &nbsp;&nbsp;&nbsp;&nbsp;这里的and其实是XPath中的运算符。另外，还有很多运算符，如or、mod等。 运算符 描述 实例 返回值 or 或 age=19 or age=20 如果age是19，则返回true。如果age是21，则返回false and 与 age&gt;19 and age&lt;21 如果age是20，则返回true。如果age是18，则返回false mod 计算除法的余数 5 mod 2 1 + 加法 6 + 4 10 - 减法 6 - 4 2 * 乘法 6 * 4 24 div 除法 8 div 4 2 = 等于 age=19 如果age是19，则返回true。如果age是20，则返回false != 不等于 age!=19 如果age是18，则返回true。如果age是19，则返回false &lt; 小于 age&lt;19 如果age是18，则返回true。如果age是19，则返回false &lt;= 小于或等于 age&lt;=19 如果age是19，则返回true。如果age是20，则返回false &gt; 大于 age&gt;19 如果age是20，则返回true。如果age是19，则返回false &gt;= 大于或等于 age&gt;=19 如果age是19，则返回true。如果age是18，则返回false 按序选择&nbsp;&nbsp;&nbsp;&nbsp;有时候，我们在选择的时候某些属性可能同时匹配了多个节点，但是只想要其中的某个节点，如第二个节点或者最后一个节点，这时该怎么办呢？&nbsp;&nbsp;&nbsp;&nbsp;这时可以利用中括号传入索引的方法获取特定次序的节点，示例如下:12345678910111213141516171819202122from lxml import etree text = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt; &lt;/ul&gt; &lt;/div&gt;'''html = etree.HTML(text)result = html.xpath('//li[1]/a/text()')print(result)result = html.xpath('//li[last()]/a/text()')print(result)result = html.xpath('//li[position()&lt;3]/a/text()')print(result)result = html.xpath('//li[last()-2]/a/text()')print(result) &nbsp;&nbsp;&nbsp;&nbsp;第一次选择时，我们选取了第一个li节点，中括号中传入数字1即可。注意，这里和代码中不同，序号是以1开头的，不是以0开头。&nbsp;&nbsp;&nbsp;&nbsp;第二次选择时，我们选取了最后一个li节点，中括号中传入last()即可，返回的便是最后一个li节点。&nbsp;&nbsp;&nbsp;&nbsp;第三次选择时，我们选取了位置小于3的li节点，也就是位置序号为1和2的节点，得到的结果就是前两个li节点。&nbsp;&nbsp;&nbsp;&nbsp;第四次选择时，我们选取了倒数第三个li节点，中括号中传入last()-2即可。因为last()是最后一个，所以last()-2就是倒数第三个。&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234['first item']['fifth item']['first item', 'second item']['third item'] 节点轴选择&nbsp;&nbsp;&nbsp;&nbsp;XPath提供了很多节点轴选择方法，包括获取子元素、兄弟元素、父元素、祖先元素等，示例如下:12345678910111213141516171819202122232425262728from lxml import etree text = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;&lt;span&gt;first item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt; &lt;/ul&gt; &lt;/div&gt;'''html = etree.HTML(text)result = html.xpath('//li[1]/ancestor::*')print(result)result = html.xpath('//li[1]/ancestor::div')print(result)result = html.xpath('//li[1]/attribute::*')print(result)result = html.xpath('//li[1]/child::a[@href="link1.html"]')print(result)result = html.xpath('//li[1]/descendant::span')print(result)result = html.xpath('//li[1]/following::*[2]')print(result)result = html.xpath('//li[1]/following-sibling::*')&lt;code class="lang-python"&gt;&lt;span class="kwd"&gt;print&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;result&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt; &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234567[&lt;Element html at 0x107941808&gt;, &lt;Element body at 0x1079418c8&gt;, &lt;Element div at 0x107941908&gt;, &lt;Element ul at 0x107941948&gt;][&lt;Element div at 0x107941908&gt;]['item-0'][&lt;Element a at 0x1079418c8&gt;][&lt;Element span at 0x107941948&gt;][&lt;Element a at 0x1079418c8&gt;][&lt;Element li at 0x107941948&gt;, &lt;Element li at 0x107941988&gt;, &lt;Element li at 0x1079419c8&gt;, &lt;Element li at 0x107941a08&gt;] &nbsp;&nbsp;&nbsp;&nbsp;第一次选择时，我们调用了ancestor轴，可以获取所有祖先节点。其后需要跟两个冒号，然后是节点的选择器，这里我们直接使用*，表示匹配所有节点，因此返回结果是第一个li节点的所有祖先节点，包括html、body、div和ul。&nbsp;&nbsp;&nbsp;&nbsp;第二次选择时，我们又加了限定条件，这次在冒号后面加了div，这样得到的结果就只有div这个祖先节点了。&nbsp;&nbsp;&nbsp;&nbsp;第三次选择时，我们调用了attribute轴，可以获取所有属性值，其后跟的选择器还是*，这代表获取节点的所有属性，返回值就是li节点的所有属性值。&nbsp;&nbsp;&nbsp;&nbsp;第四次选择时，我们调用了child轴，可以获取所有直接子节点。这里我们又加了限定条件，选取href属性为link1.html的a节点。&nbsp;&nbsp;&nbsp;&nbsp;第五次选择时，我们调用了descendant轴，可以获取所有子孙节点。这里我们又加了限定条件获取span节点，所以返回的结果只包含span节点而不包含a节点。&nbsp;&nbsp;&nbsp;&nbsp;第六次选择时，我们调用了following轴，可以获取当前节点之后的所有节点。这里我们虽然使用的是*匹配，但又加了索引选择，所以只获取了第二个后续节点。&nbsp;&nbsp;&nbsp;&nbsp;第七次选择时，我们调用了following-sibling轴，可以获取当前节点之后的所有同级节点。这里我们使用*匹配，所以获取了所有后续同级节点。]]></content>
      <tags>
        <tag>python</tag>
        <tag>解析库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓取猫眼电影排行]]></title>
    <url>%2F2018%2F04%2F07%2F%E6%8A%93%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;利用requests库和正则表达式来抓取猫眼电影TOP100的相关内容。requests比urllib使用更加方便，而且目前我还没有系统学习HTML解析库，所以这里就选用正则表达式来作为解析工具。 目标&nbsp;&nbsp;&nbsp;&nbsp;我们提取出猫眼电影TOP100的电影名称、时间、评分、图片等信息，提取的站点URL为http://maoyan.com/board/4 抓取分析&nbsp;&nbsp;&nbsp;&nbsp;我们要抓取的目标站点为http://maoyan.com/board/4 ,打开后便可以查看到榜单信息。&nbsp;&nbsp;&nbsp;&nbsp;排名第一的电影是霸王别姬，页面中显示的有效信息有影片名称、主演、上映时间、上映地区、评分、图片等信息。将网页 滚动到最下方，可以发现有分页的列表，直接点击第2页，观察页面的URL和内容发生了怎样的变化。&nbsp;&nbsp;&nbsp;&nbsp;可以发现页面的URL变成http://maoyan.com/board/4?offset=10 ,比之前的URL多了一个参数，那就是offset=10，而目前显示的结果是排行11~20名的电影，初步推断这是一个偏移量的参数。再点击下一页，发现页面的URL变成了http://maoyan.com/board/4?offset=20 ,参数offset变成了20，而显示的结果是排行21~30的电影。&nbsp;&nbsp;&nbsp;&nbsp;由此可以总结出规律: offset代表偏移量值，如果偏移量为n，则显示的电影序号就是n+1到n+10，每页显示10个。所以如果想获取TOP100电影，只需要分开请求10次，而10次的offset参数分别设置为0、10、20…90即可，这样获取不同的页面之后，再用正则表达式提取出相关信息，就可以得到TOP100的所有电影信息了。 抓取首页&nbsp;&nbsp;&nbsp;&nbsp;接下来用代码实现这个过程。首先抓取第一页的内容。我们实现了get_one_page()方法，并给它传入url参数。然后将抓取的页面结果返回，再通过main()方法调用。初步代码实现如下:1234567891011121314import requests def get_one_page(url): response = requests.get(url) if response.status_code == 200: return response.text return None def main(): url = 'http://maoyan.com/board/4' html = get_one_page(url) print(html) main() &nbsp;&nbsp;&nbsp;&nbsp;这样运行之后，就可以成功获取首页的源代码了。获取源代码后，就需要解析页面，提取出我们想要的信息。 正则提取&nbsp;&nbsp;&nbsp;&nbsp;接下来，回到网页看一下页面的真实源码。在开发者模式下的Network监听组件中查看源代码，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;注意，这里不要在Elements选项卡中直接查看源码，因为那里的源码可能经过Javascript操作而与原始请求不同，而是需要从Network选项卡部分查看原始请求得到的源码。&nbsp;&nbsp;&nbsp;&nbsp;查看其中一个条目的源代码，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;可以看到，一部电影信息对应的源代码是一个dd节点，我们用正则表达式来提取这里面的一些电影信息。首先，需要提取它的排名信息。而它的排名信息是在class为board-index的i节点内，这里利用非贪婪匹配来提取i节点内的信息，正则表达式为:1&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt; &nbsp;&nbsp;&nbsp;&nbsp;随后需要提取电影的图片。可以看到，后面有a节点，其内部有两个img节点。经过检测后发现，第二个img节点的data-src属性是图片的链接。这里提取第二个img节点的data-src属性，正则表达式可以改写如下:1&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)" &nbsp;&nbsp;&nbsp;&nbsp;再往后，需要提取电影的名称，它在后面的p节点内，class为name。所以，可以用name做一个标志位，然后进一步提取到期内a节点的正文内容，此时正则表达式改写如下:1&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;再提取主演、发布时间、评分等内容时候，都是同样的原理。最后，正则表达式写为:1&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt; &nbsp;&nbsp;&nbsp;&nbsp;这样一个正则表达式可以匹配一个电影的结果，里面匹配了7个信息。接下来，通过调用findall()方法提取出所有的内容。&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们再定义解析页面的方法parse_one_page()，主要是通过正则表达式来从结果中提取出我们想要的内容，实现代码如下:123456def parse_one_page(html): pattern = re.compile( '&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;', re.S) items = re.findall(pattern, html) print(items) &nbsp;&nbsp;&nbsp;&nbsp;这样就可以成功地将一页地10个电影信息都提取出来，这是一个列表形式，输出结果如下: [(‘1’, ‘http://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg@160w_220h_1e_1c‘, ‘霸王别姬’, ‘\n 主演：张国荣,张丰毅,巩俐\n ‘, ‘上映时间：1993-01-01(中国香港)’, ‘9.’, ‘6’), (‘2’, ‘http://p0.meituan.net/movie/__40191813__4767047.jpg@160w_220h_1e_1c‘, ‘肖申克的救赎’, ‘\n 主演：蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿\n ‘, ‘上映时间：1994-10-14(美国)’, ‘9.’, ‘5’), (‘3’, ‘http://p0.meituan.net/movie/fc9d78dd2ce84d20e53b6d1ae2eea4fb1515304.jpg@160w_220h_1e_1c‘, ‘这个杀手不太冷’, ‘\n 主演：让·雷诺,加里·奥德曼,娜塔莉·波特曼\n ‘, ‘上映时间：1994-09-14(法国)’, ‘9.’, ‘5’), (‘4’, ‘http://p0.meituan.net/movie/23/6009725.jpg@160w_220h_1e_1c‘, ‘罗马假日’, ‘\n 主演：格利高利·派克,奥黛丽·赫本,埃迪·艾伯特\n ‘, ‘上映时间：1953-09-02(美国)’, ‘9.’, ‘1’), (‘5’, ‘http://p0.meituan.net/movie/53/1541925.jpg@160w_220h_1e_1c‘, ‘阿甘正传’, ‘\n 主演：汤姆·汉克斯,罗宾·怀特,加里·西尼斯\n ‘, ‘上映时间：1994-07-06(美国)’, ‘9.’, ‘4’), (‘6’, ‘http://p0.meituan.net/movie/11/324629.jpg@160w_220h_1e_1c‘, ‘泰坦尼克号’, ‘\n 主演：莱昂纳多·迪卡普里奥,凯特·温丝莱特,比利·赞恩\n ‘, ‘上映时间：1998-04-03’, ‘9.’, ‘5’), (‘7’, ‘http://p0.meituan.net/movie/99/678407.jpg@160w_220h_1e_1c‘, ‘龙猫’, ‘\n 主演：日高法子,坂本千夏,糸井重里\n ‘, ‘上映时间：1988-04-16(日本)’, ‘9.’, ‘2’), (‘8’, ‘http://p0.meituan.net/movie/92/8212889.jpg@160w_220h_1e_1c‘, ‘教父’, ‘\n 主演：马龙·白兰度,阿尔·帕西诺,詹姆斯·凯恩\n ‘, ‘上映时间：1972-03-24(美国)’, ‘9.’, ‘3’), (‘9’, ‘http://p0.meituan.net/movie/62/109878.jpg@160w_220h_1e_1c‘, ‘唐伯虎点秋香’, ‘\n 主演：周星驰,巩俐,郑佩佩\n ‘, ‘上映时间：1993-07-01(中国香港)’, ‘9.’, ‘2’), (‘10’, ‘http://p0.meituan.net/movie/9bf7d7b81001a9cf8adbac5a7cf7d766132425.jpg@160w_220h_1e_1c‘, ‘千与千寻’, ‘\n 主演：柊瑠美,入野自由,夏木真理\n ‘, ‘上映时间：2001-07-20(日本)’, ‘9.’, ‘3’)] &nbsp;&nbsp;&nbsp;&nbsp;但是这样还不够，数据比较杂乱，我们再将匹配结果处理一下，遍历提取结果并生成字典，此时方法改写如下:1234567891011121314def parse_one_page(html): pattern = re.compile( '&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;', re.S) items = re.findall(pattern, html) for item in items: yield &#123; 'index': item[0], 'image': item[1], 'title': item[2].strip(), 'actor': item[3].strip()[3:] if len(item[3]) &gt; 3 else '', 'time': item[4].strip()[5:] if len(item[4]) &gt; 5 else '', 'score': item[5].strip() + item[6].strip() &#125; &nbsp;&nbsp;&nbsp;&nbsp;这样就可以成功提取出电影地排名、图片、标题、演员、时间、评分等内容了，并把它赋值为一个个的字典，形成结构化数据。运行结果如下: {‘image’: ‘http://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg@160w_220h_1e_1c‘, ‘actor’: ‘张国荣,张丰毅,巩俐’, ‘score’: ‘9.6’, ‘index’: ‘1’, ‘title’: ‘霸王别姬’, ‘time’: ‘1993-01-01(中国香港)’}{‘image’: ‘http://p0.meituan.net/movie/__40191813__4767047.jpg@160w_220h_1e_1c‘, ‘actor’: ‘蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿’, ‘score’: ‘9.5’, ‘index’: ‘2’, ‘title’: ‘肖申克的救赎’, ‘time’: ‘1994-10-14(美国)’}{‘image’: ‘http://p0.meituan.net/movie/fc9d78dd2ce84d20e53b6d1ae2eea4fb1515304.jpg@160w_220h_1e_1c‘, ‘actor’: ‘让·雷诺,加里·奥德曼,娜塔莉·波特曼’, ‘score’: ‘9.5’, ‘index’: ‘3’, ‘title’: ‘这个杀手不太冷’, ‘time’: ‘1994-09-14(法国)’}{‘image’: ‘http://p0.meituan.net/movie/23/6009725.jpg@160w_220h_1e_1c‘, ‘actor’: ‘格利高利·派克,奥黛丽·赫本,埃迪·艾伯特’, ‘score’: ‘9.1’, ‘index’: ‘4’, ‘title’: ‘罗马假日’, ‘time’: ‘1953-09-02(美国)’}{‘image’: ‘http://p0.meituan.net/movie/53/1541925.jpg@160w_220h_1e_1c‘, ‘actor’: ‘汤姆·汉克斯,罗宾·怀特,加里·西尼斯’, ‘score’: ‘9.4’, ‘index’: ‘5’, ‘title’: ‘阿甘正传’, ‘time’: ‘1994-07-06(美国)’}{‘image’: ‘http://p0.meituan.net/movie/11/324629.jpg@160w_220h_1e_1c‘, ‘actor’: ‘莱昂纳多·迪卡普里奥,凯特·温丝莱特,比利·赞恩’, ‘score’: ‘9.5’, ‘index’: ‘6’, ‘title’: ‘泰坦尼克号’, ‘time’: ‘1998-04-03’}{‘image’: ‘http://p0.meituan.net/movie/99/678407.jpg@160w_220h_1e_1c‘, ‘actor’: ‘日高法子,坂本千夏,糸井重里’, ‘score’: ‘9.2’, ‘index’: ‘7’, ‘title’: ‘龙猫’, ‘time’: ‘1988-04-16(日本)’}{‘image’: ‘http://p0.meituan.net/movie/92/8212889.jpg@160w_220h_1e_1c‘, ‘actor’: ‘马龙·白兰度,阿尔·帕西诺,詹姆斯·凯恩’, ‘score’: ‘9.3’, ‘index’: ‘8’, ‘title’: ‘教父’, ‘time’: ‘1972-03-24(美国)’}{‘image’: ‘http://p0.meituan.net/movie/62/109878.jpg@160w_220h_1e_1c‘, ‘actor’: ‘周星驰,巩俐,郑佩佩’, ‘score’: ‘9.2’, ‘index’: ‘9’, ‘title’: ‘唐伯虎点秋香’, ‘time’: ‘1993-07-01(中国香港)’}{‘image’: ‘http://p0.meituan.net/movie/9bf7d7b81001a9cf8adbac5a7cf7d766132425.jpg@160w_220h_1e_1c‘, ‘actor’: ‘柊瑠美,入野自由,夏木真理’, ‘score’: ‘9.3’, ‘index’: ‘10’, ‘title’: ‘千与千寻’, ‘time’: ‘2001-07-20(日本)’}&nbsp;&nbsp;&nbsp;&nbsp;到此为止，我们就成功提取了单页的电影信息。 写入文件&nbsp;&nbsp;&nbsp;&nbsp;随后，我们将提取的结果写入文件，这里直接写入到一个文本文件中。这里通过JSON库的dumps()方法实现字典的序列化，并指定ensure_ascii参数为False，这样可以保证输出结果是中文形式而不是Unicode编码。代码如下:1234def write_to_json(content): with open('result.txt', 'a') as f: print(type(json.dumps(content))) f.write(json.dumps(content, ensure_ascii=False,).encode('utf-8')) &nbsp;&nbsp;&nbsp;&nbsp;通过调用write_to_json()方法即可实现将字典写入到文本文件的过程，此处的content参数就是一部电影的提取结果，是一个字典。 整合代码&nbsp;&nbsp;&nbsp;&nbsp;最后，实现main()方法来调用前面实现的方法，将单页的电影结果写入到文件中。相关代码如下:12345def main(): url = 'http://maoyan.com/board/4' html = get_one_page(url) for item in parse_one_page(html): write_to_json(item) 分页爬取&nbsp;&nbsp;&nbsp;&nbsp;因为我们需要抓取的是TOP100电影，所以还需要遍历一下，给这个链接传入offset参数，实现其他90部电影的爬取，此时添加如下调用即可:123if __name__ == '__main__': for i in range(11): main(offset=i * 10) &nbsp;&nbsp;&nbsp;&nbsp;这里还需要将main()方法修改一下，接收一个offset值作为偏移量，然后构造URL进行爬取。实现代码如下:123456def main(offset): url = 'http://maoyan.com/board/4?offset=' + str(offset) html = get_one_page(url) for item in parse_one_page(html): print(item) write_to_file(item) &nbsp;&nbsp;&nbsp;&nbsp;到此为止，我们的猫眼电影TOP100的爬虫就全部完成了，再稍微整理下，完整的代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!usr/bin/python# -*- coding: UTF-8 -*-import jsonimport requestsfrom requests.exceptions import RequestExceptionimport reimport timedef get_one_page(url): try: headers = &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36' &#125; response = requests.get(url, headers=headers) if response.status_code == 200: return response.text return None except RequestException: return Nonedef parse_one_page(html): pattern = re.compile('&lt;dd&gt;.*?board-index.*?&gt;(\d+)&lt;/i&gt;.*?data-src="(.*?)".*?name"&gt;&lt;a' + '.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*?)&lt;/p&gt;.*?releasetime"&gt;(.*?)&lt;/p&gt;' + '.*?integer"&gt;(.*?)&lt;/i&gt;.*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;', re.S) items = re.findall(pattern, html) for item in items: yield &#123; 'index': item[0], 'image': item[1], 'title': item[2], 'actor': item[3].strip()[3:], 'time': item[4].strip()[5:], 'score': item[5] + item[6] &#125;def write_to_file(content): with open('result.txt', 'a', encoding='utf-8') as f: f.write(json.dumps(content, ensure_ascii=False) + '\n')def main(offset): url = 'http://maoyan.com/board/4?offset=' + str(offset) html = get_one_page(url) for item in parse_one_page(html): print(item) write_to_file(item)if __name__ == '__main__': for i in range(10): main(offset=i * 10) time.sleep(1) &nbsp;&nbsp;&nbsp;&nbsp;现在猫眼多了反爬虫，如果速度过快，则会无响应，所以这里又增加了一个延时等待。 运行结果&nbsp;&nbsp;&nbsp;&nbsp;最后，我们运行一下代码，输出结果类似如下:123456&#123;'index': '1', 'image': 'http://p1.meituan.net/movie/20803f59291c47e1e116c11963ce019e68711.jpg@160w_220h_1e_1c', 'title': '霸王别姬', 'actor': '张国荣,张丰毅,巩俐', 'time': '1993-01-01(中国香港)', 'score': '9.6'&#125;&#123;'index': '2', 'image': 'http://p0.meituan.net/movie/__40191813__4767047.jpg@160w_220h_1e_1c', 'title': '肖申克的救赎', 'actor': '蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿', 'time': '1994-10-14(美国)', 'score': '9.5'&#125;...&#123;'index': '98', 'image': 'http://p0.meituan.net/movie/76/7073389.jpg@160w_220h_1e_1c', 'title': '东京物语', 'actor': '笠智众,原节子,杉村春子', 'time': '1953-11-03(日本)', 'score': '9.1'&#125;&#123;'index': '99', 'image': 'http://p0.meituan.net/movie/52/3420293.jpg@160w_220h_1e_1c', 'title': '我爱你', 'actor': '宋在河,李彩恩,吉海延', 'time': '2011-02-17(韩国)', 'score': '9.0'&#125;&#123;'index': '100', 'image': 'http://p1.meituan.net/movie/__44335138__8470779.jpg@160w_220h_1e_1c', 'title': '迁徙的鸟', 'actor': '雅克·贝汉,菲利普·拉波洛,Philippe Labro', 'time': '2001-12-12(法国)', 'score': '9.1'&#125; &nbsp;&nbsp;&nbsp;&nbsp;这里省略了中间的部分输出结果。可以看到，这样就成功地把TOP100的电影信息爬取下来了。&nbsp;&nbsp;&nbsp;&nbsp;这时我们再看下文本文件，结果如图所示。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F04%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;打开开源中国提供的正则表达式测试工具–&gt;在线正则表达式测试，输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。例如，这里输入待匹配的文本如下: Hello, my phone number is 086+18845658121 and email is sunstady@gmail.com, and my website is http://sanstylemc.cn &nbsp;&nbsp;&nbsp;&nbsp;这段字符串中包含了一个电话号码和一个电子邮件，接下来就尝试用正则表达式提取出来，如图所示。&nbsp;&nbsp;&nbsp;&nbsp;在网页右侧选择”匹配Email地址”，就可以看到下方出现了文本中的E-mail。如果选择”匹配网址URL”，就可以看到下方出现了文本中的URL。&nbsp;&nbsp;&nbsp;&nbsp;其实，这里就是用了正则表达式匹配，也就是用一定的规则将特定的文本提取出来。比如，电子邮件开头是一段字符串，然后是一个@符号，最后是某个域名，这是有特定的组成格式的。另外，对于URL，开头是协议类型，然后是冒号加双斜线，最后是域名加路径。&nbsp;&nbsp;&nbsp;&nbsp;对于URL来说，可以用下面的正则表达式匹配: [a-zA-z]+://[^\s]* &nbsp;&nbsp;&nbsp;&nbsp;用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似URL的文本，那就会被提取出来。&nbsp;&nbsp;&nbsp;&nbsp;这个正则表达式看上去是乱糟糟的一团，其实不然，这里面都是有特定的语法规则的。比如，a-z代表匹配任意的小写字母，\s表示匹配任意的空白字符，*就代表匹配前面的字符任意多个，这一长串的正则表达式就是这么多匹配规则的组合。&nbsp;&nbsp;&nbsp;&nbsp;写好正则表达式后，就可以拿它去一个长字符串里匹配查找了。不论这个字符串里面有什么，只要符合我们写的规则，统统可以找出来。对于网页来说，如果想找出网页源码里有多少个URL，用匹配URL的正则表达式去匹配即可。&nbsp;&nbsp;&nbsp;&nbsp;下面是常用的匹配规则。 模式 描述 \w 匹配字母、数字及下划线 \W 匹配不是字母、数字及下划线的字符 \s 匹配任意空白字符，等价于[\t\n\r\f] \S 匹配任意非空字符 \d 匹配任意数字，等价于[0-9] \D 匹配任意非数字的字符 \A 匹配字符串开头 \Z 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串 \z 匹配字符串结尾，如果存在换行，同时还会匹配换行符 \G 匹配最后匹配完成的位置 \n 匹配一个换行符 \t 匹配一个制表符 ^ 匹配一行字符串的开头 $ 匹配一行字符串的结尾 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符 […] 用来表示一组字符，单独列出，比如[amk]匹配a、m或k [^…] 不在[]中的字符，比如[^abc]匹配除了a、b、c之外的字符 * 匹配0个或多个表达式 + 匹配1个或多个表达式 ? 匹配0个或1个前面的正则表达式定义的片段，非贪婪方式 {n} 精确匹配n个前面的表达式 {n,m} 匹配n到m次由前面正则表达式定义的片段，贪婪方式 a\b 匹配a或b () 匹配括号内的表达式，也表示一个组 match()&nbsp;&nbsp;&nbsp;&nbsp;向它传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。&nbsp;&nbsp;&nbsp;&nbsp;match()方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回None。示例如下:12345678import re content = 'Hello 123 4567 World_This is a Regex Demo'print(len(content))result = re.match('^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;', content)print(result)print(result.group())print(result.span()) 运行结果如下:123441&lt;_sre.SRE_Match object; span=(0, 25), match='Hello 123 4567 World_This'&gt;Hello 123 4567 World_This(0, 25) &nbsp;&nbsp;&nbsp;&nbsp;这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式。1^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125; &nbsp;&nbsp;&nbsp;&nbsp;用它来匹配这个长字符串。开头的^是匹配字符串的开头，也就是以Hello开头；然后\s匹配空白字符，用来匹配目标字符串的空格；\d匹配数字，3个\d匹配123；然后再写1个\s匹配空格；后面还有4567，我们其实可以依然用4个\d来匹配，但是这么写比较烦琐，所以后面可以跟{4}以代表匹配前面的规则4次，也就是匹配4个数字；然后后面再紧接1个空白字符，最后\w{10}匹配10个字母及下划线。我们注意到，这里其实并没有把目标字符串匹配完，不过这样依然可以进行匹配，只不过匹配结果短一点而已。&nbsp;&nbsp;&nbsp;&nbsp;而在match()方法中，第一个参数传入了正则表达式，第二个参数传入了要匹配的字符串。&nbsp;&nbsp;&nbsp;&nbsp;打印输出结果，可以看到结果是SRE_Match()对象，这证明成功匹配。该对象有两个方法: group()方法可以输出匹配到的内容，结果是Hello 123 4567 World_This，这恰好是正则表达式规则所匹配的内容；span()方法可以输出匹配的范围，结果是(0, 25)，这就是匹配到的结果字符串在原字符串中的位置范围。 匹配目标&nbsp;&nbsp;&nbsp;&nbsp;刚才我们用match()方法可以得到匹配到的字符串内容，但是如果想从字符串中提取一部分内容，该怎么办呢？就像最前面的实例一样，从一段文本中提取出邮件或电话号码等内容。&nbsp;&nbsp;&nbsp;&nbsp;这里可以使用()括号将想提取的子字符串括起来。()实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用group()方法传入分组的索引即可获取提取的结果。示例如下:12345678import re content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^Hello\s(\d+)\sWorld', content)print(result)print(result.group())print(result.group(1))print(result.span()) &nbsp;&nbsp;&nbsp;&nbsp;这里我们想把字符串中的1234567提取出来，此时可以将数字部分的正则表达式用()括起来，然后调用了group(1)获取匹配结果。运行结果如下:1234&lt;_sre.SRE_Match object; span=(0, 19), match='Hello 1234567 World'&gt;Hello 1234567 World1234567(0, 19) &nbsp;&nbsp;&nbsp;&nbsp;可以看到，我们成功得到了1234567。这里用的是group(1)，它与group()有所不同，后者会输出完整的匹配结果，而前者会输出第一个被()包围的匹配结果。假如正则表达式后面还有()包括的内容，那么可以依次用group(2)、group(3)等来获取。 通用匹配&nbsp;&nbsp;&nbsp;&nbsp;刚才我们写的正则表达式其实比较复杂，出现空白字符我们就写\s匹配，出现数字我们就用\d匹配，这样的工作量非常大。其实完全没必要这么做，因为还有一个万能匹配可以用，那就是.*（点星）。其中.（点）可以匹配任意字符（除换行符），*（星）代表匹配前面的字符无限次，所以它们组合在一起就可以匹配任意字符了。有了它，我们就不用挨个字符地匹配了。&nbsp;&nbsp;&nbsp;&nbsp;接着上面的例子，我们可以改写一下正则表达式:1234567import re content = 'Hello 123 4567 World_This is a Regex Demo'result = re.match('^Hello.*Demo$', content)print(result)print(result.group())print(result.span()) &nbsp;&nbsp;&nbsp;&nbsp;这里我们将中间部分直接省略，全部用.*来代替，最后加一个结尾字符串就好了。运行结果如下:123&lt;_sre.SRE_Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo(0, 41) &nbsp;&nbsp;&nbsp;&nbsp;可以看到，group()方法输出了匹配的全部字符串，也就是说我们写的正则表达式匹配到了目标字符串的全部内容；span()方法输出(0, 41)，这是整个字符串的长度。&nbsp;&nbsp;&nbsp;&nbsp;因此，我们可以用.*简化正则表达式的书写。 贪婪与非贪婪&nbsp;&nbsp;&nbsp;&nbsp;使用上面的.*时，可能有时候匹配到的并不是我们想要的结果。看下面的例子:123456import re content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*(\d+).*Demo$', content)print(result)print(result.group(1)) &nbsp;&nbsp;&nbsp;&nbsp;这里我们依然想获取中间的数字，所以中间依然写的是(\d+)。而数字两侧由于内容比较杂乱，所以想省略来写，都写成.*。最后，组成^He.*(\d+).*Demo$，看样子并没有什么问题。我们看下运行结果:12&lt;_sre.SRE_Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;7 &nbsp;&nbsp;&nbsp;&nbsp;发现我们只得到数字7。&nbsp;&nbsp;&nbsp;&nbsp;这里就涉及一个贪婪与非贪婪匹配的问题了。在贪婪匹配下，.*会匹配尽可能多的字符。正则表达式中.*后面是\d+，也就是至少一个数字，并没有指定具体多少个数字，因此，.*就尽可能匹配多的字符，这里就把123456匹配了，给\d+留下一个可满足条件的数字7，最后得到的内容就只有数字7了。&nbsp;&nbsp;&nbsp;&nbsp;但这很明显会给我们带来很大的不便。有时候，匹配结果会莫名其妙少了一部分内容。其实，这里只需要使用非贪婪匹配就好了。非贪婪匹配的写法是.*?，多了一个?，那么它可以达到怎样的效果？我们再用实例看一下:123456import re content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*?(\d+).*Demo$', content)print(result)print(result.group(1)) &nbsp;&nbsp;&nbsp;&nbsp;这里我们只是将第一个.*改成了.*?，转变为非贪婪匹配。结果如下:12&lt;_sre.SRE_Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567 &nbsp;&nbsp;&nbsp;&nbsp;此时就可以成功获取1234567了。原因可想而知，贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当.*?匹配到Hello后面的空白字符时，再往后的字符就是数字了，而\d+恰好可以匹配，那么这里.*?就不再进行匹配，交给\d+去匹配后面的数字。所以这样.*?匹配了尽可能少的字符，\d+的结果就是1234567了。&nbsp;&nbsp;&nbsp;&nbsp;所以说，在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用.*?来代替.*，以免出现匹配结果缺失的情况。&nbsp;&nbsp;&nbsp;&nbsp;但这里需要注意，如果匹配的结果在字符串结尾，.*?就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如:1234567import re content = 'http://weibo.com/comment/kEraCN'result1 = re.match('http.*?comment/(.*?)', content)result2 = re.match('http.*?comment/(.*)', content)print('result1', result1.group(1))print('result2', result2.group(1)) 运行结果如下:12result1 result2 kEraCN &nbsp;&nbsp;&nbsp;&nbsp;可以观察到，.*?没有匹配到任何结果，而.*则尽量匹配多的内容，成功得到了匹配结果。 修饰符&nbsp;&nbsp;&nbsp;&nbsp;正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。我们用实例来看一下:1234567import re content = '''Hello 1234567 World_Thisis a Regex Demo'''result = re.match('^He.*?(\d+).*?Demo$', content)print(result.group(1)) &nbsp;&nbsp;&nbsp;&nbsp;和上面的例子相仿，我们在字符串中加了换行符，正则表达式还是一样的，用来匹配其中的数字。看一下运行结果:1234567AttributeError Traceback (most recent call last)&lt;ipython-input-18-c7d232b39645&gt; in &lt;module&gt;() 5 ''' 6 result = re.match('^He.*?(\d+).*?Demo$', content)----&gt; 7 print(result.group(1)) AttributeError: 'NoneType' object has no attribute 'group' &nbsp;&nbsp;&nbsp;&nbsp;运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为None，而我们又调用了group()方法导致AttributeError。&nbsp;&nbsp;&nbsp;&nbsp;那么，为什么加了一个换行符，就匹配不到了呢？这是因为\.匹配的是除换行符之外的任意字符，当遇到换行符时，.*?就不能匹配了，所以导致匹配失败。这里只需加一个修饰符re.S，即可修正这个错误:1result = re.match('^He.*?(\d+).*?Demo$', content, re.S) &nbsp;&nbsp;&nbsp;&nbsp;这个修饰符的作用是使.匹配包括换行符在内的所有字符。此时运行结果如下:11234567 &nbsp;&nbsp;&nbsp;&nbsp;这个re.S在网页匹配中经常用到。因为HTML节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。&nbsp;&nbsp;&nbsp;&nbsp;另外，还有一些修饰符，在必要的情况下也可以使用。 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响^和$ re.S 使.匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响\w、\W、 \b和\B re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 在网页匹配中，较为常用的有re.S和re.I。 转义匹配&nbsp;&nbsp;&nbsp;&nbsp;我们知道正则表达式定义了许多匹配模式，如.匹配除换行符以外的任意字符，但是如果目标字符串里面就包含.，那该怎么办呢？&nbsp;&nbsp;&nbsp;&nbsp;这里就需要用到转义匹配了，示例如下:12345import re content = '(百度)www.baidu.com'result = re.match('\(百度\)www\.baidu\.com', content)print(result) &nbsp;&nbsp;&nbsp;&nbsp;当遇到用于正则匹配模式的特殊字符时，在前面加反斜线转义一下即可。例如.就可以用.来匹配，运行结果如下:1&lt;_sre.SRE_Match object; span=(0, 17), match='(百度)www.baidu.com'&gt; 可以看到，这里成功匹配到了原字符串。 search()&nbsp;&nbsp;&nbsp;&nbsp;前面提到过，match()方法是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就失败了。我们看下面的例子:12345import re content = 'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'result = re.match('Hello.*?(\d+).*?Demo', content)print(result) &nbsp;&nbsp;&nbsp;&nbsp;这里的字符串以Extra开头，但是正则表达式以Hello开头，整个正则表达式是字符串的一部分，但是这样匹配是失败的。运行结果如下:1None &nbsp;&nbsp;&nbsp;&nbsp;因为match()方法在使用时需要考虑到开头的内容，这在做匹配时并不方便。它更适合用来检测某个字符串是否符合某个正则表达式的规则。&nbsp;&nbsp;&nbsp;&nbsp;这里就有另外一个方法search()，它在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果。也就是说，正则表达式可以是字符串的一部分，在匹配时，search()方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，就返回None。&nbsp;&nbsp;&nbsp;&nbsp;我们把上面代码中的match()方法修改成search()，再看下运行结果:12&lt;_sre.SRE_Match object; span=(13, 53), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567 &nbsp;&nbsp;&nbsp;&nbsp;这时就得到了匹配结果。&nbsp;&nbsp;&nbsp;&nbsp;因此，为了匹配方便，我们可以尽量使用search()方法。&nbsp;&nbsp;&nbsp;&nbsp;下面再用几个实例来看看search()方法的用法。&nbsp;&nbsp;&nbsp;&nbsp;首先，这里有一段待匹配的HTML文本，接下来写几个正则表达式实例来实现相应信息的提取:1234567891011121314151617181920html = '''&lt;div id="songs-list"&gt; &lt;h2 class="title"&gt;经典老歌&lt;/h2&gt; &lt;p class="introduction"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id="list" class="list-group"&gt; &lt;li data-view="2"&gt;一路上有你&lt;/li&gt; &lt;li data-view="7"&gt; &lt;a href="/2.mp3" singer="任贤齐"&gt;沧海一声笑&lt;/a&gt; &lt;/li&gt; &lt;li data-view="4" class="active"&gt; &lt;a href="/3.mp3" singer="齐秦"&gt;往事随风&lt;/a&gt; &lt;/li&gt; &lt;li data-view="6"&gt;&lt;a href="/4.mp3" singer="beyond"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt; &lt;li data-view="5"&gt;&lt;a href="/5.mp3" singer="陈慧琳"&gt;记事本&lt;/a&gt;&lt;/li&gt; &lt;li data-view="5"&gt; &lt;a href="/6.mp3" singer="邓丽君"&gt;&lt;i class="fa fa-user"&gt;&lt;/i&gt;但愿人长久&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;''' &nbsp;&nbsp;&nbsp;&nbsp;可以观察到，ul节点里有许多li节点，其中li节点中有的包含a节点，有的不包含a节点，a节点还有一些相应的属性——超链接和歌手名。&nbsp;&nbsp;&nbsp;&nbsp;首先，我们尝试提取class为active的li节点内部的超链接包含的歌手名和歌名，此时需要提取第三个li节点下a节点的singer属性和文本。&nbsp;&nbsp;&nbsp;&nbsp;此时正则表达式可以以li开头，然后寻找一个标志符active，中间的部分可以用.*?来匹配。接下来，要提取singer这个属性值，所以还需要写入singer=&quot;(.*?)&quot;，这里需要提取的部分用小括号括起来，以便用group()方法提取出来，它的两侧边界是双引号。然后还需要匹配a节点的文本，其中它的左边界是&gt;，右边界是&lt;/a&gt;。然后目标内容依然用(.*?)来匹配，所以最后的正则表达式就变成了:1&lt;li.*?active.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt; &nbsp;&nbsp;&nbsp;&nbsp;然后再调用search()方法，它会搜索整个HTML文本，找到符合正则表达式的第一个内容返回。&nbsp;&nbsp;&nbsp;&nbsp;另外，由于代码有换行，所以这里第三个参数需要传入re.S。整个匹配代码如下:123result = re.search('&lt;li.*?active.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;', html, re.S)if result: print(result.group(1), result.group(2)) &nbsp;&nbsp;&nbsp;&nbsp;由于需要获取的歌手和歌名都已经用小括号包围，所以可以用group()方法获取。&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1齐秦 往事随风 &nbsp;&nbsp;&nbsp;&nbsp;可以看到，这正是class为active的li节点内部的超链接包含的歌手名和歌名。&nbsp;&nbsp;&nbsp;&nbsp;如果正则表达式不加active（也就是匹配不带class为active的节点内容），那会怎样呢？我们将正则表达式中的active去掉，代码改写如下:123result = re.search('&lt;li.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;', html, re.S)if result: print(result.group(1), result.group(2)) &nbsp;&nbsp;&nbsp;&nbsp;由于search()方法会返回第一个符合条件的匹配目标，这里结果就变了:1任贤齐 沧海一声笑 &nbsp;&nbsp;&nbsp;&nbsp;把active标签去掉后，从字符串开头开始搜索，此时符合条件的节点就变成了第二个li节点，后面的就不再匹配，所以运行结果就变成第二个li节点中的内容。&nbsp;&nbsp;&nbsp;&nbsp;注意，在上面的两次匹配中，search()方法的第三个参数都加了re.S，这使得.*?可以匹配换行，所以含有换行的li节点被匹配到了。如果我们将其去掉，结果会是什么？代码如下:123result = re.search('&lt;li.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;', html)if result: print(result.group(1), result.group(2)) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1beyond 光辉岁月 &nbsp;&nbsp;&nbsp;&nbsp;可以看到，结果变成了第四个li节点的内容。这是因为第二个和第三个li节点都包含了换行符，去掉re.S之后，.*?已经不能匹配换行符，所以正则表达式不会匹配到第二个和第三个li节点，而第四个li节点中不包含换行符，所以成功匹配。&nbsp;&nbsp;&nbsp;&nbsp;由于绝大部分的HTML文本都包含了换行符，所以尽量都需要加上re.S修饰符，以免出现匹配不到的问题。 findall()&nbsp;&nbsp;&nbsp;&nbsp;前面我们介绍了search()方法的用法，它可以返回匹配正则表达式的第一个内容，但是如果想要获取匹配正则表达式的所有内容，那该怎么办呢？这时就要借助findall()方法了。该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容。还是上面的HTML文本，如果想获取所有a节点的超链接、歌手和歌名，就可以将search()方法换成findall()方法。如果有返回结果的话，就是列表类型，所以需要遍历一下来依次获取每组内容。代码如下:123456results = re.findall('&lt;li.*?href="(.*?)".*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;', html, re.S)print(results)print(type(results))for result in results: print(result) print(result[0], result[1], result[2]) 运行结果如下:123456789101112[('/2.mp3', '任贤齐', '沧海一声笑'), ('/3.mp3', '齐秦', '往事随风'), ('/4.mp3', 'beyond', '光辉岁月'), ('/5.mp3', '陈慧琳', '记事本'), ('/6.mp3', '邓丽君', '但愿人长久')]&lt;class 'list'&gt;('/2.mp3', '任贤齐', '沧海一声笑')/2.mp3 任贤齐 沧海一声笑('/3.mp3', '齐秦', '往事随风')/3.mp3 齐秦 往事随风('/4.mp3', 'beyond', '光辉岁月')/4.mp3 beyond 光辉岁月('/5.mp3', '陈慧琳', '记事本')/5.mp3 陈慧琳 记事本('/6.mp3', '邓丽君', '但愿人长久')/6.mp3 邓丽君 但愿人长久 &nbsp;&nbsp;&nbsp;&nbsp;可以看到，返回的列表中的每个元素都是元组类型，我们用对应的索引依次取出即可。&nbsp;&nbsp;&nbsp;&nbsp;如果只是获取第一个内容，可以用search()方法。当需要提取多个内容时，可以用findall()方法。 sub()&nbsp;&nbsp;&nbsp;&nbsp;除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。比如，想要把一串文本中的所有数字都去掉，如果只用字符串的replace()方法，那就太烦琐了，这时可以借助sub()方法。示例如下:12345import re content = '54aK54yr5oiR54ix5L2g'content = re.sub('\d+', '', content)print(content) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1aKyroiRixLg &nbsp;&nbsp;&nbsp;&nbsp;这里只需要给第一个参数传入\d+来匹配所有的数字，第二个参数为替换成的字符串（如果去掉该参数的话，可以赋值为空），第三个参数是原字符串。&nbsp;&nbsp;&nbsp;&nbsp;在上面的HTML文本中，如果想获取所有li节点的歌名，直接用正则表达式来提取可能比较烦琐。比如，可以写成这样子:123results = re.findall('&lt;li.*?&gt;\s*?(&lt;a.*?&gt;)?(\w+)(&lt;/a&gt;)?\s*?&lt;/li&gt;', html, re.S)for result in results: print(result[1]) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:123456一路上有你沧海一声笑往事随风光辉岁月记事本但愿人长久 &nbsp;&nbsp;&nbsp;&nbsp;此时借助sub()方法就比较简单了。可以先用sub()方法将a节点去掉，只留下文本，然后再利用findall()提取就好了:12345html = re.sub('&lt;a.*?&gt;|&lt;/a&gt;', '', html)print(html)results = re.findall('&lt;li.*?&gt;(.*?)&lt;/li&gt;', html, re.S)for result in results: print(result.strip()) &nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:1234567891011121314151617181920212223242526&lt;div id="songs-list"&gt; &lt;h2 class="title"&gt;经典老歌&lt;/h2&gt; &lt;p class="introduction"&gt; 经典老歌列表 &lt;/p&gt; &lt;ul id="list" class="list-group"&gt; &lt;li data-view="2"&gt;一路上有你&lt;/li&gt; &lt;li data-view="7"&gt; 沧海一声笑 &lt;/li&gt; &lt;li data-view="4" class="active"&gt; 往事随风 &lt;/li&gt; &lt;li data-view="6"&gt;光辉岁月&lt;/li&gt; &lt;li data-view="5"&gt;记事本&lt;/li&gt; &lt;li data-view="5"&gt; 但愿人长久 &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;一路上有你沧海一声笑往事随风光辉岁月记事本但愿人长久 &nbsp;&nbsp;&nbsp;&nbsp;可以看到，a节点经过sub()方法处理后就没有了，然后再通过findall()方法直接提取即可。可以看到，在适当的时候，借助sub()方法可以起到事半功倍的效果。 compile()&nbsp;&nbsp;&nbsp;&nbsp;前面所讲的方法都是用来处理字符串的方法，最后再介绍一下compile()方法，这个方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。示例代码如下:12345678910import re content1 = '2016-12-15 12:00'content2 = '2016-12-17 12:55'content3 = '2016-12-22 13:21'pattern = re.compile('\d&#123;2&#125;:\d&#123;2&#125;')result1 = re.sub(pattern, '', content1)result2 = re.sub(pattern, '', content2)result3 = re.sub(pattern, '', content3)print(result1, result2, result3) &nbsp;&nbsp;&nbsp;&nbsp;例如，这里有3个日期，我们想分别将3个日期中的时间去掉，这时可以借助sub()方法。该方法的第一个参数是正则表达式，但是这里没有必要重复写3个同样的正则表达式，此时可以借助compile()方法将正则表达式编译成一个正则表达式对象，以便复用。&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下:12016-12-15 2016-12-17 2016-12-22 &nbsp;&nbsp;&nbsp;&nbsp;另外，compile()还可以传入修饰符，例如re.S等修饰符，这样在search()、findall()等方法中就不需要额外传了。所以，compile()方法可以说是给正则表达式做了一层封装，以便我们更好地复用。]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下SCP指令的使用]]></title>
    <url>%2F2018%2F04%2F07%2FLinux%E4%B8%8BSCP%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SCP，即Secure copy的简写。通常在Linux下执行远程拷贝文件使用，他和cp指令类似，只不过cp是本机使用，而SCP则是跨机器使用。SCP传输是基于SSH的加密传输，也就是说知道SSH的账密就可以上下载文件了，因此比较安全。SCP常用实例(在Linux的centos环境下为例，从服务器上下载一个文件到本地)1、从远程服务器下载文件到本地服务器。 scp 用户名@IP地址:/home/1.txt ./ 2、Linux下，通过指定端口从远程服务器下载文件到本地。 scp -oPort=端口号 用户名@IP地址:/opt/ftp-0.17054.el6.x86_64.rpm ./ 3、Linux下，通过指定端口将本地文件，上传到远程服务器指定目录下。 scp -oPort=端口号 -r ./1.txt 用户名@IP地址:/opt/]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公平锁与非公平锁]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在Java并发编程中，公平锁与非公平锁是很常见的概念，ReentrantLock、ReadWriteLock默认都是非公平模式，非公平锁的效率为何高于公平锁呢？公平锁与非公平锁有什么区别呢？&nbsp;&nbsp;&nbsp;&nbsp;首先先简单从名字上来理解，公平锁就是保障了多线程下各种线程取锁的顺序，先到的线程优先获取锁，而非公平锁则无法提供这个保障。看到网上很多说法说非公平锁获取锁时各线程的概率是随机的，这也是一种很不确切的说法。非公平锁并非真正的随机，其获取锁还是有一定顺序的，但其顺序究竟是怎样呢？先看图:公平锁与非公平锁的一个重要区别就在于上图中的2、6、10那个步骤，对应源码如下:123456789101112131415161718192021222324252627282930313233343536373839404142//非公平锁final boolean nonfairTryAcquire(int acquires) &#123; final Thread current= Thread.currentThread(); int c= getState(); if (c== 0) &#123; //区别重点在这里 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current== getExclusiveOwnerThread()) &#123; int nextc= c+ acquires; if (nextc&lt; 0) &#123; throw new Error("Maximum lock count exceeded"); &#125; setState(true); return true; &#125; return false;&#125;//公平锁final boolean nonfairTryAcquire(int acquires) &#123; final Thread current= Thread.currentThread(); int c= getState(); if (c== 0) &#123; //hasQueuedPredecessors这个方法就是最大区别所在 if (!hasQueuedPredecessors()&amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current== getExclusiveOwnerThread()) &#123; int nextc= c+ acquires; if (nextc&lt; 0) &#123; throw new Error("Maximum lock count exceeded"); &#125; setState(true); return true; &#125; return false;&#125; 分析以上代码，我们可以看到公平锁就是在获取锁之前会先判断等待队列是否为空或者自己是否位于队列头部，该条件通过才能继续获取锁。在结合兔子喝水的图分析，非公平锁获取所得顺序基本确定在9、10、11这三个事件发生的先后顺序:1、若在释放锁的时候总是没有新的兔子来打扰，则非公平锁等于公平锁；2、若释放锁的时候，正好一个兔子来喝水，而此时位于队列头的兔子还没有被唤醒(因为线程上下文切换是需要不少开销的)，此时后来的兔子则优先获得锁，成功打破公平，成为非公平锁。其实对于非公平锁，只要线程进入了等待队列， 队列里面依然是FIFO的原则，跟公平锁的顺序是一样的。因为公平锁与非公平锁的release()部分代码是公用AQS的代码。12345678910111213141516171819private void unparkSuccessor(Node node) &#123; int ws= node.waitStatus; if(ws&lt; 0) &#123; compareAndSetWaitStatus(node, ws, 0); &#125; Node s= node.next; if (s== null|| s.waitStatus&gt; 0) &#123; s= null; for(Node t= tail; t!= null&amp;&amp; t!= node; t= t.prev) &#123; if (t.waitStatus&lt;= 0) &#123; s= t; &#125; &#125; &#125; if (s!= null) &#123; //唤醒队列头的线程 LockSupport.unpark(s.thread); &#125;&#125; 上文说到的线程切换的开销，其实就是非公平锁效率高于公平锁的原因，因为非公平锁减少了线程挂起的几率，后来的线程有一定几率逃离被挂起的开销。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py统计单词个数]]></title>
    <url>%2F2018%2F04%2F06%2Fpy%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[任一个英文的纯文本文件，统计其中的单词出现的个数123456789101112131415import stringf= open(r'C:\Users\12905\Desktop\1.txt', 'r+') #从文件中读取内容str1= f.read()str= str1.lower() #全部切换成小写list= str.split() #切片list1= []for i in range(0, len(list)): list[i]= list[i].strip(string.punctuation)for word in list: if word not in list1: list1.append(word)for word in list1: print(word, list.count(word)) 运行结果如下图所示:]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py生成图片验证码]]></title>
    <url>%2F2018%2F04%2F06%2Fpy%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[生成图片二维码，并判断填写的验证码是否正确。1234567891011121314151617181920212223242526272829import randomimport stringimport sysfrom PIL import Image,ImageDraw,ImageFontdef random_text (): #生成一串4位的随机字符串 text= string.digits+ string.ascii_letters str= '' for i in range(0, 4): str= str+ text[random.randint(0, len(text))] return strdef get_code (str): width= 120 height= 60 #设置图片大小 color= (43, 34, 88) #设置图片颜色 image= Image.new('RGB', (width, height), color) #创建图片 fontl= ImageFont.truetype("simsun.ttc", 40, index= 1) #设置字体样式 draw= ImageDraw.Draw(image) #将验证码画到图片上 draw.text((20, 10), str, fill=(355, 0, 0), font= fontl) image.show()s= random_text()get_code(s)code= input("请输入图片中的验证码: ")if s.lower()== code.lower(): print("验证码输入正确")else: print ("验证码输入错误") 运行结果如图所示:]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的生命周期]]></title>
    <url>%2F2018%2F04%2F06%2F%E7%BA%BF%E7%A8%8B%E5%9C%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;当线程被创建并启动后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)和死亡(Dead)五种状态。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。 1、新建状态: 当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。2、就绪状态: 当线程对象调用了start()方法后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。3、运行状态: 如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态。4、阻塞状态: 当处于运行状态的线程失去所占用资源后，便进入阻塞状态。5、死亡状态: 当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能进入就绪状态等待执行。 新建和就绪状态&nbsp;&nbsp;&nbsp;&nbsp;当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。&nbsp;&nbsp;&nbsp;&nbsp;当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。 注意：启动线程使用start()方法，而不是run()方法。永远不要调用线程对象的run()方法。调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理；但如果直按调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。需要指出的是，调用了线程的run()方法之后，该线程已经不再处于新建状态，不要再次调用线程对象的start()方法。只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常。 &nbsp;&nbsp;&nbsp;&nbsp;调用线程对象的start()方法之后，该线程立即进入就绪状态——就绪状态相当于”等待执行”，但该线程并未真正进入运行状态。如果希望调用子线程的start()方法后子线程立即开始执行，程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行。 运行和阻塞状态&nbsp;&nbsp;&nbsp;&nbsp;如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU。那么在任何时刻只有一个线程处于运行状态，当然在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。&nbsp;&nbsp;&nbsp;&nbsp;当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了）。线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。&nbsp;&nbsp;&nbsp;&nbsp;所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机则可能采用协作式调度策略，在这样的系统中，只有当一个线程调用了它的sleep()或yield()方法后才会放弃所占用的资源——也就是必须由该线程主动放弃所占用的资源。&nbsp;&nbsp;&nbsp;&nbsp;当发生如下情况时，线程将会进入阻塞状态 1、线程调用sleep()方法主动放弃所占用的处理器资源。2、线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。3、线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。4、线程在等待某个通知(notify)5、程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。 &nbsp;&nbsp;&nbsp;&nbsp;当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。&nbsp;&nbsp;&nbsp;&nbsp;针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态 1、调用sleep()方法的线程经过了指定时间2、线程调用的阻塞式IO方法已经返回3、线程成功地获得了识图取得地同步监视器4、线程正在等待的某个通知时，其他线程发出了一个通知（signal）5、处于挂起状态地线程被调用了resume()恢复方法 线程死亡&nbsp;&nbsp;&nbsp;&nbsp;线程会以如下三种方式结束，结束以后就处于死亡状态 1、run()或call()方法执行完成，线程正常结束2、线程抛出一个未捕获地Exception或Error3、直接调用该线程stop()方法来结束该线程–该方法容易导致死锁，通常不推荐使用。 注意: 当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，他就拥有和主线程相同地地位，他不会受主线程地影响。为了测试某个线程是否已经死亡，可以调用线程对象的isAlivc()方法，当线程处于就绪、运行、阻塞了种状态时，该方法将返回true；当线程处于新建、死亡状态时，该方法将返回false。 不要试图对一个已经死亡的线程调用start()方法使它重新启动，死亡就是死亡，该线程将不可再次作为线程执行。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sleep()和wait()的区别]]></title>
    <url>%2F2018%2F04%2F06%2Fsleep-%E5%92%8Cwait-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;对于sleep()方法，该方法是属于Thread类中的。而wait()方法是属于Object()类中的。&nbsp;&nbsp;&nbsp;&nbsp;sleep()方法导致了程序暂停执行指定的时间，让出cpu改其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。&nbsp;&nbsp;&nbsp;&nbsp;在调用sleep()方法的过程中，线程不会释放对象锁。&nbsp;&nbsp;&nbsp;&nbsp;而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。举个例子说明:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class long1_1 &#123; public static void main(String[] args) &#123; new Thread(new Thread1()).start(); try &#123; Thread.sleep(5000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; new Thread(new Thread2()).start(); &#125; private static class Thread1 implements Runnable &#123; @Override public void run() &#123; synchronized (long1_1.class) &#123; System.out.println("enter thread1..."); System.out.println("thread1 is waiting..."); try &#123; // 调用wait()方法，线程会放弃对象锁，进入等待此对象的等待锁定池 long1_1.class.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("thread1 is going on ...."); System.out.println("thread1 is over!!!"); &#125; &#125; &#125; private static class Thread2 implements Runnable &#123; @Override public void run() &#123; synchronized (long1_1.class) &#123; System.out.println("enter thread2...."); System.out.println("thread2 is sleep...."); // 只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。 long1_1.class.notify(); // ================== // 区别 // 如果我们把代码：TestD.class.notify();给注释掉，即TestD.class调用了wait()方法，但是没有调用notify() // 方法，则线程永远处于挂起状态。 try &#123; // sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程， // 但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。 // 在调用sleep()方法的过程中，线程不会释放对象锁。 Thread.sleep(5000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("thread2 is going on...."); System.out.println("thread2 is over!!!"); &#125; &#125; &#125;&#125; 运行结果如下:如果注释掉long1_1.class.notify();运行结果如下:且程序一直处于挂起状态。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[start和run的区别]]></title>
    <url>%2F2018%2F04%2F06%2Fstart%E5%92%8Crun%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[run()方法:在本线程内调用Runnable对象的run()方法，可以重复多次调用。start()方法:启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程。这个解释看过好多次了，但是理解不够，现在想想，其实run方法并不是启动线程，而是方法调用，在主线程中调用一个对象的run()方法而已，而start才是真的启动来了一个线程。看一下代码:1234567891011121314151617181920public class long1_1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TestThread tt = new TestThread(); tt.run(); &#125; &#125; class TestThread extends Thread &#123; static int i = 0; final static int MAX_I = 10; @Override public void run() &#123; // TODO Auto-generated method stub while (i &lt; MAX_I) &#123; System.out.println(i++); &#125; &#125; &#125; 运行结果如下:或许有人会得出结论，这样启动一个线程是可以的，我们再对程式稍作修改，会发现一个问题:123456789101112131415161718192021public class long1_1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TestThread tt = new TestThread(); tt.run(); System.out.println("Printed by main thread"); &#125; &#125; class TestThread extends Thread &#123; static int i = 0; final static int MAX_I = 10; @Override public void run() &#123; // TODO Auto-generated method stub while (i &lt; MAX_I) &#123; System.out.println(i++); &#125; &#125; &#125; 这里只在主线程中加入了一行代码，打印一行”Printed by main thread”，运行代码，结果如下:熟练多线程的开发的要发现问题了，为什么”Printed by main thread”会打印在最后一行呢？TestThread类中一直持有时间段吗？对上面的代码进行分析，其实非常简单，这只是一个普通的类中方法的调用，其实是一个单线程的执行，我们来修改代码进一步验证下:1234567891011121314151617181920212223public class long1_1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TestThread tt = new TestThread(); tt.run(); System.out.println(Thread.currentThread().getName()); System.out.println("Printed by main thread"); &#125; &#125; class TestThread extends Thread &#123; static int i = 0; final static int MAX_I = 10; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()); while (i &lt; MAX_I) &#123; System.out.println(i++); &#125; &#125; &#125; 这段代码分别在主线程和我们的TestThread的方法中打印当前线程名字，运行结果如下:在TestThread类和主线程中运行的是同一个线程，说明在直接调用run时是不能使用多线程的，那么把上面的run方法调用改为start方法的调动再看一下。1234567891011121314151617181920212223public class long1_1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TestThread tt = new TestThread(); tt.start(); System.out.println(Thread.currentThread().getName()); System.out.println("Printed by main thread"); &#125; &#125; class TestThread extends Thread &#123; static int i = 0; final static int MAX_I = 10; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()); while (i &lt; MAX_I) &#123; System.out.println(i++); &#125; &#125; &#125; 运行结果如下:很明显，这才是我们想看到的结果，所以结论是只有调用Thread的start方法，将线程交由JVM控制，才能产生多线程，而直接调用run方法只是一个普通的单线程程式。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是线程池]]></title>
    <url>%2F2018%2F04%2F06%2F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;到目前为止我们使用多线程应用程序的目的是尽可能多地使用计算机处理器资源。所以，看起来我们仅需要为每个独立的任务分配一个不同的线程，并让处理器确定在任何时间它总会处理其中的某一个任务。额，对小系统来说这样做很好。但是当系统越来越复杂时，线程的数量也会越来越多，操作系统将会花费更多时间处理锁分配，理清线程之间的关系，处理程序指令的时间实际上是很少的。为了让我们的程序具备可扩展性，我们将不得不对线程进行一些控制。&nbsp;&nbsp;&nbsp;&nbsp;对那些生存周期比较短的线程来说，使用线程池来处理任务要比为每个任务都创建一个线程然后顺序地回收它们要高效得多。一个任务，在概念上说，可以是一个单一方法的执行过程或者一系列方法的执行过程。为一个线程预分配一个集合或者一个池来以备未来之需以及能够在一个应用程序中重用的技术称作线程池。 什么是线程池&nbsp;&nbsp;&nbsp;&nbsp;线程池是指在初始化一个多线程应用程序过程中创建一个线程集合，然后在需要执行新的任务时重用这些线程而不是新建一个线程。线程池中线程的数量通常完全取决于可用内存数量和应用程序的需求。然而，增加可用线程数量是可能的。线程池中的每个线程都有被分配一个任务，一旦任务已经完成了，线程回到池子中并等待下一个分配任务。 为什么需要线程池基于以下几个原因在多线程应用程序中使用线程是必须的:1、线程池改进了一个应用程序的响应时间。由于线程池中的线程已经准备好且等待被分配任务，应用程序可以直接拿来使用而不用新建一个线程。2、线程池节省了CLR为每个短生存周期任务创建一个完整的线程的开销并可以在任务完成后回收资源。3、线程池根据当前在系统中运行的进程来优化线程时间片。4、线程池允许我们开启多个任务而不用为每个线程设置属性。5、线程池允许我们为正在执行的任务的程序参数传递一个包含状态信息的对象引用。6、线程池可以用来解决处理一个特定请求最大线程数量限制问题。 线程池的概念&nbsp;&nbsp;&nbsp;&nbsp;影响一个多线程应用程序的相应时间的几个主要因素之一是为每个任务生成一个线程时间。&nbsp;&nbsp;&nbsp;&nbsp;例如，一个web Server是一个多线程应用程序，它可以同时对多个客户端请求提供服务。假设有是个客户端同时访问web Server:1、如果服务执行一个客户端对应一个线程的策略，它将为这些客户端生成十个新线程，从创建第一个线程开始到在线程的整个生命周期管理它们都会增加系统开销。也有可能在某个时间计算机的资源耗尽。2、相反的，如果服务端使用一个线程池来处理这些请求，那么当每次客户端请求来到后都创建一个线程的时间会节省下来。它可以管理已经创建的线程，如果线程池太忙的话也可以拒绝客户端请求。这是线程池背后的概念。&nbsp;&nbsp;&nbsp;&nbsp;.NET CLR 为服务请求维护一个线程池。如果我们的应用程序从线程池中请求一个新线程，CLR 将试着从线程池中取出一个。如果线程池是空的，它将生成一个新线程并把它给我们。当我们的代码使用的线程结束以后，线程由.NET 回收并返回给线程池。线程池中线程的数量由当前可用地内存数量决定。&nbsp;&nbsp;&nbsp;&nbsp;影响设计一个多线程应用程序的因素有:1、一个应用程序的响应时间。2、线程管理资源的分配。3、资源共享。4、线程同步。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo提交文章被killed]]></title>
    <url>%2F2018%2F04%2F06%2Fhexo%E6%8F%90%E4%BA%A4%E6%96%87%E7%AB%A0%E8%A2%ABkilled%2F</url>
    <content type="text"><![CDATA[如图所示，不管如何提交，都是被killed。问题原因:2016年4月15日起，新购买的Linux操作系统CVM，将不再提供2GB的SWAP盘。swap分区是在系统物理内存不够用的时候，由系统内存管理程序将那些很长时间没有操作内存数据，临时保存到Swap分区中，以提高可用内存额度的一种机制。当那些程序要再次重新运行时，会再从Swap分区恢复之前保存的数据到内存中。相关操作会导致额外的IO开销，特别是，如果内存使用率已经非常高，而同时IO性能也不是很好的情况下，该机制其实会起到相反的效果：不仅系统性能提升较小（因为内存使用率已经非常高了），而且由于频繁的内存到SWAP的切换操作，会导致产生大量额外的IO操作，导致IO性能进一步降低，最终反而降低了系统总体性能。内存与磁盘性能有10倍以上的差距，如Mysql等业务，当内存数据临时保存到SWAP分区时，数据库的整体服务质量会大大下降。为了保证您业务的正常运行，当服务器内存不足时，建议您增加内存空间。解决方法:12345free -m //查看系统当前的分区情况dd if=/dev/zero of=/swap bs=4096 count=1572864 //创建用于交换分区的文件mkswap /swap //设置交换分区文件swapon /swap //启用交换分区文件echo “LABEL=SWAP-sda /xxx/swap swap swap defaults 0 0” &gt;&gt; /etc/fstab //若想开机时自启用，则需要修改文件/etc/fstab中的swap行 如果已经修改过一次，则会报下面这个错误，这时候就必须先关闭swap分区。1swapoff -a 修改完成后再开启swap分区。1swapon -a 再执行上面的指令。]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程的区别]]></title>
    <url>%2F2018%2F04%2F06%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[进程狭义定义:进程是正在运行的程序的实例。 组成:进程是一个实体。每一个进程都有它自己的地址空间。一般情况下，包括文本区域(text region)、数据区域(data region)和堆栈(stack region)。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。结构:结构特征: 进程由程序、数据和进程控制块三部分组成。 调度算法:实时系统中: FIFO(First Input First Output, 先进先出算法)， SJF(Shortest Job First, 最短作业优先算法)，SRTF(Shortest Remaining Time First, 最短剩余时间优先算法)。交互式系统中: RR(Round Robin, 时间片轮转法)，HPF(Highest Priority First, 最高优先级算法)，多级队列，最短进程优先，保证调度，彩票调度，公平分享调度。 线程的定义及基本概念一个标准的线程由线程ID，当前指令指针(PC)，寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。 线程之间的关系:一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。 特点: 轻型实体(线程的实体包括程序、数据和TCB。TCB用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。) 独立调度和分派的基本单位 可并发执行 共享进程资源(所有线程都具有相同的地址空间(进程的地址空间)，这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。) 进程和线程的区别 1、线程是处理器调度的基本单位，但进程不是。2、二者均可并发执行。3、进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元4、同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。5、进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束6、线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的7、线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源8、线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志 线程同步 Mutex(互斥锁): 用来锁住公用的内存，同时只有一个线程访问。 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 总结进程是资源分配的基本单位，线程是调度的基本单位。进程包含线程，线程共用进程的资源。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery技巧]]></title>
    <url>%2F2018%2F04%2F05%2FjQuery%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[这里有几个jQuery代码片段，这些代码可以给JavaScript项目提供一些帮助。 修改jQuery默认编码(例如默认UTF-8改成GB2312)1$.ajaxSetup(&#123;ajaxSettings:&#123; contentType:"application/x-www-form-urlencoded;chartset=GB2312"&#125;&#125;); ##解决jQuery、prototype共存，$全局变量冲突问题1&lt;script src="prototype.js"&gt;&lt;/script&gt;&lt;script src="http://blogbeta.blueidea.com/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;jQuery.noConflict();&lt;/script&gt; 注意：一定要先引入prototype.js再引入jquery.js，先后顺序不可错。 jQuery判断元素上是否绑定了事件12//jQuery event封装支持判断元素上是否绑定了事件，此方法只适用于jQuery绑定的事件var $events = $("#foo").data("events");if( $events &amp;&amp; $events["click"] )&#123;//your code&#125; 使用jQuery来切换样式表12//找出你希望切换的媒体类型（media-type），然后把href设置成新的样式表。$('link[media='screen']').attr('href', 'alternative.css'); 限制选择范围（基于优化目的）123456//尽可能使用标签名来作为类名的前缀//这样jQuery就不需要花费更多的时间来搜索//你想要的元素。还要记住的一点是//针对于你的页面上的元素的操作越具体化//就越能降低执行和搜索的时间。var in_stock = $('#shopping_cart_items input.is_in_stock');&lt;ul id="shopping_cart_items"&gt;&lt;li&gt;&lt;input type="radio" value="Item-X" name="item" class="is_in_stock" /&gt; Item X&lt;/li&gt;&lt;li&gt;&lt;input type="radio" value="Item-Y" name="item" class="3-5_days" /&gt; Item Y&lt;/li&gt;&lt;li&gt;&lt;input type="radio" value="Item-Z" name="item" class="unknown" /&gt; Item Z&lt;/li&gt;&lt;/ul&gt; 正确地使用toggleClass1234//切换（toggle）类允许你根据某个类的//是否存在来添加或是删除该类。//这种情况下有些开发者使用：a.hasClass('blueButton') ? a.removeClass('blueButton') : a.addClass('blueButton');//toggleClass允许你使用下面的语句来很容易地做到这一点a.toggleClass('blueButton'); 设置IE特有的功能1if ($.browser.msie) &#123;// Internet Explorer就是个虐待狂&#125; 使用jQuery来代替一个元素1$('#thatdiv').replaceWith('fnuh'); 验证某个元素是否为空1// 方法一if (! $('#keks').html()) &#123;//什么都没有找到;&#125;// 方法二if ($('#keks').is(":empty")) &#123;//什么都没有找到;&#125; 从一个未排序的集合中找出某个元素的索引号12$("ul &gt; li").click(function () &#123;var index = $(this).prevAll().length; //prevAll([expr]): 查找当前元素之前所有的同辈元素&#125;); 把函数绑定到事件上1234//方法一$('#foo').click(function(event) &#123;alert('User clicked on "foo."');&#125;);//方法二, 支持动态传参$('#foo').bind('click', &#123;test1:"abc", test2:"123"&#125;, function(event) &#123;alert('User clicked on "foo."' + event.data.test1 + event.data.test2 );&#125;); 追加或是添加html到元素中1$('#lal').append('sometext'); 在创建元素时，如何使用对象字面量（literal）来定义属性1var e = $("", &#123; href: "#", class: "a-class another-class", title: "..." &#125;); 使用多个属性来进行过滤123//在使用许多相类似的有着不同类型的input元素时//这种基于精确度的方法很有用var elements = $('#someid input[type=sometype][value=somevalue]').get(); 使用jQuery来预加载图像123jQuery.preloadImages = function() &#123;for(var i = 0; i &lt; arguments.length; i++) &#123;$("&lt;img /&gt;").attr('src', arguments);&#125;&#125;;//用法$.preloadImages('image1.gif', '/path/to/image2.png', 'some/image3.jpg'); 为任何与选择器相匹配的元素设置事件处理程序123456$('button.someClass').live('click', someFunction);//注意，在jQuery1.4.2中，delegate和undelegate选项//被引入代替live，因为它们提供了更好的上下文支持//例如，就table来说，以前你会用$("table").each(function()&#123;$("td", this).live("hover", function()&#123;$(this).toggleClass("hover");&#125;);&#125;);//现在用$("table").delegate("td", "hover", function()&#123;$(this).toggleClass("hover");&#125;); 找到一个已经被选中的option元素1$('#someElement').find('option:selected'); 隐藏一个包含了某个值文本的元素1$("p.value:contains('thetextvalue')").hide(); 创建嵌套的过滤器12345//允许你减少集合中的匹配元素的过滤器//只剩下那些与给定的选择器匹配的部分。在这种情况下//查询删除了任何没（:not）有（:has）//包含class为“selected”（.selected）的子节点。.filter(":not(:has(.selected))") 检测各种浏览器12345678检测Safari (if( $.browser.safari))检测IE6及之后版本 (if ($.browser.msie &amp;&amp; $.browser.version &gt; 6 ))检测IE6及之前版本 (if ($.browser.msie &amp;&amp; $.browser.version &lt;= 6 ))检测FireFox 2及之后版本 (if ($.browser.mozilla &amp;&amp; $.browser.version &gt;= '1.8' )) 任何使用has()来检查某个元素是否包含某个类或是元素123//jQuery 1.4.*包含了对这一has方法的支持。//该方法找出某个元素是否包含了其他另一个元素类或是其他任何的你正在查找并要在其之上进行操作的东东。$("input").has(".email").addClass("email_icon"); 禁用右键单击上下文菜单1$(document).bind('contextmenu',function(e)&#123;return false;&#125;); 定义一个定制的选择器12345678$.expr[':'].mycustomselector = function(element, index, meta, stack)&#123;// element- 一个DOM元素// index – 栈中的当前循环索引// meta – 有关选择器的元数据// stack – 要循环的所有元素的栈// 如果包含了当前元素就返回true// 如果不包含当前元素就返回false &#125;;// 定制选择器的用法：$('.someClasses:test').doSomething(); 检查某个元素是否存在123if ($('#someDiv').length) &#123;//万岁！！！它存在……&#125; 使用jQuery来检测右键和左键的鼠标单击两种情况1$("#someelement").live('click', function(e) &#123;if( (!$.browser.msie &amp;&amp; e.button == 0) || ($.browser.msie &amp;&amp; e.button == 1) ) &#123;alert("Left Mouse Button Clicked");&#125; else if(e.button == 2) &#123;alert("Right Mouse Button Clicked");&#125;&#125;); 替换串中的词1var el = $('#id');el.html(el.html().replace(/word/ig, '')); 在一段时间之后自动隐藏或关闭元素（支持1.4版本）1234//这是1.3.2中我们使用setTimeout来实现的方式setTimeout(function() &#123;$('.mydiv').hide('blind', &#123;&#125;, 500)&#125;, 5000);//而这是在1.4中可以使用delay()这一功能来实现的方式（这很像是休眠）$(".mydiv").delay(5000).hide('blind', &#123;&#125;, 500); 把已创建的元素动态地添加到DOM中1var newDiv = $('&lt;div&gt;&lt;/div&gt;');newDiv.attr('id','myNewDiv').appendTo('body'); 限制“Text-Area”域中的字符的个数12345jQuery.fn.maxLength = function(max)&#123;return this.each(function()&#123;var type = this.tagName.toLowerCase();var inputType = this.type? this.type.toLowerCase() : null;if(type == "input" &amp;&amp; inputType == "text" || inputType == "password")&#123;//Apply the standard maxLengththis.maxLength = max;&#125; else if(type == "textarea")&#123;this.onkeypress = function(e)&#123;var ob = e || event;var keyCode = ob.keyCode;var hasSelection = document.selection? document.selection.createRange().text.length &gt; 0 : this.selectionStart != this.selectionEnd;return !(this.value.length &gt;= max &amp;&amp; (keyCode &gt; 50 || keyCode == 32 || keyCode == 0 || keyCode == 13) &amp;&amp; !ob.ctrlKey &amp;&amp; !ob.altKey &amp;&amp; !hasSelection);&#125;;this.onkeyup = function()&#123;if(this.value.length &gt; max)&#123;this.value = this.value.substring(0,max);&#125;&#125;;&#125;&#125;);&#125;;//用法$('#mytextarea').maxLength(500); jQuery注册和禁用jQuery全局事件123//jQuery注册ajax全局事件ajaxStart，ajaxStop：$(document).ajaxStart(function()&#123;$("#background,#progressBar").show();&#125;).ajaxStop(function()&#123;$("#background,#progressBar").hide();&#125;);//ajax请求禁用全局事件：$.ajax() 有个参数global (默认: true) 是否触发全局 AJAX 事件.设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 Ajax 事件。 在jQuery中克隆一个元素1var cloned = $('#somediv').clone(); 在jQuery中如何测试某个元素是否可见123if($(element).is(':visible')) &#123;//该元素是可见的&#125; 把一个元素放在屏幕的中心位置12jQuery.fn.center = function () &#123;return this.each(function()&#123;$(this).css(&#123;position:'absolute',top, ( $(window).height() - this.height() ) / 2 + $(window).scrollTop() + 'px',left, ( $(window).width() - this.width() ) / 2 + $(window).scrollLeft() + 'px'&#125;);&#125;);&#125;//这样来使用上面的函数： $(element).center(); 把有着某个特定名称的所有元素的值都放到一个数组中1var arrInputValues = new Array();$("input[name='xxx']").each(function()&#123;arrInputValues.push($(this).val());&#125;); 从元素中除去HTML12(function($) &#123;$.fn.stripHtml = function() &#123;var regexp = /&lt;("[^"]*"|'[^']*'|[^'"&gt;])*&gt;/gi;this.each(function() &#123;$(this).html( $(this).html().replace(regexp,'') );&#125;);return $(this);&#125;&#125;)(jQuery);//用法：$('p').stripHtml(); 使用closest来取得父元素1$('#searchBox').closest('div'); 使用Firebug和Firefox来记录jQuery事件日志1234// 允许链式日志记录jQuery.log = jQuery.fn.log = function (msg) &#123;if (console)&#123;console.log("%s: %o", msg, this);&#125;return this;&#125;;// 用法：$('#someDiv').hide().log('div hidden').addClass('someClass'); 强制在弹出窗口中打开链接1$('a.popup').live('click', function()&#123;var newwindow = window.open($(this).attr('href'),'','height=200,width=150');if (window.focus) &#123;newwindow.focus();&#125;return false;&#125;); 强制在新的选项卡中打开链接1$('a.newTab').live('click', function()&#123;var newwindow=window.open(this.href);$(this).target = "_blank";return false;&#125;); 在jQuery中如何使用.siblings()来选择同辈元素1234// 不这样做$('#nav li').click(function()&#123;$('#nav li').removeClass('active');$(this).addClass('active');&#125;);//替代做法是$('#nav li').click(function()&#123;$(this).addClass('active').siblings().removeClass('active');&#125;); 切换页面上的所有复选框123var tog = false;// 或者为true，如果它们在加载时为被选中状态的话$('a').click(function() &#123;$("input[type=checkbox]").attr("checked",!tog);tog = !tog;&#125;); 基于一些输入文本来过滤一个元素列表12//如果元素的值和输入的文本相匹配的话,该元素将被返回$('.someClass').filter(function() &#123;return $(this).attr('value') == $('input#someId').val();&#125;) 获得鼠标垫光标位置x和y1$(document).ready(function() &#123;$(document).mousemove(function(e)&#123;$(’#XY’).html(”X Axis : ” + e.pageX + ” | Y Axis ” + e.pageY);&#125;);&#125;); 扩展String对象的方法1$.extend(String.prototype, &#123;isPositiveInteger:function()&#123;return (new RegExp(/^[1-9]d*$/).test(this));&#125;,isInteger:function()&#123;return (new RegExp(/^d+$/).test(this));&#125;,isNumber: function(value, element) &#123;return (new RegExp(/^-?(?:d+|d&#123;1,3&#125;(?:,d&#123;3&#125;)+)(?:.d+)?$/).test(this));&#125;,trim:function()&#123;return this.replace(/(^s*)|(s*$)| | /g, "");&#125;,trans:function() &#123;return this.replace(/&amp;lt;/g, '&lt;').replace(/&amp;gt;/g,'&gt;').replace(/&amp;quot;/g, '"');&#125;,replaceAll:function(os, ns) &#123;return this.replace(new RegExp(os,"gm"),ns);&#125;,skipChar:function(ch) &#123;if (!this || this.length===0) &#123;return '';&#125;if (this.charAt(0)===ch) &#123;return this.substring(1).skipChar(ch);&#125;return this;&#125;,isValidPwd:function() &#123;return (new RegExp(/^([_]|[a-zA-Z0-9])&#123;6,32&#125;$/).test(this));&#125;,isValidMail:function()&#123;return(new RegExp(/^w+((-w+)|(.w+))*@[A-Za-z0-9]+((.|-)[A-Za-z0-9]+)*.[A-Za-z0-9]+$/).test(this.trim()));&#125;,isSpaces:function() &#123;for(var i=0; i&lt;this.length; i+=1) &#123;var ch = this.charAt(i);if (ch!=' '&amp;&amp; ch!=" " &amp;&amp; ch!=" " &amp;&amp; ch!=" ") &#123;return false;&#125;&#125;return true;&#125;,isPhone:function() &#123;return (new RegExp(/(^([0-9]&#123;3,4&#125;[-])?d&#123;3,8&#125;(-d&#123;1,6&#125;)?$)|(^([0-9]&#123;3,4&#125;)d&#123;3,8&#125;((d&#123;1,6&#125;))?$)|(^d&#123;3,8&#125;$)/).test(this));&#125;,isUrl:function()&#123;return (new RegExp(/^[a-zA-z]+://([a-zA-Z0-9-.]+)([-w ./?%&amp;=:]*)$/).test(this));&#125;,isExternalUrl:function()&#123;return this.isUrl() &amp;&amp; this.indexOf("://"+document.domain) == -1;&#125;&#125;); 规范化写jQuery插件12345(function($)&#123;$.fn.extend(&#123;pluginOne: function()&#123;return this.each(function()&#123;// my code&#125;);&#125;,pluginTwo: function()&#123;return this.each(function()&#123;// my code&#125;);&#125;&#125;);&#125;)(jQuery); 检查图像是否已经被完全加载进来1$('#theImage').attr('src', 'image.jpg').load(function() &#123;alert('This Image Has Been Loaded');&#125;); 使用jQuery来为事件指定命名空间123456//事件可以这样绑定命名空间$('input').bind('blur.validation', function(e)&#123;// ...&#125;);//data方法也接受命名空间$('input').data('validation.isValid', true); 检查cookie是否启用123var dt = new Date();dt.setSeconds(dt.getSeconds() + 60);document.cookie = "cookietest=1; expires=" + dt.toGMTString();var cookiesEnabled = document.cookie.indexOf("cookietest=") != -1;if(!cookiesEnabled) &#123;//没有启用cookie&#125; 让cookie过期1var date = new Date();date.setTime(date.getTime() + (x * 60 * 1000));$.cookie('example', 'foo', &#123; expires: date &#125;); 使用一个可点击的链接来替换页面中任何的URL123$.fn.replaceUrl = function() &#123;var regexp = /((ftp|http|https)://(w+:&#123;0,1&#125;w*@)?(S+)(:[0-9]+)?(/|/([w#!:.?+=&amp;%@!-/]))?)/gi;return this.each(function() &#123;$(this).html($(this).html().replace(regexp,'&lt;a href="$1"&gt;$1&lt;/a&gt;'));&#125;);&#125;//用法 $('p').replaceUrl();]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看内存]]></title>
    <url>%2F2018%2F04%2F05%2FLinux%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[方法一: free直观的展示Linux系统内存使用及交换区的容量大小方法二: top动态实时查看系统中每一个进程的资源使用情况方法三: cat /proc/meminfo方法四: gnome-system-monitor一个显示最近一段时间内的CPU、内存、交换区及网络使用情况的识图工具。方法五: ps aux –sort -rss各个线程的资源使用情况。方法六: vmstat -s vmstat命令显示实时的和平均的统计，覆盖CPU、内存、I/O等内容。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令]]></title>
    <url>%2F2018%2F04%2F05%2FGit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[需要学习的东西太多了，很多命令用到时却忘了，分享一个经典的Git 常用命清单，建议收藏，或者收进你的云笔记中，方便用到时查阅。 名词 翻译 workspace 工作区 Index/Stage 暂存区 Repository 仓库区(本地仓库) Remote 远程仓库 新建代码库在当前目录新建一个Git代码库1$ git init 新建一个目录，将其初始化为Git代码库1$ git init [project-name] 下载一个项目和它的整个代码历史1$ git clone [url] 添加或删除文件添加指定文件到暂存区1$ git add [file1] [file2]...... 添加指定目录到暂存区，包括子目录1$ git add [dir] 添加当前目录的所有文件到暂存区1$ git add . 添加每个变化前，都会要求确认。对于同一个文件的多处变化，可以实现分次提交1$ git add -p 删除工作区文件，并且将这次删除放入暂存区1$ git rm [file1] [file2]...... 停止追踪指定文件，但该文件会保留在工作区1$ git rm --cached [file] 改名文件，并且将这个改名放入暂存区1$ git mv [file-original] [file-original] 代码提交到仓库提交暂存区到仓库区1$ git commit -m [message] 提交暂存区的指定文件到仓库区1$ git commit [file1] [file2]... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区1$ git commit -a 提交时显示所有diff信息1git commit -v 使用一次新的commit，替代上一次提交。如果代码没有任何变化，则用来改写上一次commit的提交信息。1$ git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化1$ git commit --amend [file1] [file2]... 分支管理列出所有本地分支1$ git branch 列出所有远程分支1$ git branch -r 列出所有本地分支和远程分支1$ git branch -a 新建一个分支，但依然停留在当前分支1$ git branch [branch-name] 新建一个分支，并切换到该分支1$ git checkout -b [branch] 新建一个分支，指向指定commit1$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系1$ git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区1$ git checkout [branch-name] 切换到上一个分支1$ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间1$ git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支1$ git merge [branch] 选择一个commit，合并进当前分支1$ git cherry-pick [commit] 删除分支1$ git branch -d [branch-name] 删除远程分支12$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签管理列出所有tag1$ git tag 新建一个tag在当前commit1$ git tag [tag] 新建一个tag在指定commit1$ git tag [tag] [commit] 删除本地tag1$ git tag -d [tag] 删除远程tag1$ git push origin :refs/tags/[tagname] 查看tag信息1$ git show [tag] 提交指定tag1$ git push [remote] [tag] 提交所有tag1$ git push [remote] --tags 新建一个分支，指向某个tag1$ git checkout -b [branch] [tag] 查看历史或统计信息显示有变更的文件1$ git status 显示当前分支的版本历史1$ git log 显示commit历史，以及每次commit发生变更的文件1$ git log --stat 搜索提交历史，根据关键词1$ git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行1$ git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件1$ git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名12$ git log --follow [file]$ git whatchanged [file] 显示指定文件相关的每一次diff1$ git log -p [file] 显示过去5次提交1$ git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序1$ git shortlog -sn 显示指定文件式什么人在什么时间修改过1$ git blame [file] 显示暂存区和工作区的差异1$ git diff 显示暂存区和上一个commit的差异1$ git diff --cached [file] 显示工作区与当前分支最新commit之间的差异1$ git diff HEAD 显示两次提交之间的差异1$ git diff [first-branch]...[second-branch] 显示今天你写了多少行代码1$ git dirr --shortstat "@&#123;0 day ago&#125;" 显示某次提交的元数据和内容变化1$ git show [commit] 显示某次提交发生变化的文件1$ git show --name-only [commit] 显示某次提交时，某个文件的内容1$ git show [commit]:[filename] 代码远程同步下载远程仓库的所有变动1$ git fetch [remote] 显示所有远程仓库1$ git remote -v 显示某个远程仓库的信息1$ git remote show [remote] 增加一个新的远程仓库，并命名1$ git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并1$ git pull [remote] [branch] 上传本地指定分支到远程仓库1$ git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突1$ git push [remote] --force 推送所有分支到远程仓库1$ git push [remote] --all 撤销恢复恢复暂存区的指定文件到工作区1$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区1$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区1$ git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变1$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致1$ git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变1$ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致1$ git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变1$ git reset --keep [commit] 新建一个commit，用来撤销指定commit。后者的所有变化都将被前者抵消，并且应用到当前分支1$ git revert [commit] 暂时将未提交的变化移除，稍后再植入12$ git stash$ git stash pop 多人工作模式多人协作的工作模式通常是这样的:1、首先，可以试图用git push origin &lt;branch-name&gt; 推送自己的修改；2、如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；3、如果合并有冲突，则解决冲突，并在本地提交；4、没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt; 推送就能成功！如果git pull提示no tracking information, 则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;branch-name&gt;。这就是多人协作的工作模式，一旦熟悉了，就非常简单。 查看远程库信息，使用git remote -v;本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name, 如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name, 本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch --set-upstream-to=origin/branch-name branch-name;从远程抓取分支，使用git pull, 如果有冲突，要先处理冲突。 配置别名我们需要敲一行命令，告诉Git，以后st就表示status：git config --global alias.st status还有别的命令可以简写，很多人用co表示checkout, ci表示commit, br表示branch;123git config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br brancgh --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。甚至还有人丧心病狂地把lg设置成了:git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; Git .gitignore使用有些时候我们不希望把一些编译的东西提交到git中，gitignore可以方便管理我们不需要提交的文件，自动过滤设置的文件。Git提供了一种可配性很强的机制来允许用户将指定的文件或目录排除在版本控制之外，它会检查代码仓库的根目录下是否存在一个名为.gitignore的文件，如果存在的话就去一行行读取这个文件中的内容，并把每一行指定的文件或目录排除在版本控制之外。注意.gitignore中指定的文件或目录是可以用*通配符的。 这里以一个项目为例。第一步，创建代码库首先进入当前的项目根目录执行git init这时项目根目录下会有.git文件夹第二部，创建.gitignore文件夹执行如下命令:touch .gitignore也可以新建一个文件夹，重命名为.gitignore.，注意后面有一个.第三部，编辑.gitignore文件vim .gitignore然后在里面加入build/表示我们不希望将build文件夹提交到git中，然后退出。第四步，提交git add .将所有文件提交到git，会过滤掉bulid文件夹git commit -m &quot;过滤掉build文件夹&quot;执行提交检查提交是否成功git status提示没有东西需要提交，说明提交成功。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解]]></title>
    <url>%2F2018%2F04%2F05%2FJava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在本文中，我们将看到五个Java编译器支持的注解，并了解其期望用途。顺便，我们将探索其创建背后的基本原理，围绕其用途的一些特质，以及正确应用的一些例子。 @Override覆盖方法的实现或为抽象方法提供实现的能力是任何面向对象(OO)语言的核心。由于Java是OO语言，具有许多常见的面向对象的抽象机制，所以在非终极超类定义的非最终方法或接口中地任何方法(接口方法不能是最终的)都可以被子类覆盖。虽然开始时覆盖方法看起来很简单，但是如果执行不正确，则可能会引入许多微小的bug。例如，用覆盖类类型的单个参数覆盖Object#equals方法就是一种常见的错误:12345public class Foo &#123; public boolean equals(Foo foo) &#123; // Check if the supplied object is equal to this object &#125;&#125; 由于所有类都隐式地从Object类继承，Foo类的目的是覆盖Object#equals方法， 因此Foo可被测试是否与Java中的任何其他对象相等。虽然我们的意图是正确的，但我们的实现则并非如此。实际上，我们的实现根本不覆盖Object#equals方法。相反，我们提供了方法的重载: 我们不是替换Object类提供的equals方法的实现，而是提供第二个方法来专门接受Foo对象，而不是Object对象。我们的错误可以简单实现来举例说明，该实现对所有的相等检查都返回true，但当提供的对象被视为Object(Java将执行的操作，例如在Java Collections Framework即JCF中)时，就永远不会调用它:12345678public class Foo &#123; public boolean equals(Foo foo) &#123; return true; &#125;&#125;Object foo = new Foo();Object identicalFoo = new Foo();System.out.println(foo.equals(identicalFoo)); // false 这是一个非常微妙但常见的错误，可以被编译器捕获。我们的意图是覆盖Object#equals方法，但因为我们指定了一个类型为Foo而不是Object类型的参数，所以我们实际上提供了重载的Object#equals方法，而不是覆盖它。为了捕获这种错误，我们引入@Override注解，它指示编译器检查覆盖实际有没有执行。如果没有执行有效的覆盖，则会抛出错误。因此，我们可以更新Foo类，如下所示:123456public class Foo &#123; @Override public boolean equals(Foo foo) &#123; return true; &#125;&#125; 如果我们尝试编译这个类，我们现在收到以下错误:12345$ javac Foo.javaFoo.java:3: error: method does not override or implement a method from a supertype@Override^1 error 实质上，我们已经将我们已经覆盖方法的这一隐含的假设转变为由编译器进行的显性验证。如果我们的意图被错误地实现，那么Java编译器会发出一个错误–不允许我们不正确实现的代码被成功编译。通常，如果以下任一条件不满足，则Java编译器将针对使用@Override注解地方法发出错误(引用自Override注解文档): 该方法确实会覆盖或实现在超类中声明地方法。 该方法的签名与在Object中声明的任何公共方法（即equals或hashCode方法）的签名覆盖等价（override-equivalent）。因此，我们也可以使用此注解来确保子类方法实际上也覆盖超类中地非最终具体方法或抽象方法: 12345678910111213141516171819public abstract class Foo &#123; public int doSomething() &#123; return 1; &#125; public abstract int doSomethingElse();&#125;public class Bar extends Foo &#123; @Override public int doSomething() &#123; return 10; &#125; @Override public int doSomethingElse() &#123; return 20; &#125;&#125;Foo bar = new Bar();System.out.println(bar.doSomething()); // 10System.out.println(bar.doSomethingElse()); // 20 @Override注解不仅不限于超类中的具体或抽象方法，而且还可用于确保接口的方法也被覆盖（从JDK 6开始）:1234567891011public interface Foo &#123; public int doSomething();&#125;public class Bar implements Foo &#123; @Override public int doSomething() &#123; return 10; &#125;&#125;Foo bar = new Bar();System.out.println(bar.doSomething()); // 10 通常，覆盖非final类方法、抽象超类方法或接口方法的任何方法都可以使用@Override进行注解。 @Functionallnterface随着JDK 8中lambda表达式的引入，函数式接口在Java中变得越来越流行。这些特殊类型的接口可以用lambda表达式、方法引用或构造函数引用代替。根据@Functionallnterface文档，函数式接口的定义如下: 一个函数式接口只有一个抽象方法。由于默认方法有一个实现，所以它们不是抽象的。 例如，以下接口被视为函数式接口:123456789public interface Foo &#123; public int doSomething();&#125;public interface Bar &#123; public int doSomething(); public default int doSomethingElse() &#123; return 1; &#125;&#125; 因此，下面的每一个都可以用lambda表达式代替，如下所示:1234567891011public class FunctionalConsumer &#123; public void consumeFoo(Foo foo) &#123; System.out.println(foo.doSomething()); &#125; public void consumeBar(Bar bar) &#123; System.out.println(bar.doSomething()); &#125;&#125;FunctionalConsumer consumer = new FunctionalConsumer();consumer.consumeFoo(() -&gt; 10); // 10consumer.consumeBar(() -&gt; 20); // 20 重点要注意的是，抽象类，即使它们只包含一个抽象方法，也不是函数式接口。与@Override注解类似，Java编译器提供了@Functionallnterface注解以确保接口确实是函数式接口。例如，我们可以将此注解添加到上面创建的接口中:1234567891011@FunctionalInterfacepublic interface Foo &#123; public int doSomething();&#125;@FunctionalInterfacepublic interface Bar &#123; public int doSomething(); public default int doSomethingElse() &#123; return 1; &#125;&#125; 如果我们错误地将接口定义为非函数接口并用@Functionallnterface注解了错误地接口，则Java编译器会发出错误。例如，我们可以定义以下带注解地非函数式接口:12345@FunctionalInterfacepublic interface Foo &#123;public int doSomething();public int doSomethingElse();&#125; 如果我们试图编译这个接口，则会收到以下错误:1234567$ javac Foo.javaFoo.java:1: error: Unexpected @FunctionalInterface annotation@FunctionalInterface^Foo is not a functional interfacemultiple non-overriding abstract methods found in interface Foo1 error 使用这个注解，我们可以确保我们不会错误地创建原本打算用作函数式接口地非函数式接口。需要注意地是，即使在@Functionallnterface注解不存在地情况下，接口也可以用作函数式接口(可以替代为lambdas，方法引用和构造函数引用)，正如我们前面地示例中所见地那样。这类似于@Override注解，即一个方法是可以被覆盖地，即使它不包含@Override注解。在这两种情况下，注解都是允许编译器执行期望意图的可选技术。 @SuppressWarnings警告是所有编译器的重要组成部分，为开发人员提供的反馈–可能危险的行为或在未来的编译器版本中可能会出现的错误。例如，在Java中使用泛型类型而没有其关联的正式型参数(称为原始类型)会导致警告，就像使用不推荐使用的代码一样(请参阅下面的@Deprecated部分)。虽然这些警告很重要，但它们可能并不总是适用甚至并不总是正确的。例如，可能会有对不安全的类型转换发生警告的情况，但是基于使用它的上下文，我们可以保证它是安全的。为了忽略某些上下文中的特定警告，JDK 5中引入了@SuppressWarnings注解。此注解接受一个或多个字符串参数–描述要忽略的警告名称。虽然这些警告的名称通常在编译器实现之间有所不同，但又3种警告在Java语言中是标准化的(因此在所有Java编译器实现中都很常见): unchecked: 表示类型转换未经检查的警告(编译器无法保证类型转换是安全的)，导致发生的可能原因有访问原始类型的成员(参见《JLS》4.8章节)、窄参考转换或不安全的向下转换(参见《JLS》5.1.6章节)、未经检查的类型转换(参见《JLS》5.1.9章节)、使用带有可变参数的泛型参数(参见《JLS》8.4.1章节和下面的@SafeVarargs部分)、使用无效的协变返回类型(参见《JLS》8.4.8.3章节)、不确定的参数评估(参见《JLS》15.12.4.2章节)、未经检查的方法引用类型的转换(参见《JLS》15.13.2章节)、或未经检查到的lambda类型的对话(参见《JLS》15.27.3章节)。 deprecation: 表示使用了已弃用的方法、类、类型等的警告(参见《JLS》9.6.4.6章节和下面的@Deprecated部分)。 removal: 表示使用了最终废弃的方法、类、类型等的警告(参见《JLS》9.6.4.6章节和下面的@Deprecated部分)。 为了忽略特定的警告，可以将@SuppressedWarning注解与抑制警告(以字符串数组的形式提供)的一个或多个名字添加到发生警告的上下文中:12345public class Foo &#123; public void doSomething(@SuppressWarnings("rawtypes") List myList) &#123; // Do something with myList &#125;&#125; @SuppressWarnings注解可用于以下任何一种情况: 类型 域 方法 参数 构造函数 局部变量 模块一般来说，@SuppressWarnings注解应该应用于最直接的警告范围。例如，如果方法中的局部变量应忽略警告，则应将@SuppressWarnings注解应用于局部变量，而不是包含局部变量的方法或类: 1234567public class Foo &#123; public void doSomething() &#123; @SuppressWarnings("rawtypes") List myList = new ArrayList(); // Do something with myList &#125;&#125; @SafeVarargs可变参数在Java中是一种很有用的技术手段，但在与泛型参数一起使用时，它们也可能会导致一些严重的问题。由于泛型在Java中式非特定的，所以具有泛型类型的变量的实际(实现)类型不能在运行时被断定。由于无法做出此判断，因此变量可能会存储非其实际类型的引用到类型，如以下代码片段所示:1234List ln = new ArrayList&lt;Number&gt;();ln.add(1);List&lt;String&gt; ls = ln; // unchecked warningString s = ls.get(0); // ClassCastException 在将ln分配给ls后，堆中存在变量ls，该变量具有List的类型，但存储引用到实际为List类型的值。这个无效的引用被称为堆污染。由于直到运行时才确定此错误，因此它会在编译时显示为警告，并在运行时出现ClassCastException。当泛型参数与可变参数组合时，可能会加剧此问题:12345public class Foo &#123; public &lt;T&gt; void doSomething(T... args) &#123; // ... &#125;&#125; 在这种情况下，Java编译器会在调用站点内部创建一个数组来存储可变数量的参数，但是T的类型并未实现，因此在运行时会丢失。实质上，到doSomething的参数实际上式Object[]类型。如果依赖T的运行时类型，那么这会导致严重的问题，如下面的代码片段所示:12345678public class Foo &#123; public &lt;T&gt; void doSomething(T... args) &#123; Object[] objects = args; String string = (String) objects[0]; &#125;&#125;Foo foo = new Foo();foo.&lt;Number&gt;doSomething(1, 2); 如果执行此代码片段，那么将导致ClassCastException，因为在调用站点传递的第一个Number参数不能转换为String（类似于独立堆污染示例中抛出的ClassCastException）。通常，可能会出现以下情况：编译器没有足够的信息来正确确定通用可变参数的确切类型，这会导致堆污染，这种污染可以通过允许内部可变参数数组从方法中转义来传播，如下面摘自《Effective Java》第3版 pp.147的例子：123public static &lt;T&gt; T[] toArray(T... args) &#123; return args;&#125; 在某些情况下，我们知道方法实际上是类型安全的，不会造成堆污染。如果可以在保证的情况下做出这个决定，那么我们可以使用@SafeVarargs注解来注解该方法，从而抑制与可能的堆污染相关的警告。但是，这引出了一个问题：什么时候通用可变参数方法会被认为是类型安全的？Josh Bloch在《Effective Java》第3版第147页的基础上提供了一个完善的解决方案——基于方法与内部创建的用于存储其可变参数的数组的交互： 如果方法没有存储任何东西到数组（这会覆盖参数）且不允许对数组的引用进行转义（这会使得不受信任的代码可以访问数组），那么它是安全的。换句话说，如果可变参数数组仅用于从调用者向方法传递可变数量的参数——毕竟，这是可变参数的目的——那么该方法是安全的。 因此，如果我们创建了以下方法（来自pp.149同上），那么我们可以用@SafeVarags注解来合理地注解我们的方法：12345678@SafeVarargsstatic &lt;T&gt; List&lt;T&gt; flatten(List&lt;? extends T&gt;... lists) &#123;List&lt;T&gt; result = new ArrayList&lt;&gt;();for (List&lt;? extends T&gt; list : lists) &#123;result.addAll(list);&#125;return result;&#125; @Deprecated在开发代码时，有时候代码会变得过时和不应该再被使用。在这些情况下，通常会有个替补的更适合手头的任务，且虽然现存的对过时代码的调用可能会保留，但是所有新的调用都应该使用替换方法。这个过时的代码被称为不推荐使用的代码。在某些紧急情况下，不建议使用的代码可能会被删除，应该在未来的框架或库版本从其代码库中删除弃用的代码之前立即转换为替换代码。了支持不推荐使用的代码的文档，Java包含@Deprecated注解，它会将一些构造函数、域、局部变量、方法、软件包、模块、参数或类型标记为已弃用。如果弃用的元素（构造函数，域，局部变量等）被使用了，则编译器发出警告。例如，我们可以创建一个弃用的类并按如下所示使用它：123@Deprecatedpublic class Foo &#123;&#125;Foo foo = new Foo(); 如果我们编译此代码（在命名为Main.java的文件中），我们会收到以下警告：123$ javac Main.javaNote: Main.java uses or overrides a deprecated API.Note: Recompile with -Xlint:deprecation for details. 通常，每当使用@Deprecated注解的元素时，都会引发警告，除了用于以下五种情况： 声明本身就被声明为是弃用的（即递归调用）。 声明被注解禁止弃用警告（即@SuppressWarnings(“deprecation”）注解，如上所述，应用于使用弃用元素的上下文。 使用和声明都在同一个最外面的类中（即，如果类调用其本身的弃用方法）。 用在import声明中，该声明导入通常不赞成使用的类型或构件（即，在将已弃用的类导入另一个类时）。 exports或opens指令内。 正如前面所说的，在某些情况下，当不推荐使用的元素将被删除，则调用代码应立即删除不推荐使用的元素（称为terminally deprecated code）。在这种情况下，可以使用forRemoval参数提供的@Deprecated注解，如下所示：12@Deprecated(forRemoval = true)public class Foo &#123;&#125; 使用此最终弃用代码会导致一系列更严格的警告：12345678$ javac Main.javaMain.java:7: warning: [removal] Foo in com.foo has been deprecated and marked for removalFoo foo = new Foo();^Main.java:7: warning: [removal] Foo in com.foo has been deprecated and marked for removalFoo foo = new Foo();^2 warnings 除了标准@Deprcated注解所描述的相同异常之外，总是会发出最终弃用的警告。我们还可以通过为注解提供since变量来添加文档到@Deprecated注解中：12@Deprecated(since = "1.0.5", forRemoval = true)public class Foo &#123;&#125; 可以使用@deprecated JavaDoc元素（注意小写字母d）进一步文档化已弃用的元素，如以下代码片段所示：1234567/*** Some test class.* @deprecated Replaced by &#123;@link com.foo.NewerFoo&#125;.* @author Justin Albano*/@Deprecated(since = "1.0.5", forRemoval = true)public class Foo &#123;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS技巧]]></title>
    <url>%2F2018%2F04%2F05%2FCSS%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[这几个CSS技巧，可以用在项目上，帮助自己很好地整理自己的元素并让他们看起来挺不错的。 黑白图像这段代码会让你的彩色照片显示为黑白照片。1img.desaturate &#123; filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%);&#125; 使用:not()在菜单上应用/取消应用边框先给每一个菜单项添加边框1/* add border*/.nav li &#123;border=right: 1px solid #666;&#125; 然后再出去最后一个元素1//remove border /.nav li: last-child &#123;border-right: none;&#125; 可以直接使用:not()伪类来应用元素:1.nav li:not(:last-child) &#123;border-right: 1px solid #666;&#125; 这样代码就干净，易读，易于理解了。当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符(~)：1..nav li: first-child ~ li &#123;border-left: 1px solid #666;&#125; 页面顶部阴影下面这个简单的CSS3代码片段可以给网页加上漂亮的顶部阴影效果:1body:before &#123; content: ""; position: fixed; top: -10px; left: 0; width: 100%; height: 10px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8); -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100;&#125; 给body添加行高你不需要分别添加line-height到每个p, h标记等，只要添加到body即可:1body&#123; line-height: 1;&#125; 这样文本元素就可以很容易地从body继承。 ##所有一切都垂直居中要将所有元素垂直居中，太简单了:1html, body &#123; height: 100%; margin: 0;&#125;body &#123; -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex;&#125; 注意: 在IE11中要小心flexbox。 逗号分隔地列表让HTML列表项看上去像一个真正地，用逗号分隔地列表:1ul &gt; li:not(:last-child)::after &#123; content: ",";&#125; 堆最后一个列表项使用:not()伪类。 使用负地nth-child选择项目在CSS中使用负地nth-child选择项目1到项目n。1li &#123; display: none;&#125;/* select items 1 through 3 and display them */li:nth-child(-n+3) &#123; display: block;&#125; 对图标使用SVG我们没有理由不对图标使用SVG:1.logo &#123; background: url("logo.svg");&#125; SVG对所有地分辨率类型都具有良好地扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。 优化显示文本有时，字体并不能在所有设备上都达到最佳地显示，所以可以让设备浏览器来帮助你:1html &#123; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;&#125; 注: 请负责人地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。 对纯CSS滑块使用max-height使用max-height和溢出隐藏来实现只有CSS地滑块:1.slider ul &#123; max-height: 0; overlow: hidden;&#125;.slider:hover ul &#123; max-height: 1000px; transition: .3s ease;&#125; 继承box-sizing让box-sizing继承html:1html &#123; box-sizing: border-box;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125; 这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。 表格单元格等宽表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽:1.calendar &#123; table-layout: fixed;&#125; 使用Flexbox摆脱外边距地各种hack当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了:1.list &#123; display: flex; justify-content: space-between;&#125;.list .person &#123; flex-basis: 23%;&#125; 现在，列表分隔符就会在均匀间隔地位置出现。 使用属性选择器用于空链接当a元素没有文本值，但 href 属性有链接的时候显示链接:1a[href^="http"]:empty::before &#123; content: attr(href); 检测鼠标双击HTML1&lt;div class="test3"&gt; &lt;span&gt;&lt;input type="text" value=" " readonly="true" /&gt; &lt;a href="http://renpingjun.com"&gt;Double click me&lt;/a&gt;&lt;/span&gt;&lt;/div&gt; CSS1.test3 span &#123; position: relative;&#125;.test3 span a &#123; position: relative; z-index: 2;&#125;.test3 span a:hover, .test3 span a:active &#123; z-index: 4;&#125;.test3 span input &#123; background: transparent; border: 0; cursor: pointer; position: absolute; top: -1px; left: 0; width: 101%; /* Hacky */ height: 301%; /* Hacky */ z-index: 3;&#125;.test3 span input:focus &#123; background: transparent; border: 0; z-index: 1;&#125; CSS写出三角形1/* create an arrow that points up */div.arrow-up &#123; width:0px; height:0px; border-left:5px solid transparent; /* left arrow slant */ border-right:5px solid transparent; /* right arrow slant */ border-bottom:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px;&#125;/* create an arrow that points down */div.arrow-down &#123; width:0px; height:0px; border-left:5px solid transparent; border-right:5px solid transparent; border-top:5px solid #2f2f2f; font-size:0px; line-height:0px;&#125;/* create an arrow that points left */div.arrow-left &#123; width:0px; height:0px; border-bottom:5px solid transparent; /* left arrow slant */ border-top:5px solid transparent; /* right arrow slant */ border-right:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px;&#125;/* create an arrow that points right */div.arrow-right &#123; width:0px; height:0px; border-bottom:5px solid transparent; /* left arrow slant */ border-top:5px solid transparent; /* right arrow slant */ border-left:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px;&#125; CSS3 calc()的使用calc() 用法类似于函数，能够给元素设置动态的值:1/* basic calc */.simpleBlock &#123; width: calc(100% - 100px);&#125;/* calc in calc */.complexBlock &#123; width: calc(100% - 50% / 3); padding: 5px calc(3% - 2px); margin-left: calc(10% + 10px);&#125; 文本渐变文本渐变效果很流行，使用 CSS3 能够很简单就实现:1h2[data-text] &#123; position: relative;&#125;h2[data-text]::after &#123; content: attr(data-text); z-index: 10; color: #e3e3e3; position: absolute; top: 0; left: 0; -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));&#125; 禁用鼠标事件CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。1.disabled &#123; pointer-events: none; &#125; 模糊文本简单但很漂亮的文本模糊效果，简单又好看！1.blur &#123; color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125; 简单的方法调整图片大小1234.content img &#123;height:auto;width:500px;&#125; IE HTML Hack12div#content &#123;width: 580px&#125;* html body div#content &#123;width: 600px&#125; CSS 阴影12345.shadow &#123;-moz-box-shadow: 3px 3px 5px 6px #ccc;-webkit-box-shadow: 3px 3px 5px 6px #ccc;box-shadow: 3px 3px 5px 6px #ccc;&#125; CSS首字放大123456789p:first-letter &#123;display: block;float: left;margin: 5px 5px 0 0;color: red;font-size: 1.4em;background: #ddd;font-family: Helvetica;&#125; 用CSS反转图像12345678#content img &#123;-moz-transform: scaleX(-1);-o-transform: scaleX(-1);-webkit-transform: scaleX(-1);transform: scaleX(-1);filter: FlipH;-ms-filter: "FlipH";&#125; 移除被点链接的点框123a &#123;outline: none&#125;或者a &#123;outline: 0&#125; 在CSS中使用特殊字体1你可以使用CSS来加载特殊字体，你要做的就是把这个TTF格式的字体上传到服务器上，然后使用字体规则在CSS上导入它。 元素透明123456.element &#123;filter:alpha(opacity=50);-moz-opacity:0.5;-khtml-opacity: 0.5;opacity: 0.5;&#125; 使用CSS显示链接之后的URL12a:after&#123;content:" (" attr(href) ") ";&#125;这会在链接锚点后显示URL。你也可以用字体或其他样式定义它。 为手持设备定制特殊样式1&lt;link type="text/css" rel="stylesheet" href="handheldstyle.css" media="handheld"&gt; 文字的水平居中1text-align:center; link状态的设置顺序1234a:linka:visiteda:hovera:active 用图片充当列表标志123456ul &#123;list-style: none&#125;ul li &#123;background-image: url("path-to-your-image");background-repeat: none;background-position: 0 0.5em;&#125; 禁止自动换行1h1 &#123; white-space:nowrap; &#125; 获得焦点的表单元素1input:focus &#123; border: 2px solid green; &#125; user-select 禁止用户选中文本123div &#123;user-select: none; /* Standard syntax */&#125; 清除手机tap事件后element 时候出现的一个高亮123* &#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125; 增强用户体验，使用伪元素实现增大点击热区12345678.btn::befoer&#123;content:"";position:absolute;top:-10px;right:-10px;bottom:-10px;left:-10px;&#125; 伪元素实现换行，替代换行标签1234inline-element ::after&#123;content:"A";white-space: pre;&#125; will-change提高页面滚动、动画等渲染性能12345678910111213141516171819202122232425/* 关键字值 */will-change: auto;will-change: scroll-position;will-change: contents;will-change: transform; /* &lt;custom-ident&gt;示例 */will-change: opacity; /* &lt;custom-ident&gt;示例 */will-change: left, top; /* 两个&lt;animateable-feature&gt;示例 */will-change的使用也要谨慎，遵循最小化影响原则，不要这样直接写在默认状态中，因为will-change会一直挂着：.will-change &#123;will-change: transform;transition: transform 0.3s;&#125;.will-change:hover &#123;transform: scale(1.5);&#125;可以让父元素hover的时候，声明will-change，这样，移出的时候就会自动remove，触发的范围基本上是有效元素范围。.will-change-parent:hover .will-change &#123;will-change: transform;&#125;.will-change &#123;transition: transform 0.3s;&#125;.will-change:hover &#123;transform: scale(1.5);&#125; box-sizing 让元素的宽度、高度包含border和padding123&#123;box-sizing: border-box;&#125; calc() function, 计算属性值1234div &#123;width: calc(100% - 100px);&#125;例子就是让宽度为100%减去100px的值 css实现不换行、自动换行、强制换行1234567//不换行white-space:nowrap;//自动换行word-wrap: break-word;word-break: normal;//强制换行word-break:break-all; perspective 透视1234这个属性的存在决定你看到的元素是2d还是3d。一般设置在包裹元素的父类上。.div-box &#123;perspective: 400px;&#125; 设置图像透明度的两种方式12opcity:0.6；background:rgba(0,0,0,.6)； position定位属性123456position属性指定一个元素(静态的、相对的、绝对或固定)的定位方法的类型。position的属性值：absolute：生成绝对定位的元素；fixed：生成绝对定位的元素，相对于浏览器窗口进行定位；relative：生成相对定位的元素，相对于其正常位置经行定位。z-index：指定一个元素的堆叠顺序。 cursor属性123456789cursor属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状。CSS提供的cursor值：pointer ：小手指；help：箭头加问号；wait：转圈圈；move：移动光标；crosshair：十字光标。通过pointer属性我们可以伪造超链接：&lt;span style="cursor:pointer;color:blue;"&gt;pointer&lt;/span&gt; 隐藏没有静音、自动播放的影片123video[autoplay]:not([muted]) &#123;display: none;&#125; Font-Size 基准1234/* 假设浏览器的默认的大小是 16px ， 首先将其设置为10px (font-size:10/16) */body &#123;font-size:10/16;&#125;/* 然后就可以用em做统一字体单位了 2.4em = 24px */h1 &#123;font-size: 2.4 em&#125; 透明容器123456.element &#123;filter:alpha(opacity=50); /* for ie */-moz-opacity:0.5; /* for ff */-khtml-opacity: 0.5; /* for webkit as chrome */opacity: 0.5; /* for opera */&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多态的实现原理]]></title>
    <url>%2F2018%2F04%2F03%2FJava%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java多态概述&nbsp;&nbsp;&nbsp;&nbsp;多态是面向对象编程语言的重要特性，它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。Java对于方法调用动态绑定的实现主要依赖于方法表，但通过类引用调用(invokevitual)和接口引用调用(invokeinterface)的实现则有所不同。&nbsp;&nbsp;&nbsp;&nbsp;多态分为操作符的多态和类的多态。操作符的多态：+可以作为算术运算，也可作为字符串连接。类的多态：父类引用指向子类对象。要实现类的多态，需要如下条件：父类(接口)引用指向子类对象和调用的方法有重写。&nbsp;&nbsp;&nbsp;&nbsp;类引用调用的大致过程为:Java编译器将Java源代码编译成class文件，在编译过程中，会根据静态类型将调用的符号引用写到class文件中。在执行时，JVM根据class文件找到调用方法的符号引用，然后在静态类型的方法表中找到偏移量，然后根据this指针确定对象的实际类型，使用实际类型的方法表，偏移量跟静态类型中方法表的偏移量一样，如果在实际类型的方法表中找到该方法，则直接调用，否则，认为没有重写父类该方法。按照继承关系从下往上搜索。&nbsp;&nbsp;&nbsp;&nbsp;从上图可以看出，当程序运行时，需要某个类时，类载入子系统会将相应的class文件载入到JVM中，并在内部建立该类的类型信息（这个类型信息其实就是class文件在JVM中存储的一种数据结构），包含java类定义的所有信息，包括方法代码，类变量、成员变量、以及本博文要重点讨论的方法表。这个类型信息就存储在方法区。&nbsp;&nbsp;&nbsp;&nbsp;注意，这个方法区中的类型信息跟在堆中存放的class对象是不同的。在方法区中，这个class的类型信息只有唯一的实例（所以是各个线程共享的内存区域），而在堆中可以有多个该class对象。可以通过堆中的class对象访问到方法区中类型信息。就像在java反射机制那样，通过class对象可以访问到该类的所有信息一样。方法表是实现动态调用的核心。上面讲过方法表存放在方法区中的类型信息中。为了优化对象 调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表， 方法表中的每一个项都是对应方法的指针。这些方法中包括从父类继承的所有方法以及自身重写（override）的方法。方法区:方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池:它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。方法区的内存回收目标是针对常量池的回收及对类型的卸载。 Java的方法调用方式 1、Java 的方法调用有两类，动态方法调用与静态方法调用。2、静态方法调用是指对于类的静态方法的调用方式，是静态绑定的；而动态方法调用需要有方法调用所作用的对象，是动态绑定的。3、类调用 (invokestatic) 是在编译时就已经确定好具体调用方法的情况。4、实例调用 (invokevirtual)则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。5、JVM 的方法调用指令有四个，分别是 invokestatic，invokespecial，invokesvirtual 和 invokeinterface。前两个是静态绑定，后两个是动态绑定的。本文也可以说是对于JVM后两种调用实现的考察。 方法表与方法调用如有类定义Persion、Girl、Boy123456789101112131415161718192021222324class Person &#123; public String toString()&#123; return "I'm a person."; &#125; public void eat()&#123;&#125; public void speak()&#123;&#125; &#125; class Boy extends Person&#123; public String toString()&#123; return "I'm a boy"; &#125; public void speak()&#123;&#125; public void fight()&#123;&#125; &#125; class Girl extends Person&#123; public String toString()&#123; return "I'm a girl"; &#125; public void speak()&#123;&#125; public void sing()&#123;&#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;当这三个类被载入到Java虚拟机之后，方法区中就包含了各自的类的信息。&nbsp;&nbsp;&nbsp;&nbsp;Girl 和 Boy 的方法表包含继承自 Object 的方法，继承自直接父类Person的方法及各自新定义的方法。注意方法表条目指向的具体的方法地址，如 Girl 继承自Object的方法中，只有 toString()指向自己的实现（Girl 的方法代码），其余皆指向 Object 的方法代码；其继承自于 Person 的方法 eat() 和 speak() 分别指向 Person 的方法实现和本身的实现。&nbsp;&nbsp;&nbsp;&nbsp;如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。&nbsp;&nbsp;&nbsp;&nbsp;因此，方法表的偏移量总是固定的。所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。&nbsp;&nbsp;&nbsp;&nbsp;Person或Object中的任意一个方法，在它们的方法表和其子类 Girl和Boy的方法表中的位置(index)是一样的。这样 JVM在调用实例方法其实只需要指定调用方法表中的第几个方法即可。 接口调用&nbsp;&nbsp;&nbsp;&nbsp;因为 Java 类是可以同时实现多个接口的，而当用接口引用调用某个方法的时候，情况就有所不同了。&nbsp;&nbsp;&nbsp;&nbsp;Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同样的方法在基类和派生类的方法表的位置就可能不一样了。1234567891011121314151617181920212223242526272829interface IDance&#123; void dance(); &#125; class Person &#123; public String toString()&#123; return "I'm a person."; &#125; public void eat()&#123;&#125; public void speak()&#123;&#125; &#125; class Dancer extends Person implements IDance &#123; public String toString()&#123; return "I'm a dancer."; &#125; public void dance()&#123;&#125; &#125; class Snake implements IDance&#123; public String toString()&#123; return "A snake."; &#125; public void dance()&#123; //snake dance &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，由于接口的介入，继承自于接口 IDance 的方法 dance()在类Dancer和Snake的方法表中的位置已经不一样了，显然我们无法仅根据偏移量来进行方法的调用。&nbsp;&nbsp;&nbsp;&nbsp;Java对于接口方法的调用是采用搜索方法表的方式，如，要在Dancer的方法表中找到dance()方法，必须搜索Dancer的整个方法表。&nbsp;&nbsp;&nbsp;&nbsp;因为每次接口调用都要搜索方法表，所以从效率上来说，接口方法的调用总是慢于类方法的调用的。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悲观锁与乐观锁]]></title>
    <url>%2F2018%2F04%2F02%2F%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在数据库的锁机制中介绍过，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。&nbsp;&nbsp;&nbsp;&nbsp;乐观并发控制(乐观锁)和悲观并发控制(悲观锁)是并发控制主要采用的技术手段。&nbsp;&nbsp;&nbsp;&nbsp;无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。&nbsp;&nbsp;&nbsp;&nbsp;针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。 悲观锁 &nbsp;&nbsp;&nbsp;&nbsp;在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作读某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。&nbsp;&nbsp;&nbsp;&nbsp;悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 &nbsp;&nbsp;&nbsp;&nbsp;悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）在数据库中，悲观锁的流程如下: &nbsp;&nbsp;&nbsp;&nbsp;在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。&nbsp;&nbsp;&nbsp;&nbsp;如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。&nbsp;&nbsp;&nbsp;&nbsp;如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。&nbsp;&nbsp;&nbsp;&nbsp;其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 MySQL InnoDB中使用悲观锁 &nbsp;&nbsp;&nbsp;&nbsp;要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0; 12345678910//0.开始事务begin;/begin work;/start transaction; (三者选一就可以)//1.查询出商品信息select status from t_goods where id=1 for update;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;//4.提交事务commit;/commit work; &nbsp;&nbsp;&nbsp;&nbsp;上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 &nbsp;&nbsp;&nbsp;&nbsp;上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 优点与不足&nbsp;&nbsp;&nbsp;&nbsp;悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。 乐观锁 &nbsp;&nbsp;&nbsp;&nbsp;在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。 &nbsp;&nbsp;&nbsp;&nbsp;乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。&nbsp;&nbsp;&nbsp;&nbsp;相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 &nbsp;&nbsp;&nbsp;&nbsp;数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。&nbsp;&nbsp;&nbsp;&nbsp;实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。 使用版本号实现乐观锁&nbsp;&nbsp;&nbsp;&nbsp;使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。12345671.查询出商品信息select (status,status,version) from t_goods where id=#&#123;id&#125;2.根据商品信息生成订单3.修改商品status为2update t_goods set status=2,version=version+1where id=#&#123;id&#125; and version=#&#123;version&#125;; 优点与不足&nbsp;&nbsp;&nbsp;&nbsp;乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的锁机制]]></title>
    <url>%2F2018%2F04%2F02%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在并发访问情况下，可能会出现脏读、不可重复读和幻读等读现象，为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念。 并发控制 在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制是确保及时纠正由并发操作导致的错误的一种机制。 &nbsp;&nbsp;&nbsp;&nbsp;数据库管理系统(DBMS)中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不被破坏事务的隔离性和统一性以及数据库的统一性。下面举例说明并发操作 带来的数据不一致性问题:&nbsp;&nbsp;&nbsp;&nbsp;现有两处火车票售票点，同时读取某一趟列车车票数据库中车票余额为 X。两处售票点同时卖出一张车票，同时修改余额为 X -1写回数据库，这样就造成了实际卖出两张火车票而数据库中的记录却只少了一张。 产生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。&nbsp;&nbsp;&nbsp;&nbsp;封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制(悲观锁)是并发控制主要采用的技术手段。 锁&nbsp;&nbsp;&nbsp;&nbsp;当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。&nbsp;&nbsp;&nbsp;&nbsp;在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。锁的分类12345按操作划分，可分为DML锁、DDL锁按锁的粒度划分，可分为表级锁、行级锁、页级锁(mysql)按锁级别划分，可分为共享锁、排他锁按加锁方式划分，可分为自动锁、显示锁按使用方式划分，可分为乐观锁、悲观锁 &nbsp;&nbsp;&nbsp;&nbsp;DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁))。 DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义。其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程通信]]></title>
    <url>%2F2018%2F04%2F01%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。 如何让两个线程依次执行&nbsp;&nbsp;&nbsp;&nbsp;假设有两个线程，一个是线程A，另一个是线程B，两个线程分别依次打印1-3三个数字即可。代码如下:123456789101112131415161718192021222324252627282930313233public class long1_1&#123; private static void demo1() &#123; Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; printNumber("A"); &#125; &#125;); Thread B = new Thread(new Runnable() &#123; @Override public void run() &#123; printNumber("B"); &#125; &#125;); A.start(); B.start(); &#125; private static void printNumber(String threadName) &#123; int i=0; while (i++ &lt; 3) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadName + "print:" + i); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果:&nbsp;&nbsp;&nbsp;&nbsp;可以看到A和B是同时打印的。&nbsp;&nbsp;&nbsp;&nbsp;那么，如果我们希望B在A全部打印完后再开始打印呢？可以利用thread.join()方法，代码如下:123456789101112131415161718192021222324252627282930313233343536373839public class long1_1&#123; private static void demo1() &#123; Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; printNumber("A"); &#125; &#125;); Thread B = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("B 开始等待 A"); try &#123; A.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; printNumber("B"); &#125; &#125;); B.start(); A.start(); &#125; private static void printNumber(String threadName) &#123; int i=0; while (i++ &lt; 3) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadName + "print:" + i); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果: 如何让两个线程按照指定方式有序交叉运行？&nbsp;&nbsp;&nbsp;&nbsp;A在打印完1后，再让B打印1，2，3，最后再回到A继续打印2，3。这种需求下，显然Thread.join()已经不能满足了。我们需要更细粒度的锁来控制执行顺序。这里可以用object.wait()和object.notify()两个方法来实现。代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class long1_1&#123; private static void demo1() &#123; Object lock = new Object(); Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("INFO: A 等待锁"); synchronized (lock) &#123; System.out.println("INFO: A 得到了锁 lock"); System.out.println("A 1"); try &#123; System.out.println("INFO: A 准备进入等待状态，放弃锁 lock 的控制权"); lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("INFO: 有人唤醒了 A, A 重新获得锁 lock"); System.out.println("A 2"); System.out.println("A 3"); &#125; &#125; &#125;); Thread B = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("INFO: B 等待锁"); synchronized (lock) &#123; System.out.println("INFO: B 得到了锁 lock"); System.out.println("B 1"); System.out.println("B 2"); System.out.println("B 3"); System.out.println("INFO: B 打印完毕，调用 notify 方法"); lock.notify(); &#125; &#125; &#125;); A.start(); B.start(); &#125; private static void printNumber(String threadName) &#123; int i=0; while (i++ &lt; 3) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadName + "print:" + i); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果:&nbsp;&nbsp;&nbsp;&nbsp;那么，这个过程发生了什么呢？ 1、首先创建一个A和B共享的对象锁lock = new Object();2、当A得到锁后，先打印1，然后调用lock.wait()方法，交出锁的控制权，进入wait状态；3、对B而言，由于A最开始得到了锁，导致B无法执行；直到A调用lock.wait()释放控制权后，B才得到了锁；4、B在得到锁后打印1，2，3；然后调用lock.notify()方法，唤醒正在 wait的A;5、A被唤醒后，继续打印剩下的2，3。 四个线程ABCD，其中D要等到ABC全执行完毕后才执行，而且ABC是同步运行的&nbsp;&nbsp;&nbsp;&nbsp;A，B，C三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要A，B，C都运行完了，D再开始运行。针对这种情况，我们可以利用CountdownLatch来实现这类通信方式。它的基本用法是： 1、创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);2、在等待线程里调用countDownLatch.await()方法，进入等待状态，直到计数值变成0；3、在其他线程里，调用countDownLatch.countDown()方法，该方法会将计数值减小1；4、当其他线程的countDown()方法把计数值变成0时，等待线程里的countDownLatch.await()立即退出，继续执行下面的代码。代码如下:12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.CountDownLatch;public class long1_1&#123; private static void demo1() &#123; int worker = 3; CountDownLatch countDownLatch = new CountDownLatch(worker); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("D is waiting for other three threads"); try &#123; countDownLatch.await(); System.out.println("All done, D starts working"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); for (char threadName='A'; threadName &lt;= 'C'; threadName++) &#123; final String tN = String.valueOf(threadName); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(tN + "is working"); try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(tN + "finished"); countDownLatch.countDown(); &#125; &#125;).start(); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果:&nbsp;&nbsp;&nbsp;&nbsp;其实简单点来说，CountDownLatch就是一个倒计数器，我们把初始计数值设置为3，当D运行时，先调用countDownLatch.await()检查计数器值是否为0，若不为0则保持等待状态；当ABC各自运行完后都会利用countDownLatch.countDown()，将倒计数器减1，当三个都运行完后，计数器被减至0；此时立即触发D的await()运行结束，继续向下执行。因此，CountDownLatch适用于一个线程去等待多个线程的情况。 线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行。&nbsp;&nbsp;&nbsp;&nbsp;为了实现线程间互相等待这种需求，我们可以利用 CyclicBarrier 数据结构，它的基本用法是： 1、先创建一个公共CyclicBarrier对象，设置同时等待的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);2、这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用cyclicBarrier.await(); 即可开始等待别人；3、当指定的 同时等待的线程数都调用了。cyclicBarrier.await();时，意味着这些线程都准备完毕好，然后这些线程才 同时继续执行。代码如下:123456789101112131415161718192021222324252627282930313233343536373839import java.util.Random;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class long1_1&#123; private static void demo1() &#123; int runner = 3; CyclicBarrier cyclicBarrier = new CyclicBarrier(runner); final Random random = new Random(); for (char runnerName='A'; runnerName &lt;= 'C'; runnerName++) &#123; final String rN = String.valueOf(runnerName); new Thread(new Runnable() &#123; @Override public void run() &#123; long prepareTime = random.nextInt(10000) + 100; System.out.println(rN + "is preparing for time:" + prepareTime); try &#123; Thread.sleep(prepareTime); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; System.out.println(rN + "is prepared, waiting for others"); cyclicBarrier.await(); // 当前运动员准备完毕，等待别人准备好 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(rN + "starts running"); // 所有运动员都准备好了，一起开始跑 &#125; &#125;).start(); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果: 子线程完成某件任务后，把得到的结果回传给主线程&nbsp;&nbsp;&nbsp;&nbsp;实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？&nbsp;&nbsp;&nbsp;&nbsp;回顾线程的创建，我们一般会把 Runnable 对象传给 Thread 去执行。Runnable定义如下：123public interface Runnable&#123; public abstract void run();&#125; &nbsp;&nbsp;&nbsp;&nbsp;可以看到 run() 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 Callable：123456789@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; &nbsp;&nbsp;&nbsp;&nbsp;可以看出 Callable 最大区别就是返回范型 V 结果。&nbsp;&nbsp;&nbsp;&nbsp;那么下一个问题就是，如何把子线程的结果回传回来呢？在Java里，有一个类是配合Callable使用的：FutureTask，不过注意，它获取结果的 get 方法会阻塞主线程。&nbsp;&nbsp;&nbsp;&nbsp;举例，我们想让子线程去计算从 1 加到 100，并把算出的结果返回到主线程。123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class long1_1&#123; private static void demo1() &#123; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; System.out.println("Task starts"); Thread.sleep(1000); int result = 0; for (int i=0; i&lt;=100; i++) &#123; result += i; &#125; System.out.println("Task finished and return result"); return result; &#125; &#125;; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callable); new Thread(futureTask).start(); try &#123; System.out.println("Before futureTask.get()"); System.out.println("Result:" + futureTask.get()); System.out.println("After futureTask.get()"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; demo1(); &#125;&#125; 输出结果:&nbsp;&nbsp;&nbsp;&nbsp;可以看到，主线程调用 futureTask.get() 方法时阻塞主线程；然后 Callable 内部开始执行，并返回运算结果；此时 futureTask.get() 得到结果，主线程恢复运行。&nbsp;&nbsp;&nbsp;&nbsp;通过 FutureTask 和Callable可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 ExecutorService，把 FutureTask 放到线程池去管理执行。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equal()和hashCode()比较]]></title>
    <url>%2F2018%2F04%2F01%2Fequal-%E5%92%8ChashCode-%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;equal()反映的是对象或变量具体的值，即两个对象里面包含的值–可能是对象的引用，也可能是值类型的值。&nbsp;&nbsp;&nbsp;&nbsp;而hashCode()是对象或变量通过哈希算法计算出的哈希值。&nbsp;&nbsp;&nbsp;&nbsp;之所以有hashCode()方法，是因为在批量的对象比较中，hashCode要比equals来的快，很多集合都用到了hashCode，比如HashTable。 两个obj，如果equals()相等，hashCode()一定相等。两个obj，如果hashCode()相等，equals()不一定相等(Hash散列值由冲突的情况，虽然概率很低)。所以: 可以考虑在集合中，判断两个对象是否相等的规则是:第一步: 如果hashCode()相等，则查看第二步，否则不相等。第二步: 查看equals()是否相等，如果相等，则两obj相等，否则还是不相等。 1、equals()和hashCode()这两个方法都是从Object类中继承过来的 equals()是对两个对象的地址值进行的比较(即比较引用是否相同)。hashCode()是一个本地方法。它的实现是根据本地机器相关的。 2、Java语言对equals()的要求如下，这些要求是必须遵循的: A) 对称性: 如果x.equals(y)返回是”true”，那么y.equals(x)也应该返回是”true”。B) 反射性: x.equals(x)必须返回是”true”。C) 类推性: 如果x.equals(y)返回是”true”，而且y.equals(z)返回是”true”，那么z.equals(x)也应该返回是”true”。D) 一致性: 如果x.equals(y)返回是”true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是”true”。任何情况下，x.euqals(null)，永远返回是”false”；x.equals(和x不同类型的对象)永远返回是”false”。 3、equals()和hashCode() equals()相等的两个对象，hashCode()一定相等；反过来: hashCode()不等，一定能推出equals()也不等；hashCode()相等，equals()可能相等，也可能不等。 1、为什么要重载equal方法？ 因为Object的equal方法默认是两个对象的引用的比较，意思就是指向同一内存，地址则相等；如果你现在需要利用对象里面的值来判断是否相等，则重载equal方法。 2、为什么重置hashCode方法？ 一般的地方不需要重置hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode，那么为什么要重载hashCode呢？就HashMap来说，好比HashMap就是一个大内存块，里面有很多小内存块，小内存块里面是一系列的对象，可以利用hashCode来查找小内存块hashCode%size(小内存块数量)，所以当equal相等时，hashCode必须相等，而且如果是Object对象，必须重载hashCode和equal方法。 3、为什么equal()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等? 1、因为是按照hashCode来访问小内存块，所以hashCode必须相等。2、HashMap获取一个对象是比较key的hashCode相等和equal为true。之所以hashCode相等，却可以equal不等，就比如ObjectA和ObjectB他们都有属性name，那么hashCode都以name计算，所以hashCode一样，但是两个对象属于不同类型，所以equal为false。 4、为什么需要HashCode？ 1、 通过hashCode可以很快的查到小内存块。2、通过hashCode比较比equal方法快，当get时先比较hashCode，如果hashCode不同，直接返回false。 5、hashCode()作用 hashCode()方法使用来提高Map里面的搜索效率的,Map会根据不同的hashCode()来放在不同的桶里面,Map在搜索一个对象的时候先通过hashCode()找到相应的桶,然后再根据equals()方法找到相应的对象。 6、Java中的集合（Collection）有两类，一类是List，再有一类是Set。你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。&nbsp;&nbsp;&nbsp;&nbsp;那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是Object.equals方法了。&nbsp;&nbsp;&nbsp;&nbsp;但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。&nbsp;&nbsp;&nbsp;&nbsp;也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。&nbsp;&nbsp;&nbsp;&nbsp;哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。我们可以认为hashCode方法返回的就是对象存储的物理地址（实际可能并不是,例如:通过获取对象的物理地址然后除以8再求余,余数几是计算得到的散列值,我们就认为返回一个不是物理地址的数值,而是一个可以映射到物理地址的值）。&nbsp;&nbsp;&nbsp;&nbsp;这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类及其常用方法]]></title>
    <url>%2F2018%2F04%2F01%2FObject%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Object类是一个特殊的类，是所有类的父类，如果一个类没有用extends明确指出继承于某个类，那么它默认继承Object类。Object类中三个常用的方法: toString()、equals()、hashCode()。 取得对象信息的方法: toString()该方法在打印对象时候被调用，将对象信息变为字符串返回，默认输出对象地址。12345678910111213class Students&#123; String name= "zhangsan"; int age= 21;&#125;public class long1_1&#123; public static void main(String[] args) &#123; Students students= new Students(); System.out.println("姓名: "+ students.name+ ", 年龄: "+ students.age);//输出对象属性 System.out.println(students);//直接输出对象信息 System.out.println(students.toString());//调用父类方法输出对象信息 &#125;&#125; 输出结果:上述结果可看出编译器默认调用toString()方法输出对象，但输出的是对象的地址，我们并不能看懂它的意思。就要通过重写Object类的toString()方法来输出对象属性信息。12345678910111213141516class Students&#123; String name= "zhangsan"; int age= 21; public String toString() &#123; return "姓名: "+ name+ ", 年龄: "+ age; &#125;&#125;public class long1_1&#123; public static void main(String[] args) &#123; Students students= new Students(); System.out.println("姓名: "+ students.name+ ", 年龄: "+ students.age);//输出对象属性 System.out.println(students);//直接输出对象信息 System.out.println(students.toString());//调用父类方法输出对象信息 &#125;&#125; 输出结果: 对象相等判断方法: equals()该方法用于比较帝乡是否相等，而且此方法必须被重写。1234567891011121314151617class Students&#123; String name; int age; public Students(String name, int age) &#123; this.name= name; this.age= age; &#125;&#125;public class long1_1&#123; public static void main(String[] args) &#123; Students s1= new Students("zhangsang", 21); Students s2= new Students("lisi", 21); System.out.println(s1.equals(s2)); System.out.println(s1.equals(s2)?"s1和s2是同一个人": "s1和s2不是同一个人"); &#125;&#125; 输出结果:很明显输出的结果是错误的，因为equals()方法比较的是两个对象的地址 ，所以必须重写方法才能到达目的。1234567891011121314151617181920212223242526class Student&#123; String name; int age; //重写父类（Object类）中的equals方法 public boolean equals()&#123; boolean temp; Student s1 = new Student(); s1.name="张三";s1.age=12; Student s2 = new Student(); s2.name="张三";s2.age=12; if((s1.name.equals(s2.name))&amp;&amp;(s1.age==s2.age))&#123; temp = true; &#125; else&#123; temp = false; &#125; return temp; &#125;&#125;public class long1_1&#123; public static void main(String[] args)&#123; Student s3 = new Student(); System.out.println(s3.equals()?"是同一人":"不是同一人"); &#125;&#125; 对象签名: hashCode()该方法用来返回其所在对象的物理地址(哈希码值)，常会和equals方法同时重写，确保相等的两个对象拥有相等的hashCode。123456789101112131415161718192021222324252627282930313233class Student&#123; String name; int age; //重写父类（Object类）中的equals方法 public boolean equals()&#123; boolean temp; Student s1 = new Student(); s1.name="张三";s1.age=12; Student s2 = new Student(); s2.name="张三";s2.age=12; System.out.println("s1的哈希码："+s1.hashCode()); System.out.println("s2的哈希码："+s2.hashCode()); if((s1.name.equals(s2.name))&amp;&amp;(s1.age==s2.age))&#123; temp = true; &#125; else&#123; temp = false; &#125; return temp; &#125; //重写hashCode()方法 public int hashCode()&#123; return age*(name.hashCode()); &#125;&#125;public class long1_1&#123; public static void main(String[] args)&#123; Student s3 = new Student(); System.out.println(s3.equals()?"s1和s2是同一人":"s1和s2不是同一人"); &#125;&#125; 输出结果:]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务及其四个特性]]></title>
    <url>%2F2018%2F04%2F01%2FMySQL%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%85%B6%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[事务概念引入&nbsp;&nbsp;&nbsp;&nbsp;现实生活中，我们往往经常会进行转账操作，转账操作可以分为两部分来完成，转入和转出。只有这两部分都完成了才可以认为是转账成功。在数据库中，这个过程是使用两条语句来完成的，如果其中任意一条语句出现了异常没有执行，则会导致两个账号的金额不同步，造成错误。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了防止上面可能出现的情况，MySQL引入了事务，所谓事务就是针对数据库的一组操作，它可以由一条或多条SQL语句组成，同一个事务的操作具备同步的特点，如果其中有一条语句不能执行的话，那么所有的语句都不会执行，也就是说，事务中的语句要么都执行，要么都不执行。&nbsp;&nbsp;&nbsp;&nbsp;在使用数据库时候需要使用事务，必须先开启事务，开启事务的语句具体如下:start transaction;即:上面语句是用来开启事务，事务开启之后就可以执行SQL语句，SQL语句执行成功之后，需要使用相应语句提交事务，提交事务的语句如下:commit;需要注意的是，在MySQL中直接书写SQL语句都是自动提交的，而事务中的操作语句需要使用commit语句手动提交，只有事务提交后其中的操作才会生效。如果不想提交事务，我们还可以使用相关语句取消事务(也称回滚)，具体语句如下:rollback;注: rollback语句只能针对未提交的事务执行的回滚操作，已经提交的事务是不能回滚的。 事务的四个基本要素(ACID)ACID，指数据库事务正确执行的四个基本要素的缩写。包含: 原子性、一致性、隔离性、持久性。1234原子性: 原子性意味着事务的整体性和不可分割性，这就类似化学中的原子，是一个不可分割的单元。一个事务可以是一个（任务）操作，也可以是多个（任务）操作，假设一个事务由多个操作（任务）组成，那么这些操作必须都执行成功这个事务才被认为执行成功，只要其中有一个任务执行失败那么整个事务都会被认为执行失败，导致自动回滚到初始状态，通俗来讲就是“同进退”，这保证了事务的整体性。这就是事物的原子性。 专业来讲，原子的执行是一个全部发生或全部失败的整体过程。在一个原子操作中，如果事务中的任何一个语句失败，前面执行的语句都将被返回，以保证数据的整体性不被破坏。这在常用的系统应用中，为保证数据的安全性起到一定作用。 一致性: 在MySql事务处理过程中，无论事务是完全成功或是在中途因某些环节失败而导致失败，但事务使系统处于一致的状态时，必须保持一致性，用户A向用户B的账户中转入5000元，但用户B在查询转账信息的时候，发现自己的账户只增加了3000元，这样不能使整个事务达到一致性。 在MySql中，一致性主要由MySql的日志机制处理，它记录数据库的所有变化，为事务回复提供跟踪记录。如果系统在事务处理中间发生错误，MySql恢复过程将使用这些日志发现事务是否已经完全成功执行或需要返回。一致性属性保证数据库从不返回一个未处理的事务。隔离性: 它是指每个事务在自己的空间发生，和其他发生在系统中的事务隔离，而且事务的结果只在它完全被执行的时候才能看到，如果该事务未提交，则其他会话看不到执行的结果。这样的话即使一个系统中同时发生多个事务，孤立性也可以保证特定的事务在完成之前，其结果是不被公布的。当系统支持多个同时存在的用户和连接时，系统必须遵守孤立性原则，否则在执行过程中可能导致大量数据被破坏，孤立性保证每个事务完整地在其各自的空间内被顺序的执行，保证事务之间不会相互冲突。持久性: 在MySql中，即使是数据库系统崩溃，一个提交的事务仍然在坚持。当一个事务完成，数据库的日志已经被更新时，持久性即可发挥其特有功效。在MySql中，如果系统崩溃或者数据存储介质被破坏，通过使用日志，系统能够恢复在重启前进行的最后一次成功更新，可以反应系统崩溃时处于执行过程的事务的变化。 MySql的持久性是通过一条记录事务过程中系统变化的二进制事务日志文件来实现的。如果遇到硬件损坏或者系统的异常关机，系统在下一次启动时，通过使用最后的备份和日志就可以恢复丢失数据。 如何使用事务？12345678create databases test;use test;create table accounts(id int primary key auto_increment,name varchar(40),money float);insert into accounts(name, money) values('a', 1000);insert into accounts(name, money) values('b', 1000); 执行效果如下:演示使用事务来实现转账功能:首先开启一个事务，然后通过update语句将a账户的100元转给b账户，然后提交事务，具体语句如下:1234start transaction;update account set money= money- 100 where name= 'a';update account set money= money+ 100 where name= 'b';commit; 执行效果如下:]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程]]></title>
    <url>%2F2018%2F03%2F31%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java多线程实现方式主要有四种:&nbsp;&nbsp;&nbsp;&nbsp;继承Thread类，重写run方法、实现Runnable接口，重写run方法，实现Run nable接口的实现类的实例对象作为Thread构造函数的target、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程(线程池)。&nbsp;&nbsp;&nbsp;&nbsp;其中前两种方式线程执行完后都没有返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果。后两种是带返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中。 继承Thread类的线程123456789101112131415public class long1_1 extends Thread &#123; public long1_1()&#123; //编写子类的构造方法，可缺省 &#125; public void run()&#123; //编写自己的线程代码 System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args)&#123; long1_1 threadDemo01 = new long1_1(); threadDemo01.setName("我是自定义的线程1"); threadDemo01.start(); System.out.println(Thread.currentThread().toString()); &#125;&#125; 输出结果: 通过实现Runnable接口、实现run方法，接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，通过调用start()方法启动线程。12345678910111213141516public class long1_1 &#123; public static void main(String[] args)&#123; System.out.println(Thread.currentThread().getName()); Thread t1 = new Thread(new MyThread()); t1.start(); &#125;&#125;class MyThread implements Runnable&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()+"--&gt;我是通过实现接口的线程实现方式！"); &#125; &#125; 输出结果: 通过Callable和FutureTask创建线程a: 创建Callable接口的实现类，并实现Call方法b: 创建Callable实现类的实现，使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的Call方法的返回值c: 使用FutureTask对象作为Thread对象的target创建并启动线程d: 调用FutureTaske对象的get()来获取子线程执行结束的返回值1234567891011121314151617181920212223242526import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;public class long1_1 &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Callable&lt;Object&gt; oneCallable = new Tickets&lt;Object&gt;(); FutureTask&lt;Object&gt; oneTask = new FutureTask&lt;Object&gt;(oneCallable); Thread t = new Thread(oneTask); System.out.println(Thread.currentThread().getName()); t.start(); &#125;&#125;class Tickets&lt;Object&gt; implements Callable&lt;Object&gt;&#123; //重写call方法 @Override public Object call() throws Exception &#123; // TODO Auto-generated method stub System.out.println(Thread.currentThread().getName()+"--&gt;我是通过实现Callable接口通过FutureTask包装器来实现的线程"); return null; &#125; &#125; 输出结果: 通过线程池创建线程123456789101112131415161718192021222324252627282930import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class long1_1&#123; private static int POOL_NUM = 10; //线程池数量 /** * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; // TODO Auto-generated method stub ExecutorService executorService = Executors.newFixedThreadPool(5); for(int i = 0; i&lt;POOL_NUM; i++) &#123; RunnableThread thread = new RunnableThread(); //Thread.sleep(1000); executorService.execute(thread); &#125; //关闭线程池 executorService.shutdown(); &#125; &#125;class RunnableThread implements Runnable &#123; @Override public void run() &#123; System.out.println("通过线程池方式创建的线程：" + Thread.currentThread().getName() + " "); &#125; &#125; 输出结果:ExecutorService、Callable都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，还有Future接口也是属于这个框架。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList和LinkedList的区别]]></title>
    <url>%2F2018%2F03%2F31%2FArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ArrayList和LinkedList是常用的两种存储结构。123456ArrayList是实现了基于动态数组的数据结构，LinkedList是基于链表的数据结构。这俩都是对List接口的实现。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList是线性的数据存储方式，需要移动指针从前往后依次查找。对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要移动数据。从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。ArrayList主要控件开销在于需要在List列表预留一定空间；而LinkedList主要控件开销在于需要存储结点信息以及结点指针信息。LinkedList需要更多的内存空间，因为它除了要存储数据之外，还需要存储该结点的前后结点信息，而ArrayList索引处就是存的数据。 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class long1_1 &#123; static final int N=50000; static long timeList(List list)&#123; long start=System.currentTimeMillis(); Object o = new Object(); for(int i=0;i&lt;N;i++) &#123; list.add(0, o); &#125; return System.currentTimeMillis()-start; &#125; static long readList(List list)&#123; long start=System.currentTimeMillis(); for(int i=0,j=list.size();i&lt;j;i++)&#123; &#125; return System.currentTimeMillis()-start; &#125; static List addList(List list)&#123; Object o = new Object(); for(int i=0;i&lt;N;i++) &#123; list.add(0, o); &#125; return list; &#125; public static void main(String[] args) &#123; System.out.println("ArrayList添加"+N+"条耗时："+timeList(new ArrayList())); System.out.println("LinkedList添加"+N+"条耗时："+timeList(new LinkedList())); List list1=addList(new ArrayList&lt;&gt;()); List list2=addList(new LinkedList&lt;&gt;()); System.out.println("ArrayList查找"+N+"条耗时："+readList(list1)); System.out.println("LinkedList查找"+N+"条耗时："+timeList(list2)); &#125;&#125; 当我们在集合中装5万条数据，测试运行结果如下:可以看到ArrayList更适合读取数据，LinkedList更多的时候添加或删除数据。 当插入的数据量很小时，两者区别不太大，当插入的数据量大时，大约在容量的1/10之前，LinkedList会优于ArrayList，在其后就劣于ArrayList，且越靠近后面越差。]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机的架构]]></title>
    <url>%2F2018%2F03%2F30%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[类加载子系统: 负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。除了类信息外，方法区中可能还会存放运行时常量池信息，包括字符串字面量和数字量(这部分常量信息是Class文件中常量池部分的内存映射)。当JVM使用类加载器装载某个类时，它首先要定位对应的Class文件，然后读入这个Class文件，最后，JVM提取该文件的内容信息，并将这些信息存储到方法区，最后返回一个Class实例。方法区： 方法区主要存储的是方法，静态成员，常量。方法区中给每个类都规定了空间并且持有this和super的引用。当运行到哪个对象的时候，通过this动态指向该对象，引用该对象的成员变量，然后和方法以及局部变量一起在栈中进行运算。方法区的大小不必是固定的，默认最小值为16MB，最大为64MB，JVM可根据应用需要动态调整。同时，方法区也不一定是连续的，方法区可以在一个堆(甚至是JVM自己的堆)中自由分配。Java堆: Java堆是在JVM启动的时候就建立的，是java程序最主要的内存工作区域。堆空间是所有线程共享的。这块内存区域存放了对象实例及数组(所有new的对象)也就是Object object= new Object();这里object只是一个引用是放在栈里面的，new Object()被放在了堆内存里面。由于现在收集器都是采用分代收集算法，堆被划为新生代和老年代。新生代主要存储所创建的对象和尚未进入老年代的对象，老年代存储经过多次新生代GC(Minor GC)仍然存活的对象。直接内存: Java的NIO库允许Java程序使用直接内存。直接内存是在Java堆外的、直接向系统申请的内存空间。通常，访问直接内存的速度会优于Java堆。因此出于性能考虑，读写频繁的场合应考虑使用直接内存。因为直接内存不在java堆内，因此直接内存的大小不会直接受限于jvm参数-Xmx，而它和java堆的总和，受制于操作系统的内存大小。垃圾回收系统: 这是JVM的重要组成部分，垃圾回收器可以直接对方法区、Java堆和直接内存进行回收。在其中Java堆则是垃圾回收器的重点工作区域，对于不在使用的垃圾对象，垃圾回收系统会在后台查找标识，并且释放这些不用的垃圾对象。Java栈: 每一个线程中都有私有的Java栈，一个线程的Java栈在线程被创建的时候就会被创建。Java栈由许多栈帧组成，一个栈帧包含一个Java方法调用的状态。当线程调用要给Java方法时，虚拟机压入一个新的栈帧到该线程的Java栈中，当该方法返回时，这个栈帧就从Java栈中弹出。Java栈中存储线程中Java方法调用的状态包括：局部变量、方法参数、返回值以及运算的中间结果等，并且对象的引用也存在栈中。Java虚拟机没有寄存器，其指令集使用Java栈来存储中间数据。这样设计的原因是为了保持Java虚拟机的指令集尽量紧凑，同时也便于Java虚拟机在只有很少通用寄存器的平台上实现。另外，基于栈的体系结构，也有助于运行时某些虚拟机实现的动态编译器和即时编译器的代码优化。本地方法栈: 任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的栈，虚拟机只是简单地动态连接并直接调用指定的本地方法。其中方法区和堆由该虚拟机实例中所有线程共享。当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息放到方法区。当程序运行时，虚拟机会把所有该程序在运行时创建的对象放到堆中。像其它运行时内存区一样，本地方法栈占用的内存区可以根据需要动态扩展或收缩。PC寄存器: PC寄存器也是每个线程私有的空间，Java虚拟机会为每个Java线程创建PC寄存器。在任意时刻，一个Java线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向当前正在被执行的指令，若是本地方法，则PC的值就是undefined。执行引擎: 最核心的组件之一，负责执行虚拟机的字节码。现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后再执行。]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重置MySQL密码]]></title>
    <url>%2F2018%2F03%2F29%2F%E9%87%8D%E7%BD%AEMySQL%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)一般这个错误是由密码错误引起的，解决的方法自然是重置密码。假设我们使用的是root账户。1、重置密码的第一步是跳过MySql的密码认证过程。 vim /etc/my.cnf(注: windows下修改的是my.ini) 在文档内搜索mysqld定位到[mysqld]字段:/mysqld(在vim编辑状态下直接输入该命令可搜索文本内容)在[mysqld]后面任意一行添加skip-grant-tables用来跳过密码验证的过程。保存文档并退出。2、接下来重启MySql:/etc/init.d/mysql restart(有些用户可能需要使用/etc/init.d/mysqld restart)3、重启之后输入mysql就可进入mysql。4、接下来就是用sql来修改root的密码。1234use mysql;update user set password=password("你的新密码") where user="root";flush privileges;quit 到这里root账户就已经重置成新的密码了。5、编辑my.cnf去掉刚才添加的内容，然后重启MySql。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie和session的区别]]></title>
    <url>%2F2018%2F03%2F28%2Fcookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[对于许多人来说，都知道的是，cookie是存储在客户端的，可以用来放需要长期使用的内容，例如用户密码、用户账户等等，服务器是可以获取到cookie的内容的；而session则是存储在服务器端，通过唯一的session_id来区别用户，用于保存用户的登录状态和请求等，客户是不能获取到其内容的。这对于许多人来说都是比较基础的内容，也是表现形式上的区别，在这里我们深入的了解一下两者。 cookie123cookie是存在于客户端的由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。cookie的内容主要包括: 名字、值、过期时间、路径和域。其中路径与域一起构成cookie的作用范围，若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。cookie是服务器端给客户端分发的一种凭证，客户端要请求服务，就需要在发送数据的同时发送cookie，服务器端通过识别cookie的内容，得知用户身份。 要查看cookie可以在控制台输入javascript: alert(document.cookie);就可以看到网站分发的cookie了。 实际上的cookie有两种，分别是停留在浏览器所占内容的临时性的cookie，在页面窗口关闭之后就被删除，被称为session cookie；而另外一种是通过存放在硬盘空间中长期 存在的cookie，这种cookie被称为persistent cookie，也就是我们通常意义上所讲的cookie。 session123session的出现: 对于cookie是存储在客户端的，这种存储在客户端的信息往往是不安全的，所以后来又有了session，客户端浏览器向服务器发送请求的时候，服务器将客户端的信息以某种形式存储在服务器上，这种存储在服务器端的信息在客户端第二次访问服务器的时候被使用，用来确定用户的状态等信息。session的使用: 服务器会在客户端第一次请求服务的时候创建session对象，与cookie类似，session对象也是以键值对的形式存储的。每个session 对象都有独立的session_id，对于特定的客户，就赋予特定的session，可以区分不同的用户。需要注意的是，通常是在用户请求具体服务的时候才会创建session，单纯的访问静态的内容（如HTML）并不会创建session。而在创建之后的每一次客户访问服务器都会更新session的内容，比如session的最后访问时间等等。还有一点是session的内容应该尽量的精简，因为session是存储在服务器端的，需要占用到宝贵的服务器资源（一般放在服务器内存里），所以这里在有大量客户访问的时候，会导致服务器的资源不够用。此外还会给session设置有效期，对于长时间没有活跃的session会从内存中删除，这也是我们用一些Web应用时会有说“登录超时”的情况出现。session的依赖实现: 对于上面所说的session，它对于用户来说是透明的，在客户请求服务的时候，客户端需要有一个标示自己身份的凭证，但是仅仅是标示自己的身份，所以这个标示会比较小。通过这个身份，服务器才能从内存中的多个session中知道用户是对应于哪一个session。一般来说session是要依赖于cookie来实现，这一点在上面讲到cookie的分类时说到，这时候生成的cookie就是上文提到的session cookie，而cookie的内容就是session的特定的id，这个cookie在浏览器关闭的时候就会失效。因此同一个机器上的两个浏览器窗口访问服务器的时候会生成两个不同的session。但是如果两个窗口是由同一个父窗口打开的话，子窗口会共享父窗口的cookie，所以这时候是共享一个session。 如果禁用了cookie，那要怎么实现session 在浏览器禁用cookie或者不支持cookie的时候，通常会采取一种叫做”URL重写”的方式来实现session，也就是以类似于GET方式，将session_id写在URL的后面，这样服务器也能获取到客户的session_id，通过这个独立的id就能识别特定的用户了。]]></content>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring解析]]></title>
    <url>%2F2018%2F03%2F28%2FSpring%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[什么是Spring1、Spring是一个开源框架，Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。Spring是一个IOC和AOP容器框架。在Java开发领域，SPring相对于EJB来说是一种 轻量级的、非侵入性的Java开发框架。Spring主要核心是:1) 控制反转(IOC): 概念: 控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系核心: bean工厂；在Spring中，bean工厂创建的各个实例称作bean 以前传统的Java开发模式中，当需要一个对象时，我们会自己使用new或getInstance等直接或间接调用构造方法创造一个对象，而在Spring开发模式中，Spring容器使用了工厂模式为我们创建了所需要的对象，我们使用时不需要自己去创建，直接调用Spring为我们提供的对象即可，这就是控制反转思想。实例化一个Java对象由三种方式: 使用类构造器，使用静态工厂方法，使用实例工厂方法。当使用Spring时我们就不需要关心通过何种方式实例化一个对象，Spring通过控制反转机制自动为我们实例化一个对象。2) 依赖注入(DI): Spring使用JavaBean对象的Set方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程就是依赖注入的基本思想。3) 面向切面编程(AOP): 在面向对象编程 (OOP)思想中，我们将事物纵向抽象成一个个的对象。而在面向切面编程中，我们将一个个对象某些类似的方面横向抽象成一个切面，对这个切面进行一些如权限验证，事物管理，记录日志等公用操作初级的过程就是面向切面编程的思想。2、在Spring中，所有管理的对象都是JavaBean对象，而BeanFactory和ApplicationContext就是Spring框架的两个IOC容器，现在一般使用ApplicationContext，其不但包含了BeanFactory的作用，同时还进行更多的扩展。 Spring原理1) 内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 。2) Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过 配置类达到的。3) Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象） 要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。 代理的两种方式静态代理 针对每个具体类分别编写代理类 针对一个接口编写一个代理类 动态代理 针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类。不用写代理类，虚拟机根据真实对象实现的接口产生一个类，通过类实例化一个动态代理，在实例化动态代理时将真实对象及装备注入到动态代理中，向客户端公开的是动态代理，当客户端调用动态代理方法时，动态代理根据类的反射得到真实对象的Method,调用装备的invoke方法，将动态代理、 Method、方法参数传与装备的invoke方法，invoke方法在唤起method方法前或后做一些处理。 产生动态代理的类: java.lang.refect.Proxy装备必须实现InvocationHandler接口实现invoke方法。 Spring的三种注入方式是什么 setterinterfaceconstructor Spring的核心接口及核类配置文件是什么 FactoryBean: 工厂 Bean主要实现ioc/diApplicationContext ac= new FileXmlApplicationContext(“applicationContext.xml”);Object obj= ac.getBean(“id值”); Spring框架的7个模块Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String中加号和字符串拼接]]></title>
    <url>%2F2018%2F03%2F28%2FString%E4%B8%AD%E5%8A%A0%E5%8F%B7%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[字符串常量是编译时确定的，编译完成，生成class文件，那就不会再变了。在编译的时候，编译器会将字符串常量直接放在一起，然后查找常量池里面，有没有对应的字符串。12345678910String str1= new String("abc");String str2= "abc";String str3= "a"+ "b"+ "c";System.out.println(str1== str2); //输出falseSystem.out.println(str1.intern()== str2); //输出true//intern()方法返回字符串对象的规范化表示形式。System.out.println(str2== str3); //输出trueString str4= "ab";String str5= str4+ "c";System.out.println(str2== str5); //输出false 第一个str1== str2对比的是引用的地址是否相同，由于str1采用的是new String方式定义的，所以地址引用一定不相等。 第二个str1.intern()== str2，当str1调用intern的时候，会检查字符串池中是否含有 该字符串。由于定义的str2已经进入字符串池中，所以会得到相同的引用。 定义str3，在编译的时候，编译器会将字符串常量直接放在一起，然后查找常量池里面，有没有对应的字符串，所以str2和str3是相等的，也就是指向相同的内存区域。 看一下下面的代码123456789101112String a = new String("ab");String b = new String("ab");String c = "ab";String d = "a" + "b";String e = "b";String f = "a" + e;System.out.println(b.intern() == a); //输出falseSystem.out.println(b.intern() == c); //输出trueSystem.out.println(b.intern() == d); //输出trueSystem.out.println(b.intern() == f); //输出falseSystem.out.println(b.intern() == a.intern()); //输出true 由运行结果可以看出来，b.intern() == a和b.intern() == c可知，采用new 创建的字符串对象不进入字符串池，并且通过b.intern() == d和b.intern() == f可知，字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如f中的e）则不会进入字符串池中。但是字符串一旦进入字符串池中，就会先查找池中有无此对象。如果有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py常识]]></title>
    <url>%2F2018%2F03%2F28%2Fpy%E5%B8%B8%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一些基础的python知识。 python特性 1) python是一种解释型语言，这意味着，与C、C++不同，python不需要在运行之前进行编译，它是边运行边解释。2) python是动态类型化的，这意味着当你声明它们或类似的东西时，你不需要声明变量的类型。你可以x= 1，然后x= “abc”没有错误。3) python非常适合面向对象编程，因为它允许定义类以及组合和继承。python没有访问修饰符(例C++大的public，private)。4) 在python中函数是一等对象，这意味着它们可以在运行时动态创建，能赋值给变量或者作为参数传给函数，还能作为函数的返回值。5) python代码容易上手，开发速度很快，但运行速度通常比编译语言慢。幸运的是，python允许包含基于C的扩展，所以瓶颈可以被优化掉。比如，numpy包就是一个很好的例子，它非常快，因为它所做的很多运算在底部都是用C编写的。 python中的赋值、浅拷贝和深拷贝的区别 1) 对象的赋值python中对象的赋值实际上是简单的对象引用，也就是说，当你创建一个对象，然后把它复制给另一个变量的时候，python并没有拷贝这个对象，而是拷贝了这个对象的引用。 2) 浅拷贝 对于可变对象深浅拷贝 Name 值 地址 =浅拷贝 值相等 地址相等 copy浅拷贝 值相等 地址不相等 deepcopy深拷贝 值相等 地址不相等 一般引用copy.copy()，可以进行对象的浅拷贝。它复制了对象但对于对象中的元素，依然使用原始的引用。使用copy对a进行浅拷贝，b复制了a的对象，但是b里面的[2, 3, 4]和a里面的[2, 3, 4]其实都是指向同一块内存地址，所以改变了a[1]之后，b里面的b[1]也发生了改变。 对于不可变对象的深浅拷贝不可变对象类型，没有被拷贝的说法，即便是用深拷贝，查看id的话也是一样的，如果对其重新赋值，也只是新创建一个对象，替换掉旧的而已。一句话就是，不可变类型，不管是深拷贝还是浅拷贝，地址值和拷贝后的值都是一样的。3) 深拷贝深拷贝需要用copy.deepcopy()进行拷贝。它是复制一个容器对象，以及它里面的所有元素(包含元素的子元素)当对a列表进行深度拷贝之后，b复制了a的对象，但是b里面的[2, 3, 4]和a里面的[2, 3, 4]其实都是指向不同的内存地址。 python中的==和is的区别 is也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是id是否相同。而==是python标准操作符中的比较操作符，用来比较判断两个对象的value(值)是否相等。 线程如何在python中实现 python有一个多线程包threading，可以使用多线程来加快你的代码。但是python有一个叫做Global Interpreter Lock(GIL)的构造。GIL确保只有一个”线程”可以在任何时候执行。线程获取GIL，做一些工作，然后将GIL传递到下一个线程。这种情况发生得非常快，所以对于人眼而言，它可能看起来像你的线程并行执行，但它们实际上只是轮流使用相同的CPU内核。因此GIL的存在是得python中的多线程无法真正的利用多核的优势来提高性能。对于IO密集型操作，在等待操作系统返回的时候会释放GIL；再比如爬虫因为有等待的服务器的响应时间，可以利用多线程来加速。但是对于CPU密集型操作，只能通过多进程Multiprocess来加速。 python中的猴子补丁式是什么 考虑下面的例子:猴子补丁:是一种非常pythonic的用法，即函数再python中可以像使用变量一样对它进行赋值等操作，我们可以再运行时动态替换模块，俗称手法，称为猴子补丁。我们通过对MyClass.f重新赋值，动态的改变了输出的结果。 python中的负数index python中的负数index是用来做什么的？python中的序列是索引的，它由正数和负数组成。正的数字使用’0’作为第一个索引，’1’作为第二个索引。负数的索引从’-1’开始，表示序列中的最后一个索引，’-2’作为倒数第二个索引，序列像整数一样向前。负数索引也可以用来非常方便的切片，比如: 类里面的new和init的区别 1) __init__为初始化方法，而__new__方法才是真正的构造函数。只有继承了object的新式类才有__new__。2) ——new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由python解释器自动提供，__new__必须要有返回值，返回实例化出来的实例。3) __init__有一个参数self，就是这个__new__返回的实例，先运行__new__然后才运行__init__。4) __init__在__new__的基础上可以完成一些其它初始的动作，__init__不需要返回值。 python中的参数*args和**kwargs *args是可变参数，一般用来表示我们不能确定多少参数将被传递给函数，或者如果我们想用列表或元组的方式传递给函数。**kwargs是可变关键字参数，当我们不知道有多少关键字参数会传递给一个函数时，或者想把一个字典作为关键字参数时使用。注: *args和**kwargs可以同时在函数的定义中，但是*args必须在**kwargs前面。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禁止U盘拷贝]]></title>
    <url>%2F2018%2F03%2F27%2F%E7%A6%81%E6%AD%A2U%E7%9B%98%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[经常会有人在我们电脑上拷贝一些东西，那我们不想让别人拷贝怎么办呢？1、键入win + r键，打开运行，输入gpedit.msc，打开本地组策略编辑器。2、点击计算机配置–&gt;管理模板–&gt;系统，找到右侧可移动存储访问。3、双击后可看到右侧有五个可移动磁盘项目，我们不想让别人从我们电脑拷贝的话，双击拒绝写入权限。4、选中已启用，点击确定。5、打开U盘，将文件放入U盘，可以看到提示需要管理员权限。6、我们点击继续，发现没有办法将文件放入U盘。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py使用itchat发送微信消息]]></title>
    <url>%2F2018%2F03%2F25%2Fpy%E4%BD%BF%E7%94%A8itchat%E5%8F%91%E9%80%81%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[环境：Windows、python3.6、itchat库代码参考于奇幻果园。itchat使用需要事先下载安装，命令如下: pip install itchat这个代码的作用就是在指定时间给微信好友发送信息，并且可以间隔特定时间再次发送，类似于短信轰炸？学习！嗯，用来学习。12345678910111213141516171819202122232425262728293031#!usr/bin/python# -*- coding: UTF-8 -*-import itchatimport datetime, os, platform,timedef timerfun(sched_time) : flag = 0 while True: now = datetime.datetime.now() if now &gt; sched_time and now &lt; sched_time + datetime.timedelta(seconds=1) : #因为时间秒之后的小数数据部分不一定相等，要标记一个范围判断 send_move() time.sleep(2) #每次判断间隔2s, 避免多次触发事件 flag = 1 else : if flag == 1 : sched_time = sched_time + datetime.timedelta(hours=24) #把目标时间增加一个小时，24小时后触发再次执行 flag = 0def send_move(): users= itchat.search_friends(name= 'Love') #使用备注名来查找实际用户名 print(users) #获取好友全部信息，返回一个列表，列表内是一个字典 userName= users[0]['UserName'] #获取UserName，用来发送消息 itchat.send("It's time to take a rest. 宝贝, 该睡觉啦!", toUserName= userName) print('succeed')if __name__=='__main__': itchat.auto_login(hotReload=True) #首次扫描登录后后续自动登录 sched_time = datetime.datetime(2018,3,25,23,40,00) #设定初次触发时间的事件点 print('run the timer task at &#123;0&#125;'.format(sched_time)) timerfun(sched_time) 有些地方需要注意下:1、第11行判断时间是否到达指定时间处，因为now = datetime.datetime.now()返回的时间精确到了ms, 所以直接拿精确到s的特定时间去比较会出现False。所以改用判断时间是否在范围内。并且判断完后会用time.sleep(2)延时2s再次比较，避免多次命中或多次判断。2、第17行内，每次时间判断满足指定时间范围时，将指定时间往后延一定时间。这里+ datetime.timedelta(hours=24)表示延后24小时，达到每过24小时触发一次send_move函数的目的。3、第28行内，itchat.auto_login(hotReload=True)如注释说明的一样，避免每次都要扫描二维码登录，在登录一次之后”保持在线状态”4、第27行，if __name__==&#39;__main__&#39;:表示当前模块仅在自己运行时才运行后续的语句，否则当该模块被其他模块引用时，不会运行后续语句。每个模块都有__name__属性，当它等于__main__时，表示该模块被用户单独运行，可以执行特殊的操作。5、第30行，注意一下这里的print函数对sched_time字符串的使用方式。为了按照一般时间格式打印输出，对sched_time进行了format格式化处理，我理解就是保持sched_time原本的时间形式不变，而按照字符串的方法进行处理。这里用{0}来表示格式化后的sched_time，让其能够以原来时间格式与前面待打印的字符串进行字符串拼接。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下py脚本后台运行]]></title>
    <url>%2F2018%2F03%2F25%2FWindows%E4%B8%8Bpy%E8%84%9A%E6%9C%AC%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[环境: Windows、python3.6py脚本在Linux的后台运行网上教程很多，而在Windows中的介绍不多。下面说一种可行方法： 将wx.py文件改为wx.pyw。cmd进入到pythonw目录下, 输入pythonw wx.pyw 1&gt;stdout.txt 2&gt;stderr.txt 由于代码原因，要进行故障排除，即在调用时使用输出重定向。这将print()在文件中捕获stdout输出，例如来自file stdout.txt, stderr输出(例如来自未处理的异常)stderr.txt。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py脚本打包成exe]]></title>
    <url>%2F2018%2F03%2F25%2Fpy%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E6%88%90exe%2F</url>
    <content type="text"><![CDATA[输入pyinstaller -F wx_dingshi.py有可能会出现错误PyInstaller cannot check for assembly dependencies.并且提示Please install PyWin32 or pywin32-ctypes.问题很明显了，缺少这俩库输入pip install PyWin32和 pip install pywin32-ctypes静等安装。安装完后再次输入pyinstaller -F wx_dingshi.py打包完成。同目录下的dist文件夹中的wx_dingshi.exe就是目标exe。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程同步]]></title>
    <url>%2F2018%2F03%2F20%2F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[什么是进程同步？列举两个生活中的进程同步的实例，详细说明同步的过程。 在多道程序环境下，进程是并发进行的，不同进程之间存在着不同的相互制约关系，这就叫进程同步。例一：理发师-顾客问题在一个理发店里有一个理发师，一个理发椅和N个沙发，理发椅是一个临界资源，沙发相当于等待队列。当一个顾客进入理发店占用理发椅时，其他顾客必须在沙发上等待。理发师和顾客必须保持同步，既不允许理发师在没有顾客时理发，也不允许顾客在理发椅被占用时理发。例二：厨师-食堂问题在一个饭店里有一个厨师，一个桌子和N个椅子，桌子是一个临界资源。当一个食客进入饭店占用桌子时，假设桌子已满，其他食客必须等待。厨师和食客必须保持同步，既不允许厨师在没有食客时做饭，也不允许食客在桌子被占满时吃饭。 什么是记录型信号量机制？举实例说明wait操作（P操作）中当信号量值小于0和不小于0时会发生什么？signal操作（V操作）中当信号量值小于等于0和不小于等于0时会发生什么？记录型信号量机制是在整形信号量机制的基础上增加了一个用于代表资源数目的整型变量和一个等待队列（用链表）。实例：理发师-顾客问题在实例中理发椅的数目就相当于资源信号量，当执行P操作时，信号量小于0时，表示资源已经分配完毕，因此进程BLOCK并插入等待队列中；信号量不小于0时（即大于等于0），表示资源还未分配完毕，因此进程继续执行。当执行V操作时，信号量小于0时，表示在等待队列中还有进程在被阻塞，因此应执行唤醒语句；信号量不小于0时（即大于等于0），等于0时，由于0是由-1变来的，所以表示等待队列中还有最后一个进程在被阻塞，因此应执行唤醒语句，大于0时说明等待队列中还没有进程在被阻塞，因此直接释放处理机即可。 解释什么是FIFO？什么是优先级高者优先调度？什么是抢占式调度和非抢占式调度？FIFO即FIRSTINPUTFIRSTOUTPUT，就是先进先出的意思，先执行先进入的进程，该进程完成后再执行下一个进程。优先级高者优先调度：说的是在执行若干个进程或作业的时候选取其中优先级最高的那一个先执行。抢占式调度：这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将以分配给该进程的处理机重新分配给另一个进程。此调度方法遵循一定的原则：1&gt;优先权原则，2&gt;短进程优先原则，3&gt;时间片原则。非抢占式调度：采用这种方式时，一旦处理机分配给某进程后，就让他一直运行下去，决不会因为时钟中断或任何其他原因去抢占当前正在运行程序的处理机，直至该进程完成或发生某事件而被阻塞时，才把处理机分配给别人。 设有两个优先级相同的进程P、Q，进入就绪队列的先后顺序为Q，P，各自运行的程序段如下： P 进程P： 进程Q： P1 Y=1; Q1 X=2; P2 Y=Y+A; Q2 A=X+1; P3 V(S1); Q3 P(S1); P4 A=Y+X; Q4 X=A+Y; P5 P(S2); Q5 V(S2); P6 A=Y+A; Q6 A=X+A; 说明：其中S1、S2为信号量，初值为0；已知X、Y、A为共享变量，A、X、Y的初值为0，若调度程序执行的策略为FIFO（先进先出）问题：请写出进程P、Q的实际执行序列（用代码Pi，Qi表示，i=1，…,6）及变量X、Y、A的中间值和运行结果？12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个优先级相同的进程P、Q，进入就绪队列的先后顺序为Q、P。根据先进先出的原则先进行Q操作。答案：A=20、 X= 10、Y= 4、S1= 0、S2= 0 将上述问题中的“进入就绪队列的先后顺序为Q、P”改为“进入就绪队列的先后顺序为P、Q”，其它不变。12：A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个优先级相同的进程P、Q，进入就绪队列的先后顺序为P、Q，根据先进先出原则先执行P操作。答案： A= 8、X= 4、Y= 1、S1= 0、S2= 0 将上述问题改为“P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P”，按优先级高者优先调度，采用非抢占式调度12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P。根据优先级高者优先调度的原则先进行Q操作。答案：A= 20、X= 10、Y= 4、S1= 0、S2= 0 将上述问题改为“P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P”，按优先级高者优先调度，采用抢占式调度12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个同时进入就绪队列的进程P、Q，进程Q的优先级高于进程P。根据优先级高者优先调度的原则先进行Q操作。答案：A= 15、X= 7、Y=4、S1= 0、S2= 0 将上述问题改为“P、Q两个进程同时进入就绪队列，进程Q的优先级高于进程P”，按优先级高者优先调度，采用抢占式调度。12A、X、Y共享变量，初值均为0，信号量S1、S2初值均为0，有两个同时进入就绪队列的进程P、Q，进程Q的优先级高于进程P。根据优先级高者优先调度的原则先进行Q操作。答案：A= 15、X= 7、Y=4、S1= 0、S2= 0]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储管理]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是虚拟存储器？ 虚拟存储器是由硬件和操作系统自动实现存储信息调度和管理的，是在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理贮存容量大的多，可寻址的“主存储器”。 为什么要引入虚拟存储器？1) 能提高操作系统的内存利用率和系统吞吐量2) 在计算机系统中，主存的容量有一定的限制，不可能大大满足各种用户的需要，而在技术上辅助存储器却可以做的相当大。为了给大作业提供方便，使它们不再承担对主存和辅存的具体分配和管理工作，而由操作系统把主存和辅存统一管理起来。 虚拟存储器的特征？虚拟存储器具有虚拟性、离散性、多次性及强对换性等特征，其中最重要的特征是虚拟性。1&gt; 虚拟性。虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际的内存容量，这是虚拟存储器所表现出的最重要的特征，也是虚拟存储器最重要的目标。2&gt; 离散性。离散性是指内存分配时采用离散分配的方式，没有离散性就不可能实现虚拟存储器。采用连续分配方式，需要将作业装入到连续的内存区域，这样需要连续地一次性申请一部分内存空间，以便将整个作业先后多次装入内存。如果仍然采用连续装入的方式，则无法实现虚拟存储功能，只有采用离散分配方式，才能为它申请内存空间，以避免浪费内存空间。3&gt; 多次性。多次性是指一个作业被分成多次调入内存运行。作业在运行时，只将当前运行的那部分程序和数据装入内存，以后再陆续从外存将需要的部分调入内存。4&gt; 对换性。对换性是指允许在作业运行过程中换进换出。允许将暂时不用的程序和数据从内存调至外存的对换区，以后需要时再从外存调入到内存。 设置你自己计算机上的虚存，并截图说明设置的过程1、右键我的电脑, 选择属性2、选择高级系统设置3、选择高级, 点性能中的设置4、选择高级, 选虚拟内存中的更改5、选择自定义大小, 输入初始大小和最大值, 推荐设置自己内存大小的1.5~ 3倍, 在这输入2048, 点击设置, 根据提示选择确定。 虚存可以建立在分区分配管理的基础上吗？为什么？不可以。在虚拟存储器中，允许将一个作业分多次调入内存。如果采用连续分配方式时，应将作业装入一个连续的内存区域中。为此，需事先为它一次性地申请足够的内存空间，以便将整个作业先后分多次装入内存，这不仅会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟存储器的实现都是建立在离散分配存储管理方式的基础上。 页面置换算法的应用题干：在请求分页存储管理系统中，若为进程分配的物理块为4，开始执行时内存中没有装入任何页面，若进程依次访问的页面号为：3,1,2,6,0,7,4,6,7,2,0,4,3,2,0,7,0,2,6,5,1,5,4,3，请按照下面的页面置换算法完成作业（低物理地址优先）1、OPT页面置换算法1234567891011*为发生缺页中断~为发生页面置换页面被置换顺序 1 3 0 6 4 7 2 0 6缺页率13/241、2、3、4内存为空，页面不在内存中发生缺页5 选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，页面1最长时间不被访问，因此被替换6 同理，页面3最长时间不被访问被替换7 同理，页面0最长时间不被访问被替换8 同理，页面6最长时间不被访问被替换9 同理，页面4最长时间不被访问被替换10 页面0,2,6在后续的访问中没有出现以此按照内存块的顺序（从上往下）依次替换 2、FIFO页面置换算法123456789101112131415161718192021222324252627282930FIFO：(按顺序置换)（1）详细执行过程1.刚开始内存并没有这个作业，所以发生缺页中断一次。页3进入内存。(1次缺页中断) 2.页1进入内存，页1又不在内存，又发生缺页中断一次。(2次缺页中断) 3.页2进入内存，页2又不在内存，缺页中断。(3次缺页中断) 4.页6进入内存，页6又不在内存，发生缺页中断（内存中为3、1、2、6）。 (4次缺页中断) 5.页0进入内存，页0又不在内存，发生缺页中断（内存中为1、2、6、0）。 (5次缺页中断) 6.页7进入内存，页7又不在内存，发生缺页中断（内存中2、6、0、7）(6次缺页中断)7.页4进入内存，页4又不在内存，发生缺页中断（内存中为6、0、7、4）。 (7次缺页中断) 8.页6在内存内不发生中断。9.页7在内存内不发生中断。10.页2进入内存，页2又不在内存，发生缺页中断（内存中为0、7、4、2）。 (8次缺页中断) 11.页0在内存内不发生中断12.页4在内存内不发生中断 13.页3进入内存，页3又不在内存，发生缺页中断（内存中为7、4、2、3）。 (9次缺页中断) 14.页2在内存内不发生中断 15.页0进入内存，页0又不在内存，发生缺页中断（内存中为4、2、3、0）。 (10次缺页中断) 16.页7进入内存，页7又不在内存，发生缺页中断（内存中为2、3、0、7）。 (11次缺页中断)17.页0在内存内不发生中断。18.页2在内存内不发生中断。19.页6进入内存，页6又不在内存，发生缺页中断（内存中为3、0、7、6）。 (12次缺页中断)20.页5进入内存，页5又不在内存，发生缺页中断（内存中为0、7、6、5）。 (13次缺页中断)21.页1进入内存，页1又不在内存，发生缺页中断（内存中为7、6、5、1）。 (14次缺页中断)22.页5在内存内不发生中断。23. 页4进入内存，页4又不在内存，发生缺页中断（内存中6、5、1、4）。 (15次缺页中断)24.页3进入内存，页3又不在内存，发生缺页中断（内存中为5、1、4、3）。 (16次缺页中断)（2）缺页次数：16（3）缺页频率：66.7％（4）置换次数：12（5）被置换出的页面依次为：3,1,2,6,0,7,4,2,3,0,7,6 3、LRU页面置换算法12345678910111213141516171819*为发缺页中断（1）1、2、3、4内存为空，页面不在内存中发生缺页5选择的被淘汰页面将是最近最久未使用的页面，页面3最长时间不被访问，因此被替换6同理，页面1最长时间不被访问被替换7 同理，页面2最长时间不被访问被替换8 同理，页面0最长时间不被访问被替换9 同理，页面4最长时间不被访问被替换10 同理，页面6最长时间不被访问被替换11 同理，页面7最长时间不被访问被替换12 同理，页面4最长时间不被访问被替换13 同理，页面3最长时间不被访问被替换14 同理，页面7最长时间不被访问被替换15 同理，页面0最长时间不被访问被替换16 同理，页面2最长时间不被访问被替换16 同理，页面6最长时间不被访问被替换（2）缺页次数：17（3）缺页频率：70.8%（4）置换次数：13（5）被置换出的页面依次为：3 1 2 0 4 6 7 4 3 7 0 2 6 4、CLOCK页面置换算法12345678910111213红色代表访问位为1，星号表示替换指针的位置缺页次数：15次缺页率：15/24=62.5％置换次数：11次依次被置换出的页号：3,1,2,6,7,4,3,2,0,7,6语言描述：1：进程分配的物理块为4，开始执行时内存中没有装入任何页面，当访问3号页面是，内存中没有，则将页面直接调入内存，根据低物理地址优先，将页面存入第一个物理块，并把访问位置为1。2：访问1号页面时，内存中没有，且内存中还有空位，直接将1号页面放入内存即可，并把访问位置为1。3：当访问0号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查3号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查1号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查2号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查6号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，这时检查到最后一位，发现访问位仍为1，则返回队首去检查第一个页面3，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。4：当访问7号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查1号页面，访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。5：当访问6号页面时，发现内存中存在，则将其访问位置为1，替换指针不动。6：当访问2号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查6号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查0号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查7号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查4号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查6号页面，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。7：当访问3号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查0号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查7号页面，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。8：当访问7号页面时，发现内存中没有，且内存中无空位，则需要替换掉一个页面。根据CLOCK置换算法找到需要替换的页面，为了避免“抖动”，因此访问指针从替换指针的下一位开始检查，首先检查4号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查2号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查0号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查3号页面，访问位为1，将其重新置为0，暂不换出，给予该页第二次驻留内存的机会，继续检查4号页面，发现访问位为0，则选择此页面替换，且替换指针此时指向被替换的页面。 5、CLOCK页面置换算法 第5题中进程依次访问的页面号为：其它条件、要求与前面的题干一样7,1,6,4,6,2,3,0,3,1,0,7,6,0,1,3,6,3,0,7,2,0,51234567891011121314151617181920212223242526红色代表访问位为1，星号表示替换指针的位置缺页次数: 14次缺页率: 14/23=60.9%置换次数: 10次依次被置换的页号: 7 1 6 4 2 3 0 1 7 67号页面：进程分配的物理块为4，开始执行的时候没有装入任何页面，当开始访问7号页面的时候，内存中没有该页面号，将页面直接调入内存，低物理地址优先，将页面放入第一个物理块，把访问位置为1.1、6、4号页面：访问1号页面的时候，内存中没有该页面号，且内存中还有空位，将1、6、4号页面放入内存，把访问位置为1，替换指针指向最高地址的物理块。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查4号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查4号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。7号页面：访问7号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查2号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查9号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查3号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。7号页面：访问7号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。5号页面：访问5号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程四]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Arrays;import java.util.Scanner; public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入总人数。"); int num = in.nextInt(); boolean[] man = new boolean[num]; for(int i = 0; i &lt; man.length; i++) &#123; man[i] = true; &#125; int t = 0, len = man.length; while(len &gt; 1) &#123; for(int i = 0; i &lt; man.length; i++) &#123; if(man[i]) &#123; t++; if(t == 3) &#123; t = 0; //重置 man[i] = false; //去掉此人 len--; //人数减 1 &#125; &#125; &#125; &#125; System.out.println("最后的情况：" + Arrays.toString(man));//返回指定数组的字符串表示形式 for(int i = 0; i &lt; man.length; i++) &#123; if(man[i]) //最后留下来的人没有被flase &#123; System.out.println("原来剩下的数：" + (i + 1)); //i + 1 是因为数组从 0 开始 &#125; &#125; &#125;&#125; 写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。123456789101112131415161718import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个字符串"); String str = in.next(); int len = lenOfstr(str); System.out.println(str + " 的长度为 " + len); &#125; private static int lenOfstr(String str) &#123; // TODO Auto-generated method stub return str.length(); &#125;&#125; 编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n(利用指针函数)。1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个整数"); int n = in.nextInt(); if(n % 2 == 0) System.out.println("1/2 + 1/4 + ... + 1/"+ n+ "= " + evenSum(n)); else System.out.println("1 + 1/3 + ... + 1/"+ n+ "= " + oddSum(n)); &#125; private static float oddSum(int n) &#123; // TODO Auto-generated method stub float sum = 0.0f; //记得用 float 或 double 型 for(float i = 1.0f; i &lt;= n;) &#123; // i 用 int 就会把结果也强转为 int sum += 1 / i; i += 2; &#125; return sum; &#125; private static float evenSum(int n) &#123; // TODO Auto-generated method stub float sum = 0.0f; for(float i = 2.0f; i &lt;= n;) &#123; sum += 1 / i; i += 2; &#125; return sum; &#125;&#125; 字符串排序。123456789101112import java.util.Arrays;public class class_name &#123; public static void main(String[] args) &#123; String[] strs = &#123;"abfds1", "advesd2", "dasfdsa3", "cdsaew1", "abbdsa2", "abbdsa"&#125;; //直接用了 java 里有的 sort 方法 Arrays.sort(strs); for(String str : strs) &#123; System.out.println(str); &#125; &#125;&#125; 海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的,问海滩上原来最少有多少个桃子？法一123456789101112131415161718192021222324252627282930313233public class class_name &#123; public static void main(String[] args) &#123; int num = 6; //分五份多一个，至少6个 while( true) &#123; if(func(num)) &#123; break; //找到答案，跳出循环 &#125; num++; &#125; System.out.println("符合要求的最小数是：" + num); &#125; //判断这个数是否能被分5次 static boolean func(long n) &#123; int i = 0; //被分次数0-4共5次 while(i &lt; 5 &amp;&amp; n &gt; 0) &#123; if((n - 1) % 5 == 0) &#123; long temp = (n - 1) / 5 + 1; n -= temp; //减去被一只猴子拿走和丢掉的 i ++; &#125; else return false; &#125; return true; &#125;&#125; 法二123456789101112131415161718192021222324public class class_name &#123; public static void main(String[] args) &#123; int i= 0, m= 1, x= 1; while(true) &#123; m= x; for(i= 0; i&lt; 5; i++) &#123; if((m- 1)% 5== 0) &#123; m= (m- 1)/ 5* 4; //System.out.println(m); &#125;else &#123; break; &#125; &#125; if (i== 5 &amp;&amp; m&gt; 0) &#123; break; &#125; x++; System.out.println(x); &#125; System.out.println("符合要求的最小数是：" + x); &#125;&#125; 809*??=800*??+9*??+1其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。1234567891011121314151617181920public class class_name&#123; public static void main(String[] args) &#123; int number = 0; boolean flag = false; for (int i=10; i&lt;100; i++) &#123; if(809*i == (800*i+9*i)) &#123; if(((8* i)&gt; 10)&amp;&amp; ((8* i) &lt; 100)&amp;&amp; ((9* i) &gt; 99)&amp;&amp; ((9* i)&lt; 1000)) &#123; flag = true; number = i; &#125; &#125; &#125; if (flag) &#123; System.out.println("??是: "+ number); System.out.println("809*"+number+"="+(809*number)); &#125;else &#123; System.out.println("无符合要求的数!"); &#125; &#125; &#125; 求0—7所能组成的奇数个数。12345678910111213141516171819public class class_name &#123; public static void main(String[] args) &#123; long total = 0L; //可以把 76543210 变成 10 或 100 来检查该代码输出结果的正确性 for(int i = 0; i &lt;= 76543210; i++)&#123; if(i % 2 == 0) &#123; continue; &#125; //把其中含有 8 和 9 的数去掉 if((i + "").indexOf("8") != -1 || (i + "").indexOf("9") != -1)&#123; continue; &#125; total++;// System.out.println(i + " "); //输入每一个奇数 &#125; System.out.println("共有 " + total + "个奇数"); &#125;&#125; 一个偶数总能表示为两个素数之和。12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个大于等于4偶数。"); int num = in.nextInt(); if(num &lt; 4) System.out.println("输入错误！"); if(num % 2 == 0) &#123; int i , j; for(i = 2; i &lt;= num /2; i++) &#123; if(isPrime(i)) &#123; j = num - i; if(isPrime(j)) System.out.println(num + " = " + i + " + " + j); &#125; &#125; &#125; &#125; public static boolean isPrime(int k) &#123; for(int i = 2; i &lt; Math.sqrt(k); i++) &#123; if(k % i == 0) return false; &#125; return true; &#125;&#125; 读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的＊。12345678910111213141516171819import java.util.Random;public class class_name &#123; public static void main(String[] args) &#123; Random rm = new Random(); for(int n = 0; n &lt; 7; n++) &#123; int i = rm.nextInt(50); //50以内的随机数 System.out.print(i + " : "); for(int m = 0; m &lt; i; m++) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; 某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5,然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。123456789101112131415161718192021222324252627282930import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个四位整数"); int num = in.nextInt(); System.out.println("加密后数据为：" + encrypt(num)); &#125; private static int encrypt(int num) &#123; // TODO Auto-generated method stub int a, b, c, d; //从左到右分别为第一到第四位 //分解 a = num / 1000; b = (num / 100) % 10; c = (num / 10) % 10; d = num % 10; //取余 a = (a + 5) % 10; b = (b + 5) % 10; c = (c + 5) % 10; d = (d + 5) % 10; //交换,其实这里只要换一下重组会整数的顺序就行了 num = d *1000 + c * 100 + b * 10 + a; return num; &#125;&#125; 计算字符串中子串出现的次数。123456789101112131415161718192021222324252627282930import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern; public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个字符串"); String sen = in.next(); System.out.println("请输入要查找的子字符串"); String str = in.next(); /* //一般方法 int count = 0; int start = 0; while (sen.indexOf(str, start) &gt;= 0 &amp;&amp; start &lt; sen.length()) &#123; count++; start = sen.indexOf(str, start) + str.length(); &#125;*/ //正则表达式 第二个参数为忽略大小写 Pattern p = Pattern.compile(str, Pattern.CASE_INSENSITIVE); Matcher m = p.matcher(sen); int count = 0; while(m.find())&#123; count ++; &#125; System.out.println(str + "在" + sen + "出现的次数为" + count); &#125;&#125; 有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，将原有的数据和计算出的平均分数存放在磁盘文件”stud”中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.util.Scanner; public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String[][] stu = new String[2][6]; //为了快速测试，5个同学变成了2个同学 for(int i = 0; i &lt; 2; i++)&#123; System.out.printf("请输入第%d个学生的姓名", i + 1); stu[i][0] = in.next(); System.out.printf("请输入第%d个学生第学号", i + 1); stu[i][1] = in.next(); for(int j = 2; j &lt; 5; j++)&#123; System.out.printf("请输入该同学的第%d门课程成绩", j - 1); stu[i][j] = in.next(); &#125; &#125; for(int i = 0; i &lt; 2; i++)&#123; int sum = 0; for(int j = 2; j &lt; 5; j++)&#123; sum += Integer.parseInt(stu[i][j]); &#125; stu[i][5] = Float.toString((float)sum / 3); &#125; String s; try&#123; File file = new File("E:/home/stu"); //要存放的路径 if(file.exists())&#123; System.out.println("文件存在"); &#125; else&#123; System.out.println("文件不存在，正在创建...."); file.createNewFile(); &#125; BufferedWriter output = new BufferedWriter(new FileWriter(file)); for(int i = 0; i &lt; 2; i++)&#123; for(int j = 0; j &lt; 6; j++)&#123; s = stu[i][j] + "\r\t"; output.write(s);// System.out.print(stu[i][j]); //被注释的这三行用来格式化输出到控制台（屏幕）// System.out.printf("\t", ""); &#125;// System.out.println(); &#125; output.close(); System.out.println("数据已写入"); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程三]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E4%B8%89%2F</url>
    <content type="text"><![CDATA[求1+2!+3!+…+20!的和 123456789101112131415161718192021222324252627import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("你想计算到哪个数的阶乘的和"); int num = in.nextInt(); long temp = 0L; long sum = 0L; for(int i = 1; i &lt;= num; i++)&#123; temp = recursion(i); sum += temp; &#125; System.out.println("计算到" + num + "的阶乘和是 " + sum); &#125; //计算某个数 num 的阶乘 private static long recursion(int num) &#123; // TODO Auto-generated method stub if(num &gt; 1)&#123; return num * recursion(num - 1); &#125; return 1; &#125;&#125; 给一个不多于5位的正整数，要求: 一、求它是几位数；二、逆序打印出各位数字123456789101112131415161718192021import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个不多于5位的整数"); int num = in.nextInt(); int n = 1; System.out.print("这个数的逆序为："); while(num / 10 &gt; 0)&#123; n++; int tmp = num % 10; System.out.print(tmp); num /= 10; &#125; System.out.println(num); System.out.println("这个数共有" + n + "位数"); &#125;&#125; 请输入星期几的第一个字母来判断以下是星期几，如果第一个字母一样，则继续判断第二个字符。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); char firstletter, secondletter; //存放第一第二个字母 System.out.println("请输入第一字母"); String letter = in.next(); firstletter = letter.charAt(0); switch(firstletter)&#123; case 'm': case 'M': System.out.println("是星期一");break; case 'w': case 'W': System.out.println("是星期三");break; case 'f': case 'F': System.out.println("是星期五");break; case 't': case 'T': System.out.println("仅由该字母无法判断出星期几，请输入第二个字母"); letter = in.next(); secondletter = letter.charAt(0); if(secondletter == 'u' || secondletter == 'U')&#123; System.out.println("是星期二"); break; &#125;else if(secondletter == 'h' || secondletter == 'H')&#123; System.out.println("是星期四"); break; &#125;else&#123; System.out.println("输入错误"); &#125; case 's': case 'S': System.out.println("仅由该字母无法判断出星期几，请输入第二个字母"); letter = in.next(); secondletter = letter.charAt(0); if(secondletter == 'a' || secondletter == 'A')&#123; System.out.println("是星期六"); break; &#125;else if(secondletter == 'u' || secondletter == 'U')&#123; System.out.println("是星期天"); break; &#125;else&#123; System.out.println("输入错误"); &#125; &#125; &#125;&#125; 求一个3*3矩阵对角线元素之和123456789101112131415161718192021222324252627282930import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); //输入数据 int[][] mat = new int[3][3]; for(int i = 1; i &lt;= 3; i++)&#123; for(int j = 1; j &lt;= 3; j++)&#123; System.out.println("请输入第" + i + "行第" + j + "列的整数"); mat[i -1][j - 1] = in.nextInt(); &#125; &#125; //显示数据 for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; 3; j++) System.out.printf("%d\t",mat[i][j]); // \t是制表符 System.out.println(); &#125; //计算对角线元素和 //从左上至右下的数归为主对角线，从左下至右上的数归为副对角线。 int sum1 = mat[0][0] + mat[1][1] + mat[2][2]; int sum2 = mat[2][0] + mat[1][1] + mat[0][2]; System.out.println("主对角线上元素和为 " + sum1); System.out.println("副对角线上元素和为 " + sum2); &#125;&#125; 有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int[] ary = &#123;10, 15, 20, 25, 30, 35, 40, 45, 50&#125;; int[] changedAry = new int[ary.length + 1]; System.out.print("初始数组："); for(int i = 0; i &lt; ary.length; i++)&#123; changedAry[i] = ary[i]; System.out.print(ary[i] + " "); &#125; System.out.println(); System.out.println("请输入一个整数"); int num = in.nextInt(); System.out.print("插入数字后的数组："); insort(changedAry, num); &#125; private static void insort(int[] changedAry, int num) &#123; // TODO Auto-generated method stub for(int i = 0; i &lt; changedAry.length; i++)&#123; if(num &lt; changedAry[i])&#123; //找到插入位置 for(int j = changedAry.length - 1; j &gt; i;j--)&#123; changedAry[j] = changedAry[j - 1]; //待插入位置及以后的数后退一个位置 &#125; changedAry[i] = num; break; &#125; &#125; if(num &gt; changedAry[changedAry.length - 1]) //待插入数大于所有数 changedAry[changedAry.length - 1] = num; for(int k = 0; k &lt; changedAry.length; k++) System.out.print(changedAry[k] + " "); &#125;&#125; 将一个数组逆序输出1234567891011121314151617public class class_name &#123; public static void main(String[] args) &#123; //这里直接初始化一个数组 int[] ary = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// String[] ary = &#123;"i", "love", "you"&#125;; //字符（串）数组也可以 System.out.print("数组初始顺序为："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); //换行 System.out.print("数组的逆序为："); for(int i = ary.length - 1; i &gt;= 0; i--) System.out.print(ary[i] + " "); System.out.println(); &#125;&#125; 取一个整数a从右端开始的4~7位。123456789101112import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入一个大于等于 7 位的整数"); long sum = in.nextLong(); Long sum1 = new Long(sum); //Long是 long 的包装类 String sum2 = sum1.toString(); System.out.println(sum2.substring(sum2.length() - 7, sum2.length() - 3)); &#125; // substring 截取两参数间的字符串&#125; 打印出杨辉三角形123456789101112131415161718192021222324252627public class class_name &#123; public static void main(String[] args) &#123; int i, j; int[][] num = new int[10][10]; for (i = 0; i &lt; 10; i++) &#123;// 把所有的 1 放入数组 num[i][0] = 1; num[i][i] = 1; &#125; for (i = 2; i &lt; 10; i++) &#123;// 计算数组的其他数 for (j = 1; j &lt; i; j++) &#123; num[i][j] = num[i - 1][j - 1] + num[i - 1][j]; &#125; &#125; for (i = 0; i &lt; 10; i++) &#123; // k &lt; 4 倍的空格是因为输出每个数字时用了 4 个占位符 for (int k = 0; k &lt; 4 * (10 - i) / 2; k++) // 输出空格 System.out.printf(" "); for (j = 0; j &lt;= i; j++) &#123; System.out.printf("%4d", num[i][j]); // 每个数字 4 个占位符 &#125; System.out.println(); &#125; &#125;&#125; 输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入数组长度"); int arylen = in.nextInt(); int[] num = new int[arylen]; for(int i = 0; i &lt; num.length; i++) &#123; System.out.printf("请输入第 %d 个数：", i + 1); num[i] = in.nextInt(); &#125; System.out.println("变化前的数组："); outArray(num); //循环找出最大值、最小值 int max = num[0]; int min = num[0]; for(int i = 1; i &lt; num.length; i++) &#123; if(num[i] &gt; max) max = num[i]; if(num[i] &lt; min) min = num[i]; &#125; //替换 num[0] = max; num[num.length - 1] = min; System.out.println("变化后的数组："); outArray(num); &#125; private static void outArray(int[] num) &#123; // TODO Auto-generated method stub for(int i = 0; i &lt; num.length; i++) System.out.print(num[i] + " "); System.out.println(); &#125;&#125; 有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数。1234567891011121314151617181920212223242526272829import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int[] num = &#123;14, 32, 5, 42, 36, 80&#125;; int[] temp = new int[num.length]; System.out.println("移动前的数组："); for(int i = 0; i &lt; num.length; i++)&#123; temp[i] = num[i]; System.out.print(num[i] + " "); &#125; System.out.println(); System.out.println("需要向后移动几个位置"); int m = in.nextInt(); for(int i = 0; i &lt; num.length; i++)&#123; int t = (i + m) % num.length; num[t] = temp[i]; //这行的 t 和 i 互换一下就变成了（1） &#125; System.out.println("移动后的数组："); for(int i: num) System.out.print(i + " "); System.out.println(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程二]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[【程序11】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ 12345678910111213141516171819202122public class class_name &#123; public static void main(String[] args) &#123; int i, j, k; //分别代表个、十、百位 int num; //用来输出符合要求的三位数 int count = 0; //用来统计符合要求的三位数有多少个 System.out.println("符合要求的三位数有："); for(i = 1; i &lt;= 4; i++)&#123; for(j = 1; j &lt;= 4; j++)&#123; if(i != j) //提前把有重复的部分情况过滤掉，减少运行次数，优化性能 for(k = 1; k &lt;= 4; k++)&#123; if(i != k &amp;&amp; j != k)&#123; num = i + j * 10 + k * 100; System.out.println(num); count++; &#125; &#125; &#125; &#125; System.out.println("符合要求的三位数共有" + count + "个"); &#125;&#125; 【程序12】一个整数，它加上100后是一个完全平方数，再加上168又是一个完平方数，请问该数是多少？1234567891011121314151617181920public class class_name &#123; public static void main(String[] args) &#123; long i, j, k; for(i = 1; i &lt; 100000; i ++) &#123; for(j = 0; j &lt; 1000; j++) &#123; if(j * j == i + 100) &#123; for(k = j; k &lt; 1000; k++) &#123; if(k * k == i + 268) System.out.println(i); &#125; &#125; &#125; &#125; &#125;&#125; 【程序13】输入年月日，判断这一天是这一年的第几天？1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入年份。"); int year = in.nextInt(); System.out.println("请输入月份。"); int month = in.nextInt(); System.out.println("请输入日期。"); int day = in.nextInt(); int sum = 0;; switch(month - 1) &#123; case 0: sum = 0; break; case 1: sum = 31; break; case 2: sum = 59; break; case 3: sum = 90; break; case 4: sum = 120; break; case 5: sum = 151; break; case 6: sum = 181; break; case 7: sum = 212; break; case 8: sum = 243; break; case 9: sum = 273; break; case 10: sum = 304; break; case 11: sum = 334; break; &#125; if((month &gt; 2)&amp;&amp;isLeap(year)) System.out.printf("这天是这年第%d天。", sum + day + 1); else System.out.printf("这天是这年第%d天。", sum + day); &#125; private static boolean isLeap(int year) &#123; if(((year % 100 != 0)&amp;&amp;(year % 4 == 0)) || (year % 400 == 0)) return true; else return false; &#125;&#125; 【程序14】输入三个整数x,y,z，请把这三个数由小到大输出。1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入三个整数"); System.out.println("请输入第1个整数"); int a = in.nextInt(); System.out.println("请输入第2个整数"); int b = in.nextInt(); System.out.println("请输入第3个整数"); int c = in.nextInt(); System.out.print("从小到大的顺序为："); if(a &lt; b)&#123; if(b &lt; c)&#123; System.out.printf("%d&lt;%d&lt;%d", a, b, c); &#125;else&#123; if(a &lt; c) System.out.printf("%d&lt;%d&lt;%d", a, c, b); else System.out.printf("%d&lt;%d&lt;%d", c, a, b); &#125; &#125;else&#123; if(c &lt; b)&#123; System.out.printf("%d&lt;%d&lt;%d", c, b, a); &#125;else&#123; if(c &lt; a) System.out.printf("%d&lt;%d&lt;%d", b, c, a); else System.out.printf("%d&lt;%d&lt;%d", b, a, c); &#125; &#125; &#125;&#125; 【程序15】排序算法以下代码只写了一个输出，所以当你要测试哪个排序算法时记得把调用另外三个排序算法的那几行代码注释掉。如果你想同时测试这四个排序算法，可以在每行调用排序方法的后面加入输出语句就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class class_name &#123; public static void main(String[] args) &#123; int[] num = &#123;23, 64, 15, 3, 93, 30, 51, 28, 49, 66&#125;; System.out.println("排序前： "); showArray(num); System.out.println(); //换行，控制格式 num = BubbleSort(num); // num = ChoiceSort(num); // num = InsertSort(num); // num = QuickSort(num, 0, num.length - 1); System.out.println("排序后："); showArray(num); System.out.println(); //换行，控制格式 &#125; private static void showArray(int[] num) &#123; for(int i = 0; i &lt; num.length; i++) &#123; System.out.print(num[i] + " "); &#125; &#125; private static int[] BubbleSort(int[] num) &#123; for(int i = 0; i &lt; num.length; i++) &#123; for(int j = 0; j &lt; num.length - 1; j++) &#123; if(num[j] &gt; num[j + 1]) &#123; int temp = num[j]; num[j] = num[j + 1]; num[j +1] = temp; &#125; &#125; &#125; return num; &#125; //插入排序 private static int[] InsertSort(int[] num) &#123; for(int i = 1; i &lt; num.length; i++) &#123; int temp = num[i]; for(int j = i; j &gt; 0; j--) &#123; if(num[j - 1] &gt; temp) &#123; num[j] = num[j - 1]; num[j - 1] = temp; &#125; &#125; &#125; return num; &#125; //优化后的选择排序 private static int[] ChoiceSort(int[] num) &#123; for (int i = 0; i &lt; 9; i++) &#123; int min = i; int j; for (j = i + 1; j &lt; num.length; j++) &#123; if (num[min] &gt; num[j]) &#123; min = j; &#125; &#125; if (min != i) &#123; int temp = num[i]; num[i] = num[min]; num[min] = temp; &#125; &#125; return num; &#125; /* //选择排序 private static int[] ChoiceSort(int[] num) &#123; for(int i = 0; i &lt; num.length - 1; i++) &#123; for(int j = i + 1; j &lt; num.length; j++) &#123; if(num[i] &gt; num[j]) &#123; int temp = num[i]; num[i] = num[j]; num[j] = temp; &#125; &#125; &#125; return num; &#125; */ // 快速排序 private static int[] QuickSort(int[] num, int i, int j) &#123; // TODO Auto-generated method stub if(i &lt; j) &#123; int middle = portition(num, i, j); QuickSort(num, i, middle - 1); QuickSort(num, middle + 1, j); &#125; return num; &#125; private static int portition(int[] num, int low, int high) &#123; int i = low, j = high; int temp = num[i]; if (low &lt; high) &#123; while (i &lt; j) &#123; while ((num[j] &gt;= temp) &amp;&amp; (i &lt; j)) &#123; j--; &#125; num[i] = num[j]; while ((num[i] &lt;= temp) &amp;&amp; (i &lt; j)) &#123; i++; &#125; num[j] = num[i]; &#125; num[i] = temp; &#125; return i; &#125; &#125; 【程序16】输出9*9口诀12345678910111213141516public class class_name &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt; 10; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; int total = 0; total = i * j; System.out.printf("%d * %d = %-5d", j, i, total); &#125; System.out.println(); &#125; &#125;&#125; 【程序17】猴子吃桃问题猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下 的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。12345678910111213public class class_name &#123; public static void main(String[] args) &#123; int total = 1; //day = 1的时候，算出来的total其实是第9天有的桃子 //day = 9的时候，算出来的total就是第1天的桃子 for(int day = 1; day &lt; 10; day++)&#123; total = 2 * (total + 1); &#125; System.out.println("一开始共有 " + total + " 桃子"); &#125;&#125; 【程序18】乒乓球比赛名单两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。1234567891011121314151617public class class_name &#123; public static void main(String[] args) &#123; char i, j, k; //i,j,k分别是a,b,c的对手 for(i = 'X'; i &lt;= 'Z'; i++)&#123; for(j = 'X'; j &lt;= 'Z'; j++)&#123; if(i != j)&#123; for(k = 'X'; k &lt; 'Z'; k++)&#123; if(i != k &amp;&amp; j != k)&#123; if(i != 'X' &amp;&amp; k != 'X' &amp;&amp; k != 'Z') System.out.printf("a -- %c\nb -- %c\nc -- %c", i, j, k); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 【程序19】打印图案打印出如下图案（菱形）1234567891011121314151617181920212223public class class_name &#123; public static void main(String[] args) &#123; for(int i = 0; i &lt; 4; i++)&#123; //1到4行 for(int j = 1; j &lt;= (6 - 2 * i) / 2; j++)&#123; //每行前面的空格数 System.out.print(" "); &#125; for(int k = 1; k &lt;= 2 * i + 1; k++)&#123; System.out.print("*"); //每行的*号 &#125; System.out.println(); //换行 &#125; //下半部分 for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; i + 1; j++)&#123; System.out.print(" "); &#125; for(int k = 0; k &lt; 5 - 2 * i; k++)&#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125;&#125; 【程序20】有一分数序列: 2/1，3/2，5/3，8/5，13/8…求这个数列的前20项之和。123456789101112131415public class class_name &#123; public static void main(String[] args) &#123; float i = 2.0f, j = 1.0f; //i为分子，j为分母 float num = 2.0f; //num是分数，sum是分数的和 float sum = 2.0f; for(int m = 1; m &lt; 20; m++)&#123; //m = 1时，num已经是第2个加数了，所以m &lt; 20 i = i + j; j = i - j; //变化前的 i 赋值给 j num = i / j; sum += num; &#125; System.out.println("前20个分数的和为 " + sum); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程一]]></title>
    <url>%2F2018%2F03%2F16%2FJava%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[【程序1】兔子总数问题有一对兔子，从出生后第3个月起 每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？123456789101112131415161718192021import java.util.Scanner;public class tuzi &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("你想知道第几个月的兔子的数量"); int month = in.nextInt(); //使用输入流对象，调用nextInt()方法输入一个整数到month中 int[] mon = new int[month]; if(month &lt; 3)&#123; System.out.println("第" + month + "个月有 1 对兔子，共 2 只"); &#125;else &#123; for(int i = 2; i &lt; month; i++)&#123; mon[0] = mon[1] = 1; mon[i] = mon[i - 1] + mon[i - 2]; System.out.printf("第 %d 个月有 %d 对兔子，共 %d 只兔子\n", i + 1, mon[i], 2 * mon[i]); &#125; &#125; &#125;&#125; 【程序2】判断两数之间素数个数判断101-200之间有多少个素数，并输出所有素数。12345678910111213141516171819public class class_name &#123; public static void main(String[] args) &#123; System.out.print("101--200中的素数有："); for(int i = 101; i &lt;= 200; i++)&#123; if(isPrime(i)) System.out.print(" " + i); &#125; &#125; //isPrime方法用来判断一个数是否是素数 private static boolean isPrime(int i) &#123; // TODO Auto-generated method stub for(int j = 2; j &lt;= Math.sqrt(i); j++)&#123; if(i % j == 0) return false; &#125; return true; &#125;&#125; 【程序3】打印”水仙花数”所谓”水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如: 153是一个”水仙花数”，因为153=1的三次方+5的三次方+3的三次方。1234567891011121314151617181920212223public class class_name &#123; public static void main(String[] args) &#123; System.out.print("水仙花数有："); for(int num = 100; num &lt; 1000; num++)&#123; if(isNarcissisticNum(num)) System.out.println(" " + num); &#125; &#125; //一个判断正整数是否为水仙花数的方法 private static boolean isNarcissisticNum(int num) &#123; // TODO Auto-generated method stub int a = num / 100; //分离出百位 a int b = (num / 10) % 10; //分离出十位 b int c = num % 10; //分离出个位 c int sum = a * a * a + b * b * b + c * c * c; if(sum == num) return true; else return false; &#125;&#125; 【程序4】正整数分解质因数将一个正整数分解质因数。例如: 输入90，打印出90=2*3*3*5。(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。(2)如果n&gt;k，但n能被k整除，则打印出k的值，并用n除以k的商，作为新的正整数n，重复执行第一步。(3)如果n不能被k整除，则用k+1作为k的值，重复执行第一步。123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println("请输入一个大于 3 的正整数"); int num = input.nextInt(); System.out.print(num + "的素因数:"); factor(num); &#125; private static void factor(int num) &#123; // TODO Auto-generated method stub for(int i = 2; i &lt;= Math.sqrt(num); i++)&#123; if(num % i == 0)&#123; System.out.print(i + " * "); if(isPrime(num / i))&#123; System.out.println(num / i); &#125; else factor(num / i); break; &#125; &#125; &#125; private static boolean isPrime(int i) &#123; // TODO Auto-generated method stub for(int j = 2; j &lt;= Math.sqrt(i); j++)&#123; if(i % j == 0) return false; &#125; return true; &#125;&#125; 【程序5】条件运算符的嵌套利用条件运算符的嵌套来完成此题: 学习成绩&gt;=90分的同学用A表示，60-89分之间用B表示，60分以下的用C表示。1234567891011121314151617181920import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入你的分数"); int score = in.nextInt(); if(score &gt;= 90)&#123; System.out.println("A 恭喜"); &#125; else if(score &gt;= 60)&#123; System.out.println("B 不错"); &#125; else&#123; System.out.println("C 加油"); &#125; &#125;&#125; 【程序6】最大公约数和最小公倍数输入两个正整数m和n，求其最大公约数和最小公倍数。1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入第一个数"); int a = in.nextInt(); System.out.println("请输入第二个数"); int b = in.nextInt(); System.out.println("这两个数的最大公约数是 " + MaxCommonDivisor(a, b)); System.out.println("这两个数的最小公倍数是 " + MinCommonMultiple(a, b)); &#125; private static int MaxCommonDivisor(int a, int b) &#123; // TODO Auto-generated method stub if(a &lt; b)&#123; int temp = a; a = b; b = temp; &#125; while(a % b != 0)&#123; int temp = a % b; a = b; b = temp; &#125; return b; &#125; private static int MinCommonMultiple(int a, int b) &#123; // TODO Auto-generated method stub return a * b / MaxCommonDivisor(a, b); &#125;&#125; 【程序7】统计英文字母、空格、数字和其它字符个数输入一行字符，分别统计出其中英文字母、空格、数字和其它字符个数。1234567891011121314151617181920212223242526272829import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("Input one sentance."); String s = in.nextLine(); int letter = 0, symbol = 0, space = 0, number = 0; char[] strArray = s.toCharArray(); for (int i = 0; i &lt; strArray.length; i++) &#123; char c = strArray[i]; if(('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z')) letter++; else if(48 &lt;= c &amp;&amp; c &lt;= 57) //注意！数字0-9的ASCII码是48-57 number++; else if(c == ' ') space++; else symbol++; &#125; System.out.println("This sentance have " + letter + " letters, "); System.out.println("have "+ number + " numbers, "); System.out.println("have " + space + " spaces, " + "and " + symbol + " symbols."); &#125;&#125; 【程序8】求s=a+aa+aaa+aaaa+…的值求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222(此时共有4个数相加)，几个数相加有键盘控制。1234567891011121314151617181920import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println("请输入相加的基数"); int n = input.nextInt(); System.out.println("请输入要相加的个数"); int i = input.nextInt(); long total = 0L; long temp = n; for(int j = 0; j &lt; i; j++)&#123; total += temp; temp = temp * 10 + n; &#125; System.out.println("和为" + total); &#125;&#125; 【程序9】完数一个数如果恰好等于它的因子之和，这个数就称为”完数”。例如: 6=1+2+3。编程: 找出1000以内的所有完数。12345678910111213141516public class class_name &#123; public static void main(String[] args) &#123; System.out.println("1000以内的完数有："); for(int i = 1; i &lt; 1000; i++)&#123; int sum= 0; for(int j= 1; j&lt; i; j++) &#123; if (i% j== 0) &#123; sum+= j; &#125; &#125; if (sum== i) &#123; System.out.println(i); &#125; &#125; &#125;&#125; 【程序10】球落地一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第10次落地时，共经过多少米？第10次反弹多高？1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class class_name &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println("请输入原始高度。"); double s = in.nextDouble(); System.out.println("要求第几次落地后的距离。"); int n = in.nextInt(); double total = s; System.out.printf("第%d次落地后共走的距离是：" , n); if(n == 1) &#123; System.out.println(total); System.out.printf("第%d次反弹的距离是%f。", n, s / 2); &#125; else &#123; for(int i = 1; i &lt; n; i++) &#123; s = s / 2; total += 2 * s; //一上一下共两倍的弹跳距离 &#125; System.out.print(total); System.out.println(); System.out.printf("第%d次反弹的距离是%f。", n, s / 2); &#125; &#125;&#125; 【程序11】使用IO流将C盘图片复制到D盘123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;public class long1_1 &#123; public static void main(String[] args) &#123; File pic1 = new File("C:/A.jpg"); File pic2 = new File("E:/A1.jpg"); FileInputStream fis = null; FileOutputStream fos = null; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; fis = new FileInputStream(pic1); fos = new FileOutputStream(pic2); bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); byte[] b = new byte[1024]; while (bis.read(b) != -1) &#123; bos.write(b); &#125; bos.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); System.out.println("找不到文件"); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("文件读取错误"); &#125; finally &#123; try &#123; if (bos != null) &#123; bos.close(); &#125; if (bis != null) &#123; bis.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.println("关闭流出错"); &#125; &#125; System.out.println("复制成功"); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse安装JBoss Tools]]></title>
    <url>%2F2018%2F03%2F04%2Feclipse%E5%AE%89%E8%A3%85JBoss-Tools%2F</url>
    <content type="text"><![CDATA[进入JBoss Tools插件下载页面，点击Download。style的eclipse版本是4.7.2，选择相对应版本的插件下载。点击Update Site，复制对应的更新地址。打开eclipse，点击Help–&gt;Install New Software。进入插件安装界面，点击Add。输入name和url。确定后选择Select All，点击Next。]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP自动提示]]></title>
    <url>%2F2018%2F02%2F26%2FJSP%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[1、Window–&gt;Preferences–&gt;Java–&gt;Editor–&gt;Content Assist修改Auto activation triggers for Java的值为:1.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 2、JavaScript–&gt;Editor–&gt;Content Assist修改Auto activation triggers for JavaScript的值为:1.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 3、Web–&gt;Html Files–&gt;Editor–&gt;Content Assist修改Prompt when these characters are inserted的值为:1&lt;=.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp编码]]></title>
    <url>%2F2018%2F02%2F25%2Fjsp%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在eclipse中修改jsp页面的默认编码。1、Window–&gt;Preferences。2、点击Web，选择JSP Files，将右边的Encoding选为UTF-8。3、新建一个jsp页面，页面编码就是修改后的。]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse Java EE配置Tomcat]]></title>
    <url>%2F2018%2F02%2F25%2Feclipse%E9%85%8D%E7%BD%AETomcat%2F</url>
    <content type="text"><![CDATA[配置Tomcat1、打开eclipse，单击Window菜单，选择下方的Preferences。2、单击Server选项，选择下方的Runtime Environments。3、点击Add，添加 Tomcat。4、点击Next， 选中自己安装的Tomcat路径。5、点击Finish完成。 建立一个Web应用1、File–&gt;New–&gt;Dynamic Web Project。2、创建一个Dynamic Web Project。3、连续点击两下Next。4、点击Finish完成。 让Tomcat服务器显示在控制台上，将Web应用部署到Tomcat1、Window–&gt;Show View–&gt;Servers2、右键Server面板中的Add and Remove。3、添加项目到Configured，选中项目并点击Add或者双击都可以添加到右边。4、点击Finish完成。返回下方的Servers面板，右键单击该面板中的Tomcat v9.0 Server at localhost节点，在弹出的快捷菜单中单击Start即可启动指定的Web服务器。如果此时直接访问http://localhost:8080/test_first ,会发现报404的错误。这是因为我们没有添加主页，下面添加主页(index.jsp)的内容。5、右键WebContent–&gt;New–&gt;JSP File。1注意: Web资源一定要在WebContent目录下添加。 此时，再一次来访问http://localhost:8080/test_first ，效果如下:]]></content>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Tomcat]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%AE%89%E8%A3%85Tomcat%2F</url>
    <content type="text"><![CDATA[Tomcat是Apache软件基金会的Jakarta项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成，成为目前比较流行的Web应用服务器。一、下载登录http://tomcat.apache.org 站点，下载合适的Tomcat版本。单击左边的Download下的Tomcat 9 超链接，在打开的新页面中，下载Tomcat的最新版9.0.5版的所有安装包。选择合适的版本下载即可。style选择下载的是64位的Windows下的64-bit Windows zip(pgp, md5, sha1, sha512)安装包。把下载得到的apache-tomcat-9.0.5-windows-x64.zip文件解压到合适的位置。可以看到如图的文件结构。style将其解压到了F:\apache-tomcat-9.0.5目录。各个文件目录的说明如下所示。1234567/bin: 存放Windows或Linux平台上启动和关闭Tomcat的脚本文件。/conf: 存放Tomcat服务器的各种全局配置文件，其中，最重要的是server.xml和web.xml。/lib: 存放Tomcat服务器所需的各种JAR文件。/logs: 存放Tomcat执行时的日志文件。/temp: 存放Web运行过程中生成的临时文件。/webapps: Tomcat的主要Web发布目录，默认情况下把Web应用文件放于此目录。/work: 存放JSP编译后产生的class文件。 二、Tomcat的配置要想运行Tomcat，还需要配置环境变量以及配置管理员。(1) 添加环境变量，如图所示，在”环境变量”里新建系统变量，变量名为CATALINA_HOME，变量值为F:\apache-tomcat-9.0.5(Tomcat解压到的目录)。(2) 如图所示，在系统变量Path的最后面添加:%CATALINA_HOME%\lib;%CATALINA_HOME%\lib\servlet-api.jar;%CATALINA_HOME%\lib\jsp-api.jar。注意不同系统变量之间的分号一定是英文的分号。(3) 如图所示，为Tomcat 9.0的管理员的配置，进入F:\apache-tomcat-9.0.5下的conf目录，编辑tomcat-users.xml,找到最后的1234567&lt;!-- &lt;role rolename="tomcat"/&gt; &lt;role rolename="role1"/&gt; &lt;user username="tomcat" password="&lt;must-be-changed&gt;" roles="tomcat"/&gt; &lt;user username="both" password="&lt;must-be-changed&gt;" roles="tomcat,role1"/&gt; &lt;user username="role1" password="&lt;must-be-changed&gt;" roles="role1"/&gt;--&gt; 在上面这段后面添加上1234&lt;role rolename="manager-gui"/&gt;&lt;role rolename="admin-gui"/&gt;&lt;user username="admin" password="123" roles="admin-gui"/&gt;&lt;user username="admin" password="123" roles="manager-gui"/&gt; 保存并关闭tomcat-users.xml。(4) 进入Tomcat目录下的bin目录，双击startup.bat启动Tomcat，在命令行窗口会显示出英文提示，如图所示。(5) 在浏览器中输入http://localhost:8080/ 出现Tomcat的欢迎页面就说明配置成功了，如图所示。(6) 单机右上角的Manager App按钮，输入上面配置的用户名和密码，就可以进入管理页面，如图所示。(7) 至此，Tomcat安装配置完成。]]></content>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py之计算器]]></title>
    <url>%2F2018%2F01%2F23%2Fpy%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[某大佬的作品，在此学习一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#!usr/bin/python# -*- coding: UTF-8 -*-import re,os,sys'''计算这表达式的值：1 - 2 * ((60-30 +(-40.0/5) * (9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 )) - (-4*3)/ (16-3*2)))'''def format_mark(express): ''' 表达式替换过程中可能出现一些组合符号， 机器无法辨别，此函数负责处理这些组合符号 ''' express = express.replace('+-', '-') express = express.replace('-+', '-') express = express.replace('++', '+') express = express.replace('--', '+') express = express.replace('*+', '*') express = express.replace('+*', '*') express = express.replace('+/', '/') express = express.replace('/+', '/') return expressdef com_jiajian(express): ''' :param express: :return: ''' expr = express sub_expr = re.search(r"\-?\d+\.?\d*[\+\-]\d+\.?\d*", expr) #print (sub_expr) #re.search()函数将对整个字符串进行搜索，并返回第一个匹配的字符串的match对象。 if not sub_expr: return expr else: sub_expr2 = sub_expr.group() #group()用来提出分组截获的字符串，（）用来分组 # print('sub_expr1',sub_expr1,'19行结果express:',div_express) if len(sub_expr2.split('+')) &gt; 1: #通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 n1, n2 = sub_expr2.split('+') result = float(n1)+float(n2) else: n1, n2 = sub_expr2.split('-') result = float(n1) - float(n2) re_sub_expr = re.sub(r"\-?\d+\.?\d*[\+\-]\d+\.?\d*", str(result), expr, count=1) # 反复调用除法 print('加减运算：',re_sub_expr) bb = com_jiajian(str(re_sub_expr)) return bbdef com_chengchu(expr_div): ''' :param expr_div: :return: ''' expr=expr_div sub_expr = re.search(r"\d+\.?\d*[\/\*]\-?\d+\.?\d*",expr) if not sub_expr: return expr else: sub_expr2 = sub_expr.group() if len(sub_expr2.split('/')) &gt; 1: n1, n2 = sub_expr2.split('/') result = float(n1)/float(n2) if len(sub_expr2.split('*')) &gt; 1: n1, n2 = sub_expr2.split('*') result = float(n1)*float(n2) else: #只计算乘除，加减直接pass，放入加减函数执行 pass re_sub_expr=re.sub(r"\d+\.?\d*[\/\*]\-?\d+\.?\d*",str(result),expr,count=1) #反复调用除法 print('乘除运算：',re_sub_expr) bb=com_chengchu(format_mark(re_sub_expr)) return bbdef compute(express): express = com_chengchu(format_mark(express)) express = com_jiajian(format_mark(express)) return expressdef delkuohao(express): #检测表达式是否存在括号，如果存在就去括号，否则直接执行 res=re.compile(r'[()]') #将一个字符串编译为字节代码。 sub_expr1 = re.search('(\([\+\-\*\/\.0-9]+\))', express) if not sub_expr1: return express else: sub_expr1=sub_expr1.group() #delkuohao(express) #匹配括号，将计算结果替换到表达式 sub_expr2=sub_expr1[1:len(sub_expr1)-1] sub_expr3=compute(sub_expr2) sub_expr3 = re.sub('(\([\+\-\*\/\.0-9]+\))', str(sub_expr3),express,count=1) print('括号运算：',sub_expr3) delkuohao_expr=delkuohao(format_mark(sub_expr3)) return delkuohao_exprif __name__=="__main__": #while True: #express=input("请输入要计算的表达式：") print('\n================================') print('\033[33m 混合运算计算器\033[0m') print('================================') #express ='1-2*((60-30+(-40.0/5)*(9-2*5/3+7/3*99/4*2998+10*568/14))-(-4*3)/(16-3*2))' while True: express = input('\033[32m请输入表达式,规范点哦 | (退出:q)\033[0m') express = re.sub('\s*', '', express) if len(express) == 0: continue elif express == 'q': sys.exit('退出程序') elif re.search('[^0-9\.\-\+\*\/\(\)]',express): print('\033[31m 不是有效的算数表达式哦，请重新输入!!!\033[0m') else: express = express.replace(' ', '') print('您输入的表达式：',express) '''调用删除括号的函数''' express2 = delkuohao(express) #删除括号 express2 = compute(format_mark(express2)) #删除括号后再调用一次计算函数 print('\033[31m表达式:%s'%express,'=', str(express2),'\033[0m')]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py基础四之异常处理]]></title>
    <url>%2F2018%2F01%2F20%2Fpy%E5%9F%BA%E7%A1%80%E5%9B%9B%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[python基础语法之异常处理12345678910111213141516171819202122232425262728293031#!/usr/bin/python# -*- coding: UTF-8 -*-try: 1 / 0except Exception as e: '''异常的父类，可以捕获所有的异常''' print "0不能被除"else: '''保护不抛出异常的代码''' print "没有异常"finally: print "最后总是要执行我"'''try： code #需要判断是否会抛出异常的代码，如果没有异常处理，python会直接停止执行程序except: #这里会捕捉到上面代码中的异常，并根据异常抛出异常处理信息#except ExceptionName，args： #同时也可以接受异常名称和参数，针对不同形式的异常做处理 code #这里执行异常处理的相关代码，打印输出等else： #如果没有异常则执行else code #try部分被正常执行后执行的代码finally： code #退出try语句块总会执行的程序''']]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py基础三]]></title>
    <url>%2F2018%2F01%2F20%2Fpy%E5%9F%BA%E7%A1%80%E4%B8%89%2F</url>
    <content type="text"><![CDATA[python基础语法(三)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!usr/bin/python# -*- coding: UTF-8 -*-#打开一个文件fo= open("4.txt", "r+")#fo.write( "www.runoob.com!\nVery good site!\n");str= fo.read(10)print "文件名: ", fo.nameprint "是否已关闭: ", fo.closedprint "访问模式: ", fo. modeprint "末尾是否强制加空格: ", fo.softspaceprint "读取的字符串是: ", strposition= fo.tell()print "当前文件位置: ", positionposition= fo.seek(0, 0)str= fo.read(10)print "重新读取字符串: ", strfo.close()#重命名文件import osos.rename("4.txt", "1.txt")#删除文件os.remove("1.txt")#创建目录os.mkdir("test")#改变目录#将当前目录改为"/home/newdir"os.chdir("/home/newdir")#显示当前目录os.getcwd()#删除目录os.rmdir("/tmp/test")#在 write 内容后，直接 read 文件输出会为空，是因为指针已经在内容末尾。#两种解决方式: 其一，先 close 文件，open 后再读取，其二，可以设置指针回到文件最初后再 readdocument = open("testfile.txt", "w+");print "文件名: ", document.name;document.write("这是我创建的第一个测试文件！\nwelcome!");print document.tell();#输出当前指针位置document.seek(os.SEEK_SET);#设置指针回到文件最初context = document.read();print context;document.close();]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py基础二]]></title>
    <url>%2F2018%2F01%2F18%2Fpy%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[python基础语法(二)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#!usr/bin/python# -*- coding: UTF-8 -*-import timelocaltime = time.localtime(time.time())print "本地时间为 :", localtime#获取格式化的时间localtime = time.asctime( time.localtime(time.time()) )print "本地时间为 :", localtime# 格式化成2016-03-20 11:45:39形式print time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 格式化成Sat Mar 28 22:24:24 2016形式print time.strftime("%a %b %d %H:%M:%S %Y", time.localtime()) # 将格式字符串转换为时间戳a = "Sat Mar 28 22:24:24 2016"print time.mktime(time.strptime(a,"%a %b %d %H:%M:%S %Y"))#获取某月日历import calendarcals = calendar.month(2018, 1)print "以下输出2018年1月份的日历:"print cals;import datetimei = datetime.datetime.now()print ("当前的日期和时间是 %s" % i)print ("ISO格式的日期和时间是 %s" % i.isoformat() )print ("当前的年份是 %s" %i.year)print ("当前的月份是 %s" %i.month)print ("当前的日期是 %s" %i.day)print ("dd/mm/yyyy 格式是 %s/%s/%s" % (i.day, i.month, i.year) )print ("当前小时是 %s" %i.hour)print ("当前分钟是 %s" %i.minute)print ("当前秒是 %s" %i.second)#函数#缺省参数#可写函数说明def printinfo( name, age = 35 ): "打印任何传入的字符串" print "Name: ", name; print "Age ", age; return; #调用printinfo函数printinfo( age=50, name="miki" );printinfo( name="miki" );#不定长参数#加了星号（*）的变量名会存放所有未命名的变量参数。# 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print "输出: " print arg1, '我是arg1' for var in vartuple: print var return; # 调用printinfo 函数printinfo( 10 );printinfo(70, 60, 50, 66);#全局变量想作用于函数内，需加globalglobvar = 0def set_globvar_to_one(): global globvar # 使用 global 声明全局变量 globvar = 1def print_globvar(): print(globvar) # 没有使用 globalset_globvar_to_one()print globvar # 输出 1print_globvar() # 输出 1，函数内的 globvar 已经是全局变量#列表反转函数def reverse(li): for i in range(0, len(li)/2): temp = li[i] li[i] = li[-i-1] li[-i-1] = templ = [1, 2, 3, 4, 5]reverse(l)print(l)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ie11降级]]></title>
    <url>%2F2018%2F01%2F17%2Fie11%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[中小学教师资格证考试有点坑…上图说是使用IE6-IE10系列浏览器或“搜狗浏览器(兼容模式)”！对于我这种不太使用IE系列浏览器的人来说，确实有点…下面说下解决方法：打开你的IE按照流程进入到报名系统处发现系统提示使用IE6-IE10系列浏览器或“搜狗浏览器(兼容模式)”！检查了下发现自家的IE是11，降级就行。在此网页下，点右上角的齿轮，选择F12开发人员工具将文档模式和用户代理字符串改为11以下的就行，比如10然后将上方网址的/memapp/ieNote删除再回车，就可以登录了。]]></content>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行管理系统修改一]]></title>
    <url>%2F2018%2F01%2F17%2F%E9%93%B6%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[之前写过一个银行管理系统，现在对它进行了一些完善。增加了主界面的背景图片。增加了管理员功能管理员登陆成功管理员界面点击查询按钮可以将数据库中的账户信息显示在上方表中。选中一行，可以对一些信息进行修改，比如删除或修改。完善了账户退出功能用户登陆账户，点第一次退出会退出当前账户，再次点击退出会退出程序。源码下载]]></content>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础一]]></title>
    <url>%2F2018%2F01%2F16%2Fpython%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[python的基本语法(一)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#!usr/bin/python# -*- coding: UTF-8 -*-print range(1, 5) #代表从1到5（不包括5）print range(1, 5, 2) #代表从1到5，间隔2（不包括5）print range(5) #代表从0到5（不包括5）print ord('b') #convert char to intprint chr(100) #convert int to charprint unichr(100) #return a unicode byte#abs()和 fabs()区别#abs()是一个内置函数， 而fabs()是在math模块中定义的。#fabs()函数只适用于float和 integer类型，而abs()也适用于复数print abs(-10)import mathprint math.fabs(-10)print type(abs(-10))print type(math.fabs(-10))#多行语句total= 'item_one '+ \'item_two '+ \'item_three'print total#字符串str = 'Hello World!' print str # 输出完整字符串print str[0] # 输出字符串中的第一个字符print str[2:5] # 输出字符串中第三个至第五个之间的字符串print str[2:] # 输出从第三个字符开始的字符串print str * 2 # 输出字符串两次print str + "TEST" # 输出连接的字符串print str[:2] # 输出从开始到第二个字符的字符串print "更新字符串: ", str[:3]+ 'sanstyle' #更新字符串print "My name is %s and age is %d!" % ('style', 21)# %s格式化字符串 %d格式化整数# %c格式化字符及其ASCII码#列表list1 = ['physics', 'chemistry', 1997, 2000];print list1print len(list1) #返回列表元素个数print list1[-2] #读取列表中倒数第二个元素print list1[-2:] #从倒数第二个元素开始读取print list1[:-2] #读到倒数第二个前(不包括倒数第二个)del list1[2] #删除第三个print list1list1.append('3e3e') #在列表末尾添加新的对象print list1.count('3e3e') #统计出现的次数print list1.index('3e3e') #从列表重找出第一个匹配项的索引位置list1.remove('3e3e') #移除列表中这个值的第一个匹配项list1.reverse() #反向列表中元素print list1list2=[123,["das","aaa"],234]print 'aaa' in list2 #in只能判断一个层次的元素 print 'aaa' in list2[1] #选中列表中的二层列表进行判断#元组(元素不能修改)#元组中只包含一个元素时，需要在元素后面添加逗号tup= (50, )print tuptup1= (12, 34, 56)tup2= ('abc', 'xyz')#以下修改元组元素的操作是非法的#tup1[0]= 100#任意无符号的对象，以逗号隔开，默认为元组print 'abc', -4.24e93, 18+6.6j, 'xyz';x, y = 1, 2;print "Value of x , y : ", x,y;#字典(可存储任意类型对象)dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; print "dict['Name']: ", dict['Name'];print "dict['Age']: ", dict['Age'];dict['Age'] = 8; # update existing entrydict['School'] = "DPS School"; # Add new entryprint "dict['Age']: ", dict['Age'];print "dict['School']: ", dict['School'];print dictdel dict['Name']; # 删除键是'Name'的条目print dict#dict.clear(); # 清空词典所有条目#print dict#del dict ; # 删除词典print dict.keys() #以列表返回一个字典所有的键print dict.values() #以列表返回一个字典所有的值#字典值可以是任意数值类型dict1= &#123;"a":[1,2]&#125; # 值为列表print dict1['a'][1]dict2= &#123;"a":&#123;"c":"d"&#125;&#125; # 值为字典 print dict2['a']['c']]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditPlus运行py编码问题]]></title>
    <url>%2F2018%2F01%2F15%2FEditPlus%E8%BF%90%E8%A1%8Cpy%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[文本编辑器是EditPlus，运行python时候报出如下错误: SyntaxError: (unicode error) &#39;utf-8&#39; codec can&#39;t decode byte 0xc4 in position 0: invalid continuation byte。非常普通的Hello World，编码格式是utf-8解决方法：用notepad++打开python1_1.py发现存储格式是ANSI。保存的时候默认是保存成ANSI格式。发现问题就好解决啦，保存文件的时候将文件格式换成UTF-8就好了。成功输出！]]></content>
      <tags>
        <tag>python</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javax/xml/bind/DatatypeConverter]]></title>
    <url>%2F2018%2F01%2F15%2Fjavax-xml-bind-DatatypeConverter%2F</url>
    <content type="text"><![CDATA[话不多说，上图。重装系统后，想调试下实训的代码，发现一样的代码竟然运行不了。后来发现，重装后安装的jdk版本是9.0，并不是完全兼容。看错误提示是java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter。这是因为Java虚拟机在编译时候能找到这个类，而在运行时没能找到这个类。按照错误提示，下载这个类的jar包就行。jar包下载地址]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.length和.length()的区别]]></title>
    <url>%2F2017%2F12%2F31%2Flength%E5%92%8C-length-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[java中的length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了length这个属性。java中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到length()这个方法。如何获取一个数组的长度？以及，如何获取一个字符串的长度？ 12345int[] arr = new int[3];System.out.println(arr.length);//使用length获取数组的程度 String str = "abc";System.out.println(str.length());//使用length()获取字符串的长度 为什么数组有length属性？ 数组是一个容器对象，其中包含固定数量的同一类型的值。一旦数组被创建，他的长度就是固定的了。数组的长度可以作为final实例变量的长度。因此，长度可以被视为一个数组的属性。 为什么String有length()方法？ String背后的数据结构是一个char数组,所以没有必要来定义一个不必要的属性（因为该属性在char数值中已经提供了）。和C不同的是，Java中char的数组并不等于字符串，虽然String的内部机制是char数组实现的。 注: 要想把char[]转成字符串有以下方式：1234char []s = &#123;'a','b','c'&#125;;String string1 = s.toString();String string2 = new String(s);String string3 = String.valueOf(s);]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识点一]]></title>
    <url>%2F2017%2F12%2F31%2FJava%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1、面向对象的特征有哪些方面 1、抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。2、继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 3、封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 4、多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 2、什么是接口？写出接口与抽象类的区别。 接口是你在写程序时所有方法的一个声明，只设计，无实现。区别：1、都没有方法体2、通过接口可以支持多重继承，抽象类不支持3、抽象类可以包含已经实现的方法而接口不可以 3、写出String和StringBuffer的区别，int和Integer有什么区别。 String类创建的对象不可修改，StringBuffer创建的的对象是内存空间可以改变的大小的，可以调用append方法追加到字符串序列;Int是java的原始数据类型，Integer是java为int提供的封装类,引用数据类型。 4、sleep() 和 wait() 有什么区别?sleep()不释放同步锁,wait()释放同步锁。 sleep方法是Thread类的静态方法,线程在占用CPU资源期间，通过调用Sleep方法来使自己放CPU资源，休眠一段时间。wait是object类的方法，可以中断方法的执行，使本线程等待，暂时让出cpu的使用权，并允许其他线程使用这个同步方法。 5、简述线程的生命周期 新建、运行、中断、死亡 6、举例说明如何获取当前的年月日，时分秒以及从1970年到现在的毫秒数。1234567Date nowtime=new Date();System.out.println(nowtime);SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date currentTime=new Date(); Date beginTime=sdf.parse("1970-01-01 12:53:30"); long interval=(currentTime.getTime()-beginTime.getTime());]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[窗口程序]]></title>
    <url>%2F2017%2F12%2F31%2F%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[编写一个程序，生成一个窗口。标题为记事本，有一个文件菜单，正中显示一个TextArea,默认值为“我是TextArea！”。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.awt.*;import java.awt.event.*;import java.io.*;class WindowJiShiBen extends Frameimplements ActionListener&#123; MenuBar menubar; Menu menu; MenuItem itemExit; MenuItem itemSave; TextArea text1; FileWriter tofile; BufferedWriter out; FileDialog filedialog_save; WindowJiShiBen(String s) &#123; super(s); text1 =new TextArea("我是TextArea"); menubar =new MenuBar(); menu =new Menu("文件"); itemExit =new MenuItem("退出"); itemExit.setShortcut(new MenuShortcut(KeyEvent.VK_E)); itemSave=new MenuItem("保存"); itemSave.setShortcut(new MenuShortcut(KeyEvent.VK_S)); filedialog_save=new FileDialog(this,"保存文件话框",FileDialog.SAVE); menu.add(itemExit); menubar.add(menu); menu.add(itemSave); setMenuBar(menubar); add(text1); itemExit.addActionListener(this); itemSave.addActionListener(this); setBounds(100,100,150,150); setVisible(true); validate(); filedialog_save.addWindowListener(new WindowAdapter() &#123;public void windowClosing(WindowEvent e) &#123; filedialog_save.setVisible(false); &#125; &#125;); &#125; public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==itemExit) &#123;System.exit(0);&#125; else if(e.getSource()==itemSave) &#123;filedialog_save.setVisible(true); if(filedialog_save.getFile()!=null) &#123; try &#123; File file=new File(filedialog_save.getDirectory(),filedialog_save.getFile()); tofile=new FileWriter(file); out=new BufferedWriter(tofile); out.write(text1.getText(),0,(text1.getText()).length()); out.close(); tofile.close(); &#125; catch(IOException e2)&#123;&#125; &#125; &#125; &#125;&#125;public class jishiben&#123; public static void main(String args[]) &#123; WindowJiShiBen win=new WindowJiShiBen("记事本"); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见问题一]]></title>
    <url>%2F2017%2F12%2F29%2FJava%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[错误: 找不到或无法加载主类 Test8.Main解决方法：右键你的项目，选最后一个properties，把properties属性里的java compiler–&gt;building–&gt;abort build when build path errors occur前的勾去掉就好了。好像还有其他的解决方法。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行管理系统]]></title>
    <url>%2F2017%2F12%2F29%2F%E9%93%B6%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[此次的项目是银行管理系统，要求连接数据库，在此记录下。 总界面在此界面除了开户和退出两个功能能实现外，其它功能都需要登录后才能使用。 开户界面此界面需要用户输入个人信息来进行开户操作，用户输入的信息将会保存到数据库中。开户成功后系统会反馈一个开户账号。这个账号是使用的System.currentTimeMillis()产生一个当前的毫秒，这个毫秒其实就是自1970年1月1日0时起的毫秒数。 登录界面此界面需要用户输入开户的账号和密码，系统会从数据库中读取信息与之比对，无误则成功登录。 存款界面此界面需要用户输入存款金额，完成后系统会显示当前账号的余额。此操作记录将会存到数据库中。 取款界面此界面需要用户输入取款金额，完成后系统会显示当前账号的余额。此操作记录将会保存到数据库中。 转账界面此界面需要用户输入对方的账号和转账金额，完成后系统会显示当前账号的余额。此操作记录将会保存到数据库中。 销户界面进入此界面，系统会判断账户余额是否为零，如果不是，不能销户。用户将余额取出，销户完成。 修改密码界面用户需要输入两次相同的六位数字或字母密码，此操作记录将会保存到数据库中。 查看个人信息界面此界面将会显示查询到的当前账户的信息包括账号，姓名，性别，身份证号，联系电话以及开户时间。源码可在这里下载。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Four_or_six]]></title>
    <url>%2F2017%2F12%2F13%2FFour-or-six%2F</url>
    <content type="text"><![CDATA[嗯…没错，就是四六级！]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS填空题]]></title>
    <url>%2F2017%2F12%2F12%2FOS%E5%A1%AB%E7%A9%BA%E9%A2%98%2F</url>
    <content type="text"><![CDATA[操作系统填空题。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869影响文件安全的主要因素: `人为因素`, `系统因素`, `自然因素`。程序执行时呈现出局部性规律: `时间局限性`, `空间局限性`。操作系统的主要功能有: `处理机管理`, `存储器管理`, `设备管理`, `文件管理`, `用户接口`。解决通道“瓶颈”问题最有效的方法是增加设备到主机间的: `通路`。进程三种基本状态: `就绪状态`, `执行状态`, `阻塞状态`。目录管理的主要功能: `实现按名存取`, `提高检索速度`, `文件共享`, `允许文件重名`。在操作系统中，实现进程同步的机制有: `信号量机制`, `管程机制`。进程同步机制应遵循的准则: `空闲让进`, `忙则等待`, `有限等待`, `让权等待`。抢占式进程调度方式基于的主要原则有: `优先权原则`, `短进程优先原则`, `时间片原则`。请求分页系统的主要硬件支持有: `请求分页页表机制`, `缺页中断机构`, `地址变换机构`。进程死锁原因: `竞争资源`, `进程间推进顺序非法`。通常采用解除死锁的两种方法是: `剥夺资源`, `撤消进程`。设备分配中的主要数据结构(英文缩写): `DCT`, `COCT`, `CHCT`, `SDT`。进程、文件、线程在系统中是否存在的唯一标志(英文缩写): `PCB`, `FCB`, `TCB`。产生进程死锁的必要条件: `互斥条件`, `请求和保持条件`, `不剥夺条件`, `环路等待条件`。目前比较流行的操作系统(实例): `Windows`, `UNIX`, `Linux`。OS(操作系统)的基本特征: `并发性`, `共享性`, `虚拟性`, `异步性`。OS(操作系统)的基本类型: `批处理系统`, `分时系统`, `实时系统`。外存分配条件: `连续分配`, `链接分配`, `索引分配`。文件物理结构: `顺序文件`, `链接文件`, `索引文件`。设备的独立性: `LUT`。按设备的固有属性分类，将I/O设备分为: `独占设备`, `共享设备`, `虚拟设备`。虚拟存储理论: `局部性原理`。虚拟设备技术: `SPOOLing`。将一台物理I/O设备虚拟为多台逻辑I/O设备的技术: `SPOOLing`。UNIX本质特征: `OSI`。UNIX内核结构: `进程控制子系统`, `文件子系统`。OS(操作系统)设计目标: `方便性`, `有效性`, `可扩充性`, `开放性`。OS(操作系统)用户接口: `命令接口`, `程序接口`, `图形用户接口`。`方便性`和`有效性`是操作系统设计中最重要的两个目标1990年后，`开放性`已成为新系统或软件能否被广泛应用的至关重要的因素。`并发性`和`共享性`是多用户、多任务操作系统两个最基本的特征。`并发性`是多用户、多任务操作系统最重要的特征。在OS基本特征中，`异步性`是指进程是以人们不可预知的速度向前推进的。在操作系统基本类型中，`可靠性`是实时系统最重要的特征。在操作系统接口中，`程序接口`亦称为`系统调用`。进程所请求的一次I/O完成后，将使进程状态从`阻塞状态`变为`就绪状态`。操作系统中处于执行状态的进程时间片用完后，进程状态将转变为`就绪状态`。操作系统中处于执行状态的进程提出I/O后请求后，进程状态将转变为`阻塞状态`。进程三种基本状态中，`就绪状态`是指进程已分配到除CPU以外的所有必要资源。同步机制准则中，`让权等待`是指当进程不能进入自己的临界区时，应立即释放处理机。在文件系统中，文件属性信息存储在`数据结构(英文缩写)FCB`中。操作系统利用`数据结构(英文缩写)PCB`描述进程的基本情况和活动过程。系统将被中断进程的CPU现场信息保存在该进程的`数据结构(英文缩写)PCB`中。1965年，荷兰学者Dijkstra提出的`信号量机制`是一种卓有成效的进程同步工具。在死锁的条件中，`不剥夺条件`是指进程已获得的资源只能在使用完时由自己释放。在死锁的条件中，`互斥条件`是指在一段时间内，某资源只能被一个进程占用。`资源的按序分配法`是摒弃死锁条件中的`环路等待条件`来预防死锁的发生。现代操作系统产生死锁的条件中，`互斥条件`是不能被摒弃来预防死锁的发生。在局部性原理中，产生`时间局限性`的典型原因是在程序中存在着大量的循环操作。在局部性原理中，产生`空间局限性`的典型情况是程序的顺序执行。在请求分页系统的硬件支持中，当所要访问的页面不在内存时，由`缺页中断机构`实现。在请求分页系统的硬件支持中，页面置换算法需要应用`请求页表机制`实现。为了实现设备的独立性，系统必须设置(英文缩写): `LUT`。在设备分配中，用于记录每一个设备情况的数据结构(英文缩写): `DCT`。在设备分配中，用于记录全部设备情况的数据结构(英文缩写): `SDT`。在设备分配中，用于记录每一个控制器情况的数据结构(英文缩写): `COCT`。在设备的固有属性分类中，`独占设备`属于临界资源，即进程临界区访问的资源。在设备的固有属性分类中，典型的独占设备有`打印机`、`磁带机`等。在设备的固有属性分类中，典型的共享设备有`磁盘`、`光盘`。在假脱机打印机系统中，在设备的固有属性分类，是将`独占设备`改造为`共享设备`。在假脱机打印机系统中，在设备的固有属性分类，实现了`虚拟设备`功能。`SPOOLing`技术是对脱机I/O系统的模拟，或称为`假脱机技术`。在索引节点中设置链接引用(links)计数的目的是为了实现目录管理的`文件共享功能`。实现`按名存取`是文件系统目录管理中最基本的功能。实现`按名存取`是文件系统向用户提供的最基本的服务。通过`建立后备系统`，防止由`自然因素`所造成的文件系统的不安全性。通过`存取控制机制`，防止由`人为因素`所造成的文件系统的不安全性。通过`采取容错技术`，防止由`系统因素`所造成的文件系统的不安全性。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐写之图片隐藏]]></title>
    <url>%2F2017%2F12%2F08%2F%E9%9A%90%E5%86%99%E4%B9%8B%E5%9B%BE%E7%89%87%E9%9A%90%E8%97%8F%2F</url>
    <content type="text"><![CDATA[在图片中插入其他的文件，例如一段音乐，一段视频，或是某个文件。1、准备一张图片和要隐藏的资料信息比如这里，style准备了一张壁纸和一个txt文件。现在需要将一个文件隐藏在这张图片里。2、选择需要隐藏的文件，右键压缩成一个rar文件，文件名字可以随便起，在这里style将其压缩成1.rar。3、新建一个文本文档，名字随便起，style这里将其命名为2.txt,，在里面输入以下代码copy /b 1.jpg+1.rar 222.jpg4、接着另存为这个文本文档，重要的是文件类型得是bat类型，也就是批处理命令。style这里命名为2.bat。5、双击这个bat命令，得到一个最终的文件222.jpg。6、这个图片打开看的话和正常的图片一样，但是大小与封面图片相比是不一样的，其实这里面包含了刚刚隐藏的那些重要信息。将得到的新的图片的后缀改为rar，然后解压就可得到我们刚刚隐藏的文件。也可以用二进制编辑器查看，发现在后面有个zip的文件头，可以将这个压缩包提取出来，再解压。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[情报搜集技术]]></title>
    <url>%2F2017%2F12%2F07%2F%E6%83%85%E6%8A%A5%E6%90%9C%E9%9B%86%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[#外围信息搜集网站的IP地址查询kali中使用nslookup工具对testfire.net这个网站进行查询root@bt:~# nslookup回车后输入set type=A回车后输入testfire.net就可以了。 IP2Location地理位置查询查询IP地址，可以在http://www.maxmind.com 网站上使用该服务。如果是国内的IP地址，推荐使用“QQ纯真数据库”。 IP2Domain反查域名一台物理服务器上面可能运行多个虚拟主机，这些虚拟主机具有不同的域名，但通常公用一个IP地址。如果你要知道有哪些网站公用这台服务器，就有可能通过此台服务器上其他网站的漏洞获取服务器控制权，进而迂回获取渗透目标的权限，这种攻击技术也称为旁注。可以使用http://www.ip-adress.com/reverse_ip/ 提供的服务查询有哪些域名指向同一个IP地址。国内也有一些类似的网站可用于IP反查，如http://www.7c.com/ ,该网站针对国内的IP查询结果更为准确。 探索网站的目录结构如果管理员允许，Web服务器会将没有默认页面的目录以文件列表的方式显示出来，而这些开放了浏览功能的网站目录往往会透露一些网站可供浏览的页面之外的信息，甚至能够再这些目录中发现网站源代码甚至后端数据库的连接口令。可以再Google中输入parent directory site:testfire.net来查找testfire.net上的此类目录。打开第一个链接，网站的bank目录中的文件内容一览无余。在浏览网站目录时，应当对以下几种文件特别留意: 1、扩展名为inc的文件:可能会包含网站的配置信息，如数据库用户名/口令等。2、扩展名为bak的文件：通常是一些文本编辑器在编辑源代码后留下的备份文件，可以让你知道与其对应的程序脚本文件中的大致内容。3、扩展名为txt或sql的文件：一般包含网站运行的SQL脚本，可能会透露类似数据库结构等信息。 检索特定类型的文件在Google中输入site:testfire.net filetype:xls，可以查询testfire.net这个网站中xls类型文件。 搜索网站中的E-mail地址使用Metasploit中一个非常棒的辅助模块search_email_collector，进行有针对性的右键地址搜集。search_email_collector模块要求提供一个邮箱后缀（域名），它并不是通过直接遍历网站页面获取邮件地址，而是通过多个搜索引擎的查询结果分析使用此后缀的邮件地址，使用它就能够很方便地获取某个机构地大量邮件地址。msf&gt; use auxiliary/gather/search_email_collectormsf auxiliary(search_email_collector)&gt; set DOMAIN altoromutual.com回车后输入runtestfire网站模拟了一个名为altoromutual地电子银行站点，用它来做测试。 搜索易存在SQL注入点地页面使用Google可以筛选出网站中容易出现SQL注入漏洞的页面，如网站登录页面。例如在google.com中输入site:testfire.net inurl:login关键字进行搜索，得到了其后台登录URL。 #主机探测与端口扫描Metasploit的主机发现模块Metasploit中提供了一些辅助模块可用于活跃主机的发现，这些模块位于Metasploit源码路径的modules/auxiliary/scanner/discovery/目录中。其中两个常用模块的主要功能为: 1、arp_sweep使用ARP请求枚举本地局域网络中的所有活跃主机。2、udp_sweep通过发送UDP数据包探查指定主机是否活跃，并发现主机上的UDP服务。 Metasploit的arp_sweep模块是一个ARP扫描器。如下演示使用方法。首先需要输入RHOSTS来对扫描目标进行设置，设置好后输入run命令启动扫描器。从代码中可以看到，arp_sweep模块很快发现了192.168.2.0/24网段上拥有3台活跃主机，其中前两个IP地址为宿主主机上模拟的虚拟网卡IP地址。arp_sweep模块只能探测同一子网中的活跃主机，对于远程网络，可以使用更为强大的Nmap扫描器进行探测。 使用Nmap进行主机探测通常一个Nmap命令格式如下所示:nmap &lt;扫描选项&gt; &lt;扫描目标&gt;如果仅是在一个内部网中发现存活主机，可以使用-sn，这个选项会使用ICMP的Ping扫描获取网络中的存活主机情况，而不会进一步探测主机的详细情况。如果是在Internet环境中，推荐使用-Pn选项，它会告诉Nmap不要使用Ping扫描，因为ICMP数据包通常无法穿透Internet上的网络边界(通常是被防火墙过滤掉了)。在Internet环境中，可以使用nmap-PU通过对开放的UDP端口进行探测以确定存活的主机，其功能类似Metasploit中的udp_sweep辅助模块。Nmap在进行UDP主机探测时，默认会列出开放的TCP端口，如果想加快扫描速度，可以使用-sn告诉Nmap仅探测存活主机，不对开放的TCP端口进行扫描。 操作系统辨识可以使用-O选项让Nmap对目标的操作系统进行识别。使用nmap -A命令可以获取更详细的服务和操作系统信息。 #端口扫描与服务类型探测Metasploit中的端口扫描器Metasploit的辅助模块中提供了几款实用的端口扫描器。可以输入search portscan命令找到相关的端口扫描器。 1、ack: 通过ACK扫描的方式对防火墙上未被屏蔽的端口进行探测。2、ftpbounce: 通过FTP bounce攻击的原理对TCP服务进行枚举，一些新的FTP服务器软件能够很好的防范FTP bounce攻击，但在一些旧的Solaris及FreeBSD系统的FTP服务中此类攻击方式仍能够被利用。3、syn: 通过一次完整的TCP连接来判断端口是否开放，这种扫描方式最精确，但扫描速度慢。4、xmas: 一种更为隐秘的扫描方式，通过发送FIN、PSH和URG标志，能够躲避一些高级的TCP标记监测器的过滤。 一般情况下，推荐使用syn端口扫描器，因为它的扫描速度较快、结果精确且不容易被对方察觉。 Nmap的端口扫描功能Nmap对端口的状态分为六个层次: open(开放)、cloase(关闭)、filtered(被过滤)、unfiltered(未过滤)、open|filtered(开放或被过滤)、closed|filtered(关闭或被过滤)。下面对这几种端口状态进行说明: 1、open: 一个应用程序正在此端口上进行监听，以接收来自TCP、UDP或SCTP协议的数据。这是在渗透测试中最关注的一类端口，开放端口往往能够为我们提供一条能够进入系统的攻击路径。2、closed: 关闭的端口指的是主机已响应，但没有应用程序监听的端口。这些信息并非毫无价值，扫描出关闭端口至少说明主机是活跃的。3、filtered: 指Nmap不能确认端口是否开放，但根据响应数据猜测该端口可能被防火墙等设备过滤。4、unfiltered: 仅在使用ACK扫描时，Nmap无法确定端口是否开放，会归为此类。可以使用其他类型的扫描(如WIndow扫描、SYN扫描、FIN扫描)进一步确认端口的信息。 常用的Nmap扫描类型参数主要有: 1、-sT: TCP connect扫描，类似Metasploit中的tcp扫描模块。2、-sS: TCP SYN扫描，类似Metasploit中的syn扫描模块。3、-sF/-sX/-sN: 这些扫描通过发送一些特殊的标志位以避开设备或软件的监测，4、-sP: 通过发送ICMP echo请求探测主机是否存活，原理同ping。5、-sU: 探测目标主机开放了哪些UDP端口。6、-sA: TCP ACK扫描，类似Metasploit中的ack扫描模块。 常用的Nmap扫描选项有: 1、-Pn: 在扫描之前，不发送ICMP echo请求测试目标是否活跃。2、-O: 启用对于TCP/IP协议栈的指纹特征扫描以获取远程主机的操作系统类型等信息。3、-F: 快速扫描模式，只扫描在nmap-services中列出的端口。4、-p&lt;端口范围&gt;: 可以使用这个参数指定希望扫描的端口，也可以使用一段端口范围(例如1~1023).在IP协议扫描中(使用-sO参数)，该参数的意义是指定想要扫描的协议号(0~255)。 使用Nmap对192.168.2.2进行一次端口扫描的结果，其中用到了-sS选项，该选项指定使用TCP SYN扫描，这种扫描方式不等待打开一个完全的TCP连接，所以执行速度会更快，而且这种扫描通常不会被IDS等设备记录。如果想同时列出UDP端口，可以加上-sU，但执行速度就会变得比较慢。 使用Nmap探测更详细的服务信息如果想获取更加详细的服务版本等信息，需要使用-sV选项。 #服务扫描与查点在Metasploit的Scanner辅助模块中，有很多用于服务扫描和查点的工具，这些工具常以[service_name]_version和[service_name]_login命令。 1、[service_name]_version可用于遍历网络中包含了某种服务的主机，并进一步确定服务的版本。2、[service_name]_login可对于某种服务进行口令探测攻击。 在MSF终端中，可以输入search name:_version命令查看所有可用的服务查点模块。 SSH服务扫描与telnet不同的是，ssh采用安全的加密信息传输方式。通常管理员会使用ssh对服务器进行远程管理，服务器会向ssh客户端返回一个远程的Shell连接。 Oracle数据库服务查点使用mssql_ping模块查找网络中的Microsoft SQL Server，使用tnslsnr_version模块查找网络中开放端口的Oracle监听器服务。 开放代理探测与利用避免被对方的入侵监测系统跟踪，需要隐藏自己的身份，最简单和最常见的是使用代理服务器。Metasploit提供了open_proxy模块，能够让你更加方便地获取免费地HTTP代理服务器地址。获取免费开放代理后，就可以在浏览器或者一些支持配置代理地渗透软件中配置代理，这可以在进行渗透测试时隐藏你的真实IP地址。比开放代理更保险地隐藏攻击源方法是利用开放的或自主架设VPN服务，可以自己架设OpenVPN。使用这些VPN可以采用加密方式转发路由你的渗透测试数据包，而无需担心你的攻击发起源被跟踪到。 #口令猜测与嗅探SSH服务口令猜测载入ssh_login模块后，首先需要设置RHOSTS参数指定口令攻击的对象，可以是一个IP地址，或一段IP地址，同样也可以使用CIDR表示的地址区段。然后使用USERNAME参数指定一个用户名(或者使用USER_FILE参数指定一个包含多个用户名的文本文件，每个用户名占一行)，并使用PASSWORD指定一个特定的口令字符串(或者使用PASS_FILE参数指定一个包含多个口令的字典文件，每个口令占一行)，也可以使用USER PASS_FILE指定一个用户名和口令的配对文件(用户名和口令之间用空格隔开，每对用户名和口令占一行)。默认情况下，ssh_login模块还会尝试空口令，以及与用户名相同的弱口令进行登录测试。 psnuffle口令嗅探psnuffle是目前Metasploit中唯一用于口令嗅探的工具，可以使用它截获常见协议的身份认证过程，并将用户名和口令信息记录下来。 #网络漏洞扫描OpenVAS漏洞扫描器可以用来识别远程主机、Web应用存在的各种漏洞，使用NVT脚本对多种远程系统的安全问题进行监测。在kali中安装openVAS，输入命令: apt-get install openvas，安装过程中可能会出现错误，输入openvas-check-setpu查看安装到哪步出错，以及缺少什么东西。配置OpenVAS的过程如下:1、输入以下命令生成OpenVAS运行所需的证书文件，生成证书过程中，系统会询问一些信息，可以按回车键使用其默认值: root@bt:~# openvas-mkcert -qroot@bt:~# openvas-mkcert-client -n om -i 2、升级NVT库: root@bt:~# openvas-nvt-sync 3、对OpenVAS的扫描引擎进行一些初始化的操作，依次输入如下命令: root@bt:~# openvassdroot@bt:~# openvasmd –migrateroot@bt:~# openvasmd –rebuild 4、使用openvasad命令添加一个管理员角色的OpenVAS登录用户: root@bt:~# openvasad -c ‘add_user’ -n admin -r ‘Admin’Enter password:admain:MESSAGE:2327:2017-12-07 03h37.44 EDT: No rules file provided, the new user will have no restrictions.admin:MESSAGE:2327:2017-12-07 03h37.44 EDT: User admin has been successfully created. 5、在终端输入如下命令启动OpenVAS Scanner: root@bt:~# openvassd –listen=127.0.0.1 –port=9391All plugins loaded 6、最后启动OpenVAS Manager，在终端中运行如下命令: root@bt:~# openvasmd –database=/usr/local/var/lib/openvas/mgr/tasks.db –slisten=127.0.0.1 –sport=9391 –listen=0.0.0.0 –port=9390 如果在启动OpenVAS各部件时报错，可以运行以下脚本确认OpenVAS已经安装配置无误，如果脚本运行检测出错误，请按照屏幕提示进行修正。 root@bt:~# /pentest/misc/openvas/openvas-check-setup Nmap扫描漏洞如果服务器开启了SMB服务，可以使用Nmap的SMB服务漏洞扫描模块对它进行探测。]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读写文件二]]></title>
    <url>%2F2017%2F12%2F05%2Fjava%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[使用Java的输入流、输出流将一个文本文件的内容按行读出，每读出一行就顺序添加行号，并写入到另一个文件中。1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class Test4 &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub BufferedReader br = null; BufferedWriter bw = null; try &#123; br = new BufferedReader(new FileReader("Input.txt")); bw = new BufferedWriter(new FileWriter("Output.txt")); String str = ""; int i = 1; while((str = br.readLine()) != null)&#123; bw.write(i+" "); bw.write(str); System.out.println(i+ " "+ str); bw.newLine(); //换行，换行后可以使用readline()来一行行读取数据 i++; &#125; bw.flush(); //清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再用数据写到文件中， //当数据读完时，如果调用close()方法关闭读写流，就可能造成数据丢失， //原因是一部分的数据可能留在缓存区 bw.close(); br.close(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block System.out.println("找不到指定文件！"); &#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java读写文件一]]></title>
    <url>%2F2017%2F12%2F05%2Fjava%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E4%B8%80%2F</url>
    <content type="text"><![CDATA[写入文件后可逆序输出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.io.*;import java.util.Scanner;public class Test3 &#123; public static void main(String[] args) &#123; //创建文件对象 File file= new File("2.txt"); if (file.exists()) &#123; //文件存在 String name= file.getName(); long len= file.length(); //判断文件隐藏属性 boolean hidden= file.isHidden(); System.out.println("文件名称: "+ name+ "\n文件长度: "+ len+ "\n隐藏属性: "+ hidden); writefile(file); readfile(file); &#125;else &#123; //文件不存在，创建文件 try &#123; file.createNewFile(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; System.out.println("文件已创建"); &#125; &#125; &#125; private static void readfile(File file) &#123; // TODO Auto-generated method stub try &#123; FileInputStream fileInputStream= new FileInputStream(file); byte[] b= new byte[1024]; int len= fileInputStream.read(b); fileInputStream.close(); StringBuilder ab = new StringBuilder(new String(b, 0, len)); System.out.println("文件读出的内容是: \n"+ ab.reverse().toString()); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; private static void writefile(File file) &#123; // TODO Auto-generated method stub Scanner in= new Scanner(System.in); System.out.println("请输入要写入得内容"); String string= in.next(); //建立文件传输管道 try &#123; FileOutputStream fileOutputStream= new FileOutputStream(file); //写文件 fileOutputStream.write(string.getBytes()); //关闭管道 fileOutputStream.close(); System.out.println("文件写入完成"); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP简单大文件传送]]></title>
    <url>%2F2017%2F12%2F04%2FUDP%E7%AE%80%E5%8D%95%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%2F</url>
    <content type="text"><![CDATA[话不多说，直接上代码。运行的时候先运行You.java, 再运行My.javaMy.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.net.*;import java.util.concurrent.TimeoutException;import java.awt.event.*;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import javax.swing.*;public class My&#123; public static void main(String[] args) &#123; new MyFrame(); &#125;&#125;class MyFrame extends JFrame implements ActionListener &#123; JTextField out_message = new JTextField(16); JTextArea in_message = new JTextArea(); JButton cfile = new JButton("选择文件"); JFileChooser chooser = new JFileChooser(); public MyFrame() &#123; setTitle("My"); // setSize(600, 600); setVisible(true); setBounds(300, 200, 350, 300); cfile.addActionListener(this); // send.addActionListener(this); // out_message.addKeyListener(this); JPanel pSouth = new JPanel(); pSouth.add(out_message); pSouth.add(cfile); // pSouth.add(send); add(pSouth, "South"); add(new JScrollPane(in_message), "Center"); validate(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void actionPerformed(ActionEvent event) &#123; chooser.setFileSelectionMode(0); int status = chooser.showOpenDialog(null); if (status == 1) &#123; return; &#125; else &#123; File file = chooser.getSelectedFile(); out_message.setText(file.getAbsolutePath()); out_message.grabFocus(); long startTime = System.currentTimeMillis();// 获取当前时间 byte[] buf = new byte[UDPUtils.BUFFER_SIZE];// 发送文件的字节数组 byte[] receiveBuf = new byte[Math.max(UDPUtils.successData.length, UDPUtils.exitData.length)];// 传送验证信息的字节数组 RandomAccessFile accessFile = null; DatagramPacket dpk = null; DatagramSocket dsk = null; int readSize = -1; try &#123; accessFile = new RandomAccessFile(file.getAbsolutePath(), "r");// 创建一个只读的文件流 dpk = new DatagramPacket(buf, buf.length, new InetSocketAddress(InetAddress.getByName("192.168.199.143"), UDPUtils.PORT + 1));// 创建一个待发送数据包 dsk = new DatagramSocket(UDPUtils.PORT);// 接收.... dsk.setSoTimeout(1000);// 设置确认报文超时重传 int sendCount = 0;// 记录发送的数据包的数量 while ((readSize = accessFile.read(buf, 0, buf.length)) != -1) &#123;// 将文件的数据读满字节数组，返回读入数组的总字节数，如果到文件尾则等于-1 // 未读到文件尾 dpk.setData(buf, 0, readSize);// 设置包的缓冲区长度为读入的字节数 dsk.send(dpk);// 发送包 // 等待服务端回应 &#123; while (true) &#123; dpk.setData(receiveBuf, 0, receiveBuf.length);// UDPUtils.successData.length); try &#123; dsk.receive(dpk);// 接收数据包 if (!UDPUtils.isEqualsByteArray(UDPUtils.successData, receiveBuf, dpk.getLength())) &#123;// 返回的不是成功标志 throw new TimeoutException("数据没有收到！"); &#125; else &#123; break; &#125; &#125; catch (SocketTimeoutException | TimeoutException e) &#123;//没有收到数据包或返回的不是成功标志 // TODO 超时重传 System.out.println("resend ..."); dpk.setData(buf, 0, readSize); dsk.send(dpk); continue; &#125; &#125; &#125; System.out.println("send count of " + (++sendCount) + "!"); &#125; // 发送退出标志等待回应 System.out.println("客户端退出 ...."); dpk.setData(UDPUtils.exitData, 0, UDPUtils.exitData.length); dsk.send(dpk); while (true) &#123; dpk.setData(receiveBuf, 0, receiveBuf.length); // byte[] receiveData = dpk.getData(); try &#123; dsk.receive(dpk); if (!UDPUtils.isEqualsByteArray(UDPUtils.exitData, receiveBuf, dpk.getLength())) &#123; throw new TimeoutException("Msg not equal"); &#125; else &#123; break; &#125; &#125; catch (SocketTimeoutException | TimeoutException e) &#123; // TODO 超时重传 System.out.println("client Resend exit message ...."); dsk.send(dpk); continue; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (accessFile != null) accessFile.close(); if (dsk != null) dsk.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; long endTime = System.currentTimeMillis(); System.out.println("time:" + (endTime - startTime)); &#125; &#125;&#125; You.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.InetSocketAddress;public class You &#123; private static final String SAVE_FILE_PATH = "C:/Users/马冲/Desktop/flag.zip";//接收文件存储的路径 public static void main(String[] args) &#123; byte[] buf = new byte[UDPUtils.BUFFER_SIZE]; DatagramPacket dpk = null;//定义一个数据包 DatagramSocket dsk = null;//定义一个接收数据包 BufferedOutputStream bos = null;//定义一个缓冲的文件输出流 try &#123; dpk = new DatagramPacket(buf, buf.length, new InetSocketAddress(InetAddress.getByName("127.0.0.1"), UDPUtils.PORT)); dsk = new DatagramSocket(UDPUtils.PORT + 1);//创建一个数据包由于接收 bos = new BufferedOutputStream(new FileOutputStream(SAVE_FILE_PATH));//创建一个缓冲的文件输出流 System.out.println("等待客户端...."); dsk.receive(dpk);//等待客户端发送文件 int readSize = 0; int readCount = 0; int flushSize = 0; while ((readSize = dpk.getLength()) != 0) &#123; // 验证客户端发送退出标志 if (UDPUtils.isEqualsByteArray(UDPUtils.exitData, buf, readSize)) &#123; System.out.println("服务器退出 ..."); dpk.setData(UDPUtils.exitData, 0, UDPUtils.exitData.length);//设置包中数据为退出标志 dsk.send(dpk);//发送退出标志 break;//退出 &#125; bos.write(buf, 0, readSize);//将字节数组中的数据写入缓冲流 if (++flushSize % 1000 == 0) &#123; flushSize = 0; bos.flush(); &#125; dpk.setData(UDPUtils.successData, 0, UDPUtils.successData.length);//设置包中数据为接收成功标志 dsk.send(dpk);//返回一个接收成功标志 dpk.setData(buf, 0, buf.length);//重新设置包用于接收下一个数据包 System.out.println("receive count of " + (++readCount) + " !"); dsk.receive(dpk);//等待客户端发送文件 &#125; // last flush bos.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (bos != null) bos.close(); if (dsk != null) dsk.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; UDPUtils.java1234567891011121314151617181920212223242526272829303132333435363738394041424344public class UDPUtils &#123; private UDPUtils() &#123; &#125; /** transfer file byte buffer **/ public static final int BUFFER_SIZE = 50 * 1024; /** controller port **/ public static final int PORT = 50000; /** mark transfer success **/ public static final byte[] successData = "success data mark".getBytes(); /** mark transfer exit **/ public static final byte[] exitData = "exit data mark".getBytes(); /** * compare byteArray equest successData * * @param compareBuf * src * @param buf * target * @return */ public static boolean isEqualsByteArray(byte[] compareBuf, byte[] buf, int len) &#123; if (buf == null || buf.length == 0 || compareBuf.length &lt; len) return false; boolean flag = true; int innerMinLen = Math.min(compareBuf.length, len); // if(buf.length == compareBuf.length)&#123; for (int i = 0; i &lt; innerMinLen; i++) &#123; if (buf[i] != compareBuf[i]) &#123; flag = false; break; &#125; &#125; // &#125;else // return false; return flag; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP通信-AES和Base64加解密]]></title>
    <url>%2F2017%2F12%2F04%2FUDP%E9%80%9A%E4%BF%A1-AES%E5%92%8CBase64%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[基于UDP的通信和基于TCP的通信不同，基于UDP的信息传递更快，但不提供可靠性保证。也就是说，数据在传输时，用户无法知道能否正确地到达目的地主机，也不能确定数据到达目的地地顺序是否和发送地顺序相同。基于UDP通信地基本模式如下:(1)将数据打包，称为数据包，然后将数据包发往目的地。(2)接收别人发来地数据包，然后查看数据包中地内容。 发送数据包用DatagramPacket类将数据打包，即用DatagramPacket类创建一个对象，称为数据包。用DatagramPacket地以下两个构造方法创建待发送地数据包: DatagramPacket(byte data[], int length, InetAddtress address, int port);使用该构造方法创建地数据包对象具有下列两个性质：(1)含有data数组指定地数据(2)该数据包将发送到地址是adress、端口号是port的主机上。用DatagramSocket类的不带参数的构造方法DatagramSocket()创建一个对象，该对象负责发送数据包。例如: DatagramSocket mail_out= new DatagramSocket();mail_out.send(data_pack); 下面附上Mac.java, 其中使用了AES和Base64加解密。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import java.net.*;import java.text.SimpleDateFormat;import java.util.Date;import java.awt.event.*;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import javax.swing.*;import org.apache.commons.codec.binary.Base64;public class Mac&#123; public static void main(String[] args) &#123; MaCs maC= new MaCs(); &#125; &#125;class MaCs extends JFrame implements Runnable, ActionListener, KeyListener&#123; SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); JTextField out_message1= new JTextField(12); JTextArea in_message= new JTextArea(); JButton send= new JButton("发送"); String password = "ABCDEFGHIJKLMNOP"; MaCs()&#123; setTitle("SS"); setSize(400, 200); setBounds(700, 200, 350, 300); setVisible(true); send.addActionListener(this); out_message1.addKeyListener(this); JPanel pSouthJPanel= new JPanel(); pSouthJPanel.add(out_message1); pSouthJPanel.add(send); add(pSouthJPanel, "South"); add(new JScrollPane(in_message), "Center"); in_message.setEditable(false); validate(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Thread thread= new Thread(this); thread.start();//线程负责接收数据包 &#125; /** * 使用参数中的密钥加密 */ public static String Encrypt(String sSrc, String sKey) &#123; try&#123; if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); //SecretKeySpec类是KeySpec接口的实现类，用于构建秘密密钥规范 //构造一个用AES算法加密的密钥 Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//"算法/模式/补码方式，创建密码器" cipher.init(Cipher.ENCRYPT_MODE, skeySpec);//初始化为加密模式的密码器 //Cipher为加密解密提供密码功能 byte[] encrypted = cipher.doFinal(sSrc.getBytes("utf-8"));//加密 return new Base64().encodeToString(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用。 &#125;catch(Exception e)&#123; e.printStackTrace(); //在命令行打印异常信息在程序中出错的位置及原因 return null; &#125; &#125; /** * 使用参数中的密钥解密 */ public static String Decrypt(String sSrc, String sKey) &#123; try &#123; // 判断Key是否正确 if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, skeySpec); byte[] encrypted1 = new Base64().decode(sSrc);//先用base64解密 try &#123; byte[] original = cipher.doFinal(encrypted1); String originalString = new String(original,"utf-8"); return originalString; &#125; catch (Exception e) &#123; System.out.println(e.toString()); return null; &#125; &#125; catch (Exception ex) &#123; System.out.println(ex.toString()); return null; &#125; &#125; //回车发送 public void keyPressed(KeyEvent e) &#123; // TODO Auto-generated method stub if (e.getKeyCode()== 10) &#123; (this).actionPerformed(null); &#125; &#125; @Override public void actionPerformed(ActionEvent event) &#123; // TODO Auto-generated method stub String content1 = Encrypt(out_message1.getText(), password); byte buffer[]= content1.trim().getBytes(); try &#123; InetAddress address= InetAddress.getByName("192.168.199.143"); DatagramPacket datagramPacket= new DatagramPacket(buffer, buffer.length, address, 888); DatagramSocket mailDatagramSocket= new DatagramSocket(); mailDatagramSocket.send(datagramPacket); String content2 = Decrypt(content1, password); in_message.append("----------"+ df.format(new Date())+ "----------\nss: "+ content2+ "\n"); out_message1.setText(null); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; @Override public void run() &#123; // TODO Auto-generated method stub DatagramPacket packet= null; DatagramSocket mailDatagramSocket=null; byte data[]= new byte[8192];//定义数据包的大小 try&#123; packet= new DatagramPacket(data, data.length); mailDatagramSocket= new DatagramSocket(666); &#125; catch(Exception e)&#123; &#125; while(true)&#123; if (mailDatagramSocket== null) &#123; break; &#125; else &#123; try &#123; mailDatagramSocket.receive(packet);//可能会发生堵塞，直到收到数据包 String mesString= new String(packet.getData(), 0, packet.getLength()); String content3 = Decrypt(mesString, password); //System.out.println("123"); in_message.append("**********"+ df.format(new Date())+ "**********\n"); in_message.append("mc: "+ content3+ "\n"); &#125; catch (Exception e1) &#123; // TODO: handle exception &#125; &#125; &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; // TODO Auto-generated method stub &#125; @Override public void keyTyped(KeyEvent e) &#123; // TODO Auto-generated method stub &#125; &#125; 接收数据包用DatagramSocket的另一个构造方法DatagramSocket(int port)创建一个对象，其中的参数必须和待接收的数据包的端口号相同。例如，如果发送方发送的数据包的端口是5666，那么如下创建DatagramSocket对象:DatagramSocket mail_in= new DatagramSocket(5666);然后对象maill_in使用方法receive(DatagramPacket pack)接收数据包。该方法有一个数据包参数pack，方法receive把收到的数据包传递给该参数。因此，用户必须预备一个数据包，以便收取数据包。这时需使用DatagramPack类的另一个构造方法DatagramPacket(byte data[], int length)创建一个数据包，用于接收数据包，例如: byte data[]= new byte[100];int length= 90;DatagramPacket pack= new DatagramPacket(data, length);mail_in.receive(pack); 该数据包pack将接收长度是length字节的数据放入data。值得注意的是: receive方法可能会堵塞，直到收到数据包。下面附上Shens.java, 其中同样使用了AES、Base64加解密。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183import java.net.*;import java.text.SimpleDateFormat;import java.util.Date;import java.awt.event.*;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import javax.swing.*;import org.apache.commons.codec.binary.Base64;public class Shens&#123; public static void main(String[] args) &#123; ShenSs shenS= new ShenSs(); &#125;&#125;class ShenSs extends JFrame implements Runnable, ActionListener, KeyListener&#123; SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); JTextField out_message= new JTextField(12); JTextArea in_message= new JTextArea(); JButton send=new JButton("发送"); String password = "ABCDEFGHIJKLMNOP"; ShenSs()&#123; setTitle("MC"); //setSize(400, 200); setBounds(300, 200, 350, 300); setVisible(true); send.addActionListener(this); out_message.addKeyListener(this); JPanel panel= new JPanel();//创建一个面板，里面可以布局 panel.add(out_message); panel.add(send); add(panel, "South"); add(new JScrollPane(in_message), "Center"); in_message.setEditable(false); validate();//验证此容器及所有组件 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Thread thread= new Thread(this); thread.start();//线程负责接收数据包 &#125; /** * 使用参数中的密钥加密 */ public static String Encrypt(String sSrc, String sKey) &#123; try&#123; if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8");//字节型数组 SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); //SecretKeySpec类是KeySpec接口的实现类，用于构建秘密密钥规范 Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//"算法/模式/补码方式" cipher.init(Cipher.ENCRYPT_MODE, skeySpec); //Cipher为加密解密提供密码功能 byte[] encrypted = cipher.doFinal(sSrc.getBytes("utf-8")); return new Base64().encodeToString(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用。 &#125;catch(Exception e)&#123; e.printStackTrace(); //在命令行打印异常信息在程序中出错的位置及原因 return null; &#125; &#125; /** * 使用参数中的密钥解密 */ public static String Decrypt(String sSrc, String sKey) &#123; try &#123; // 判断Key是否正确 if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); //SecretKeySpec类是KeySpec接口的实现类，用于构建秘密密钥规范 Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//只实例化一次 //Cipher为加密解密提供密码功能 cipher.init(Cipher.DECRYPT_MODE, skeySpec); //初始化为解密模式的密码器 byte[] encrypted1 = new Base64().decode(sSrc);//先用base64解密 try &#123; byte[] original = cipher.doFinal(encrypted1);//解密 String originalString = new String(original,"utf-8"); return originalString;//明文 &#125; catch (Exception e) &#123; System.out.println(e.toString()); return null; &#125; &#125; catch (Exception ex) &#123; System.out.println(ex.toString()); return null; &#125; &#125; //回车发送 public void keyPressed(KeyEvent e) &#123; // TODO Auto-generated method stub if (e.getKeyCode()== 10) &#123; (this).actionPerformed(null); &#125; &#125; @Override public void actionPerformed(ActionEvent event) &#123;//单击按钮发送数据包 // TODO Auto-generated method stub String content1 = Encrypt(out_message.getText(), password); byte buffer[]= content1.trim().getBytes(); try &#123; InetAddress address= InetAddress.getByName("127.0.0.1"); DatagramPacket datagramPacket= new DatagramPacket(buffer, buffer.length, address, 666); //存放数据的数据报 DatagramSocket mailDatagramSocket= new DatagramSocket(); //接受或发送数据报的套接字 mailDatagramSocket.send(datagramPacket); String content2 = Decrypt(content1, password); in_message.append("**********"+ df.format(new Date())+ "**********\nmc: "+ content2+ "\n"); out_message.setText(null); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; @Override public void run() &#123; // TODO Auto-generated method stub DatagramPacket packet= null; DatagramSocket mailDatagramSocket=null; byte data[]= new byte[8192];//指定数据包的大小 try&#123; packet= new DatagramPacket(data, data.length); mailDatagramSocket= new DatagramSocket(888); &#125; catch(Exception e)&#123; &#125; while(true)&#123; if (mailDatagramSocket== null) &#123; break; &#125; else &#123; try &#123; mailDatagramSocket.receive(packet); String mesString= new String(packet.getData(), 0, packet.getLength()); String content3 = Decrypt(mesString, password); in_message.append("----------"+ df.format(new Date())+ "----------\n"); in_message.append("ss: "+ content3+ "\n"); &#125; catch (Exception e1) &#123; // TODO: handle exception &#125; &#125; &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; // TODO Auto-generated method stub &#125; @Override public void keyTyped(KeyEvent e) &#123; // TODO Auto-generated method stub &#125;&#125; 由于使用了Base64加解密，会出现Base64 cannot be resolved to a type这个错误。可以参考我的上一篇博文，那里有解决的方法。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java解决Base64包问题]]></title>
    <url>%2F2017%2F11%2F28%2FJava%E8%A7%A3%E5%86%B3Base64%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[java中使用AES对数据进行加解密算法模式：ECB 密钥 长度：128bits 16位长 偏移量： 默认 补码方式：PKCS5Padding 解密串编码方式：base64密钥为16位长度的字符串1234567891011121314151617181920212223242526272829/** * 使用参数中的密钥加密 * @param 明文 * @param 密钥 * @return 密文 */public static String Encrypt(String sSrc, String sKey) &#123; try&#123; if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");//"算法/模式/补码方式" cipher.init(Cipher.ENCRYPT_MODE, skeySpec); byte[] encrypted = cipher.doFinal(sSrc.getBytes("utf-8")); return new Base64().encodeToString(encrypted);//此处使用BASE64做转码功能，同时能起到2次加密的作用。 &#125;catch(Exception e)&#123; e.printStackTrace(); return null; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/** * 使用参数中的密钥解密 * @param 密文 * @param 密钥 * @return 明文 */public static String Decrypt(String sSrc, String sKey) &#123; try &#123; // 判断Key是否正确 if (sKey == null) &#123; System.out.print("Key为空null"); return null; &#125; // 判断Key是否为16位 if (sKey.length() != 16) &#123; System.out.print("Key长度不是16位"); return null; &#125; byte[] raw = sKey.getBytes("utf-8"); SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, skeySpec); byte[] encrypted1 = new Base64().decode(sSrc);//先用base64解密 try &#123; byte[] original = cipher.doFinal(encrypted1); String originalString = new String(original,"utf-8"); return originalString; &#125; catch (Exception e) &#123; System.out.println(e.toString()); return null; &#125; &#125; catch (Exception ex) &#123; System.out.println(ex.toString()); return null; &#125;&#125; 12345678测试方法String password = "ABCDEFGHIJKLMNOP";String content1 = "我的博客名是geekfly";System.out.println("加密前：" + content1); String content2 = Encrypt(content1, password);System.out.println("加密后：" + content2);String content3 = Decrypt(content2, password);System.out.println("解密后：" + content3); 在这个过程中出现个问题，base64 cannot be resolved to a type,问题显示: The import org.apache cannot be resolved.解决方法: 去 http://hc.apache.org/downloads.cgi 下载， HttpClient4.5.3.zip, 解压后得到\httpcomponents-client-4.5.3\lib, 里面有很多jar包加进来这样就好了！总结下：org.apache, 不是标准的java中的库。所以eclipse中，无法自动识别。org.apache下包括了一堆相关的库，此处用到的是org.apache.http, 所以：需要找到对应的org.apache.http相关的jar包，然后加到当前的项目中。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java获取本机外网IP]]></title>
    <url>%2F2017%2F11%2F28%2FJava%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E5%A4%96%E7%BD%91IP%2F</url>
    <content type="text"><![CDATA[一种可行的获取方法，是通过http请求从网站中取出ip字段。例如: http://ip.chinaz.com/通过这个网址，加上简单的正则表达式，即可得到123456789101112131415161718192021222324252627282930313233343536373839404142public static String getV4IP()&#123; String ip = ""; String chinaz = "http://ip.chinaz.com"; StringBuilder inputLine = new StringBuilder(); String read = ""; URL url = null; HttpURLConnection urlConnection = null; BufferedReader in = null; try &#123; url = new URL(chinaz); urlConnection = (HttpURLConnection) url.openConnection(); in = new BufferedReader( new InputStreamReader(urlConnection.getInputStream(),"UTF-8")); while((read=in.readLine())!=null)&#123; inputLine.append(read+"\r\n"); &#125; //System.out.println(inputLine.toString()); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(in!=null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; Pattern p = Pattern.compile("\\&lt;dd class\\=\"fz24\"&gt;(.*?)\\&lt;\\/dd&gt;"); Matcher m = p.matcher(inputLine.toString()); if(m.find())&#123; String ipstr = m.group(1); ip = ipstr; //System.out.println(ipstr); &#125; return ip;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CLOCK置换算法]]></title>
    <url>%2F2017%2F11%2F13%2FCLOCK%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在请求分页存储管理系统中，若为进程分配的物理块为4，开始执行时内存中没有装入任何页面，若进程依次访问的页面号为：7，1，6，4，6，2，3，0，3，1，0，7，6，0，1，3，6，3，0，7，2，0，5请用CLOCK算法完成作业(低物理地址优先)红色代表访问位为1，星号表示替换指针的位置 缺页次数: 14次缺页率: 14/23= 60.9%置换次数: 10次依次被置换的页号: 7 1 6 4 2 3 0 1 7 61234567891011121314151617181920217号页面：进程分配的物理块为4，开始执行的时候没有装入任何页面，当开始访问7号页面的时候，内存中没有该页面号，将页面直接调入内存，低物理地址优先，将页面放入第一个物理块，把访问位置为1.1、6、4号页面：访问1号页面的时候，内存中没有该页面号，且内存中还有空位，将1、6、4号页面放入内存，把访问位置为1，替换指针指向最高地址的物理块。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查4号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查4号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。7号页面：访问7号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查2号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查9号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查3号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。1号页面：访问1号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查1号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。6号页面：访问6号页面的时候，内存中有，将其访问位置为1，替换指针不动。3号页面：访问3号页面的时候，内存中有，将其访问位置为1，替换指针不动。0号页面：访问0号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查1号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。7号页面：访问7号页面的时候，内存中有，将其访问位置为1，替换指针不动。2号页面：访问2号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查7号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查6号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查3号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会；检查0号页面，访问位为1，将其置为0，暂不换出，给予该页第二次驻留内存的机会。检查到队列的最后一个页面时，访问位仍为1，返回队首检查第一个页面，发现访问位为0，则选择此页面替换，访问位置为1，替换指针指向被替换的页面。0号页面：访问0号页面的时候，内存中有，将其访问位置为1，替换指针不动。5号页面：访问5号页面的时候，内存中没有，且内存中没有空位，需要替换掉一个页面。将内存中所有的页面链成一个循环队列，从替换指针的下一位开始检查。先检查6号页面，访问位为0，选择此页面替换，访问位置为1，替换指针指向被替换的页面。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟存储器]]></title>
    <url>%2F2017%2F11%2F12%2F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1、什么是虚拟存储器？（虚存）1解答：虚拟存储器是由硬件和操作系统自动实现存储信息调度和管理的，是在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理贮存容量大的多，可寻址的“主存储器”。 2、为什么要引入虚拟存储器？12解答：1&gt;能提高操作系统的内存利用率和系统吞吐量 2&gt;在计算机系统中，主存的容量有一定的限制，不可能大大满足各种用户的需要，而在技术上辅助存储器却可以做的相当大。为了给大作业提供方便，使它们不再承担对主存和辅存的具体分配和管理工作，而由操作系统把主存和辅存统一管理起来。 3、虚拟存储器的特征？12345解答：虚拟存储器具有虚拟性、离散性、多次性及强对换性等特征，其中最重要的特征是虚拟性。1&gt; 虚拟性。虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际的内存容量，这是虚拟存储器所表现出的最重要的特征，也是虚拟存储器最重要的目标。2&gt; 离散性。离散性是指内存分配时采用离散分配的方式，没有离散性就不可能实现虚拟存储器。采用连续分配方式，需要将作业装入到连续的内存区域，这样需要连续地一次性申请一部分内存空间，以便将整个作业先后多次装入内存。如果仍然采用连续装入的方式，则无法实现虚拟存储功能，只有采用离散分配方式，才能为它申请内存空间，以避免浪费内存空间。3&gt; 多次性。多次性是指一个作业被分成多次调入内存运行。作业在运行时，只将当前运行的那部分程序和数据装入内存，以后再陆续从外存将需要的部分调入内存。4&gt; 对换性。对换性是指允许在作业运行过程中换进换出。允许将暂时不用的程序和数据从内存调至外存的对换区，以后需要时再从外存调入到内存。 4、虚存可以建立在分区分配管理的基础上吗？为什么？1解答：不可以。在虚拟存储器中，允许将一个作业分多次调入内存。入宫采用连续分配方式时，应将作业装入一个连续的内存区域中。为此，需事先为它一次性地申请足够的内存空间，以便将整个作业先后分多次装入内存，这不仅会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟存储器的实现都是建立在离散分配存储管理方式的基础上。]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生苦短]]></title>
    <url>%2F2017%2F11%2F10%2F%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%2F</url>
    <content type="text"><![CDATA[用Wireshark打开这个流量包点文件中的导出对象，选HTTP，发现其中有如下文件在010编辑器中打开，发现flagaa中有压缩包的头部，flagaf中有压缩包的尾部，猜测应该是压缩包分解成aa-af，拼凑一下，导出压缩包解压此压缩包，发现有密码先尝试用Ziperello爆破下没有加密文件，发现它是伪加密压缩包打开，得flag]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RGB]]></title>
    <url>%2F2017%2F11%2F10%2FRGB%2F</url>
    <content type="text"><![CDATA[python脚本之RGB，将其转化为图片12345678910111213141516#!/usr/bin/env pythonfrom PIL import ImageMAX = 280pic = Image.new("RGB",(MAX, MAX))file = open("flag.txt",'r')m = file.read().split('\n')i=0for y in range (0,MAX): for x in range (0,MAX): if(m[i] == '(0, 0, 0)'): pic.putpixel([x,y],(0, 0, 0)) else: pic.putpixel([x,y],(255,255,255)) i = i+1pic.show()pic.save("flag.png")]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base混合解密]]></title>
    <url>%2F2017%2F11%2F10%2Fbase%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[Base64和Base32混合解密脚本12345678910111213import base64file = open('base.txt','r')st = file.read()while True: try: st = base64.b16decode(st) except: try: st = base64.b32decode(st) except: st = base64.b64decode(st) if(st.find('flag') == 0): print(st)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware Workstation 14黑屏问题及密钥]]></title>
    <url>%2F2017%2F11%2F08%2FVMware-Workstation-14%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98%E5%8F%8A%E5%AF%86%E9%92%A5%2F</url>
    <content type="text"><![CDATA[今儿个升级VM到14，完事后打开VM，想用下kali，却发现进入黑屏，如论如何都不能解决，没办法，拜访了下度娘。首先上VM的密钥：VMware Workstation Pro 14 许可证序列号：FF590-2DX83-M81LZ-XDM7E-MKUT4CG54H-D8D0H-H8DHY-C6X7X-N2KG6ZC3WK-AFXEK-488JP-A7MQX-XL8YFAC5XK-0ZD4H-088HP-9NQZV-ZG2R4ZC5XK-A6E0M-080XQ-04ZZG-YF08DZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8 黑屏问题解决:1以管理员身份进入cmd，输入`netsh winsock reset`, 重启，问题解决 网上也有其他的解决方法，不过没试过：123以管理员身份运行命令提示符（cmd.exe），输入命令 netsh winsock show catalog可以看到VMware注册了两个LSP：vSockets DGRAM、vSockets STREAM，路径是%windir%\system32\vsocklib.dll观察有没有其他模块也注册了vSockets DGRAM、vSockets STREAM，如果有，就卸载掉这个模块所属的软件。]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example5_10]]></title>
    <url>%2F2017%2F10%2F31%2FExample5-10%2F</url>
    <content type="text"><![CDATA[写一个类，该类有一个方法，public int ff(int a, int b), 该方法返回a 和b 的最大公约数。然后再编写一个该类的子类，要求子类重写方法ff，而且重写的方法将返回a 和b 的最小公约数；要求在重写的方法的方法体中首先调用被隐藏的方法返回a 和b 的最大公约数m ，然后将乘积(a* b)/ m返回；要求在应用的程序的主类中分别使用父类和子类创建对象，并分别调用方法f 计算两个正整数的最大公约数和最小公约数。123456789101112131415161718192021222324252627282930313233class AAb&#123; public int f(int a, int b)&#123; if(b&lt; a)&#123; int temp= 0; temp= a; a= b; b= temp; &#125; int r= b% a; while(r!= 0)&#123; b= a; a= r; r= b% a; &#125; return a; &#125;&#125;class BBb extends AAb&#123; public int f(int a, int b)&#123; int division= super.f(a, b); return (a* b)/ division; &#125;&#125;public class Example5_10 &#123; public static void main(String[] args) &#123; AAb aAb= new AAb(); BBb bBb= new BBb(); System.out.println("最大公约数: "+ aAb.f(36, 24)); System.out.println("最小公倍数: "+ bBb.f(36, 24)); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example5_9]]></title>
    <url>%2F2017%2F10%2F31%2FExample5-9%2F</url>
    <content type="text"><![CDATA[写一个类Aa， 该类创建的对象可以调用方法k输出英文字母表，然后再编写一个该类的子类Bb，要求子类Bb必须继承Aa类的方法k(不允许重写)，子类创建的对象不仅可以调用方法k输出英文字母表，而且可以调用子类新增的方法g输出希腊字母表。1234567891011121314151617181920212223242526class Ab&#123; public final void k()&#123; char cStart= 'a', cEnd= 'z'; for(char c= cStart; c&lt;= cEnd; c++)&#123; System.out.print(" "+ c); &#125; &#125;&#125;class Ba extends Ab&#123; public void g()&#123; char cStart= 'α', cEnd= 'ω'; for(char c= cStart; c&lt;= cEnd; c++)&#123; System.out.print(" "+ c); &#125; &#125;&#125;public class Example5_9 &#123; public static void main(String[] args) &#123; Ba ba=new Ba(); ba.k(); System.out.println(""); ba.g(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java连接MySQL数据库]]></title>
    <url>%2F2017%2F10%2F29%2FJava%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[工具：eclipseMySQL5.5MySQL连接驱动：mysql-connector-java-5.1.44-bin.jar Java编译器是eclipse，下载mysql-connector-java-5.1.44-bin.jar，我下的是最新版。加载驱动：1、在工程目录中创建lib文件夹，将下载好的JDBC放到该文件夹下，如图所示：2、右键工程名，点击Properties 选择Java Build Path中的Libraries，点击Add JARs…, 选择刚才添加的JDBC，如下图:3、配置好MySQL，添加一个用户，用户名是style,密码是1234, 创建一个数据库, 数据库名是student。创建表： create table students( -&gt; sno int(10) not null, -&gt; sname varchar(8) not null, -&gt; sex char(2) not null, -&gt; bdate date not null, -&gt; height dec(5,2) default 000.00, -&gt; primary key(sno)); 然后插入一条数据： insert into students(sno,sname,sex,bdate,height) values(‘1’,’gfa’,’男’,’2017-10-29’,’fwef’); 创建好数据库后, 编写Java文件来访问MySQL数据库。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package sqldemo;import java.sql.*;public class mains &#123; public static void main(String[] args) &#123; //声明Connection对象 Connection con; //驱动程序名 String driver = "com.mysql.jdbc.Driver"; //URL指向要访问的数据库名student String url = "jdbc:mysql://localhost:3306/student"; //MySQL配置时的用户名 String user = "style"; //MySQL配置时的密码 String password = "1234"; //遍历查询结果集 try &#123; //加载驱动程序 Class.forName(driver); //1.getConnection()方法，连接MySQL数据库！！ con = DriverManager.getConnection(url,user,password); if(!con.isClosed()) System.out.println("Succeeded connecting to the Database!"); //2.创建statement类对象，用来执行SQL语句！！ Statement statement = con.createStatement(); //要执行的SQL语句 String sql = "select * from students"; //3.ResultSet类，用来存放获取的结果集！！ ResultSet rs = statement.executeQuery(sql); System.out.println("-----------------"); System.out.println("执行结果如下所示:"); System.out.println("-----------------"); System.out.println("姓名" + "\t" + "性别"); System.out.println("-----------------"); String job = null; String id = null; while(rs.next())&#123; //获取stuname这列数据 job = rs.getString("sname"); //获取stuid这列数据 id = rs.getString("sex"); //输出结果 System.out.println(job + "\t" + id); &#125; rs.close(); con.close(); &#125; catch(ClassNotFoundException e) &#123; //数据库驱动类异常处理 System.out.println("Sorry,can`t find the Driver!"); e.printStackTrace(); &#125; catch(SQLException e) &#123; //数据库连接失败异常处理 e.printStackTrace(); &#125;catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally&#123; System.out.println("数据库数据获取成功！"); &#125; &#125;&#125; 运行结果如图所示：]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[txt文件导入MySQL]]></title>
    <url>%2F2017%2F10%2F28%2Ftxt%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5MySQL%2F</url>
    <content type="text"><![CDATA[创建数据表 CRETE TABLE tes(NAME VARCHAR(20) NULL,SEX VARCHAR(5) NULL,STUDENTID INT(20) NULL);txt文件中的内容如下你好 男 123世界 女 456啦啦啦 男 485 中间空格部分是TAB键, 保存为UTF-8编码.导入txt文件 load data local infile ‘C:/文件名.txt’ into table 数据表名; 如果第一行开头出现特殊符号，我的解决方法是在第一行中增加一行可以删去的信息，等导入数据库后，DELETE FROM 数据库表 WHERE 字段=&#39;字段对应的唯一信息&#39;;删除第一行就行。但这只是治标不治本，希望大家能提出宝贵的建议，共同学习。 导入数据库到MySQL mysql -u root -p &lt; 数据库文件名 回车后输入数据库密码，即可导入成功。 导出数据库 mysqldump -u root -p 数据库名 &gt; 要保存的数据库文件名 回车后输入数据库密码，导出的数据库在当前目录。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地连接腾讯云MySQL]]></title>
    <url>%2F2017%2F10%2F28%2F%E6%9C%AC%E5%9C%B0%E8%BF%9E%E6%8E%A5%E8%85%BE%E8%AE%AF%E4%BA%91MySQL%2F</url>
    <content type="text"><![CDATA[在腾讯云的MySQL中先新建一个用户，用于远程登录账号。环境是centos7登录MySQL mysql -u root -p 回车后输入密码 创建用户 允许本地IP访问localhost1create user 'style'@'localhost' identified by '123456'; 用户名是style，密码是123456; 允许外网IP访问1create user 'style'@'%' identified by '123456'; 刷新授权1flush privileges; 为用户创建数据库 数据库名是student1create database student DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 为新用户分配权限 授予用户通过外网IP对于该数据库的全部权限1grant all privileges on student.* to 'style'@'%' identified by '1234'; 授予用户在本地服务器对该数据库的全部权限1grant all privileges on student.* to 'style'@'localhost' identified by '1234'; 刷新权限1flush privileges; 退出root重新登录1exit 用新账号style重新登录，由于使用的是 % 任意IP连接， 所以需要指定外部访问IP1mysql -h 腾讯云的公网IP -u用户名 -p密码 登录成功！ 查询用户权限1show grants for style 赋予权限1grant all privileges on *.* to 'style'@'%' identified by '1234'; 授予style用户在所有数据库上的所有权限 如果此时发现刚刚给的权限太大了，如果我们只想授予它在某个数据库上的权限，那么需要切换到root用户撤销刚才的权限，重新授权12revoke all privileges on *.* from 'style'@'%';grant all privileges on student.* to 'style`@'%' identified by '1234'; 甚至还可以指定该用户只能执行select和update命令1grant select, update on student.* to 'style'@'%' identified by '1234'; 这样一来，再次以style用户登录MySQL，只有student数据库是对其可见的，并且如果你只授权它select权限，那么它就不能执行delete语句 每当调整权限后，通常需要执行以下语句来刷新权限1flush privileges; 删除创建的用户1drop user style@'%'; 可用如下命令查看相应用户及对应的host1select host, user from user; MarkSown语法用的不是很好，有些符号没有显示，以下图为准]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改MySQL密码]]></title>
    <url>%2F2017%2F10%2F27%2F%E4%BF%AE%E6%94%B9MySQL%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在DOS下执行：mysql -u root -p然后输入旧的密码，如果是第一次进入，则直接回车mysql&gt;show databases;mysql&gt;use mysql;注意一定先执行use mysql;再执行下面命令设置密码，如新密码123456mysql&gt;UPDATE user SET authentication_string=PASSWORD(&#39;123456&#39;) WHERE user=&#39;root&#39;;mysql&gt;FLUSH PRIVILEGES;mysql&gt;exit; 是的，您没看错，就是authentication_string而不是password。MySQL数据库下已经没有password这个字段了，password字段改成了authentication_string。如果写成password的话，会报ERROR 1054 (42S22): Unknown column &#39;password&#39; in &#39;field list&#39;这个错误。 附上常用mysql命令(win8.1以管理员身份执行win+x+a):安装mysql服务：mysqld -install卸载mysql服务：mysqld -remove启动mysql服务：net start mysql停止mysql服务：net stop mysql 如果启动mysql服务出现1067错误码尝试清理datadir目录下的以下文件：auto.cnf、Cryhelyxx-pc.err、Cryhelyxx-pc.pid、ib_logfile0、ib_logfile1、ibdata1、ibtmp1注意：在清理之前请备份好数据库，否则后果自负，并再次启动mysql服务：net start mysql。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 安装问题]]></title>
    <url>%2F2017%2F10%2F10%2FAndroid-Studio-%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装android studio的时候，出现几个错误，在此记录下。第一个是出现这个解决方法：在自己的android studio安装目录下找到这个文件idea.properties,在最后面添加一行disable.android.first.run=true 第二个是出现这个(图是百度的==当时没保存下来)解决方法：SDK的目录名称不能有汉字，换个路径 第三个是出现这个解决方法：点击右下角的Configure点击project Defaults,点击Project Structure,填入SDK的地址 第四个是出现这个解决方法：SDK的目录不能有空格，换路径]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[super关键字]]></title>
    <url>%2F2017%2F09%2F28%2Fsuper%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[使用super调用父类的构造方法子类不继承父类的构造方法，因此，子类如果想使用父类的构造方法，必须在子类的构造方法中使用，必须使用关键字super来表示，而且super必须是子类构造方法中的头一条语句Student5_6.java1234567891011121314151617public class Student5_6 &#123; int number; String name; Student5_6()&#123; &#125; Student5_6(int number, String name)&#123; this.number= number; this.name= name; &#125; public int getNumber()&#123; return number; &#125; public String getName() &#123; return name; &#125;&#125; UniverStudent.java123456789public class UniverStudent extends Student5_6 &#123; boolean isNarriage;//子类新增的结婚属性 UniverStudent(int number, String name, boolean v)&#123; super(number, name);//调用父类的构造方法 &#125; public boolean getIsNarriage()&#123; return isNarriage; &#125;&#125; Example5_6.java123456789101112131415public class Example5_6 &#123; public static void main(String[] args) &#123; UniverStudent zhangStudent= new UniverStudent(20111, "张三", false); int number= zhangStudent.getNumber(); String name= zhangStudent.getName(); boolean marriage= zhangStudent.getIsNarriage(); System.out.println(name+ "的学号是: "+ number); if(marriage== true)&#123; System.out.println(name+ "已婚"); &#125; else &#123; System.out.println(name+ "未婚"); &#125; &#125;&#125; 使用super操作被隐藏的成员变量和方法如果在子类中想使用被子类隐藏的成员变量或方法，可以使用关键字super，super.x、super.play()，就是访问和调用被子类隐藏的成员变量x和方法play()Sum.java12345678910public class Sum &#123; int n; public double f()&#123; double sum= 0; for(int i= 1; i&lt;= n;i++)&#123; sum= sum+ i; &#125; return sum; &#125;&#125; Average.java1234567891011121314public class Average extends Sum &#123; double nm; public double fq()&#123; double c; super.n= (int)nm; c= super.f(); return c+ nm; &#125; public double g()&#123; double c; c= super.f(); return c- nm; &#125;&#125; Example5_7.java12345678910public class Example5_7 &#123; public static void main(String[] args) &#123; Average average= new Average(); average.nm= 100.5678; double result1= average.fq(); double result2= average.g(); System.out.println("result1= "+ result1); System.out.println("result2= "+ result2); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法内部类]]></title>
    <url>%2F2017%2F09%2F26%2F%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。1234567891011121314151617181920212223242526//外部类public class HelloWorld &#123; private String name = "爱慕课"; // 外部类中的show方法 public void show() &#123; // 定义方法内部类 class MInner &#123; int score = 83; public int getScore() &#123; return score + 10; &#125; &#125; // 创建方法内部类的对象 MInner mi= new MInner(); // 调用内部类的方法 int newScore= mi.getScore(); System.out.println("姓名：" + name + "\n加分后的成绩：" + newScore); &#125; // 测试方法内部类 public static void main(String[] args) &#123; // 创建外部类的对象 HelloWorld mo= new HelloWorld(); // 调用外部类的方法 mo.show(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成员内部类与静态内部类]]></title>
    <url>%2F2017%2F09%2F26%2F%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类中最常见的就是成员内部类，也称为普通内部类123456789101112131415161718192021222324252627//外部类HelloWorldpublic class HelloWorld&#123; //外部类的私有属性name private String name = "imooc"; //外部类的成员属性 int age = 20; //成员内部类Inner public class Inner &#123; String name = "爱慕课"; //内部类中的方法 public void show() &#123; System.out.println("外部类中的name：" + HelloWorld.this.name); System.out.println("内部类中的name：" + name); System.out.println("外部类中的age：" + age); &#125; &#125; //测试成员内部类 public static void main(String[] args) &#123; //创建外部类的对象 HelloWorld o = new HelloWorld (); //创建内部类的对象 Inner inn = o.new Inner(); //调用内部类对象的show方法 inn.show(); //外部类不能直接使用内部类的成员何方法，如show(); &#125;&#125; 静态内部类是static修饰的内部类，这种内部类的特点是:静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员； 如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();123456789101112131415161718192021//外部类public class HelloWorld &#123; // 外部类中的静态变量score private static int score = 84; // 创建静态内部类 public static class SInner &#123; // 内部类中的变量score int score = 91; public void show() &#123; System.out.println("访问外部类中的score：" + HelloWorld.score); System.out.println("访问内部类中的score：" + score); &#125; &#125; // 测试静态内部类 public static void main(String[] args) &#123; // 直接创建内部类的对象 SInner si= new SInner(); // 调用show方法 si.show(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2017%2F09%2F26%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类内部类的方法可以直接访问外部类的所有数据，包括私有的数据内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便内部类分为：成员内部类、静态内部类、方法内部类、匿名内部类1234567891011121314151617public class neibulei &#123; //内部类Inner，类Inner在类neibulei的内部 public class Inner&#123; //内部类的方法 public void show()&#123; System.out.println("Hello World!"); &#125; &#125; public static void main(String[] args)&#123; //创建外部类对象 neibulei neibulei= new neibulei(); //创建内部类对象 Inner inner= neibulei.new Inner(); //调用内部类对象的方法 inner.show(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可变参数]]></title>
    <url>%2F2017%2F09%2F26%2F%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[x是可变参数的代表，代表若干哥int型参数x.length是x代表的参数的个数x[i]是x代表的第i个参数(类似数组)123456789101112public class Example4_11 &#123; public static void main(String[] args) &#123; f(1,2); f(-1, -2, -3, -4); f(9, 7, 6); &#125; public static void f(int ... x)&#123; for(int i=0; i&lt; x.length; i++)&#123; System.out.println(x[i]); &#125; &#125;&#125; 上面的方法输出的是一个数字一行，觉得不好看，改版如下print输出不换行，println输出换行12345678910111213public class Example4_11 &#123; public static void main(String[] args) &#123; f(1,2); f(-1, -2, -3, -4); f(9, 7, 6); &#125; public static void f(int ... x)&#123; for(int i=0; i&lt; x.length-1; i++)&#123; System.out.print(x[i]); &#125; System.out.println(x[x.length-1]); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static]]></title>
    <url>%2F2017%2F09%2F26%2Fstatic%2F</url>
    <content type="text"><![CDATA[static存在的时候，调用b2.setN(5)，sum=6，去掉static，sum从0开始123456789101112131415161718192021222324252627class B&#123; int n; static int sum= 0; void setN(int n)&#123; this.n= n; System.out.println("this.n= "+ this.n); &#125; int getSum()&#123; for(int i= 1;i&lt;= n; i++)&#123; sum= sum+ i; &#125; System.out.println(sum); return sum; &#125; &#125;public class Example4_9 &#123; public static void main(String[] args) &#123; B b1=new B(), b2= new B(); b1.setN(3); b2.setN(5); int a1= b1.getSum(); int a2= b2.getSum(); System.out.println(a1+ a2); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[enum问题]]></title>
    <url>%2F2017%2F09%2F23%2Fenum%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天有个想法，是输出每个月的天数，正好最近学了enum，就想用这个来做。 &lt;!--more--&gt; 说干就干，啪啪啪啪...咦~有个错误，我改我改我改！ 然而改了多次，还是没成功，最后根据错误提示问了下度娘，说是格式有误。 我就想，是不是不能重复内容，我改我改，改到enum里面的内容只有两位31，30，还真是！ 但还是有相同的错误，又想了想，前面加上月份呢？ 啪！问题解决123456789101112enum Tian&#123; 一月31天, 二月28天, 三月31天, 四月30天, 五月31天, 六月30天, 七月31天, 八月31天, 九月30天, 十月31天, 十一月30天, 十二月31天&#125;public class Java &#123; public static void main(String[] args) &#123; for(Tian a: Tian.values())&#123; System.out.println(a); &#125; &#125;&#125; 总结: enum中的内容不能重复，enum中的内容不能只是数字,不然会出现Syntax error on token(s), misplaced constructs(s)这个错误]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse快捷键]]></title>
    <url>%2F2017%2F09%2F23%2Feclipse%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[eclipse常用快捷键12345678910Syso+alt+/ 快速输出代码Ctrl+shift+f 快速调整代码格式Ctrl+D 快速删除光标所在的行shift+回车 当输入代码较长的时候换行ctrl+F11 运行Alt+上下箭头 快速移动光标所在的行代码Ctrl+alt+上下箭头 快速复制光标所在行代码Alt+/ 快速补全代码Ctrl+/ 快速添加单行注释Ctrl+shift+/ 添加多行注释 小常识 打开eclipse，在上方的菜单栏中找到Window选中Preferences，点击Java–&gt;Editor–&gt;Content在红框中输入下面一行字符串，点击OK，退出。1.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 输入这一串，敲代码的时候可以智能提示 包的命名规则123456**.**(对应项目的名字).**（项目功能）com 公司 org 组织model 模型util 工具edu 教育]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小型通讯录]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%B0%8F%E5%9E%8B%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[定义Friend类，编写它具有的属性：姓名(name)、电话(phone)、邮箱(email)和公司(comp)以及它的方法showInfo()。编写测试类AddFriend，实现添加联系人的功能(从键盘输入)1234567891011121314151617181920212223242526272829303132//AddFriend.javaimport java.util.Scanner;public class AddFried &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Friend friend= new Friend(); Scanner inputScanner= new Scanner(System.in); System.out.println("请输入联系人姓名: "); friend.setName(inputScanner.next()); System.out.println("请输入联系人电话: "); friend.setPhone(inputScanner.next()); System.out.println("请输入联系人电子邮箱: "); friend.setEmail(inputScanner.next()); System.out.println("请输入联系人公司: "); friend.setComp(inputScanner.next()); friend.showInfo(); // friend.name= "花千骨";// friend.showInfo(); /* * 没有封装，将String name等四个变量封装为private就行 * 封装：把不想或不该告诉别人的事情隐藏起来 * 具体做法：将属性私有化，提供公有化的方法来访问属性 * */ inputScanner.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940//Friend.javapublic class Friend &#123; String name;// 默认private String phone; String email; String comp; public void setName(String name) &#123; this.name= name;// 访问本类中的属性和方法 &#125; public String getName()&#123; return name; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getComp() &#123; return comp; &#125; public void setComp(String comp) &#123; this.comp = comp; &#125; public void showInfo()&#123; System.out.println("新朋友的联系信息为: "); System.out.println("姓名: "+ this.getName()); System.out.println("电话: "+ this.getPhone()); System.out.println("电子邮箱: "+ this.getEmail()); System.out.println("公司: "+ this.hashCode()); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[竞猜商品]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%AB%9E%E7%8C%9C%E5%95%86%E5%93%81%2F</url>
    <content type="text"><![CDATA[电视商品价格竞猜活动， 活动规则是：随机出现一个商品名，用户猜测它的价格，连续猜测5次，如果猜对便可获得此商品提示：(1)定义GuessMachine，编写它的initial方法，预定义商品信息根据产生的随机数字，选定一款竞猜商品(2)编写GuessMachine的guess方法，如果猜测正确，返回“猜对了，恭喜中奖！”，价格偏高，提示高了，偏低，提示低了。(3)编写测试类模拟竞猜，产生随机数 Math.radom();只产生0.0~1.0之间的数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//GuessMachineimport java.util.Scanner;public class GuessMachine &#123; String mach= null; int price= 0; public void initial()&#123; int data= (int)(Math.random()* 4); switch(data)&#123; case 0: mach= "电视机"; price= 3359; break; case 1: mach= "电冰箱"; price= 1243; break; case 2: mach= "油烟机"; price= 4654; break; case 3: mach= "ipthone"; price= 2324; break; case 4: mach= "洗衣机"; price= 5643; break; default: break; &#125;// System.out.println(data);// System.out.println("请输出"+ mach+ "的价格: "); &#125; public void guess() &#123; Scanner inpScanner= new Scanner(System.in); int guess= 0;//用户输入的价格 int i= 0;//用户猜价格的次数 while(i&lt; 5)&#123; System.out.println("请输入您竞猜的价格: "); guess= inpScanner.nextInt(); if(price== guess)&#123; System.out.println("猜对了，恭喜中奖！"); &#125;else if(price&gt; guess) &#123; System.out.println("低了，请高一点。"); &#125;else if (price&lt; guess) &#123; System.out.println("高了， 请低一点。"); &#125; i++; &#125; if(i&gt;= 5)&#123; System.out.println("您已经猜奖5次，欢迎下次光临！"); &#125; inpScanner.close(); &#125; &#125; 123456789101112//Test.javapackage com.cnstrong.com;public class Test &#123; public static void main(String[] args)&#123; GuessMachine gMachine= new GuessMachine(); gMachine.initial();//初始化 gMachine.guess(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base32解密]]></title>
    <url>%2F2017%2F09%2F23%2Fbase32%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[运行环境python2.712import base64print base64.b32decode("NNSXS63JONRWGY3GOJTGO5DBMVTGCZ3SNB2H2===")]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列置换]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%88%97%E7%BD%AE%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[运行环境python2.7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#!usr/bin/env python#-*- coding:utf-8 -*-from itertools import *from optparse import *def start(): opt = OptionParser() opt.add_option('-c',dest='content',help='Input your content') opt.add_option('-o',dest='output',help='File to save the result') get,args = opt.parse_args() if get.content is None or get.output is None: print 'Use \'help\' to get help' exit(0) return get.content,get.outputdef Exp(content,output): for i in range(2,len(content)): if len(content)%i == 0: filename = open(output,'a+') getList = Code(i) getCo = SplitStr(i,content) for num in getList: get = '' for s in getCo: for one in num: get = get + s[int(one):int(one)+1] filename.write(get+'\n') filename.close() print 'The result is saved as ' + outputdef SplitStr(num,content): result = [] for i in range(len(content)/num): result.append(content[i*num:(i+1)*num]) return resultdef Code(num): number = '' result = [] for i in range(num): number = number + str(i) for i in permutations(number,num): result.append(i) return resultdef main(): content,output = start() Exp(content,output)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大小写转换]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[运行环境python31234567891011121314151617181920def UCaseChar(ch): if ord(ch) in range(97, 122): return chr(ord(ch) - 32) else: return ch def LCaseChar(ch): if ord(ch) in range(65, 91): return chr(ord(ch) + 32) else: return ch def UCase(str): return ''.join(map(UCaseChar, str)) def LCase(str): return ''.join(map(LCaseChar, str)) print (LCase('ABC我abc')) print (UCase('ABC我abc'))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移位]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%A7%BB%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[运行环境python2.7123456789key='CRL'.upper()for i in range(0,26): flag='' for j in key: if j.isalpha(): flag+=chr(((ord(j)-ord('A')+i)%26)+ord('A')) else: flag+=j print str(i).zfill(2),flag]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串转莫尔斯]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E8%8E%AB%E5%B0%94%E6%96%AF%2F</url>
    <content type="text"><![CDATA[运行环境python3123456789101112131415161718192021222324252627CODE = &#123;'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' &#125;def main(): msg = input('MESSAGE: ') for char in msg: if char == ' ': print else: print (CODE[char.upper()] + ' ',)if __name__ == "__main__": main()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转换字符串为莫尔斯]]></title>
    <url>%2F2017%2F09%2F23%2F%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BA%E8%8E%AB%E5%B0%94%E6%96%AF%2F</url>
    <content type="text"><![CDATA[请在python3环境下运行12345678chars = ",.0123456789?abcdefghijklmnopqrstuvwxyz"codes = """--..-- .-.-.- ----- .---- ..--- ...-- ....- ..... -.... --... ---.. ----. ..--.. .- -... -.-. -... . ..-. --. .... .. .--- -.- .-.. -- -. --- .--. --.- .-. ... - ..- ...- .-- -..- -.-- --.."""keys = dict(zip(chars, codes.split()))def char2morse(char): return keys.get(char.lower(), char)print (' '.join(char2morse(c) for c in 'SOS'))]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[维吉尼亚]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%2F</url>
    <content type="text"><![CDATA[运行环境python312345678910111213141516171819key='helloworld'plaintext='whereisthekey'#key='relations'#plaintext='tobeornottobeth' ascii='abcdefghijklmnopqrstuvwxyz'keylen=len(key)ptlen=len(plaintext)ciphertext = ''i = 0while i &lt; ptlen: j = i % keylen k = ascii.index(key[j]) m = ascii.index(plaintext[i]) ciphertext += ascii[(m+k)%26] i += 1 print (ciphertext)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n次base64解密]]></title>
    <url>%2F2017%2F09%2F23%2Fn%E6%AC%A1base64%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[运行环境python31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import base64str = '''Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSWFJteFZVMjA1VjAxV2JETlhhMk0xVmpKS1NHVkVRbUZXVmxsM1ZtcEJlRll5U2tWVWJHaG9UVlZ3VlZacVFtRlRNbEpJVm10a1dHSkdjSEJXYTFwaFpWWmFkRTFVVWxSTmF6RTFWa2QwYzJGc1NuUmhSemxWVmpOT00xcFZXbUZrUjA1R1drWlNUbUpGY0VwV2JURXdZVEZrU0ZOclpHcFNWR3hoV1d4U1IyUnNXbGRYYlhSWFRWaENSbFpYZUhkV01ERkZVbFJDVjAxdVVuWldha3BIVmpGT2RWVnNXbWhsYlhob1ZtMXdUMkl5UmtkalJtUllZbGhTV0ZSV2FFTlNiRnBZWlVoa1YwMUVSa1pWYkZKRFZqSkdjbUV6YUZaaGExcG9WakJhVDJOdFJrZFhiV2hzWWxob2IxWnRNWGRVTVZWNVVtdGtWMWRIYUZsWmJGWmhZMVphZEdONlJteFNiSEJaV2xWb2ExWXdNVVZTYTFwV1lrWktSRlpxU2tabFZsSlpZVVprVTFKV2NIbFdWRUpoVkRKT2MyTkZhR3BTYkVwVVZteG9RMWRzV25KWGJHUmFWakZHTkZaSGRHdFdiVXBIVjJ4U1dtSkhhRlJXTUZwVFZqRmtkRkp0ZUZkaVZrbzFWbXBLTkZReFdsaFRiRnBxVWxkU1lWUlZXbmRsYkZweFVtMUdUMkpGV2xwWlZWcHJWVEZLVjJOSWJGZFdSVXBvVmtSS1QyUkdTbkphUm1ocFZqTm9WVmRXVWs5Uk1XUkhWMjVTVGxaRlNsaFVWbVEwVjBaYVdHUkhkRmhTTUhCSlZsZDRjMWR0U2toaFJsSlhUVVp3VkZacVNrZFNiRkp6Vlcxc1UwMHhSalpXYWtvd1ZURlZlRmR1U2s1WFJYQnhWVzB4YjFZeFVsaE9WemxzWWtad2VGVnRNVWRVTWtwR1YyeHdXbFpXY0hKV1ZFWkxWMVpHY21KR1pHbFhSVXBKVm10U1MxVXhXWGhXYmxaV1lsaENWRmxyVm5kV1ZscDBaVWM1VWsxWFVucFdNV2h2VjBkS1JrNVdVbFZXTTJoSVZHdGFjMk5zWkhSa1IyaHBVbGhCZDFkV1ZtOVVNVnAwVTJ4V1YyRXhTbUZhVjNSaFYwWndSbFpZYUZkTlZrcDVWR3hhVDJGV1NuUlBWRTVYVFc1b1dGbHFTa1psUm1SWldrVTFWMVpzY0ZWWFZsSkhaREZrUjJKSVRtaFNlbXhQVkZaYWQyVkdWblJsU0dScFVqQndWMVl5ZEhkV01ERnhVbXRvVjFaRldreFdNVnBIWTIxS1IxcEdaRTVOUlhCS1ZtMTBVMU14VlhoWFdHaGhVMFphVmxscldrdGpSbHB4VkcwNWEySkhVbnBYYTFKVFYyeFpkMkpFVWxkTmFsWlVWa2Q0WVZKc1RuTmhSbkJZVTBWS1NWWnFRbUZXYlZaWVZXdG9hMUp0YUZSWmJGcExVMnhrVjFadFJtcE5WMUl3Vld4b2MyRkdTbGRUYlVaaFZqTlNhRmxWV25OT2JFcHpXa2R3YVZORlNrbFdiR040WXpGVmQwMUliR2hTYlhoWVdXeG9RMVJHVW5KYVJWcHNVbTFTZWxsVldsTmhSVEZ6VTI1b1YxWjZSVEJhUkVaclVqSktTVlJ0YUZObGJYaFFWa1phWVdReVZrZFdibEpPVmxkU1YxUlhkSGRXTVd4eVZXMUdXRkl3VmpSWk1HaExWMnhhV0ZWclpHRldWMUpRVldwS1MxSXlSa2hoUlRWWFltdEtNbFp0TVRCVk1VMTRWVzVTVjJKSFVsVlpiWFIzWWpGV2NWTnRPVmRTYlhoYVdUQmFhMkV3TVZkalJteGhWbGROTVZaWGMzaGpNVTUxWTBaa1RtRnNXbFZXYTJRMFV6RktjMXBJVmxSaVJscFlXV3RhZG1Wc1drZFdiVVphVmpGS1IxUnNXbUZWUmxsNVlVaENWbUpIYUVSVWJYaHJWbFpHZEZKdGNFNVdNVWwzVmxkNGIyTXlSa2RUYkdSVVlsVmFWbFp1Y0Zka2JGcHlWMjFHYWxacmNEQmFSV1F3VlRKRmVsRllaRmhpUmxwb1dWUktSMVl4VG5OYVIyaE9UV3hLV1ZkWGVHOVJNVTE0WTBaYVdHRXpRbk5WYlRGVFpXeHNWbGRzVG1oV2EzQXhWVmMxYjFZeFdYcGhTRXBYVmtWYWVsWnFSbGRqTVdSellVZG9UazFWY0RKV2JHTjRUa2RSZVZaclpGZGlSMUp2Vlc1d2MySXhVbGRYYm1Sc1ZteHNOVlJzYUd0V01rcEhZa1JhV2xaV1NsQldNakZHWlZaV2NscEhSbGRXTVVwUlZsUkNWazVXV1hsU2EyaG9VbFJXV0ZsdGRFdE5iRnAwVFZSQ1ZrMVZNVFJXVnpWVFZqSktTRlZzV2xwaVdGSXpXV3BHVjJOV1RuUlBWbVJUWWxob1lWZFVRbUZoTVZwelUyNU9hbEp0ZUZaV2JGcExVMFphV0dNemFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRmxVUms5U01WcDFWR3hvYVZKc2NGbFhWM1JoWkRGa1YxZHJhR3hTTUZwaFZtcEdTMUl4VW5OWGJVWldVbXhzTlZsVldsTldNa1Y0VjJ0MFZWWnNjSEpaZWtaaFpFVTVWMVpyTlZkaWEwWXpWbXhqZDAxV1RYaFZXR2hZWW1zMVZWbHNWbUZXYkZwMFpVaGtUazFXY0hsV01qRkhZV3hhY21ORVJsaGhNWEJRVmtkNFlXTnRUa1ZYYkdST1lteEtlVmRZY0VkV2JWWlhWRzVXVkdKRk5XOVpXSEJYVjFaa1YxVnJaR3ROYTFwSVdXdGFiMkZ0Vm5KWGJHaFZWbTFTVkZZeWVHdGpiRnBWVW14b1UyRXpRbUZXVm1NeFlqRlplRmRxV2xKWFIyaFhWbXRXWVdWc1duRlNiWFJyVm14S01GVnRlRTloUjFaelYyeGtWMkpIVGpSVWEyUlNaVlphY2xwR1pGaFNNMmg1Vmxkd1ExbFhUa2RXYmxKc1UwZFNjMWxyV2xkT1ZsSnpXWHBXVjAxRVJsaFphMUpoVjJ4YVYyTklXbGROYm1ob1ZtcEdZV05XVm5OYVJUVlhZbXRLU2xZeGFIZFNNVmw1VkZoc1UyRXlhSEJWYlhNeFkwWnNWVkZ1WkU1aVJuQXdXbFZqTldFd01WWk5WRkpYWWtkb2RsWXdXbXRUUjBaSFlVWndhVmRIYUc5V2JURTBZekpPYzFwSVZtRlNNMEpVV1d0YWQwNUdXbGhOVkVKT1VteHNORll5TlZOV2JVcElaVWRvVm1KSFVsUlZNRnBoWTFaT2NscEZPV2xTV0VJMlZtdGtORmxXVlhsVGExcFlWMGhDV0Zac1duZFNNVkY0VjJ0T1ZtSkZTbFpVVlZGM1VGRTlQUT09'''for i in range(1,16): str = base64.b64decode(str)print (str)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相册]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[老规矩，先贴上index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;精品相册1&lt;/title&gt; &lt;link rel="stylesheet" href="css/img_style.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="picList"&gt; &lt;!--&lt;div id="Left"&gt;&lt;/div&gt;--&gt; &lt;span&gt;&lt;img src="img/main/1.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/2.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/3.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/4.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/5.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/6.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/7.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/8.jpg"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/main/9.jpg"/&gt;&lt;/span&gt; &lt;!--&lt;div id="Right"&gt;&lt;/div&gt;--&gt; &lt;/div&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：添加挡板 --&gt; &lt;div id="pan"&gt;&lt;/div&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：显示特效图片的位置 包含图片以及按钮 --&gt; &lt;div id="show"&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：中间显示图片容器的位置 --&gt; &lt;div id="showimage"&gt; &lt;span&gt;&lt;img src="img/show/0/1.jpg" title="1"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/2.jpg" title="2"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/3.jpg" title="3"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/4.jpg" title="4"/&gt;&lt;/span&gt; &lt;span&gt;&lt;img src="img/show/0/5.jpg" title="5"/&gt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：切换图片的按钮 --&gt; &lt;span id="pre"&gt; &lt;p&gt;&lt;&lt;/p&gt;&lt;/span&gt; &lt;span id="next"&gt;&lt;p&gt;&gt;&lt;/p&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-08-11 描述：导入js文件 --&gt; &lt;script type="text/javascript" src="js/jquery-1.11.3.js" &gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; //点击每一张图片容器的时候 $("#picList span").click(function()&#123; //获取showimage中的所有img标签 var $img = $("#showimage img"); //获取点击的那一个图片 //$(this).index();返回指定元素在相对应的集合中下标的位置 var index = $(this).index();//0 for(var i=0;i&lt;5;i++)&#123; //获取图片路径 //img/show/0/1.jpg var url="img/show/"+index+"/"+(i+1)+".jpg"; //更换图片 $img.eq(i).attr("src",url); &#125; //让特效显示 //淡入效果、600毫秒的执行时间 $("#pan").fadeIn(600); $("#show").fadeIn(600).show(); &#125;); //点击挡板的事件，让特效消失 $("#pan").click(function()&#123; //淡出的效果 $("#pan").fadeOut(600); $("#show").fadeOut(600); &#125;); //点击下一张按钮 $("#next").click(function()&#123; //索引到最后 一张图片 $("#showimage span:last-child").animate( &#123;left:"680px"&#125;,500,function()&#123; $(this).animate(&#123;left:"0px"&#125;,500); //更换位置 //将指定的元素，插入到当前集合中的开头位置 $("#showimage").prepend(this); &#125;); &#125;); //点击上一张按钮 $("#pre").click(function()&#123; //索引到第一张图片 $("#showimage span:first-child").animate( &#123;left:"-680px"&#125;,500,function()&#123; $(this).animate(&#123;left:"0px"&#125;,500); //更换位置 //将指定的元素，插入到当前集合中的结尾位置 $("#showimage").append(this); &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/html&gt; /img目录下的图片放在ghthub /js目录下的jquery-1.11.3.js /css目录下的img_style.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109*&#123; margin: 0; padding: 0; &#125;/*添加背景*/body&#123; background: url(../img/bg.jpg); /*隐藏滚动栏*/ overflow: hidden;&#125;#picList&#123; width: 750px; height: 600px; /*margin:第一个上下距离 第二个左右距离 auto 自适应*/ margin: 100px auto;&#125;img&#123; width: 230px; height: 160px; padding: 5px; margin: auto auto;&#125;/*行内元素不支持宽高的设置*/span&#123; background-color: #FFFFFF; width: 240px; height: 170px; /*把行内元素改变成块元素，支持宽高的设置*/ display: block; float: left; margin: 5px; /*加入外阴影*/ box-shadow: 0px 0px 20px #FFFFFF;&#125;/*遮光挡板*/#pan&#123; position: absolute; left: 0px; top: 0px; width: 100%; height: 100%; /*前三个参数：设置颜色编码 第四个参数：设置透明度*/ background: rgba(0,0,0,0.8); /*设置默认隐藏*/ display: none;&#125;#showimage&#123; /*设置中间容器的显示位置*/ position: absolute; top: 150px; left: 50%; margin-left: -330px; /*设置层级显示关系*/ z-index: 10;&#125;/*设置每一张大图的容器边框*//*派生选择器控制绝对路径的属性*/#showimage span&#123; width: 650px; height: 440px; background: #FFFFFF; box-shadow: 0px 0px 0px #FFFFFF; position: absolute; &#125;#showimage img&#123; width: 640px; height: 430px;&#125;#show p&#123; color: white; font-size: 60px; text-align: center; margin-top: -5px; /*设置粗体*/ font-weight: bold;&#125;/*上一张图片的按钮*/#pre&#123; position: absolute; width: 50px; height: 80px; top: 320px; left: 10%; background: rgba(0,0,0,0.5); /*设置圆角*/ border-radius: 10px; z-index: 20px;&#125;#next&#123; position: absolute; width: 50px; height: 80px; top: 320px; right: 10%; background: rgba(0,0,0,0.5); /*设置圆角*/ border-radius: 10px; z-index: 20px;&#125;/*让这个显示特效的区域隐藏*/#show&#123; display: none;&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打砖块]]></title>
    <url>%2F2017%2F09%2F22%2F%E6%89%93%E7%A0%96%E5%9D%97%2F</url>
    <content type="text"><![CDATA[style在北京实训的时候，跟着培训老师做的一个小游戏，有不足之处请指教！先放上index.html 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;打砖块游戏&lt;/title&gt; &lt;link rel="stylesheet" href="css/new_file.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-07-12 描述：创建一个画布 --&gt; &lt;canvas id="gameCanvas" width="1024px" height="768px"&gt;&lt;/canvas&gt; &lt;audio id="bgmp3" src="img/happy.mp3" autoplay="autoplay"&gt;&lt;/audio&gt; &lt;audio id="breakermp3" src="img/bucket1.mp3"&gt;&lt;/audio&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-07-13 描述：得分 --&gt; &lt;span id="kuangjia"&gt;&lt;p id="p_number"&gt;得分:0&lt;/p&gt;&lt;/span&gt; &lt;img id="start_game" src="img/image/4.png" onclick="Start_game()" /&gt; &lt;!-- 作者：sunstady@gmail.com 时间：2017-07-12 描述：导入js文件 --&gt; &lt;script type="text/javascript" src="js/game_style.js" &gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; /img目录下的的图片和音频在github /js目录下的game_style.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243window.onload = init;//小括号写不写都行//window.onload = init();window.onmousemove = mouseMoveHandler;//获取鼠标移动的属性//画板设置成全局变量var canvas;//画笔设置成全局变量var context;var gamebg;//背景var board;//挡板var ball;//小球//挡板的坐标var boardY = 650;var boardX = 0;var it = 0;//定义画布的宽高var cW = 1024;var cH = 768;//设置小球的初始化坐标var ballX = 400;var ballY = 500;//定义小球XY轴的速度var vx = 8;var vy = -8;//定义一个数组用于存储砖块var Breaders;var breakermp3;//得分var score = 0;var p;var Tick;//游戏入口function init()&#123; //方法的调用 log("进入游戏中..."); //找到画布 canvas = document.getElementById("gameCanvas"); //找到声音控件 breakermp3 = document.getElementById("breakermp3"); //找到得分文字 p = document.getElementById("p_number"); //相当于画笔 context = canvas.getContext("2d");// gamebg = new Image();//创建一个image对象，用于加载图片// gamebg.src="img/image/bg.png";// //三个参数：第一个绘制的对象；第二个第三个绘制的起始坐标；// context.drawImage(gamebg,0,0); gamebg = AddImg("img/image/bg.png"); board = AddImg("img/image/board.png"); ball = AddImg("img/image/ball.png"); createrBreaders();//创建砖块 //删除数组中的参数 //Breaders.splice(0,1); //调用刷新机制 Tick = setInterval(gameTick,1000/60);//一秒刷新60次,1000毫秒等于1秒&#125;//创建一个刷新界面的方法function gameTick()&#123; log("刷新次数:"+(it++)); //清空当前屏幕 cleanScreen();//调用清空屏幕的方法 //绘制背景 context.drawImage(gamebg,0,0); //绘制的挡板 context.drawImage(board,boardX,boardY); //刷新砖块 updateBreaker(); //调用刷新小球位置 updateBall(); //调用检查碰撞 TextBallandBoread(); //调用检查小球与砖块碰撞 TextBallandBreaker();&#125;//检查小球跟砖块的碰撞function TextBallandBreaker()&#123; for(var i = Breaders.length-1;i&gt;=0 ;i--)&#123; var item = Breaders[i];//先提取最后一个 var hit = hitTextpoint(item.x,item.y,200,66,(ballX+ball.width/2),ballY); if(hit)&#123; breakermp3.play(); Breaders.splice(i,1); vy *= -1; p.innerText = "得分:"+(++score); if(score&gt;=25)&#123; RestartandClean(); &#125; &#125; &#125;&#125;//重新开始游戏的方法function Start_game()&#123; window.location.reload();//让界面重新刷新&#125;//游戏结束，清空屏幕function RestartandClean()&#123; clearInterval(Tick); cleanScreen(); context.drawImage(gamebg,0,0); var gamestart = document.getElementById("start_game"); gamestart.style.display = "block";//游戏结束，出现砖块&#125;//检查小球跟挡板的碰撞function TextBallandBoread()&#123; var hit = hitTextpoint(boardX-ball.width,boardY-ball.height,board.width+ball.width,board.height+ball.height,ballX,ballY); if(hit)&#123; ballY = boardY-ball.height; vy *= -1;//取反 &#125;else&#123; &#125;&#125;//碰撞满足的条件//x1、y1障碍物的坐标//w1、h1障碍物的宽高//x2、y2小球的坐标function hitTextpoint(x1,y1,w1,h1,x2,y2)&#123; if(x2&gt;=x1&amp;&amp;x2&lt;=x1+w1&amp;&amp;y2&gt;y1&amp;&amp;y2&lt;=y1+h1)&#123; return true; &#125;else&#123; return false; &#125;&#125;//刷新砖块function updateBreaker()&#123; //循环提取数组中的砖块 for(var i = 0; i&lt; Breaders.length; i++)&#123; var items = Breaders[i]; context.drawImage(items.bimg,items.x,items.y); &#125;&#125;//创建砖块function createrBreaders()&#123; Breaders = new Array(); for(var j=0; j&lt;5; j++)&#123; for(var i = 0; i &lt; 5; i++)&#123; var item = AddImg("img/image/"+(4+j)+".png"); //item.x = 20+200*i; //item.y = 100+70*j; Breaders.push(&#123; bimg:item, x: 20 + 200 * i, y: 100 + 72 * j &#125;); &#125; &#125; &#125;//小球位置刷新的方法function updateBall()&#123; ballX += vx; ballY += vy; log("小球的坐标为:X"+ballX+",Y轴坐标:"+ballY); //上边 if(ballY&lt;=80)&#123; ballY = 80; vy *= -1; &#125; //下方 if(ballY&gt;=cH)&#123;// ballY = cH - ball.height;// vy *= -1; log("游戏结束。。。"); RestartandClean(); &#125; //右边 if(ballX&gt;=cW - ball.width)&#123; ballX = cW -ball.width; vx *= -1; &#125; //左边 if(ballX&lt;=0)&#123; ballX = 0; vx *= -1; &#125; //绘制小球 context.drawImage(ball,ballX,ballY);&#125;//鼠标滑动触发的事件function mouseMoveHandler(e)&#123; //获取鼠标的X轴的数值 //将中心点设置为挡板的中心 boardX = e.x - board.width/2; //判断挡板不超出左边屏幕 if(e.x&lt;=0+board.width/2)&#123; boardX = 0; &#125; //判断挡板不超出右边屏幕 if(e.x&gt;cW - board.width/2)&#123; boardX = cW - board.width; &#125;&#125;//创建一个清空屏幕的方法function cleanScreen()&#123; /* * 第一个参数：X 坐标 * 第二个参数：Y 坐标 * 第三个参数：画板的宽度 * 第四个参数：画板的高度 * */ context.clearRect(0,0,cW,cH);&#125;//加载图片的方法 url 图片的路径function AddImg(url)&#123; var img = new Image();//创建一个Image对象 img.src = url; return img;&#125;//后台控制面板游戏进度数据输出function log(msg)&#123; //打印到控制台 console.log(msg);&#125; /css目录下的new_file.css 123456789101112131415161718192021222324#p_number&#123; /*设置绝对定位*/ position: absolute; left: 10px; top: -15px; font-size: 20px; padding: 5px; border-radius:5px;&#125;#kuangjia&#123; position: absolute; left: 100px; top: 20px; background: orange; width: 100px; height: 50px; border-radius:5px;&#125;#start_game&#123; position: absolute; top: 400px; left:300px; display: none;&#125;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this用法(二)]]></title>
    <url>%2F2017%2F09%2F22%2FJava%E4%B8%ADthis%E7%94%A8%E6%B3%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[/* 关键字this： 1，在普通方法中，关键字this代表方法的调用者，即本次调用了该方法的对象 2，在构造方法中，关键字this代表了该方法本次运行所创建的那个新对象 */12345678910111213141516171819202122232425262728class A&#123; private int i; public A(int i) &#123; this.i = i; //将形参 i 赋给该构造方法本次运行所创建的那个新对象的i数据成员 &#125; public void show()&#123; System.out.println("i = " + this.i); //this表示当前时刻正在调用show方法的对象 //this可以省略 &#125; public void show1()&#123; System.out.println("i = " + i); //this表示当前时刻正在调用show方法的对象 //this可以省略 &#125;&#125;public class TestThis &#123; public static void main(String[] args)&#123; A aa1 = new A(100); aa1.show(); A aa2 = new A(300); aa2.show1(); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this用法(一)]]></title>
    <url>%2F2017%2F09%2F22%2FJava%E4%B8%ADthis%E7%94%A8%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[/* 作为参数传递 需要在某些完全分离的类中调用一个方法，并将当前对象的一个引用作为参数传递时 */12345678910111213141516171819202122232425262728public class Demo &#123; public static void main(String[] args) &#123; B b = new B(new AB()); System.out.println(b); &#125;&#125;class AB&#123; public AB()&#123; new B(this).print(); // 匿名对象 /*匿名对象就是没有名字的对象。 * 如果对象只使用一次，就可以作为匿名对象，代码中 new B(this).print(); * 等价于 ( new B(this) ).print();， * 先通过 new B(this) 创建一个没有名字的对象，再调用它的方法。*/ &#125; public void print()&#123; System.out.println("Hello from A!"); &#125;&#125;class B&#123; AB a; public B(AB a)&#123; this.a = a; &#125; public void print() &#123; a.print(); System.out.println("Hello from B!"); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断输入的字符串是否为数字]]></title>
    <url>%2F2017%2F09%2F21%2F%E5%88%A4%E6%96%AD%E8%BE%93%E5%85%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[传入的str1包含中文、负数,位数很长的数字的字符串也能正常匹配12345678910111213141516171819202122232425262728293031import java.math.BigDecimal;import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern;public class jisuanqiceshi &#123; public static void main(String[] args) &#123; Scanner str1= new Scanner(System.in); System.out.println("请输入您要判断的字符串: "); String str2 = str1.next(); System.out.println(isNumeric(str2)); str1.close(); &#125; //用正则表达式判断字符串是否为数字（含负数） public static boolean isNumeric(String str) &#123; String regEx = "-?[0-9]+\\.?[0-9]*"; Pattern pat = Pattern.compile(regEx); try&#123; regEx= new BigDecimal(str).toString(); &#125; catch (Exception e)&#123; return false;//异常 说明包含非数字 &#125; Matcher mat = pat.matcher(str); if (mat.find()) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 多组输入试过，没成功，希望大家多多指教！]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_9]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-9%2F</url>
    <content type="text"><![CDATA[求满足1+ 2!+ 3!+ ... +n!&lt;= 9999的最大整数N12345678910111213141516public class Example3_9 &#123; public static void main(String[] args) &#123; int n= 1; long sum= 0, t= 1; t= n* t; while(true)&#123; sum= sum+ t; if(sum&gt; 9999)&#123; break; &#125; n++; t= n* t; &#125; System.out.println("满足条件的最大整数："+ (n- 1)); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_8]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-8%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，计算两个非零正整数的最大公约数和最小公约数，要求两个非零正整数从键盘输入1234567891011121314151617181920212223public class Example3_8 &#123; public static void main(String[] args) &#123; System.out.println("请输入两个非零正整数，每输入一个数回车确认"); Scanner reader= new Scanner(System.in); int m= 0, n= 0, t= 0, gy= 0, gb= 0; m= reader.nextInt(); n= reader.nextInt(); if(m&gt; n)&#123; t= m; m= n; n= t; &#125; for(int i= 1; i&lt;= m; i++)&#123; if(m% i== 0 &amp;&amp; n% i== 0)&#123; gy= i; &#125; &#125; gb= m* n/ gy; System.out.println(m+ "和"+ n+ "的最大公约数为: "+ gy); System.out.println(m+ "和"+ n+ "的最小公倍数为: "+ gb); reader.close(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_7]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-7%2F</url>
    <content type="text"><![CDATA[一个数如果恰好等于它的因子之和，这个数就称为“完数”，编写一个应用程序，求1000之内的所有完整完数123456789101112131415public class Example3_7 &#123; public static void main(String[] args) &#123; int sum= 0, i, j; for(i= 1; i&lt;=1000; i++)&#123; for(j= 1, sum= 0; j&lt; i; j++)&#123; if(i% j== 0)&#123; sum+= j; &#125; &#125; if(sum== i)&#123; System.out.println("完数: "+ i); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_6]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-6%2F</url>
    <content type="text"><![CDATA[分别用while和for循环计算1+ 1/2!+ 1/3!+ 1/4!+ ... 的前20项之和1234567891011121314151617public class Example3_6 &#123; public static void main(String[] args) &#123; double sum= 0, a= 1, i= 1; while(i&lt;= 20)&#123; a= (1.0/i)* a; i++; sum= sum+ a; &#125; System.out.println("使用while循环计算的sum= "+ sum); for(sum= 0, i= 1, a= 1; i&lt;= 20; i++)&#123; a= a*(1.0/ i); sum= sum+ a; &#125; System.out.println("使用for循环计算的sum= "+ sum); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_5]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-5%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，求100以内的全部素数法一:123456789101112131415public class Example3_5 &#123; public static void main(String[] args) &#123; int i, j; for(j= 2; j&lt;= 100; j++)&#123; for(i= 2; i&lt;= j/2; i++)&#123; if(j%i== 0)&#123; break; &#125; &#125; if(i&gt; j/ 2)&#123; System.out.print(" "+ j); &#125; &#125; &#125;&#125; 法二:1234567891011121314public class demos &#123; public static void main(String[] args) &#123; int i, n; for(n= 2; n&lt;= 100; n++)&#123; for(i= 2; i&lt;= n- 1; i++)&#123; if (n% i== 0) &#123; break; &#125; &#125;if (i== n) &#123; System.out.print(n+ " "); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_4]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-4%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，求1!+ 2!+ ... + 20!123456789101112public class Example3_4 &#123; public static void main(String[] args) &#123; double sum= 0, a= 1; int i= 1; while (i&lt;= 20)&#123; sum= sum+ a; i++; a= a*i; &#125; System.out.println("sum= "+ sum); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Example3_3]]></title>
    <url>%2F2017%2F09%2F19%2FExample3-3%2F</url>
    <content type="text"><![CDATA[编写一个应用程序，用for循环输出俄文的字母表1234567891011121314151617public class Example3_3&#123; public static void main (String args[]) &#123; int startPosition=0,endPosition=0; char cStart='А',cEnd='Я'; startPosition=(int)cStart;//cStart做int型转换运算，并将结果赋值给startPosition endPosition=(int)cEnd;//cEnd做int型转换运算，并将结果赋值给endPosition System.out.println("俄文字母共有:"+(endPosition-startPosition+1)+"个"); for(int i=startPosition;i&lt;=endPosition;i++) &#123; char c='\0'; c=(char)i;//i做char型转换运算，并将结果赋值给c System.out.print(" "+c); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays类中binarySearch()的问题]]></title>
    <url>%2F2017%2F09%2F10%2FArrays%E7%B1%BB%E4%B8%ADbinarySearch-%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近新上手了Java，学习的过程中发现在binarySearch()方法中有点地方不明，so~google了一下。binarySearch()方法的返回值有两种情况：1、如果找到关键字，则返回值为关键字在数组中的位置索引，且索引从0开始； 2、如果没有找到关键字，返回值为负的插入点值，插入点值就是第一个比关键字大的元素在数组中的位置索引，而且这个位置索引从1开始。 注：调用binarySearch()方法前要先调用sort方法对数组进行排序，否则得出的返回值不定，这是二分搜索算法决定的。 如下一个小例1234567891011121314151617181920212223242526272829303132import java.util.Arrays;public class Example2_7 &#123; public static void main(String[] args) &#123; int[] a= new int[] &#123;12, 34, 9, 23, 45, 6, 45, 90, 123, 19, 34&#125;; int[] b= &#123;12, 34, 9, 23, 45, 6, 45, 90, 123, 19, 34&#125;; //两种定义方法都可 Arrays.sort(b); System.out.println(Arrays.toString(b)); Arrays.sort(a); System.out.println(Arrays.toString(a)); int number= 45; int index= Arrays.binarySearch(a, number); System.out.println(index); if( index&gt;= 0)&#123; System.out.println(number+ "和数组中索引为"+ index+ "的元素值相同"); &#125; else &#123; System.out.println(number+ "不与数组中的任何元素值相同"); &#125; int numberd= 89; //此时没有找到关键字，返回值为-10，第一个比89大的数是90，位置是第十个，此时位置索引从1开始 int indexd= Arrays.binarySearch(a, numberd); System.out.println(indexd); if( indexd&gt;= 0)&#123; System.out.println(numberd+ "和数组中索引为"+ indexd+ "的元素值相同"); &#125; else &#123; System.out.println(numberd+ "不与数组中的任何元素值相同"); &#125; &#125;&#125; 运行结果为123456[6, 9, 12, 19, 23, 34, 34, 45, 45, 90, 123][6, 9, 12, 19, 23, 34, 34, 45, 45, 90, 123]845和数组中索引为8的元素值相同-1089不与数组中的任何元素值相同]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FengCms上传Webshell]]></title>
    <url>%2F2017%2F08%2F31%2FFengCms%E4%B8%8A%E4%BC%A0Webshell%2F</url>
    <content type="text"><![CDATA[今天拿一个演示站做测试 首页很平常，有一个输入框，可能有注入漏洞。查看源代码后，在最底下有一行注释，提示一些信息，有门！ 上网搜查下FengCms，发现FengCms是由地方网络工作室完全知识产权打造的一套适用于个人、企业建站的内容管理系统。在这个网页上有相关的漏洞https://www.seebug.org/appdir/FengCMS这次使用的是任意文件下载漏洞 通过扫描发现这段PHP代码有明显的漏洞。 通过找到这个文件名，base64编码后获取文件内容，将其下载到本地。 演示站证明: http://guf521656.h163.92hezu.org/?controller=down&amp;file=Y29uZmlnLnBocA 打开后发现MySQL的用户名和密码 用nmap扫描到演示站开着3306端口 利用所得的账号密码，进入数据库根据phpinfo.php中，找到的绝对路径/var/www/htmldocument_root的值，得到网站的绝对路径利用MySQL上传一句话木马 就会发现/upload/下多出1.php文件，上传成功随后可用中国菜刀链接到网站，提取里面的信息~]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP提数据]]></title>
    <url>%2F2017%2F08%2F30%2FSQLMAP%E6%8F%90%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[查询数据库中信息的sqlmap语句SQLMAP读取数据： -u 漏洞url-data “vul” POST内容 –dbs 罗列所有数据库 -D 指定数据库 –tables列表 -D 指定数据库 -T 指定表 –columns 列所有字段 -D 指定数据库 -T 指定表 -C 指定字段 –dump 获取数据 –random-agent 随机ua头 –level -risk 设置扫描等级 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ - -dbs查询数据库 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ - -current-db查询当前使用的数据库 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ -D security - -tables查询所有的表 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ -D security -T users - -columns查询表中所有字段 sqlmap -u “http://10.6.67.209:8881/sqli-labs/Less-1/?id=1“ -D security -T users -C username,password - -dump指定查询的列 两条-之间没有空格，style在编辑的时候，两条-之间没加空格，它们会连在一起，不容易看出，额，markdown用的不是很熟~]]></content>
      <tags>
        <tag>SQLMAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos + Hexo + Github]]></title>
    <url>%2F2017%2F08%2F30%2FCentos-Hexo-Github%2F</url>
    <content type="text"><![CDATA[本文只介绍style安装的过程，其他版本请另行借鉴！(万变不离其宗)必需品： 注册有腾讯有以及域名 腾讯云中安装Centos 7 注册有Github ###Centos 7 中 下载并安装LNMP 我安装的是稳定版 wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp 安装成功后， 下一步 ###Centos 7 中 安装Hexo这个茬可真不好弄==，style第一次安装的时候出了许多的错误，无奈之下只能一点一点解决。安装过程中借鉴了许多资料，另行总结才搭配好，总觉得网上的教程不是很全面。在root下安装 ####首先安装Node.js找到最新的下载地址，用 wget 命令下载到本地 wget https://nodejs.org/dist/v4.4.4/node-v4.4.4-linux-x64.tar.xz 下载完后解压，因为是xz文件， 所以如下 xz -d node-v4.4.4-linux-x64.tar.gz tar -xvf node-v4.4.4-linux-x64.tar 文件被解压到当前文件夹下 mv node-v4.4.4-linux-x64 node-v4.4.4 mv node-v4.4.4 /usr/local/node ####配置环境变量 #编辑 /etc/profile (使用 vim) vim /etc/profile #在底部添加PATH变量 export PATH=$PATH:/usr/local/node/bin*#保存退出， 先按Esc键， 再按Shift + : 输入wq即可保存退出 最后保存并使其生效即可 source /etc/profile ###安装Hexo 创建目录 mkdir hexo 切换目录 cd hexo 安装Git(已安装， 跳过) yum install git-core 安装Hexo npm install -g hexo-cli 初始化Hexo hexo init 这里可能有个问题，就是在安装Hexo的时候， 输入安装Hexo的安装指令npm install -g hexo-cli，可能会出现错误，如果出错，可将官方源替换成淘宝源 npm install -g hexo –registry=https://registry.npm.taobao.org ####安装插件 npm install hexo-generator-index –save npm install hexo-generator-archive –save npm install hexo-generator-category –save npm install hexo-generator-tag –save npm install hexo-server –save npm install hexo-deployer-git –save npm install hexo-deployer-heroku –save npm install hexo-deployer-rsync –save npm install hexo-deployer-openshift –save npm install hexo-renderer-marked –save npm install hexo-renderer-stylus –save npm install hexo-generator-feed –save npm install hexo-generator-sitemap –save 安装结束后，进行下一步修改Hexo配置文件(站点文件，即hexo/config._yml,, hexo/themes/next/_config.yml是主题文件)注： key值没有对应的value值的时候，冒号后面一定要有空格！否则会报错，例如：timezone:会报错，，timezone: 不会 ###部署到Github这个简单 ####配置本机全局git变量(如果已经配置过请忽略)在VPS(你的服务器)上设置你的Git git config –global user.email “你的github注册时的邮箱” git config –global user.name “你的名字” ####生成ssh和密钥输入下面一段指令 less ~/.ssh/id_rsa.pub 如果出现一堆密码，则证明你已经生成ssh，可跳过下面一步，如果报错，请进行下一步。 ssh-keygen -t rsa -C example@126.com注： -C后面跟你在github注册的用户名邮箱，这样公钥才会被github认可回车后，不用输入文件夹路径和名字，自动选择默认的路径，存储新的ssh密钥连续回车，结束查看公钥内容，稍后加入github账户的sshkey中 less ~/.ssh/id_rsa.pub ###创建博客工程 创建一个新的仓库，仓库名为用户名.github.io，比如我的github用户名是sunstady，则创建的项目名为sunstady.github.io ###将ssh密钥添加到github中生成后，需要将密钥放到github上去，登录你的github账号，进入密钥设置面板：https://github.com/settings/ssh在执行less ~/.ssh/id_rsa.pub后，会有一堆长的密码，把这一堆密码全部复制到github上 ####配置Hexo， 编译与部署在站点文件_config.yml里第一段 #Site 站点信息设置title: Sanstyle #站名subtitle: 世界， 你好 #这是副标题description: #站描述autor: MC #作者language: zh-CN #语言timezone: 在站点文件_config.yml里最后一段 deploy:type: git repo:git@github.com:sunstady/sunstady.github.io.git branch: master message: &apos;站点更新:{{now("YYYY-MM-DD HH/mm/ss")}}&apos; 这里， 就是你创建的博客工程最后一步，编译， 上传静态代码 编译 hexo generate 在主机的hexo目录下，执行以下命令将自动更新到github hexo d ###修改主题和配置文件 ####安装主题NEXT切换到目录hexo下 git clone https://github.com/iissnan/hexo-theme-next themes/next在站点文件_config.yml中 找到 theme: 修改后面的参数，默认是 landscape theme: next ####验证主题首先启动Hexo站点， 并开启调试模式，整个命令是hexo s --debug。在启动服务的过程中，注意观察命令行输出是否有任何异常信息，当命令行提示：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问http://localhost:4000，检查站点是否正确运行。 ###主题设定 ####选择SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认Scheme， 这是NexT最初的版本，黑白主调，大量留白 Mist - Muse的紧凑版本， 整洁有序的单栏外观 Pisces - 双栏Scheme， 小家碧玉似的清新 Scheme的切换通过更改主题文件，搜索scheme关键字(用 vim 打开后，输入/scheme就可搜索)你会看到三行scheme的配置，将你启用的scheme前面注释#去掉即可。 scheme: Pisces ####设置菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑主题文件， 修改如下： menu:home: / archives: /archives about: /about categories: /categories tags: /tags commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的/去掉 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 menu_icons: enable: true home: home about: about categories: th tags: tags archives: archive commonweal: heartbeat ####设置头像编辑主题文件，修改字段avatar, 值设置成头像的链接地址 avatar: http://xxxx.com/xxxxx.jpg ###访问：现在可以通过用户名.github.io访问博客]]></content>
      <tags>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
